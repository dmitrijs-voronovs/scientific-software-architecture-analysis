quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"bal mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21651,safe,safe,21651,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety,"base class gets TStreamerSTL as its class, so this test is not enough.; 6263 // See InitializeOffsets() for the proper test.; 6264 if (elem->IsA() == TStreamerBase::Class()) {; 6265 // -- This is a base class of cl.; 6266 TClass* clOfBase = elem->GetClassPointer();; 6267 if (!clOfBase || ((clOfBase->Property() & kIsAbstract) && cl->InheritsFrom(TCollection::Class()))) {; 6268 // -- Do nothing if we are one of the abstract collection (we know they have no data).; 6269 return -1;; 6270 }; 6271 if ((btype == 31) || (btype == 41)) {; 6272 // -- Elide the base-class sub-branches of a split TClonesArray or STL container.; 6273 //; 6274 // Note: We are eliding the base class here, that is, we never; 6275 // create a branch for it, so the branch hierarchy is not; 6276 // complete.; 6277 // Note: The clParent parameter is the value class of the; 6278 // container which we are splitting. It does not; 6279 // appear in the branch hierarchy either.; 6280 // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.; 6281 Int_t unroll = -1;; 6282 if (!elem->CannotSplit() || clOfBase == TObject::Class()) {; 6283 unroll = Unroll(name, clParent, clOfBase, ptr + offset, basketsize, splitlevel+splitSTLP, btype);; 6284 }; 6285 if (unroll < 0) {; 6286 // FIXME: We could not split because we are abstract, should we be doing this?; 6287 if (namelen) {; 6288 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6289 } else {; 6290 branchname.Form(""%s"", elem->GetFullName());; 6291 }; 6292 TBranchElement* branch = new TBranchElement(this, branchname, sinfo, elemID, nullptr, basketsize, 0, btype);; 6293 branch->SetParentClass(clParent);; 6294 fBranches.Add(branch);; 6295 }; 6296 } else if (clOfBase->GetListOfRealData()->GetSize()) {; 6297 // -- Create a branch for a non-empty base class.; 6298 if (namelen) {; 6299 branchname.Form(""%s%s%s"", name, dotlast ? """" : ""."", elem->GetFullName());; 6300 // Elide the base class name when creating the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:235996,detect,detection,235996,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['detect'],['detection']
Safety,"base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<Syste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8cxx_source.html:1224,avoid,avoid,1224,doc/master/TEnv_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html,1,['avoid'],['avoid']
Safety,"batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two generators that return training and validation batches; # as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; target=target,; validation_split=0.3,; ); ; # Get a list of the columns used for training; input_columns = gen_train.train_columns; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_validation):; # Make prediction and calculate accuracy; pred = model(x_train).view(-1); accuracy = calc_accuracy(y_train, pred); ; print(f""Validation => accuracy: {accuracy}""); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html:1484,predict,prediction,1484,doc/master/RBatchGenerator__PyTorch_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html,1,['predict'],['prediction']
Safety,"be selected via the parameter mode. The parameter mode can be = pcev (default = 0111) p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors. When v = 1 is specified, only the non-fixed parameters are shown.; When v = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to gStyle->SetOptFit(111). The error bars options. Option Description . ""E"" Default. Shows only the error bars, not a marker. . ""E1"" Small lines are drawn at the end of the error bars. . ""E2"" Error rectangles are drawn. . ""E3"" A filled area is drawn through the end points of the vertical error bars. . ""E4"" A smoothed filled area is drawn through the end points of the vertical error bars. . ""E0"" Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping . ""E5"" Like E3 but ignore the bins with 0 contents. . ""E6"" Like E4 but ignore the bins with 0 contents. . ""X0"" When used with one of the ""E"" option, it suppress the error bar along X as gStyle->SetErrorX(0) would do. . {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::SetErrorXvoid SetErrorX(Float_t errorx=0.5)Definition TStyle.h:340. The options ""E3"" and ""E4"" draw an error band through the end points of the vertical error bars. With ""E4"" the error band is smoothed. Because of the smoothing algorithm used some artefacts may appear at t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:28210,avoid,avoids,28210,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avoid'],['avoids']
Safety,"be set on the chain *before* calling Process"");; }; }; }; ; ; void h1analysisProxy_SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; printf(""Starting (slave) h1analysis with process option: %s\n"",option.Data());; ; //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; //process cases with entry list; fillList = kFALSE;; useList = kFALSE;; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; }; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; } else elist = 0;; ; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(0); //otherwise the file destructor will delete elist; if (tree) tree->SetEntryList(elist);; else {; // Option ""useList"" not supported in PROOF directly; Warning(""Begin"", ""option 'useList' not supported in PROOF - ignoring"");; Warning(""Begin"", ""the entry list must be set on the chain *before* calling Process"");; }; }; ; }; ; Double_t h1analysisProxy() {; return 0;; }; ; ; Bool_t h1analysisProxy_Process(Long64_t entry); {; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; ; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; ; float f1 = md0_d;; float f2 = md0_d-1.864",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:6603,avoid,avoid,6603,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['avoid'],['avoid']
Safety,"be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. Double_t getVal(const RooArgSet* set=0); Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=0); Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:76649,unsafe,unsafe,76649,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['unsafe'],['unsafe']
Safety,"been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 2075 while (idcur < fEND) {; 2076 Seek(idcur); // NOLINT: silence clang-tidy warnings; 2077 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 2078 if (ReadBuffer(header, nread)) { // NOLINT: silence clang-tidy warnings; 2079 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:73253,recover,recovery,73253,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovery']
Safety,"bel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains the fraction of our money invested in each stock . We can calculate the average daily return \( z \) of our portfolio and its variance using the portfolio covariance Covar :; \( z = r^T x \) and \( var = x^T Covar x \); Assuming that the daily returns have a Normal distribution, \( N(x) \), so will \( z \) with mean \( r^T x \) and variance \( x^T Covar x \); The expected value of the utility function is :. \[; E(u(x)) = Int (1-exp(-k*x) N(x) dx \\; = 1-exp(-k (r^T x - 0.5 k x^T Covar x) ) \\; \]. Its value is maximised by maximising \( r^T x -0.5 k x^T Covar x \) under the condition \( sum (x_i) = 1 \), meaning we want all our money invested and \( x_i \ge 0 \), we can not ""short"" a stock; For 10 stocks we got the historical daily data for Sep-2000 to Jun-2004:. GE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2984,risk,risk-loving,2984,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,2,['risk'],"['risk-averse', 'risk-loving']"
Safety,"bel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Jun 30 14:29:59 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:28371,safe,safe,28371,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,1,['safe'],['safe']
Safety,"ber Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TEnv.h>. Inheritance diagram for TEnv:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEnv() [1/2]. TEnv::TEnv ; (; const TEnv & ; ). privatedelete . ◆ TEnv() [2/2]. TEnv::TEnv ; (; const char * ; name = """"). Create a resource table and read the (possibly) three resource files, i.e. $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and $PWD/<name>. ; ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can read additional user defined resource files by creating additional TEnv objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of the $HOME/<name> resource file will be skipped. This might be useful in case the home directory resides on an auto-mounted remote file system and one wants to avoid the file system from being mounted. ; Definition at line 401 of file TEnv.cxx. ◆ ~TEnv(). TEnv::~TEnv ; (; ). virtual . Delete the resource table. ; Definition at line 430 of file TEnv.cxx. Member Function Documentation. ◆ Class(). static TClass * TEnv::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEnv::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEnv::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 167 of file TEnv.h. ◆ DeclFileName(). static const char * TEnv::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 167 of file TEnv.h. ◆ Defined(). Bool_t TEnv::Defined ; (; const char * ; name); const. inline . Definition at line 141 of file TEnv.h. ◆ GetRcName(). virtual const char * TEnv::GetRcName ; (; ); const. inlinevirtual . D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnv.html:16328,avoid,avoid,16328,doc/master/classTEnv.html,https://root.cern,https://root.cern/doc/master/classTEnv.html,1,['avoid'],['avoid']
Safety,"ber in the current tree.; 72Assuming that fChain is the pointer to the TChain being processed,; 73use `fChain->GetTree()->GetEntry(entry);`; 74*/; 75 ; 76#include ""TROOT.h""; 77#include ""TSystem.h""; 78#include ""TTree.h""; 79#include ""TError.h""; 80#include ""TSelector.h""; 81#include ""TClass.h""; 82#include ""TInterpreter.h""; 83 ; 84ClassImp(TSelector);; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4411,abort,aborted,4411,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['abort'],['aborted']
Safety,"ber of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy war",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72745,recover,recovered,72745,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:40972,avoid,avoids,40972,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['avoid'],['avoids']
Safety,"bers; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPoints(Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:12139,safe,safe,12139,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,3,['safe'],['safe']
Safety,"bers; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html:8334,predict,predictions,8334,root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:12137,avoid,avoid,12137,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,2,['avoid'],['avoid']
Safety,"bie. One can detect this situation with a code like: TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the environment variable ""TFile.Recover: 0"" in the system.rootrc file.; A bit TFile::kReproducible can be enabled specifying the ""reproducible"" url option when creating the file: TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; Unlike regular TFiles, the content of such file has reproducible binary content when writing exactly same data. This achieved by writing pre-defined values for creation and modification date of TKey/TDirectory objects and null value for TUUID objects inside TFile. As drawback, TRef objects stored in such file cannot be read correctly.; In case the name of the file is not reproducible either (in case of creating temporary filenames) a value can be passed to the reproducible option to replace the name stored in the file. TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");. Definition at line 339 of file TFile.cxx. ◆ ~TFile(). TFile::~TFile ; (; ). override . File destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:52387,recover,recovery,52387,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovery']
Safety,"bin size 2-D histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) . Definition at line 97 of file TH2.cxx. ◆ TH2() [3/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . Double_t ; ylow, . Double_t ; yup . ). protected . Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbinsx+1 ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) . Definition at line 126 of file TH2.cxx. ◆ TH2() [4/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . Double_t ; xlow, . Double_t ; xup, . Int_t ; nbinsy, . const Double_t * ; ybins . ). protected . Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis titl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:58343,avoid,avoid,58343,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['avoid'],['avoid']
Safety,"bject::(anonymous)TObject::kOverwrite; static TStdExceptionHandler::EStatuskSEAbort; static TStdExceptionHandler::EStatuskSEHandled; static TStdExceptionHandler::EStatuskSEProceed; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←; TStdExceptionHandler. ←. TEveManager::TExceptionHandler. Function documentation; TStdExceptionHandler(); Handle standard C++ exceptions intercepted by the TSystem::Run(). Virtual method EStatus Handle(std::exception& exc) is called on the; collection of handlers registered to TSystem. The return value of; each handler influences the continuation of handling procedure:; kSEProceed - Proceed with passing of the exception to other; handlers, the exception has not been handled.; kSEHandled - The exception has been handled, do not pass it to; other handlers.; kSEAbort - Abort application.; If all handlers return kSEProceed TSystem::Run() rethrows the; exception, possibly resulting in process abortion. void Add(); Add std::exception handler to system handler list. void Remove(); Remove std::exception handler from system handler list. Bool_t Notify(); Notify when signal occurs. TStdExceptionHandler(). virtual ~TStdExceptionHandler(); { }. EStatus Handle(exception& exc). » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStdExceptionHandler.html:10762,abort,abortion,10762,root/html604/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html604/TStdExceptionHandler.html,1,['abort'],['abortion']
Safety,"bject::(anonymous)TObject::kOverwrite; static TStdExceptionHandler::EStatuskSEAbort; static TStdExceptionHandler::EStatuskSEHandled; static TStdExceptionHandler::EStatuskSEProceed; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←; TStdExceptionHandler. ←. TEveManager::TExceptionHandler. Function documentation; TStdExceptionHandler(); Handle standard C++ exceptions intercepted by the TSystem::Run(). Virtual method EStatus Handle(std::exception& exc) is called on the; collection of handlers registered to TSystem. The return value of; each handler influences the continuation of handling procedure:; kSEProceed - Proceed with passing of the exception to other; handlers, the exception has not been handled.; kSEHandled - The exception has been handled, do not pass it to; other handlers.; kSEAbort - Abort application.; If all handlers return kSEProceed TSystem::Run() rethrows the; exception, possibly resulting in process abortion. void Add(); Add std::exception handler to system handler list. void Remove(); Remove std::exception handler from system handler list. Bool_t Notify(); Notify when signal occurs. TStdExceptionHandler(). virtual ~TStdExceptionHandler(); { }. EStatus Handle(exception& exc). » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStdExceptionHandler.html:10762,abort,abortion,10762,root/html602/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html602/TStdExceptionHandler.html,1,['abort'],['abortion']
Safety,"bject::(anonymous)TObject::kZombie. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←; TTimer. ←. TProcessEventTimer. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:12162,timeout,timeout,12162,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,4,['timeout'],['timeout']
Safety,"bject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterTree&operator=(const TEventIterTree&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterTree.html:4513,abort,abort,4513,root/html528/TEventIterTree.html,https://root.cern,https://root.cern/root/html528/TEventIterTree.html,1,['abort'],['abort']
Safety,"bject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterUnit&operator=(const TEventIterUnit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterUnit.html:4497,abort,abort,4497,root/html528/TEventIterUnit.html,https://root.cern,https://root.cern/root/html528/TEventIterUnit.html,1,['abort'],['abort']
Safety,"bject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoScaledShape&operator=(const TGeoScaledShape&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:8431,safe,safe,8431,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,1,['safe'],['safe']
Safety,"bject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShapeAssembly.html:8182,safe,safe,8182,root/html602/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html,2,['safe'],['safe']
Safety,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:5817,timeout,timeout,5817,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,9,['timeout'],['timeout']
Safety,"bject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoNavigator (const TGeoNavigator &)=delete;  ; TGeoNode * CrossDivisionCell ();  Cross a division cell. ;  ; TGeoNode * FindInCluster (Int_t *cluster, Int_t nc);  Find a node inside a cluster of overlapping nodes. ;  ; Int_t GetTouchedCluster (Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);  Make the cluster of overlapping nodes in a voxel, containing point in reference of the mother. ;  ; TGeoNavigator & operator= (const TGeoNavigator &)=delete;  ; void SafetyOverlaps ();  Compute safe distance from the current point within an overlapping node. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TGeoCacheState * fBackupState;  current point is supposed to be inside this node ;  ; TGeoNodeCache * fCache;  current geometry ;  ; Double_t fCldir [3];  cosine of incident angle on current checked surface ;  ; Double_t fCldirChecked [3];  unit vector to current closest shape ;  ; TGeoHMatrix * fCurrentMatrix;  backup state ;  ; TGeoNode * fCurrentNode;  current volume ;  ; Bool_t fCurrentOverlapping;  flag set when an overlapping cluster is searched ;  ; TGeoVolume * fCurrentVolume;  cache of states ;  ; Double_t fDirection [3];  current point ;  ; TGeoHMatrix * fDivMatrix;  current pointer to cached global matrix ;  ; TGeoNode * fForcedNode;  next node that will be cros",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:18315,safe,safe,18315,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"bjective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24480,safe,safe,24480,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['safe'],['safe']
Safety,"bjects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; rf514_RooCustomizerDefinition rf514_RooCustomizer.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; The proto model before customisation:; 0x7ffc956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x557340631bf0/V- RooRealVar::meanG_Sample1 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b71f0/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf514__RooCustomizer_8C.html:6145,safe,safe,6145,doc/master/rf514__RooCustomizer_8C.html,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html,1,['safe'],['safe']
Safety,"ble x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions; boolfPolynomialflag for polynomial functions; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature); static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f); fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); constructor from a TF1 function pointer. WrappedTF1(TF1& f); fParams(rhs.fParams); copy constructor. void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values; need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed. unsigned int NPar() const; return number of parameters. std::string Paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html:4418,avoid,avoid,4418,root/html604/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html,1,['avoid'],['avoid']
Safety,"ble_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; TGeoShape::Safetyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; TGeoShape::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:6273,safe,safe,6273,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety,"ble_t * ; dir). inline . Definition at line 185 of file TGeoNavigator.h. ◆ SetCurrentDirection() [2/2]. void TGeoNavigator::SetCurrentDirection ; (; Double_t ; nx, . Double_t ; ny, . Double_t ; nz . ). inline . Definition at line 186 of file TGeoNavigator.h. ◆ SetCurrentPoint() [1/2]. void TGeoNavigator::SetCurrentPoint ; (; const Double_t * ; point). inline . Definition at line 172 of file TGeoNavigator.h. ◆ SetCurrentPoint() [2/2]. void TGeoNavigator::SetCurrentPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 173 of file TGeoNavigator.h. ◆ SetLastPoint(). void TGeoNavigator::SetLastPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 179 of file TGeoNavigator.h. ◆ SetLastSafetyForPoint() [1/2]. void TGeoNavigator::SetLastSafetyForPoint ; (; Double_t ; safe, . const Double_t * ; point . ). inline . Definition at line 194 of file TGeoNavigator.h. ◆ SetLastSafetyForPoint() [2/2]. void TGeoNavigator::SetLastSafetyForPoint ; (; Double_t ; safe, . Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 199 of file TGeoNavigator.h. ◆ SetOutside(). void TGeoNavigator::SetOutside ; (; Bool_t ; flag = kTRUE). inline . Definition at line 148 of file TGeoNavigator.h. ◆ SetPWSafetyCaching(). static void TGeoNavigator::SetPWSafetyCaching ; (; Bool_t ; b). inlinestatic . Definition at line 231 of file TGeoNavigator.h. ◆ SetStartSafe(). void TGeoNavigator::SetStartSafe ; (; Bool_t ; flag = kTRUE). inline . Definition at line 136 of file TGeoNavigator.h. ◆ SetStep(). void TGeoNavigator::SetStep ; (; Double_t ; step). inline . Definition at line 137 of file TGeoNavigator.h. ◆ Step(). TGeoNode * TGeoNavigator::Step ; (; Bool_t ; is_geom = kTRUE, . Bool_t ; cross = kTRUE . ). Make a rectiliniar step of length fStep from current point (fPoint) on current direction (fDirection). ; If the step is imposed by geometry, is_geom flag must be true (default). The cross flag specifies if the bound",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:43447,safe,safe,43447,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"ble_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:3440,safe,safe,3440,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,['safe'],['safe']
Safety,"ble_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual const Double_t * GetOrigin () const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void Sizeof3D () const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:6606,safe,safe,6606,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoHelix.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2010-09-23 20:09; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:9168,safe,safety,9168,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoHelix.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-07-04 15:31; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHelix.html:9237,safe,safety,9237,root/html530/TGeoHelix.html,https://root.cern,https://root.cern/root/html530/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoHelix.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHelix.html:9237,safe,safety,9237,root/html532/TGeoHelix.html,https://root.cern,https://root.cern/root/html532/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:9266,safe,safety,9266,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHelix.html:9830,safe,safety,9830,root/html604/TGeoHelix.html,https://root.cern,https://root.cern/root/html604/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:9830,safe,safety,9830,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,1,['safe'],['safety']
Safety,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:16789,predict,predict,16789,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,1,['predict'],['predict']
Safety,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFitter.html:16858,predict,predict,16858,root/html530/TFitter.html,https://root.cern,https://root.cern/root/html530/TFitter.html,1,['predict'],['predict']
Safety,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitter.html:16858,predict,predict,16858,root/html532/TFitter.html,https://root.cern,https://root.cern/root/html532/TFitter.html,1,['predict'],['predict']
Safety,"ble_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup hook for RooSentinel atexit handler. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getVal(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getVal(). If used as regular PDF,; call RooAbsPdf::getVal(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:42040,avoid,avoid,42040,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,3,['avoid'],['avoid']
Safety,"ble_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup hook for RooSentinel atexit handler. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:44331,avoid,avoid,44331,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['avoid'],['avoid']
Safety,"blic:. enum ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EDestruct { kNone; kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tfAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; void*fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tfColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tfDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TRefArray*fDigitIdsArray holding references to external objects.; Bool_tfDisableLightingDisable lighting for rend",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveDigitSet.html:23649,avoid,avoid,23649,root/html528/TEveDigitSet.html,https://root.cern,https://root.cern/root/html528/TEveDigitSet.html,4,['avoid'],['avoid']
Safety,"booking time using the convention ""Hist_title ; X_title ; Y_title""; TH1F *h1 = new TH1F(""h1"", ""Two gaussian plots and their ratio;x title; h1 and h2 gaussian histograms"", 100, -5, 5);; TH1F *h2 = new TH1F(""h2"", ""h2"", 100, -5, 5);; h1->FillRandom(""gaus"");; h2->FillRandom(""gaus"");; ; // Define the Canvas; TCanvas *c = new TCanvas(""c"", ""canvas"", 800, 800);; ; // Upper plot will be in pad1; TPad *pad1 = new TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0);; pad1->SetBottomMargin(0); // Upper and lower plot are joined; pad1->SetGridx(); // Vertical grid; pad1->Draw(); // Draw the upper pad: pad1; pad1->cd(); // pad1 becomes the current pad; h1->SetStats(0); // No statistics on upper plot; h1->Draw(); // Draw h1; h2->Draw(""same""); // Draw h2 on top of h1; ; #if ROOT_VERSION_CODE >= ROOT_VERSION(6,8,0); // Avoid the first label (0) to be clipped.; TAxis *axis = h1->GetYaxis();; axis->ChangeLabel(1, -1, -1, -1, -1, -1, "" "");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; #else; // Do not draw the Y axis label on the upper plot and redraw a small; // axis instead, in order to avoid the first label (0) to be clipped.; h1->GetYaxis()->SetLabelSize(0.);; TGaxis *axis = new TGaxis( -5, 20, -5, 220, 20,220,510,"""");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; axis->Draw();; #endif; ; // lower plot will be in pad; c->cd(); // Go back to the main canvas before defining pad2; TPad *pad2 = new TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3);; pad2->SetTopMargin(0);; pad2->SetBottomMargin(0.2);; pad2->SetGridx(); // vertical grid; pad2->Draw();; pad2->cd(); // pad2 becomes the current pad; ; // Define the ratio plot; TH1F *h3 = (TH1F*)h1->Clone(""h3"");; h3->SetLineColor(kBlack);; h3->SetMinimum(0.8); // Define Y ..; h3->SetMaximum(1.35); // .. range; h3->Sumw2();; h3->SetStats(0); // No statistics on lower plot; h3->Divide(h2);; h3->SetMarkerStyle(21);; h3->Draw(""ep""); // Draw the ratio plot; ; // h1 settings",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplotOld_8C.html:1646,avoid,avoid,1646,doc/master/ratioplotOld_8C.html,https://root.cern,https://root.cern/doc/master/ratioplotOld_8C.html,1,['avoid'],['avoid']
Safety,"bool changeModel (const RooResolutionModel &newModel);  Change the current resolution model to newModel. ;  ; virtual double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const;  Default implementation of function implementing advertised integrals. ;  ; virtual RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:5852,unsafe,unsafe,5852,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['unsafe'],['unsafe']
Safety,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:61053,sanity check,sanity check,61053,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:54192,sanity check,sanity check,54192,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,122,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:56537,sanity check,sanity check,56537,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,12,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"bort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 IPPROTO_IPV6,; 15094 IPV6_V6ONLY,; 15095 (void *)&on,; 15096 sizeof(on)); 15097 != 0) {; 15098 ; 15099 /* Set IPv6 only option, but don't abort on errors. */; 15100 mg_cry_ctx_internal(phys_ctx,; 15101 ""cannot set socket option ""; 15102 ""IPV6_V6ONLY=on (entry %i)"",; 15103 portsTotal);; 15104 }; 15105 }; 15106#else; 15107 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15108 closesocket(so.sock);; 15109 so.sock = INVALID_SOCKET;; 15110 continue;; 15111#endif; 15112 }; 15113 ; 15114 if (so.lsa.sa.sa_family == AF_INET) {; 15115 ; 15116 len = sizeof(so.lsa.sin);; 15117 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15118 mg_cry_ctx_internal(phys_ctx,; 15119 ""cannot bind to %.*s: %d (%s)"",; 15120 (int)vec.len,; 15121 vec.ptr,; 15122 (int)ERRNO,; 15123 strerror(errno));; 15124 closesocket(so.sock);; 15125 so.sock = INVALID_SOCKET;; 15126 continue;; 15127 }; 15128 }; 15129#if defined(USE_IPV6); 15130 else if (so.lsa.sa.sa_family == AF_INET6) {; 15131 ; 15132 len = sizeof(so.lsa.sin6);; 15133 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15134 mg_cry_ctx_i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:446693,abort,abort,446693,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"bort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 IPPROTO_IPV6,; 15095 IPV6_V6ONLY,; 15096 (void *)&on,; 15097 sizeof(on)); 15098 != 0) {; 15099 ; 15100 /* Set IPv6 only option, but don't abort on errors. */; 15101 mg_cry_ctx_internal(phys_ctx,; 15102 ""cannot set socket option ""; 15103 ""IPV6_V6ONLY=on (entry %i)"",; 15104 portsTotal);; 15105 }; 15106 }; 15107#else; 15108 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15109 closesocket(so.sock);; 15110 so.sock = INVALID_SOCKET;; 15111 continue;; 15112#endif; 15113 }; 15114 ; 15115 if (so.lsa.sa.sa_family == AF_INET) {; 15116 ; 15117 len = sizeof(so.lsa.sin);; 15118 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15119 mg_cry_ctx_internal(phys_ctx,; 15120 ""cannot bind to %.*s: %d (%s)"",; 15121 (int)vec.len,; 15122 vec.ptr,; 15123 (int)ERRNO,; 15124 strerror(errno));; 15125 closesocket(so.sock);; 15126 so.sock = INVALID_SOCKET;; 15127 continue;; 15128 }; 15129 }; 15130#if defined(USE_IPV6); 15131 else if (so.lsa.sa.sa_family == AF_INET6) {; 15132 ; 15133 len = sizeof(so.lsa.sin6);; 15134 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15135 mg_cry_ctx_i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:446726,abort,abort,446726,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:14792,safe,safe,14792,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,6,['safe'],['safe']
Safety,"bra matrix of size at least 3x3,; 129 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 130 Precondition: The matrix is assumed to be orthonormal. No checking; 131 or re-adjusting is performed.; 132 */; 133 template<class ForeignMatrix>; 134 explicit constexpr Rotation3D(const ForeignMatrix & m) { SetComponents(m); }; 135 ; 136 /**; 137 Construct from three orthonormal vectors (which must have methods; 138 x(), y() and z()) which will be used as the columns of the rotation; 139 matrix. The orthonormality will be checked, and values adjusted; 140 so that the result will always be a good rotation matrix.; 141 */; 142 template<class ForeignVector>; 143 Rotation3D(const ForeignVector& v1,; 144 const ForeignVector& v2,; 145 const ForeignVector& v3 ) { SetComponents(v1, v2, v3); }; 146 ; 147 // compiler generated destruuctor is ok; 148 ; 149 /**; 150 Raw constructor from nine Scalar components (without any checking); 151 */; 152 Rotation3D(Scalar xx, Scalar xy, Scalar xz,; 153 Scalar yx, Scalar yy, Scalar yz,; 154 Scalar zx, Scalar zy, Scalar zz); 155 {; 156 SetComponents (xx, xy, xz, yx, yy, yz, zx, zy, zz);; 157 }; 158 ; 159 // need to implement assignment operator to avoid using the templated one; 160 ; 161 /**; 162 Assignment operator; 163 */; 164 Rotation3D &; 165 operator=( Rotation3D const & rhs ) {; 166 SetComponents( rhs.fM[0], rhs.fM[1], rhs.fM[2],; 167 rhs.fM[3], rhs.fM[4], rhs.fM[5],; 168 rhs.fM[6], rhs.fM[7], rhs.fM[8] );; 169 return *this;; 170 }; 171 ; 172 /**; 173 Assign from an AxisAngle; 174 */; 175 Rotation3D &; 176 operator=( AxisAngle const & a ) { return operator=(Rotation3D(a)); }; 177 ; 178 /**; 179 Assign from EulerAngles; 180 */; 181 Rotation3D &; 182 operator=( EulerAngles const & e ) { return operator=(Rotation3D(e)); }; 183 ; 184 /**; 185 Assign from RotationZYX; 186 */; 187 Rotation3D &; 188 operator=( RotationZYX const & r ) { return operator=(Rotation3D(r)); }; 189 ; 190 /**; 191 Assign from a Quaternion; 192 */; 193 R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:5385,avoid,avoid,5385,doc/master/GenVector_2Rotation3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html,1,['avoid'],['avoid']
Safety,"branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias sin the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:34526,risk,risk,34526,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['risk'],['risk']
Safety,"break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 12784 ; 12785 if (ret <= 0) {; 12786 /* Error: send failed */; 12787 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12788 break;; 12789 }; 12790 ping_count++;; 12791 }; 12792 }; 12793 /* Timeout: should retry */; 12794 /* TODO: get timeout def */; 12795 }; 12796 }; 12797 }; 12798 ; 12799 /* Leave data processing loop */; 12800 mg_set_thread_name(""worker"");; 12801 conn->in_websocket_handling = 0;; 12802 DEBUG_TRACE(""Websocket connection %s:%u left data processing loop"",; 12803 conn->request_info.remote_addr,; 12804 conn->request_info.remote_port);; 12805}; 12806 ; 12807 ; 12808static int; 12809mg_websocket_write_exec(struct mg_connection *conn,; 12810 int opcode,; 12811 const char *data,; 12812 size_t dataLen,; 12813 uint32_t masking_key); 12814{; 12815 unsigned char header[14];; 12816 size_t headerLen;; 12817 int retval;; 12818 ; 12819#if defined(GCC_DIAGNOSTIC); 12820 /* Disable spurious conversion warning for GCC */; 12821#pragma GCC diagnostic push; 12822#pragma GCC diagnostic ignored ""-Wconversion""; 12823#endif; 12824 ; 12825 /* Note that POSIX/Winsock's send() is threadsafe; 12826 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:371820,timeout,timeout,371820,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 12785 ; 12786 if (ret <= 0) {; 12787 /* Error: send failed */; 12788 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12789 break;; 12790 }; 12791 ping_count++;; 12792 }; 12793 }; 12794 /* Timeout: should retry */; 12795 /* TODO: get timeout def */; 12796 }; 12797 }; 12798 }; 12799 ; 12800 /* Leave data processing loop */; 12801 mg_set_thread_name(""worker"");; 12802 conn->in_websocket_handling = 0;; 12803 DEBUG_TRACE(""Websocket connection %s:%u left data processing loop"",; 12804 conn->request_info.remote_addr,; 12805 conn->request_info.remote_port);; 12806}; 12807 ; 12808 ; 12809static int; 12810mg_websocket_write_exec(struct mg_connection *conn,; 12811 int opcode,; 12812 const char *data,; 12813 size_t dataLen,; 12814 uint32_t masking_key); 12815{; 12816 unsigned char header[14];; 12817 size_t headerLen;; 12818 int retval;; 12819 ; 12820#if defined(GCC_DIAGNOSTIC); 12821 /* Disable spurious conversion warning for GCC */; 12822#pragma GCC diagnostic push; 12823#pragma GCC diagnostic ignored ""-Wconversion""; 12824#endif; 12825 ; 12826 /* Note that POSIX/Winsock's send() is threadsafe; 12827 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:371853,timeout,timeout,371853,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"bust locally weighted regression. The American Statistician, 35, 54. . Definition at line 219 of file TGraphSmooth.cxx. ◆ SmoothSuper(). TGraph * TGraphSmooth::SmoothSuper ; (; TGraph * ; grin, . Option_t * ; option = """", . Double_t ; bass = 0, . Double_t ; span = 0, . Bool_t ; isPeriodic = kFALSE, . Double_t * ; w = nullptr . ). Smooth data with Super smoother. ; Smooth the (x, y) values by Friedman's `‘super smoother’'.; Parameters. [in]gringraph for smoothing ; [in]optionspecific options ; [in]spanthe fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. ; [in]basscontrols the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. ; [in]isPeriodicif TRUE, the x values are assumed to be in [0, 1] and of period 1. ; [in]wcase weights. Details:; supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.; The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.; The FORTRAN code says: `‘For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.’'; References:; Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.; Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5. . Definition at line 479 of file TGraphSmooth.cxx. ◆ Streamer().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphSmooth.html:26129,predict,predicted,26129,doc/master/classTGraphSmooth.html,https://root.cern,https://root.cern/doc/master/classTGraphSmooth.html,1,['predict'],['predicted']
Safety,"by observables 'dimSet'. ;  ; void checkBinBounds () const;  ; void importDHistSet (const RooArgList &vars, RooCategory &indexCat, std::map< std::string, RooDataHist * > dmap, double initWgt);  Import data from given set of TH1/2/3 into this RooDataHist. ;  ; void importTH1 (const RooArgList &vars, const TH1 &histo, double initWgt, bool doDensityCorrection);  Import data from given TH1/2/3 into this RooDataHist. ;  ; void importTH1Set (const RooArgList &vars, RooCategory &indexCat, std::map< std::string, TH1 * > hmap, double initWgt, bool doDensityCorrection);  Import data from given set of TH1/2/3 into this RooDataHist. ;  ; void initialize (const char *binningName=nullptr, bool fillTree=true);  Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ;  ; double interpolateDim (int iDim, double xval, size_t centralIdx, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:35208,safe,safe,35208,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety,"by vertices.Definition TGeoPolygon.h:19; TGeoPolygon::IsConvexBool_t IsConvex() constDefinition TGeoPolygon.h:59; TGeoPolygon::GetNconvexInt_t GetNconvex() constDefinition TGeoPolygon.h:53; TGeoPolygon::GetVerticesvoid GetVertices(Double_t *x, Double_t *y) constFill list of vertices into provided arrays.Definition TGeoPolygon.cxx:243; TGeoPolygon::GetNvertInt_t GetNvert() constDefinition TGeoPolygon.h:52; TGeoPolygon::GetConvexVerticesvoid GetConvexVertices(Double_t *x, Double_t *y) constFill list of vertices of the convex outscribed polygon into provided arrays.Definition TGeoPolygon.cxx:252; TGeoShapeAssembly::Classstatic TClass * Class(); TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Contain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:109754,avoid,avoid,109754,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in the constructor or set later with the method SetWeight() of the class TMultiLayerPerceptron. Two datasets must be defined before learning the network: a training dataset that is used when minimizing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “grap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:236130,avoid,avoid,236130,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:53108,timeout,timeout,53108,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['timeout'],['timeout']
Safety,"bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50321,timeout,timeout,50321,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['timeout'],['timeout']
Safety,"c . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAddModel::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAddModel::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 131 of file RooAddModel.h. ◆ clone(). TObject * RooAddModel::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooResolutionModel.; Definition at line 33 of file RooAddModel.h. ◆ coefList(). const RooArgList & RooAddModel::coefList ; (; ); const. inline . Return list of coefficients of component p.d.f.s. ; Definition at line 71 of file RooAddModel.h. ◆ convolution(). RooResolutionModel * RooAddModel::convolution ; (; RooFormulaVar * ; inBasis, . RooAbsArg * ; owner . ); const. overridevirtual . Instantiate a clone of this resolution model representing a convolution with given basis function. ; The owners object name is incorporated in the clones name to avoid multiple convolution objects with the same name in complex PDF structures.; RooAddModel will clone all the component models to create a composite convolution object ; Reimplemented from RooResolutionModel.; Definition at line 224 of file RooAddModel.cxx. ◆ DeclFileName(). static const char * RooAddModel::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 131 of file RooAddModel.h. ◆ doEval(). void RooAddModel::doEval ; (; RooFit::EvalContext & ; ctx); const. overridevirtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented from RooAbsReal.; Definition at line 378 of file RooAddModel.cxx. ◆ evaluate(). double RooAddModel::evaluate ; (; ); const. overridevirtual . Calculate the current value. ; Implements RooAbsReal.; Definition at line 347 of file RooAddModel.cxx. ◆ expectedEvents(). double RooAddModel::expectedEvents ; (; const RooArgSet * ; nset); con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:82237,avoid,avoid,82237,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['avoid'],['avoid']
Safety,"c intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QString SetFileName(const QString& fileName); Set the file pattern. QString GetNewFileName(const QString& fileNamePrototype); Find the filename for the given ""fileNamePrototype"". QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". QWidget * winid(Window_t id); returns the top level QWidget for the ROOT widget. Window_t wid(TQtClientWidget* widget). Window_t rootwid(QPaintDevice* dev). QWidget * wid(Window_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:27946,safe,safely,27946,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,2,['safe'],['safely']
Safety,"c stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged;; 4758}; 4759 ; 4760////////////////////////////////////////////////////////////////////////////////; 4761/// Return kTRUE if 'url' matches the coordinates o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:173680,timeout,timeout,173680,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['timeout'],['timeout']
Safety,"c to support the case where the same object is; 658 //added multiple times in fFunctions.; 659 //This case happens when the same object is added with different; 660 //drawing modes; 661 //In the loop below we must be careful with objects (eg TCutG) that may; 662 // have been added to the list of functions of several histograms; 663 //and may have been already deleted.; 664 while ((obj = fFunctions->First())) {; 665 while(fFunctions->Remove(obj)) { }; 666 if (ROOT::Detail::HasBeenDeleted(obj)) {; 667 break;; 668 }; 669 delete obj;; 670 obj = nullptr;; 671 }; 672 delete fFunctions;; 673 fFunctions = nullptr;; 674 }; 675 if (fDirectory) {; 676 fDirectory->Remove(this);; 677 fDirectory = nullptr;; 678 }; 679 delete fPainter;; 680 fPainter = nullptr;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Constructor for fix bin size histograms.; 685/// Creates the main histogram structure.; 686///; 687/// \param[in] name name of histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:28430,avoid,avoid,28430,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"c voidH2Verr(const TH1D* histo, TVectorD& vec); voidInitHistos(); static TMatrixDMatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); static voidRegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 1e-3); static voidV2H(const TVectorD& vec, TH1D& histo); static TVectorDVecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. const TH2D*fAdetDetector response matrix; const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHistDistribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHistDistribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1). TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1). TH1D* GetD() const; Returns d vector. TH1D* GetSV() const; Returns singular values vector. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVDUnfold.html:6904,detect,detector,6904,root/html528/TSVDUnfold.html,https://root.cern,https://root.cern/root/html528/TSVDUnfold.html,1,['detect'],['detector']
Safety,"cGeom () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; TClass * IsA () const override;  ; virtual Bool_t IsNullBox () const;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:4562,safe,safe,4562,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['safe'],['safe']
Safety,"cOps::ArgMaxstd::size_t ArgMax(const RVec< T > &v)Get the index of the greatest element of an RVec In case of multiple occurrences of the maximum value...Definition RVec.hxx:2067; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T7#define T7Definition md5.inl:152; T6#define T6Definition md5.inl:151; T3#define T3Definition md5.inl:148; T5#define T5Definition md5.inl:150; T4#define T4Definition md5.inl:149; F#define F(x, y, z); I#define I(x, y, z); T1#define T1Definition md5.inl:146; ROOT::Detail::VecOps::IsSmallbool IsSmall(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1118; ROOT::Detail::VecOps::IsAdoptingbool IsAdopting(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1124; ROOT::Internal::VecOps::MapImplauto MapImpl(F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>Definition RVec.hxx:105; ROOT::Internal::VecOps::ResetViewvoid ResetView(RVec< T > &v, T *addr, std::size_t sz)An unsafe function to reset the buffer for which this RVec is acting as a view.Definition RVec.hxx:546; ROOT::Internal::VecOps::NextPowerOf2uint64_t NextPowerOf2(uint64_t A)Return the next power of two (in 64-bits) that is strictly greater than A.Definition RVec.hxx:126; ROOT::Internal::VecOps::Allconstexpr bool All(const bool *vals, std::size_t size)Definition RVec.hxx:79; ROOT::Internal::VecOps::GetVectorsSizestd::size_t GetVectorsSize(const std::string &id, const RVec< T > &... vs)Definition RVec.hxx:88; ROOT::Internal::VecOps::UninitializedValueConstructvoid UninitializedValueConstruct(ForwardIt first, ForwardIt last)Definition RVec.hxx:530; ROOT::Internal::VecOps::MapFromTupleauto MapFromTuple(Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...))Definition RVec.hxx:117; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:154797,unsafe,unsafe,154797,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['unsafe'],['unsafe']
Safety,"cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:53983,predict,predict,53983,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['predict'],['predict']
Safety,"cal shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923023,safe,safe,923023,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"cal so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen positio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPhysicalShape.html:6444,avoid,avoid,6444,root/html528/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html,4,['avoid'],['avoid']
Safety,"cal sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:14100,safe,safe,14100,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,3,['safe'],['safe']
Safety,"calIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:47778,safe,safe,47778,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,6,['safe'],['safe']
Safety,"called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains the fraction of our money invested in each stock . We can calculate the average daily return \( z \) of our portfolio and its variance using the portfolio covariance Covar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2369,risk,risk,2369,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risk']
Safety,"called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1373 of file RooAbsArg.cxx. ◆ removeServer(). void RooAbsArg::removeServer ; (; RooAbsArg & ; server, . bool ; force = false . ). Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ; Definition at line 378 of file RooAbsArg.cxx. ◆ removeStringAttribute(). void RooAbsArg::removeStringAttribute ; (; const Text_t * ; key). Delete a string attribute with a given key. ; Definition at line 266 of file RooAbsArg.cxx. ◆ replaceServer(). void RooAbsArg::replaceServer ; (; RooAbsArg & ; oldServer, . RooAbsArg & ; newServer, . bool ; propValue, . bool ; propShape . ). Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ; WarningThis function should not be used! This method is quite unsafe for many reasons. For once, the new server will be put at the end of the server list, no matter the position of the original server. This might mess up code that expects the servers to be in a certain order. Furthermore, the proxy objects corresponding to the server are not updated, leaving the object in an invalid state where the servers are out of sync with the proxies. This can have very bad consequences. Finally, by having to manually specify the value and shape server properties, it is very easy to get them wrong.; If you want to safely replace a server, you should use RooAbsArg::redirectServers(), which replaces the server in-place at the same position of the server list, keeps the same value and shape server properties, and also updates the corresponding proxies. ; Definition at line 421 of file RooAbsArg.cxx. ◆ resetDataToken(). void RooAbsArg::resetDataToken ; (; ). inline . Definition at line 681 of file RooAbsArg.h. ◆ serverNameChangeHook(). virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:94404,unsafe,unsafe,94404,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['unsafe'],['unsafe']
Safety,"cally it reduces the file size by a factor 10 (compare to the previous implementation) for normal plots with math formulae and greek characters.; Offer 0 as line width option. Useful to make a line invisible. TPDF. When a text size was equal or smaller than 0 the PDF file was corrupted.; Small fix for fill patterns 1, 2 and 3.; When printing a coloured 2D histograms (with option COLZ) into a PDF or PostScript file, the preview on screen using many standard PDF previewer tools showed very thin white lines between the bins as well as in the color palette. This made very ugly the final output. This problem is due to bad implementation of anti-aliasing in these previewers. A way to bypass this issue was to turn off the anti-aliasing in the previewer but then the rest of the document does not look nice. This problem is now bypassed with a fix in both PDF and PostScript output.; Offer 0 as line width option. Useful to make a line invisible. TSVG. Use float numbers instead of integer to describe graphics paths to avoid rounding problems.; Implement missing math symbols.; Offer 0 as line width option. Useful to make a line invisible. TASImage. In the animated gif it is now possible to specify the delay between the last image and the fist image in case of infinite loop. (Fernando Hueso González f.gonzalez at hzdr dot de). TPadPainter. Offer 0 as line width option. Useful to make a line invisible. TPad. In TPad::ShowGuidelines the number of guide lines is limited to 15. Above that they become useless.; Print a warning if one of the pad limit is a NaN.; Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. TCanvas. Make sure that “/” and “.” are not part of the method name when a canvas is saved as a .C file. TLatex. With the Cocoa backend the PDF and PS output produced miss-aligned exponents because the GetTextExtend method behaved differently in batch mode and “screen” mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; Improve the square-root dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:23160,avoid,avoid,23160,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 867 of file TUDPSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TUDPSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 898 of file TUDPSocket.cxx. ◆ Select(). Int_t TUDPSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 407 of file TUDPSocket.cxx. ◆ Send() [1/4]. Int_t TUDPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Definition at line 464 of file TUDPSocket.cxx. ◆ Send() [2/4]. Int_t TUDPSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:29034,timeout,timeout,29034,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['timeout'],['timeout']
Safety,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1,				 const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:62920,safe,safe,62920,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['safe'],['safe']
Safety,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:63907,safe,safe,63907,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['safe'],['safe']
Safety,"canvases. ; Definition at line 149 of file TROOT.h. ◆ fClasses. TCollection* TROOT::fClasses. protected . List of classes definition. ; Definition at line 140 of file TROOT.h. ◆ fClassGenerators. TCollection* TROOT::fClassGenerators. protected . List of user defined class generators;. ; Definition at line 160 of file TROOT.h. ◆ fCleanups. TSeqCollection* TROOT::fCleanups. protected . List of recursiveRemove collections. ; Definition at line 157 of file TROOT.h. ◆ fClipboard. TSeqCollection* TROOT::fClipboard. protected . List of clipboard objects. ; Definition at line 163 of file TROOT.h. ◆ fClosedObjects. TSeqCollection* TROOT::fClosedObjects. protected . List of closed objects from the list of files and sockets, so we can delete them if neededCl. ; Definition at line 145 of file TROOT.h. ◆ fColors. TSeqCollection* TROOT::fColors. protected . List of colors. ; Definition at line 153 of file TROOT.h. ◆ fConfigFeatures. TString TROOT::fConfigFeatures. protected . ROOT ./configure detected build features. ; Definition at line 112 of file TROOT.h. ◆ fConfigOptions. TString TROOT::fConfigOptions. protected . ROOT ./configure set build options. ; Definition at line 111 of file TROOT.h. ◆ fCutClassName. TString TROOT::fCutClassName. protected . Name of default CutG class in graphics editor. ; Definition at line 170 of file TROOT.h. ◆ fDataSets. TSeqCollection* TROOT::fDataSets. protected . List of data sets (TDSet or TChain) ; Definition at line 164 of file TROOT.h. ◆ fDefCanvasName. TString TROOT::fDefCanvasName. protected . Name of default canvas. ; Definition at line 171 of file TROOT.h. ◆ fEditHistograms. Bool_t TROOT::fEditHistograms. protected . True if histograms can be edited with the mouse. ; Definition at line 130 of file TROOT.h. ◆ fEditorMode. Int_t TROOT::fEditorMode. protected . Current Editor mode. ; Definition at line 137 of file TROOT.h. ◆ fEnums. AListOfEnums_t TROOT::fEnums. protected . List of enum types. ; Definition at line 165 of file TROOT.h. ◆ fEsc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:81967,detect,detected,81967,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['detect'],['detected']
Safety,"carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1655,recover,recovery,1655,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void UnixSignal(ESignals sig, void* h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignr is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:36674,timeout,timeout,36674,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"catedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMonitor (Bool_t mainloop=kTRUE);  Create a monitor object. ;  ;  TMonitor (const TMonitor &m);  Copy constructor. ;  ; virtual ~TMonitor ();  Cleanup the monitor object. Does not delete sockets being monitored. ;  ; virtual void Activate (TSocket *sock);  Activate a de-activated socket. ;  ; virtual void ActivateAll ();  Activate all de-activated sockets. ;  ; virtual void Add (TSocket *sock, Int_t interest=kRead);  Add socket to the monitor's active list. ;  ; virtual void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal when some socket is ready. ;  ; virtual void Remove (TSocket *sock);  Remove a socket from the monitor. ;  ; virtual void RemoveAll ();  Remove all sockets from the monitor. ;  ; void ResetInterrupt ();  ; TSocket * Select ();  Return pointer to socket for which an event is waiting. ;  ; TSocket * Select (Long_t timeout);  Return pointer to socket for which an event is waiting. ;  ; Int_t Select (TList *rdready, TList *wrready, Long_t timeout);  Return numbers of sockets that are ready for reading or w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:1727,timeout,timeout,1727,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2304,recover,recovered,2304,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['recover'],['recovered']
Safety,"causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:24575,predict,predict,24575,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['predict'],"['predict', 'predictions']"
Safety,"ccess (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6011 if (n <= 0) {; 6012 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6013 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6014 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6015 n = 0;; 6016 } else {; 6017 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6018 return -2;; 6019 }; 6020 } else {; 602",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:175250,timeout,timeout,175250,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,['timeout'],['timeout']
Safety,"ccess (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6012 if (n <= 0) {; 6013 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6014 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6015 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6016 n = 0;; 6017 } else {; 6018 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6019 return -2;; 6020 }; 6021 } else {; 602",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:175282,timeout,timeout,175282,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,['timeout'],['timeout']
Safety,"ce::CodeRepo::ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,RooWorkspace::CodeRepo::ExtraHeader>_ehmapList of extra header files; map<TString,RooWorkspace::CodeRepo::ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& ); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. CodeRepo(const RooWorkspace::CodeRepo& other, RooWorkspace* wspace = 0); {}. virtual ~CodeRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooWorkspace__CodeRepo.html:7802,abort,abort,7802,root/html602/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html602/RooWorkspace__CodeRepo.html,2,['abort'],['abort']
Safety,"ceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicType.html:3345,detect,detected,3345,doc/master/classTStreamerBasicType.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicType.html,1,['detect'],['detected']
Safety,"ce_Check(pyobject);; 200 ; 201// all C++ objects should have sq_item defined, but a user-derived class may; 202// have deleted it, in which case this is not a sequence; 203 PyTypeObject* t = Py_TYPE(pyobject);; 204 if (!t->tp_as_sequence || !t->tp_as_sequence->sq_item); 205 return false;; 206 ; 207// if this is the default getitem, it is only a sequence if it's an array type; 208 if (t->tp_as_sequence->sq_item == CPPInstance_Type.tp_as_sequence->sq_item) {; 209 if (((CPPInstance*)pyobject)->fFlags & CPPInstance::kIsArray); 210 return true;; 211 return false;; 212 }; 213 ; 214// TODO: could additionally verify whether __len__ is supported and/or whether; 215// operator()[] takes an int argument type; 216 ; 217 return true;; 218}; 219 ; 220//-----------------------------------------------------------------------------; 221bool CPyCppyy::Instance_IsLively(PyObject* pyobject); 222{; 223// Test whether the given instance can safely return to C++; 224 if (!CPPInstance_Check(pyobject)); 225 return true; // simply don't know; 226 ; 227// the instance fails the lively test if it owns the C++ object while having a; 228// reference count of 1 (meaning: it could delete the C++ instance any moment); 229 if (pyobject->ob_refcnt <= 1 && (((CPPInstance*)pyobject)->fFlags & CPPInstance::kIsOwner)); 230 return false;; 231 ; 232 return true;; 233}; 234 ; 235//-----------------------------------------------------------------------------; 236bool CPyCppyy::Overload_Check(PyObject* pyobject); 237{; 238// Test if the given pyobject is of CPPOverload derived type.; 239 if (!Initialize()); 240 return false;; 241 ; 242// detailed walk through inheritance hierarchy; 243 return CPPOverload_Check(pyobject);; 244}; 245 ; 246//-----------------------------------------------------------------------------; 247bool CPyCppyy::Overload_CheckExact(PyObject* pyobject); 248{; 249// Test if the given pyobject is of CPPOverload type.; 250 if (!Initialize()); 251 return false;; 252 ; 253// direct pointer co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:7708,safe,safely,7708,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['safe'],['safely']
Safety,"ced object and the parent object supporting this referenced object ;  CTRegexpRegular expression class ;  CTRemoteObjectProtocol for browsing ROOT objects from a remote ROOT session ;  CTResponseTable;  CTRFIOFileA ROOT file that reads/writes via a rfiod server ;  CTRFIOSystemDirectory handler for RFIO ;  Ctriangulateio;  CTRint;  CTRobustEstimator;  CTRolke;  CTROOTROOT top level object description ;  CTRootApplication;  CTRootAuth;  CTRootBrowser;  CTRootBrowserLite;  CTRootCanvas;  CTRootContextMenu;  CTRootControlBar;  CTRootDialog;  CTRootEmbeddedCanvas;  CTRootGuiBuilder;  CTRootGuiFactory;  CTRootHelpDialog;  CTRootIOCtor;  CTRootSecContext;  CTRootSniffer;  CTRootSnifferScanRec;  CTRootSnifferStoreAbstract interface for storage of hierarchy scan in TRootSniffer ;  CTRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format ;  CTRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format ;  ►CTRotation;  CTRotationRow;  CTRotMatrixManages a detector rotation matrix ;  CTRSA_fun;  CTRuby;  CTRWLock;  CTS3HTTPRequest;  CTS3WebFile;  CTSapDBResult;  CTSapDBRow;  CTSapDBServer;  CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ;  CTSecContext;  CTSecContextCleanup;  CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ;  CTSelectorCintThis class is a special version of TSelector for user interpreted classes ;  CTSelectorDrawA specialized TSelector for TTree::Draw ;  CTSelectorEntriesThe class is derived from the ROOT class TSelector ;  CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees) ;  CTSelectorScalarNamed scalar type, based on Long64_t, streamable, storable and mergable ;  CTSelEvent;  CTSelEventGen;  CTSelHandleDataSet;  CTSelHist;  CTSelVerifyDataSet;  CTSemaphore;  CTSeqCollectionSequenceable collection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:153309,detect,detector,153309,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['detect'],['detector']
Safety,"ceived bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:34522,timeout,timeout,34522,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety,"cess; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results; static TRootSnifferScanRec::(anonymous)kActions; static TRootSnifferScanRec::(anonymous)kCheckChilds; static TRootSnifferScanRec::(anonymous)kExpand; static TRootSnifferScanRec::(anonymous)kOnlyFields; static TRootSnifferScanRec::(anonymous)kScan; static TRootSnifferScanRec::(anonymous)kSearch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they will be replaced with '_'.; To avoid item name duplication, additional id number can be appended. void BuildFullName(TString& buf, TRootSnifferScanRec* prnt = 0); Produce full name, including all parents. void CreateNode(const char* _node_name); creates new node with specified name; if special symbols like ""[]&<>"" are used, node name; will be replaced by default name like ""extra_item_N"" and; original node name will be recorded as ""_original_name"" field; Optionally, object name can be recorded as ""_realname"" field. void CloseNode(); close started node. void SetRootClass(TClass* cl); set root class name as node kind; in addition, path to master item (streamer info) specified; Such master item required to correctly unstream data on JavaScript. Bool_t Done() const; returns true if scanning is done; Can happen when searched element is found. Bool_t IsReadyForResult() const; Checks if result will be accepted.; Used to verify if sniffer should read object from the file. Bool_t SetResult(void* obj, TClass* cl, TDataMember* member = 0); set results of sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSnifferScanRec.html:2999,avoid,avoid,2999,root/html604/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html604/TRootSnifferScanRec.html,1,['avoid'],['avoid']
Safety,"cessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:5365,safe,safe,5365,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['safe'],['safe']
Safety,"cetoPrimitive(). Int_t TGeoSphere::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoSphere::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoSphere::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoSphere::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoSphere::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToSphere(). Double_t TGeoSphere::DistToSphere ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rsph, . Bool_t ; check = kTRUE, . Bool_t ; firstcross = kTRUE . ); const. ◆ Divide(). TGeoVolume * TGeoSphere::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisName(). const char * TGeoSphere::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoSphere::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Rei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:26147,safe,safe,26147,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['safe'],['safe']
Safety,"ch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IBaseParam.html:1663,avoid,avoid,1663,root/html530/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"ch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IBaseParam.html:1663,avoid,avoid,1663,root/html532/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"chanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971099,detect,detector,971099,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,"char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:2428,safe,safe,2428,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,3,['safe'],['safe']
Safety,"char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCtub.html:2823,safe,safe,2823,root/html532/TGeoCtub.html,https://root.cern,https://root.cern/root/html532/TGeoCtub.html,1,['safe'],['safe']
Safety,"cheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:173617,timeout,timeout,173617,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,"cified entries.; Returns -1 in case of error or number of selected events in case of success.; For more see TTree::Draw(). void StartViewer(); Start the TTreeViewer on this TTree. TTree* GetTreeHeader(TProof* proof); Returns a tree header containing the branches' structure of the dataset. Bool_t ElementsValid(); Check if all elements are valid. Int_t Remove(TDSetElement* elem, Bool_t deleteElem = kTRUE); Remove TDSetElement 'elem' from the list.; Return 0 on success, -1 if the element is not in the list. void Validate(); Validate the TDSet by opening files. void Lookup(Bool_t removeMissing = kFALSE, TList** missingFiles = 0); Resolve the end-point URL for the current elements of this data set; If the removeMissing option is set to kTRUE, remove the TDSetElements; that can not be located.; The method returns the list of removed TDSetElements in *listOfMissingFiles; if the latter is defined (the list must be created outside). void SetLookedUp(); Flag all the elements as looked-up, so to avoid opening the files; if the functionality is not supported. void Validate(TDSet* dset); Validate the TDSet against another TDSet.; Only validates elements in common from input TDSet. void Streamer(TBuffer& ); Stream an object of class TDSet. void SetWriteV3(Bool_t on = kTRUE); Set/Reset the 'OldStreamer' bit in this instance and its elements.; Needed for backward compatibility in talking to old client / masters. void SetEntryList(TObject* aList); Set entry (or event) list for this data set. void SplitEntryList(); Splits the main entry (or event) list into sub-lists for the elements of; thet data set. Int_t GetNumOfFiles(); Return the number of files in the dataset. TDSetElement& operator=(const TDSet& ). const char * GetObjName() const; { return GetTitle(); }. const char * GetDirectory() const. TObject * GetEntryList() const; { return fEntryList; }. TDSet(const TDSet& ). Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDSet.html:15499,avoid,avoid,15499,root/html534/TDSet.html,https://root.cern,https://root.cern/root/html534/TDSet.html,3,['avoid'],['avoid']
Safety,"cified entries.; Returns -1 in case of error or number of selected events in case of success.; For more see TTree::Draw(). void StartViewer(); Start the TTreeViewer on this TTree. TTree* GetTreeHeader(TProof* proof); Returns a tree header containing the branches' structure of the dataset. Bool_t ElementsValid(); Check if all elements are valid. Int_t Remove(TDSetElement* elem, Bool_t deleteElem = kTRUE); Remove TDSetElement 'elem' from the list.; Return 0 on success, -1 if the element is not in the list. void Validate(); Validate the TDSet by opening files. void Lookup(Bool_t removeMissing = kFALSE, TList** missingFiles = 0); Resolve the end-point URL for the current elements of this data set; If the removeMissing option is set to kTRUE, remove the TDSetElements; that can not be located.; The method returns the list of removed TDSetElements in *listOfMissingFiles; if the latter is defined (the list must be created outside). void SetLookedUp(); Flag all the elements as looked-up, so to avoid opening the files; if the functionality is not supported. void Validate(TDSet* dset); Validate the TDSet against another TDSet.; Only validates elements in common from input TDSet. void Streamer(TBuffer& b); Stream an object of class TDSet. void SetWriteV3(Bool_t on = kTRUE); Set/Reset the 'OldStreamer' bit in this instance and its elements.; Needed for backward compatibility in talking to old client / masters. void SetEntryList(TObject* aList); Set entry (or event) list for this data set. void SplitEntryList(); Splits the main entry (or event) list into sub-lists for the elements of; thet data set. Int_t GetNumOfFiles(); Return the number of files in the dataset. TDSetElement& operator=(const TDSet& ). const char * GetObjName() const; { return GetTitle(); }. const char * GetDirectory() const. TObject * GetEntryList() const; { return fEntryList; }. TDSet(const TDSet& ). Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDSet.html:14899,avoid,avoid,14899,root/html528/TDSet.html,https://root.cern,https://root.cern/root/html528/TDSet.html,3,['avoid'],['avoid']
Safety,"cifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:13721,safe,safe,13721,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,3,['safe'],['safe']
Safety,"citMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:25154,safe,safe,25154,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['safe'],['safe']
Safety,"city() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of ax",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:13543,safe,safe,13543,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,3,['safe'],['safe']
Safety,"civetweb.c:3149; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16230; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3166; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10317; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18031; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20559; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6184; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17979; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1851; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17216; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20496; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6468; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4350; mg_startstruct mg_context * mg_start(const struct mg_callbacks *callbacks, void *user_data, const char **options)Definition civetweb.c:20284; MG_FOPEN_MODE_READ#define MG_FOPEN_MODE_READDefinition civetw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:659696,timeout,timeout,659696,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"civetweb.c:3150; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16231; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3167; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10318; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18032; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20560; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6185; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17980; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1852; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17217; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20497; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6469; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4351; mg_startstruct mg_context * mg_start(const struct mg_callbacks *callbacks, void *user_data, const char **options)Definition civetweb.c:20285; MG_FOPEN_MODE_READ#define MG_FOPEN_MODE_READDefinition civetw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:659729,timeout,timeout,659729,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"cket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUDPSocket.html:12899,timeout,timeout,12899,root/html532/TUDPSocket.html,https://root.cern,https://root.cern/root/html532/TUDPSocket.html,1,['timeout'],['timeout']
Safety,"cl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. Monte Carlo inputs:. xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins). Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitely, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by. TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );. where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments. Covariance matrices on the measured spectrum (for either the total uncertainties or i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSVDUnfold.html:1251,detect,detector,1251,root/html532/TSVDUnfold.html,https://root.cern,https://root.cern/root/html532/TSVDUnfold.html,1,['detect'],['detector']
Safety,"class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. TBackCompFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.68300000000000005); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBackCompFitter.html:1180,avoid,avoid,1180,root/html602/TBackCompFitter.html,https://root.cern,https://root.cern/root/html602/TBackCompFitter.html,2,['avoid'],['avoid']
Safety,"class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. More...;  ; struct  RDavixFileDes;  ; struct  RecurseCounts;  ; struct  RHashMap;  ; class  RIoUring;  ; class  RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  RRawFileDavix;  The RRawFileDavix class provides read-only access to remote non-ROOT files. More...;  ; class  RRawFileNetXNG;  The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. More...;  ; struct  RRawFileNetXNGImpl;  ; class  RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  RSlotStack;  A thread-safe stack of N indexes (0 to size - 1). More...;  ; struct  RSlotStackRAII;  A RAII object to pop and push slot numbers from a RSlotStack object. More...;  ; class  RStl;  ; class  RTaskArenaWrapper;  Wrapper for tbb::task_arena. More...;  ; class  TArrayCharProxy;  Concrete Implementation of the branch proxy around the data members which are array of char. More...;  ; class  TArrayProxy;  Template for concrete implementation of proxy around array of T. More...;  ; struct  TArrayType;  Helper template to be able to determine and use array dimensions. More...;  ; struct  TArrayType< T, 0 >;  Helper class for proxy around multi dimension array. More...;  ; class  TAtomicPointer;  Helper class to manage atomic pointers. More...;  ; class  TBranchCacheInfo;  ; class  TBranchDescriptor;  ; class  TBranchIMTHelper;  A helper class for managing IMT work during TTree:Fill operations. More...;  ; class  TBranchProxyClassDescriptor;  ; class  TBranchProxyDescriptor;  ; class  TBranchProxyDirector;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:2329,safe,safe,2329,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['safe'],['safe']
Safety,"class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:65924,safe,safety,65924,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"clicMode(expandedDir,mode,fargs,io);; 531 char *mac;; 532 if (!fFiles) fFiles = new TObjArray;; 533 if ((mac = gSystem->Which(TROOT::GetMacroPath(), fname,; 534 kReadPermission))) {; 535 // if file add to list of files to be processed; 536 fFiles->Add(new TObjString(argv[i]));; 537 argv[i] = null;; 538 delete [] mac;; 539 } else {; 540 // if file add an invalid entry to list of files to be processed; 541 fFiles->Add(new TNamed(""NOT FOUND!"", argv[i]));; 542 // only warn if we're plain root,; 543 // other progs might have their own params; 544 if (!strcmp(gROOT->GetName(), ""Rint"")) {; 545 Error(""GetOptions"", ""macro %s not found"", fname.Data());; 546 // Return 2 as the Python interpreter does in case the macro; 547 // is not found.; 548 Terminate(2);; 549 }; 550 }; 551 }; 552 }; 553 }; 554 // ignore unknown options; 555 }; 556 ; 557 // go back to startup directory; 558 if (pwd != """"); 559 gSystem->ChangeDirectory(pwd);; 560 ; 561 // remove handled arguments from argument array; 562 j = 0;; 563 for (i = 0; i < *argc; i++) {; 564 if (strcmp(argv[i], """")) {; 565 argv[j] = argv[i];; 566 j++;; 567 }; 568 }; 569 ; 570 *argc = j;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Handle idle timeout. When this timer expires the registered idle command; 575/// will be executed by this routine and a signal will be emitted.; 576 ; 577void TApplication::HandleIdleTimer(); 578{; 579 if (!fIdleCommand.IsNull()); 580 ProcessLine(GetIdleCommand());; 581 ; 582 Emit(""HandleIdleTimer()"");; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Handle exceptions (kSigBus, kSigSegmentationViolation,; 587/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 588/// Specific TApplication implementations may want something different here.; 589 ; 590void TApplication::HandleException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:19569,timeout,timeout,19569,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['timeout'],['timeout']
Safety,"cludes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSubtraction.html:8738,safe,safe,8738,root/html528/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"cludes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoSubtraction.html:8838,safe,safe,8838,root/html530/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"cludes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSubtraction.html:9042,safe,safe,9042,root/html532/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html532/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:533958,timeout,timeout,533958,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,['timeout'],['timeout']
Safety,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:533991,timeout,timeout,533991,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,['timeout'],['timeout']
Safety,"code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; 17078close_connection(struct mg_connection *conn); 17079{; 17080#if defined(USE_SERVER_STATS); 17081 conn->conn_state = 6; /* to close */; 17082#endif; 17083 ; 17084#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17085 if (conn->lua_websocket_state) {; 17086 lua_websocket_close(conn, conn->lua_websocket_state);; 17087 conn->lua_websocket_state = NULL;; 17088 }; 17089#endif; 17090 ; 17091 mg_lock_connection(conn);; 17092 ; 17093 /* Set close flag, so keep-alive loops will stop */; 17094 conn->must_close = 1;; 17095 ; 17096 /* call the connection_close callback if assigned */; 17097 if (conn->phys_ctx->callbacks.connection_close != NULL) {; 17098 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17099 conn->phys_ctx->callbacks.connection_close(conn);; 17100 }; 17101 }; 17102 ; 17103 /* Reset user data,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:506855,safe,safe,506855,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; 17079close_connection(struct mg_connection *conn); 17080{; 17081#if defined(USE_SERVER_STATS); 17082 conn->conn_state = 6; /* to close */; 17083#endif; 17084 ; 17085#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17086 if (conn->lua_websocket_state) {; 17087 lua_websocket_close(conn, conn->lua_websocket_state);; 17088 conn->lua_websocket_state = NULL;; 17089 }; 17090#endif; 17091 ; 17092 mg_lock_connection(conn);; 17093 ; 17094 /* Set close flag, so keep-alive loops will stop */; 17095 conn->must_close = 1;; 17096 ; 17097 /* call the connection_close callback if assigned */; 17098 if (conn->phys_ctx->callbacks.connection_close != NULL) {; 17099 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17100 conn->phys_ctx->callbacks.connection_close(conn);; 17101 }; 17102 }; 17103 ; 17104 /* Reset user data,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:506888,safe,safe,506888,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromInvalidParameters.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7843,recover,recovery,7843,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,2,['recover'],['recovery']
Safety,"column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46915,risk,risks,46915,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['risk'],['risks']
Safety,"compatibility with the first implementation. ; Definition at line 103 of file TSemaphore.cxx. ◆ Streamer(). void TSemaphore::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TSemaphore::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file TSemaphore.h. ◆ TryWait(). Int_t TSemaphore::TryWait ; (; ). If the semaphore value is > 0 then decrement it and return 0. ; If it's already 0 then return 1. This call never blocks. ; Definition at line 87 of file TSemaphore.cxx. ◆ Wait() [1/2]. Int_t TSemaphore::Wait ; (; ). If the semaphore value is > 0 then decrement it and carry on, else block, waiting on the condition until it is signaled. ; Returns always 0, for backward compatibility with the first implementation. ; Definition at line 35 of file TSemaphore.cxx. ◆ Wait() [2/2]. Int_t TSemaphore::Wait ; (; Int_t ; millisec). If the semaphore value is > 0 then decrement it and carry on, else block. ; If millisec > 0 then a relative timeout of millisec milliseconds is applied. For backward compatibility with the first implementation, millisec == 0 means no timeout. Returns 1 if timed-out, 0 otherwise. ; Definition at line 57 of file TSemaphore.cxx. Member Data Documentation. ◆ fCond. std::condition_variable TSemaphore::fCond. private . Definition at line 33 of file TSemaphore.h. ◆ fMutex. std::mutex TSemaphore::fMutex. private . Definition at line 32 of file TSemaphore.h. ◆ fValue. Int_t TSemaphore::fValue. private . Definition at line 34 of file TSemaphore.h. ◆ fWakeups. UInt_t TSemaphore::fWakeups. private . Definition at line 35 of file TSemaphore.h. Libraries for TSemaphore:. [legend]; The documentation for this class was generated from the following files:; core/thread/inc/TSemaphore.h; core/thread/src/TSemaphore.cxx. TSemaphore. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSemaphore.html:13188,timeout,timeout,13188,doc/master/classTSemaphore.html,https://root.cern,https://root.cern/doc/master/classTSemaphore.html,2,['timeout'],['timeout']
Safety,"compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id: TFractionFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:18490,predict,prediction,18490,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['predict'],['prediction']
Safety,"config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:15505,timeout,timeout,15505,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,6,['timeout'],['timeout']
Safety,"config"")) {; 376 fprintf(stderr, ""ROOT ./configure options:\n%s\n"", gROOT->GetConfigOptions());; 377 Terminate(0);; 378 } else if (!strcmp(argv[i], ""-a"")) {; 379 fprintf(stderr, ""ROOT splash screen is not visible with root.exe, use root instead.\n"");; 380 Terminate(0);; 381 } else if (!strcmp(argv[i], ""-b"")) {; 382 MakeBatch();; 383 argv[i] = null;; 384 } else if (!strcmp(argv[i], ""-n"")) {; 385 fNoLog = kTRUE;; 386 argv[i] = null;; 387 } else if (!strcmp(argv[i], ""-t"")) {; 388 ROOT::EnableImplicitMT();; 389 // EnableImplicitMT() only enables thread safety if IMT was configured;; 390 // enable thread safety even with IMT off:; 391 ROOT::EnableThreadSafety();; 392 argv[i] = null;; 393 } else if (!strcmp(argv[i], ""-q"")) {; 394 fQuit = kTRUE;; 395 argv[i] = null;; 396 } else if (!strcmp(argv[i], ""-l"")) {; 397 // used by front-end program to not display splash screen; 398 fNoLogo = kTRUE;; 399 argv[i] = null;; 400 } else if (!strcmp(argv[i], ""-x"")) {; 401 fExitOnException = kExit;; 402 argv[i] = null;; 403 } else if (!strcmp(argv[i], ""-splash"")) {; 404 // used when started by front-end program to signal that; 405 // splash screen can be popped down (TRint::PrintLogo()); 406 argv[i] = null;; 407 } else if (strncmp(argv[i], ""--web"", 5) == 0) {; 408 // the web mode is requested; 409 const char *opt = argv[i] + 5;; 410 argv[i] = null;; 411 gROOT->SetWebDisplay((*opt == '=') ? opt + 1 : """");; 412 } else if (!strcmp(argv[i], ""-e"")) {; 413 argv[i] = null;; 414 ++i;; 415 ; 416 if ( i < *argc ) {; 417 if (!fFiles) fFiles = new TObjArray;; 418 TObjString *expr = new TObjString(argv[i]);; 419 expr->SetBit(kExpression);; 420 fFiles->Add(expr);; 421 argv[i] = null;; 422 } else {; 423 Warning(""GetOptions"", ""-e must be followed by an expression."");; 424 }; 425 } else if (!strcmp(argv[i], ""--"")) {; 426 TObjString* macro = nullptr;; 427 bool warnShown = false;; 428 ; 429 if (fFiles) {; 430 for (auto f: *fFiles) {; 431 TObjString *file = dynamic_cast<TObjString *>(f);; 432 if (!file) {; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:13598,safe,safety,13598,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,['safe'],['safety']
Safety,"const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::InspectShapevoid InspectShape() const override; TGeoTube::ContainsBool_t Contains(const Double_t *point) const override; TGeoTube::fRmaxDouble_t fRmaxDefinition TGeoTube.h:21; TGeoTube::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTube::SetSegsAndPolsvoid SetSegsAndPols(TBuffer3D &buff) const override; TGeoTube::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTube::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTube::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoTube::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTube::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTube::Capacitystatic Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::CapacityDouble_t Capacity() const override; TGeoTube::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTube::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::Sizeof3Dvoid Sizeof3D() const override; TGeoTube::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTube::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTube::TGeoTubeTGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::HasRminBool_t HasRmin() constDefinition TGeoTube.h:75; TGeoTube::GetAxisNameconst char * GetAxisName(Int_t iaxis) const override; TGeoTube::GetRmaxvirtual Double_t GetRmax() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:27199,safe,safe,27199,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoTorus::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisName(). const char * TGeoTorus::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoTorus::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoTorus::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoTorus::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoTorus::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoTorus.h. ◆ GetDphi(). Double_t TGeoTorus::GetDphi ; (; ); const. inline . Definition at line 77 of file TGeoTorus.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoTorus::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoTorus::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoTorus::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPhi1(). Double_t TGeoTorus::GetPhi1 ; (; ); const. inline . Definition at line 76 of file TGeoTorus.h. ◆ GetPointsOnSegments(). Bool_t TGeoTorus::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:27372,avoid,avoid,27372,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['avoid'],['avoid']
Safety,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:3054,safe,safe,3054,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,3,['safe'],['safe']
Safety,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:2840,safe,safe,2840,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['safe'],['safe']
Safety,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:2617,safe,safe,2617,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,9,['safe'],['safe']
Safety,"const PDF& pdfB ) const; 175{; 176 Double_t xmin = pdfS.GetXmin();; 177 Double_t xmax = pdfS.GetXmax();; 178 // sanity check; 179 if (xmin != pdfB.GetXmin() || xmax != pdfB.GetXmax()) {; 180 Log() << kFATAL << ""<GetSeparation> Mismatch in PDF limits: ""; 181 << xmin << "" "" << pdfB.GetXmin() << xmax << "" "" << pdfB.GetXmax() << Endl;; 182 }; 183 ; 184 Double_t separation = 0;; 185 Int_t nstep = 100;; 186 Double_t intBin = (xmax - xmin)/Double_t(nstep);; 187 for (Int_t bin=0; bin<nstep; bin++) {; 188 Double_t x = (bin + 0.5)*intBin + xmin;; 189 Double_t s = pdfS.GetVal( x );; 190 Double_t b = pdfB.GetVal( x );; 191 // separation; 192 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 193 }; 194 separation *= (0.5*intBin);; 195 ; 196 return separation;; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// sanity check; 201 ; 202void TMVA::Tools::ComputeStat( const std::vector<TMVA::Event*>& events, std::vector<Float_t>* valVec,; 203 Double_t& meanS, Double_t& meanB,; 204 Double_t& rmsS, Double_t& rmsB,; 205 Double_t& xmin, Double_t& xmax,; 206 Int_t signalClass, Bool_t norm ); 207{; 208 if (0 == valVec); 209 Log() << kFATAL << ""<Tools::ComputeStat> value vector is zero pointer"" << Endl;; 210 ; 211 if ( events.size() != valVec->size() ); 212 Log() << kWARNING << ""<Tools::ComputeStat> event and value vector have different lengths ""; 213 << events.size() << ""!="" << valVec->size() << Endl;; 214 ; 215 Long64_t entries = valVec->size();; 216 ; 217 // first fill signal and background in arrays before analysis; 218 Double_t* varVecS = new Double_t[entries];; 219 Double_t* varVecB = new Double_t[entries];; 220 Double_t* wgtVecS = new Double_t[entries];; 221 Double_t* wgtVecB = new Double_t[entries];; 222 xmin = +DBL_MAX;; 223 xmax = -DBL_MAX;; 224 Long64_t nEventsS = 0;; 225 Long64_t nEventsB = 0;; 226 Double_t xmin_ = 0, xmax_ = 0;; 227 ; 228 if (norm) {; 229 xmin_ = *std::min( valVec->begin(), valVec->end() );; 230 xmax_ = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:6837,sanity check,sanity check,6837,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSVDUnfold.html:7598,detect,detector,7598,root/html530/TSVDUnfold.html,https://root.cern,https://root.cern/root/html530/TSVDUnfold.html,3,['detect'],['detector']
Safety,"const char * TRootSniffer::GetAutoLoad ; (; ); const. return name of configured autoload scripts (or 0) ; Definition at line 490 of file TRootSniffer.cxx. ◆ GetItem(). TObject * TRootSniffer::GetItem ; (; const char * ; fullname, . TFolder *& ; parent, . Bool_t ; force = kFALSE, . Bool_t ; within_objects = kTRUE . ). protected . Return item from the subfolders structure. ; Definition at line 1571 of file TRootSniffer.cxx. ◆ GetItemField() [1/2]. const char * TRootSniffer::GetItemField ; (; const char * ; fullname, . const char * ; name . ). Return field for specified item. ; Definition at line 1836 of file TRootSniffer.cxx. ◆ GetItemField() [2/2]. const char * TRootSniffer::GetItemField ; (; TFolder * ; parent, . TObject * ; item, . const char * ; name . ). protected . Return field for specified item. ; Definition at line 1820 of file TRootSniffer.cxx. ◆ GetItemHash(). ULong_t TRootSniffer::GetItemHash ; (; const char * ; itemname). virtual . Get hash function for specified item used to detect any changes in the specified object. ; Reimplemented in TRootSnifferFull.; Definition at line 1099 of file TRootSniffer.cxx. ◆ GetStreamerInfoHash(). virtual ULong_t TRootSniffer::GetStreamerInfoHash ; (; ). inlinevirtual . Reimplemented in TRootSnifferFull.; Definition at line 243 of file TRootSniffer.h. ◆ GetSubFolder(). TFolder * TRootSniffer::GetSubFolder ; (; const char * ; foldername, . Bool_t ; force = kFALSE . ). protected . Creates subfolder where objects can be registered. ; Definition at line 1622 of file TRootSniffer.cxx. ◆ GetTopFolder(). TFolder * TRootSniffer::GetTopFolder ; (; Bool_t ; force = kFALSE). Returns top TFolder instance for the sniffer. ; Definition at line 932 of file TRootSniffer.cxx. ◆ HasRestriction(). Bool_t TRootSniffer::HasRestriction ; (; const char * ; item_name). Made fast check if item with specified name is in restriction list If returns true, requires precise check with CheckRestriction() method. ; Definition at line 499 of file TRootSnif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:25826,detect,detect,25826,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['detect'],['detect']
Safety,"const char *). This function:; reads a Tree with name treename from the file; adds the Tree to the list of friends . Reimplemented in TChain.; Definition at line 1366 of file TTree.cxx. ◆ AddFriend() [3/3]. TFriendElement * TTree::AddFriend ; (; TTree * ; tree, . const char * ; alias = """", . bool ; warn = false . ). virtual . Add a TFriendElement to the list of friends. ; The TTree is managed by the user (e.g., the user must delete the file). For a complete description see AddFriend(const char *, const char *). ; Reimplemented in TChain.; Definition at line 1397 of file TTree.cxx. ◆ AddTotBytes(). virtual void TTree::AddTotBytes ; (; Int_t ; tot). inlinevirtual . Definition at line 331 of file TTree.h. ◆ AddZipBytes(). virtual void TTree::AddZipBytes ; (; Int_t ; zip). inlinevirtual . Definition at line 332 of file TTree.h. ◆ AutoSave(). Long64_t TTree::AutoSave ; (; Option_t * ; option = """"). virtual . AutoSave tree header every fAutoSave bytes. ; When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:74526,safe,safe,74526,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['safe'],['safe']
Safety,"const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerMulti.html:5830,abort,abort,5830,root/html530/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html530/TPacketizerMulti.html,2,['abort'],['abort']
Safety,"const. inline . Definition at line 156 of file TGeoNavigator.h. ◆ GetNextDaughterIndex(). Int_t TGeoNavigator::GetNextDaughterIndex ; (; ); const. inline . Definition at line 153 of file TGeoNavigator.h. ◆ GetNextNode(). TGeoNode * TGeoNavigator::GetNextNode ; (; ); const. inline . Definition at line 154 of file TGeoNavigator.h. ◆ GetNmany(). Int_t TGeoNavigator::GetNmany ; (; ); const. inline . Definition at line 105 of file TGeoNavigator.h. ◆ GetNodeId(). Int_t TGeoNavigator::GetNodeId ; (; ); const. inline . Definition at line 152 of file TGeoNavigator.h. ◆ GetNormal(). const Double_t * TGeoNavigator::GetNormal ; (; ); const. inline . Definition at line 168 of file TGeoNavigator.h. ◆ GetPath(). const char * TGeoNavigator::GetPath ; (; ); const. Get path to the current node in the form /node0/node1/... ; Definition at line 2682 of file TGeoNavigator.cxx. ◆ GetPWSafety(). double TGeoNavigator::GetPWSafety ; (; Double_t ; cpoint[3], . Double_t ; saf_max . ). Wrapper for getting the safety from the parallel world. ; Takes care of caching mechanics + talking to the parallel world. ; Definition at line 1656 of file TGeoNavigator.cxx. ◆ GetPWSafetyEstimateFromCache(). Double_t TGeoNavigator::GetPWSafetyEstimateFromCache ; (; Double_t ; cpoint[3]); const. inline . Definition at line 208 of file TGeoNavigator.h. ◆ GetSafeDistance(). Double_t TGeoNavigator::GetSafeDistance ; (; ); const. inline . Definition at line 126 of file TGeoNavigator.h. ◆ GetSafeLevel(). Int_t TGeoNavigator::GetSafeLevel ; (; ); const. Go upwards the tree until a non-overlapping node. ; Definition at line 2406 of file TGeoNavigator.cxx. ◆ GetStackLevel(). Int_t TGeoNavigator::GetStackLevel ; (; ); const. inline . Definition at line 171 of file TGeoNavigator.h. ◆ GetStep(). Double_t TGeoNavigator::GetStep ; (; ); const. inline . Definition at line 128 of file TGeoNavigator.h. ◆ GetThreadId(). Int_t TGeoNavigator::GetThreadId ; (; ); const. inline . Definition at line 129 of file TGeoNavigator.h. ◆ Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:33571,safe,safety,33571,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 415 of file RooTemplateProxy.h. ◆ lvptr() [3/4]. template<class T > . LValue_t * RooTemplateProxy< T >::lvptr ; (; LValue_t * ; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 411 of file RooTemplateProxy.h. ◆ lvptr() [4/4]. template<class T > . LValue_t * RooTemplateProxy< T >::lvptr ; (; RooAbsArg * ; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:25239,safe,safe,25239,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:7546,avoid,avoid,7546,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,5,['avoid'],['avoid']
Safety,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:7186,avoid,avoid,7186,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,5,['avoid'],['avoid']
Safety,"const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ Safety_v(). virtual void TGeoShape::Safety_v ; (; const Double_t * ; , . const Bool_t * ; , . Double_t * ; , . Int_t ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 151 of file TGeoShape.h. ◆ SafetyPhi(). Double_t TGeoShape::SafetyPhi ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; phi1, . Double_t ; phi2 . ). static . Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ; Definition at line 494 of file TGeoShape.cxx. ◆ SafetySeg(). Double_t TGeoShape::SafetySeg ; (; Double_t ; r, . Double_t ; z, . Double_t ; r1, . Double_t ; z1, . Double_t ; r2, . Double_t ; z2, . Bool_t ; outer . ). static . Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ; Definition at line 528 of file TGeoShape.cxx. ◆ SetDimensions(). virtual void TGeoShape::SetDimensions ; (; Double_t * ; param). pure virtual . Implemented in TGeoCompositeShape, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ SetId(). void TGeoShape::SetId ; (; Int_t ; id). inline . Definition at line 155 of file TGeoShape.h. ◆ SetOnBoundary(). void TGeoShape::SetOnBoundary ; (; Bool_t ; ). inlineprotecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:46697,safe,safety,46697,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safety']
Safety,"const; Int_tLoadDir(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfCurcurrent entry; TDSet*fDSetdata set over which to iterate; TDirectory*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEventIter(); Destructor. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 30859 2009-10-24 14:53:07Z ganis $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIter.html:6444,abort,abort,6444,root/html528/TEventIter.html,https://root.cern,https://root.cern/root/html528/TEventIter.html,1,['abort'],['abort']
Safety,"const; Make a clone of this. Pointers are preserved. void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoUnion.html:9305,safe,safe,9305,root/html534/TGeoUnion.html,https://root.cern,https://root.cern/root/html534/TGeoUnion.html,1,['safe'],['safe']
Safety,"const; Make a clone of this. Pointers are preserved. void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoUnion.html:9903,safe,safe,9903,root/html604/TGeoUnion.html,https://root.cern,https://root.cern/root/html604/TGeoUnion.html,1,['safe'],['safe']
Safety,"const; Make a clone of this. Pointers are preserved. void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoUnion.html:9903,safe,safe,9903,root/html602/TGeoUnion.html,https://root.cern,https://root.cern/root/html602/TGeoUnion.html,1,['safe'],['safe']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSAViewer.html:27636,timeout,timeout,27636,root/html534/TGLSAViewer.html,https://root.cern,https://root.cern/root/html534/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:29921,timeout,timeout,29921,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSAViewer.html:29790,timeout,timeout,29790,root/html602/TGLSAViewer.html,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSAViewer.html:27118,timeout,timeout,27118,root/html528/TGLSAViewer.html,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLSAViewer.html:27238,timeout,timeout,27238,root/html530/TGLSAViewer.html,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLSAViewer.html:27238,timeout,timeout,27238,root/html532/TGLSAViewer.html,https://root.cern,https://root.cern/root/html532/TGLSAViewer.html,1,['timeout'],['timeout']
Safety,"const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. Bool_t IsTransient() const; Return kTRUE if the element represent an entity that is not written; to the disk (transient members, cache allocator/deallocator, etc.). void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to Streamer function for this element. void Streamer(TBuffer& ); Stream an object of class TStreamerElement. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. TStreamerElement(const TStreamerElement& ). TStreamerElement& operator=(const TStreamerElement& ). Int_t GetArrayDim() const; {return fArrayDim;}. Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerElement.html:10860,detect,detected,10860,root/html602/TStreamerElement.html,https://root.cern,https://root.cern/root/html602/TStreamerElement.html,2,['detect'],['detected']
Safety,"const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to Streamer function for this element. void Streamer(TBuffer& ); Stream an object of class TStreamerElement. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. TStreamerElement(const TStreamerElement& ). TStreamerElement& operator=(const TStreamerElement& ). Int_t GetArrayDim() const; {return fArrayDim;}. Int_t GetArrayLength() const; {return fArrayLength;}. TClass * GetClass() const; {return GetClassPointer();}. const char * GetInclude() const; {return """";}. Int_t GetMaxIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerElement.html:9570,detect,detected,9570,root/html534/TStreamerElement.html,https://root.cern,https://root.cern/root/html534/TStreamerElement.html,1,['detect'],['detected']
Safety,"const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPcon.html:2247,safe,safe,2247,root/html532/TGeoPcon.html,https://root.cern,https://root.cern/root/html532/TGeoPcon.html,1,['safe'],['safe']
Safety,"const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIter&operator=(const TEventIter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIter.html:4720,abort,abort,4720,root/html534/TEventIter.html,https://root.cern,https://root.cern/root/html534/TEventIter.html,1,['abort'],['abort']
Safety,"const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TProofServ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void ErrorHandler (Int_t level, Bool_t abort, const char *location, const char *msg);  The PROOF error handler function. ;  ; static void FilterLocalroot (TString &path, const char *url=""root://dum/"");  If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings, if any. ;  ; static TMap * GetDataSetNodeMap (TFileCollection *fc, TString &emsg);  Get a map {server-name, list-of-files} for collection 'fc' to be used in TPacketizerFile. ;  ; static void GetLocalServer (TString &dsrv);  Extract LOCALDATASERVER info in 'dsrv'. ;  ; static Float_t GetMemHWM ();  MemHWM getter. ;  ; static Float_t GetMemStop ();  MemStop getter. ;  ; static Long_t GetResMemMax ();  ResMemMax getter. ;  ; static Long_t GetVirtMemMax ();  VirtMemMax getter. ;  ; static Bool_t IsActive ();  Static function that returns kTRUE in case we are a PROOF server. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:18305,abort,abort,18305,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['abort'],['abort']
Safety,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:23451,timeout,timeout,23451,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:23067,timeout,timeout,23067,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22729,timeout,timeout,22729,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"coord from vy; and the errors from vectors vex and vey.; The number of points in the graph is the minimum of number of points; in vx and vy. TGraphErrors(const TGraphErrors& gr); TGraphErrors copy constructor. TGraphErrors& operator=(const TGraphErrors& gr); TGraphErrors assignment operator. TGraphErrors(const TH1* h); TGraphErrors constructor importing its parameters from the TH1 object passed as argument. TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); GraphErrors constructor reading input from filename; filename is assumed to contain at least 3 columns of numbers; convention for format (default=""%lg %lg %lg %lg); format = ""%lg %lg"" read only 2 first columns into X,Y; format = ""%lg %lg %lg"" read only 3 first columns into X,Y and EY; format = ""%lg %lg %lg %lg"" read only 4 first columns into X,Y,EX,EY. For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower.; In case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:17073,avoid,avoid,17073,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,3,['avoid'],['avoid']
Safety,corder/replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:121026,safe,safe,121026,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,"['detect', 'safe']","['detector', 'safe']"
Safety,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35624,recover,recovered,35624,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24737,detect,detected,24737,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['detect'],['detected']
Safety,"cribing this class . ◆ Class_Name(). static const char * TShape::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TShape::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 65 of file TShape.h. ◆ DeclFileName(). static const char * TShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 65 of file TShape.h. ◆ FillBuffer3D(). void TShape::FillBuffer3D ; (; TBuffer3D & ; buffer, . Int_t ; reqSections . ); const. protectedvirtual . We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ; Definition at line 211 of file TShape.cxx. ◆ GetBasicColor(). Int_t TShape::GetBasicColor ; (; ); const. protected . Get basic color. ; Definition at line 241 of file TShape.cxx. ◆ GetBuffer3D(). const TBuffer3D & TShape::GetBuffer3D ; (; Int_t ; reqSections); const. virtual . Stub to avoid forcing implementation at this stage. ; Reimplemented in TBRIK, TPCON, TSPHE, TTUBE, TTUBS, and TXTRU.; Definition at line 252 of file TShape.cxx. ◆ GetMaterial(). TMaterial * TShape::GetMaterial ; (; ); const. inline . Definition at line 56 of file TShape.h. ◆ GetNumber(). virtual Int_t TShape::GetNumber ; (; ); const. inlinevirtual . Definition at line 57 of file TShape.h. ◆ GetVisibility(). Int_t TShape::GetVisibility ; (; ); const. inline . Definition at line 58 of file TShape.h. ◆ IsA(). TClass * TShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TSPHE, TTRAP, TTRD1, TTRD2, TTUBE, TTUBS, and TXTRU.; Definition at line 65 of file TShape.h. ◆ operator=(). TShape & TShape::operator= ; (; const TShape & ; ts). assignment operator ; Definition at line 92 of file TShape.cxx. ◆ Paint(). void TShape::Paint ; (; Option_t * ; option = """"). overridevirtual . This method is used only when a shape is painted outside a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTShape.html:18918,avoid,avoid,18918,doc/master/classTShape.html,https://root.cern,https://root.cern/doc/master/classTShape.html,1,['avoid'],['avoid']
Safety,"cross the next boundary with respect to the position given by FindNextBoundary. ;  ; virtual void CheckBoundaryReference (Int_t icheck=-1);  Check the boundary errors reference file created by CheckBoundaryErrors method. ;  ; void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const;  Shoot nrays with random directions from starting point (startx, starty, startz) in the reference frame of this volume. ;  ; void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr);  Geometry checking. ;  ; void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""");  Check illegal overlaps for volume VOL within a limit OVLP. ;  ; void CheckOverlapsBySampling (TGeoVolume *vol, Double_t ovlp=0.1, Int_t npoints=1000000) const;  Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ;  ; void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.);  Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ;  ; void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);  Test for shape navigation methods. ;  ; Double_t CheckVoxels (TGeoVolume *vol, TGeoVoxelFinder *voxels, Double_t *xyz, Int_t npoints);  count voxel timing ;  ; TClass * IsA () const override;  ; TH2F * LegoPlot (Int_t ntheta=60, Double_t themin=0., Double_t themax=180., Int_t nphi=90, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; TGeoOverlap * MakeCheckOverlap (const char *name, TGeoVolume *vol1, TGeoVolume *vol2, TGeoMatrix *mat1, TGeoMatrix *mat2, Bool_t isovlp, Double_t ovlp);  Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. ;  ; void OpProgress (const char *opname, Long64_t current, Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:3813,safe,safety,3813,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"ct is essentially a //; 24// container of several lists pointing to the main ROOT objects. //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TDirectory.h""; 29// #include ""TList.h"" // included in TDirectory.h; 30// #include ""RConfigure.h"" // included via Rtypes.h; 31 ; 32#include <atomic>; 33#include <string>; 34#include <vector>; 35#include <utility>; 36 ; 37class TClass;; 38class TCanvas;; 39class TColor;; 40class TDataType;; 41class TFile;; 42class TStyle;; 43class TVirtualPad;; 44class TApplication;; 45class TInterpreter;; 46class TBrowser;; 47class TGlobal;; 48class TFunction;; 49class TFolder;; 50class TPluginManager;; 51class TProcessUUID;; 52class TClassGenerator;; 53class TVirtualMutex;; 54class TROOT;; 55class TListOfDataMembers;; 56class TListOfEnums;; 57class TListOfFunctions;; 58class TListOfFunctionTemplates;; 59class TSeqCollection;; 60class TFunctionTemplate;; 61class TGlobalMappedFunction;; 62 ; 63R__EXTERN TVirtualMutex *gROOTMutex;; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 class TROOTAllocator;; 68 ; 69 TROOT *GetROOT2();; 70 ; 71 // Manage parallel branch processing; 72 void EnableParBranchProcessing();; 73 void DisableParBranchProcessing();; 74 Bool_t IsParBranchProcessingEnabled();; 75 class TParBranchProcessingRAII {; 76 public:; 77 TParBranchProcessingRAII() { EnableParBranchProcessing(); }; 78 ~TParBranchProcessingRAII() { DisableParBranchProcessing(); }; 79 };; 80} } // End ROOT::Internal; 81 ; 82namespace ROOT {; 83 /// \brief Enable support for multi-threading within the ROOT code; 84 /// in particular, enables the global mutex to make ROOT thread safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:2703,safe,safe,2703,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['safe'],['safe']
Safety,"ct);; 3746 ; 3747 if (ignore != ignoreSig[sig]) {; 3748 ignoreSig[sig] = ignore;; 3749 if (ignore) {; 3750 struct sigaction sigact;; 3751#if defined(R__SUN); 3752 sigact.sa_handler = (void (*)())SIG_IGN;; 3753#elif defined(R__SOLARIS); 3754 sigact.sa_handler = (void (*)(int))SIG_IGN;; 3755#else; 3756 sigact.sa_handler = SIG_IGN;; 3757#endif; 3758 sigemptyset(&sigact.sa_mask);; 3759 sigact.sa_flags = 0;; 3760 if (sigaction(gSignalMap[sig].fCode, &sigact, &oldsigact[sig]) < 0); 3761 ::SysError(""TUnixSystem::UnixIgnoreSignal"", ""sigaction"");; 3762 } else {; 3763 if (sigaction(gSignalMap[sig].fCode, &oldsigact[sig], nullptr) < 0); 3764 ::SysError(""TUnixSystem::UnixIgnoreSignal"", ""sigaction"");; 3765 }; 3766 }; 3767}; 3768 ; 3769////////////////////////////////////////////////////////////////////////////////; 3770/// When the argument is true the SIGALRM signal handler is set so that; 3771/// interrupted syscalls will not be restarted by the kernel. This is; 3772/// typically used in case one wants to put a timeout on an I/O operation.; 3773/// By default interrupted syscalls will always be restarted (for all; 3774/// signals). This can be controlled for each a-synchronous TTimer via; 3775/// the method TTimer::SetInterruptSyscalls().; 3776 ; 3777void TUnixSystem::UnixSigAlarmInterruptsSyscalls(Bool_t set); 3778{; 3779 if (gSignalMap[kSigAlarm].fHandler) {; 3780 struct sigaction sigact;; 3781#if defined(R__SUN); 3782 sigact.sa_handler = (void (*)())sighandler;; 3783#elif defined(R__SOLARIS); 3784 sigact.sa_handler = sighandler;; 3785#elif defined(R__LYNXOS); 3786# if (__GNUG__>=3); 3787 sigact.sa_handler = sighandler;; 3788# else; 3789 sigact.sa_handler = (void (*)(...))sighandler;; 3790# endif; 3791#else; 3792 sigact.sa_handler = sighandler;; 3793#endif; 3794 sigemptyset(&sigact.sa_mask);; 3795 sigact.sa_flags = 0;; 3796 if (set) {; 3797#if defined(SA_INTERRUPT) // SunOS; 3798 sigact.sa_flags |= SA_INTERRUPT;; 3799#endif; 3800 } else {; 3801#if defined(SA_RESTART); 3802 s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:120624,timeout,timeout,120624,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ct. ; Definition at line 140 of file TBuffer.cxx. Member Function Documentation. ◆ ApplySequence() [1/2]. virtual Int_t TBuffer::ApplySequence ; (; const TStreamerInfoActions::TActionSequence & ; sequence, . void * ; object . ). pure virtual . Implemented in TBufferText, and TBufferFile. ◆ ApplySequence() [2/2]. virtual Int_t TBuffer::ApplySequence ; (; const TStreamerInfoActions::TActionSequence & ; sequence, . void * ; start_collection, . void * ; end_collection . ). pure virtual . Implemented in TBufferText, and TBufferFile. ◆ ApplySequenceVecPtr(). virtual Int_t TBuffer::ApplySequenceVecPtr ; (; const TStreamerInfoActions::TActionSequence & ; sequence, . void * ; start_collection, . void * ; end_collection . ). pure virtual . Implemented in TBufferText, and TBufferFile. ◆ AutoExpand(). void TBuffer::AutoExpand ; (; Int_t ; size_needed). Automatically calculate a new size and expand the buffer to fit at least size_needed. ; The goals is to minimize the number of memory allocation and the memory allocation which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy is to expand to double the current size or the size_needed which ever is largest. ; Definition at line 158 of file TBuffer.cxx. ◆ Buffer(). char * TBuffer::Buffer ; (; ); const. inline . Definition at line 96 of file TBuffer.h. ◆ BufferSize(). Int_t TBuffer::BufferSize ; (; ); const. inline . Definition at line 98 of file TBuffer.h. ◆ ByteSwapBuffer(). Bool_t TBuffer::ByteSwapBuffer ; (; Long64_t ; n, . EDataType ; type . ). Byte-swap N primitive-elements in the buffer. ; Bulk API relies on this function. ; Definition at line 392 of file TBuffer.cxx. ◆ CheckByteCount() [1/2]. virtual Int_t TBuffer::CheckByteCount ; (; UInt_t ; startpos, . UInt_t ; bcnt, . const char * ; classname . ). pure virtual . Implemented in TBufferFile, and TBufferText. ◆ CheckByteCount() [2/2]. virtual Int_t TBuffer::CheckByteCount ; (; UInt_t ; startpos, . UInt_t ; bcnt, . const TClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:28226,avoid,avoiding,28226,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['avoid'],['avoiding']
Safety,"ct::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTProofServ::EnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidTProofServ::FilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:4228,abort,abort,4228,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,1,['abort'],['abort']
Safety,"ct::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTProofServ::EnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*TProofServ::GetCacheLock(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServLite.html:4228,abort,abort,4228,root/html528/TProofServLite.html,https://root.cern,https://root.cern/root/html528/TProofServLite.html,3,['abort'],['abort']
Safety,"ct::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPacketizer.html:5876,abort,abort,5876,root/html602/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html602/TVirtualPacketizer.html,2,['abort'],['abort']
Safety,"ct::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIter&operator=(const TEventIter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIter(); TEventIter(const TEventIter&); TEventIter(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIter.html:4703,abort,abort,4703,root/html602/TEventIter.html,https://root.cern,https://root.cern/root/html602/TEventIter.html,2,['abort'],['abort']
Safety,"ct::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveCluster(); TEveCluster(const TEveCluster&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveCluster& ); { *((TParticle*)this) = p; return *this; }. TEveCluster(); TEveVector fW; // Cluster widt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCluster.html:4949,detect,detector,4949,root/html602/TEveCluster.html,https://root.cern,https://root.cern/root/html602/TEveCluster.html,2,['detect'],['detector']
Safety,"ct::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TServerSocket.html:5808,timeout,timeout,5808,root/html602/TServerSocket.html,https://root.cern,https://root.cern/root/html602/TServerSocket.html,2,['timeout'],['timeout']
Safety,"cted . Definition at line 93 of file MethodC50.h. ◆ fControlNoGlobalPruning. Bool_t TMVA::MethodC50::fControlNoGlobalPruning. protected . Definition at line 91 of file MethodC50.h. ◆ fControlSample. Double_t TMVA::MethodC50::fControlSample. protected . Definition at line 95 of file MethodC50.h. ◆ fControlSeed. Int_t TMVA::MethodC50::fControlSeed. protected . Definition at line 96 of file MethodC50.h. ◆ fControlSubset. Bool_t TMVA::MethodC50::fControlSubset. protected . Definition at line 88 of file MethodC50.h. ◆ fControlWinnow. Bool_t TMVA::MethodC50::fControlWinnow. protected . Definition at line 90 of file MethodC50.h. ◆ fDataSetManager. DataSetManager* TMVA::MethodC50::fDataSetManager. private . Definition at line 79 of file MethodC50.h. ◆ fModel. ROOT::R::TRObject* TMVA::MethodC50::fModel. protected . Definition at line 106 of file MethodC50.h. ◆ fModelControl. ROOT::R::TRObject TMVA::MethodC50::fModelControl. protected . Definition at line 107 of file MethodC50.h. ◆ fMvaCounter. UInt_t TMVA::MethodC50::fMvaCounter. protected . Definition at line 99 of file MethodC50.h. ◆ fNTrials. UInt_t TMVA::MethodC50::fNTrials. protected . Definition at line 84 of file MethodC50.h. ◆ fRules. Bool_t TMVA::MethodC50::fRules. protected . Definition at line 85 of file MethodC50.h. ◆ IsModuleLoaded. Bool_t MethodC50::IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""C50""). staticprotected . Definition at line 100 of file MethodC50.h. ◆ ListOfVariables. std::vector<TString > TMVA::MethodC50::ListOfVariables. protected . Definition at line 108 of file MethodC50.h. ◆ predict. ROOT::R::TRFunctionImport TMVA::MethodC50::predict. protected . Definition at line 102 of file MethodC50.h. Libraries for TMVA::MethodC50:. [legend]; The documentation for this class was generated from the following files:; tmva/rmva/inc/TMVA/MethodC50.h; tmva/rmva/src/MethodC50.cxx. TMVAMethodC50. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:35374,predict,predict,35374,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,2,['predict'],['predict']
Safety,"cted Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:47425,detect,detection,47425,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['detect'],['detection']
Safety,"cted value of the utility function is :. \[; E(u(x)) = Int (1-exp(-k*x) N(x) dx \\; = 1-exp(-k (r^T x - 0.5 k x^T Covar x) ) \\; \]. Its value is maximised by maximising \( r^T x -0.5 k x^T Covar x \) under the condition \( sum (x_i) = 1 \), meaning we want all our money invested and \( x_i \ge 0 \), we can not ""short"" a stock; For 10 stocks we got the historical daily data for Sep-2000 to Jun-2004:. GE : General Electric Co; SUNW : Sun Microsystems Inc; QCOM : Qualcomm Inc; BRCM : Broadcom Corp; TYC : Tyco International Ltd; IBM : International Business Machines Corp; AMAT : Applied Materials Inc; C : Citigroup Inc; PFE : Pfizer Inc; HD : Home Depot Inc. We calculate the optimal portfolio for 2.0 and 10.0 .; Food for thought :; We assumed that the stock returns have a Normal distribution . Check this assumption by histogramming the stock returns !; We used for the expected return in the objective function, the flat average over a time period . Investment firms will put significant resources in improving the return prediction .; If you want to trade significant number of shares, several other considerations have to be taken into account :; If you are going to buy, you will drive the price up (so-called ""slippage"") . This can be taken into account by adding terms to the objective (Google for ""slippage optimization""); FTC regulations might have to be added to the inequality constraints. Investment firms do not want to be exposed to the ""market"" as defined by a broad index like the S&P and ""hedge"" this exposure away . A perfect hedge this can be added as an equality constrain, otherwise add an inequality constrain . ; stock daily daily w1 w2; symb return sdv ; GE : 1.001 0.022 0.000 0.134; SUNW : 1.004 0.047 0.676 0.145; QCOM : 1.001 0.039 0.000 0.000; BRCM : 1.003 0.056 0.179 0.035; TYC : 1.001 0.042 0.145 0.069; IBM : 1.001 0.023 0.000 0.096; AMAT : 1.001 0.040 0.000 0.000; C : 1.000 0.023 0.000 0.000; PFE : 1.000 0.019 0.000 0.424; HD : 1.001 0.029 0.000 0.098; ; #in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:4622,predict,prediction,4622,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['predict'],['prediction']
Safety,"cter “@”. The use of these special characters is illustrated in several scripts referenced by the TPostScript constructor.; 9.10.2 Writing Several Canvases to the Same PostScript File; The following sequence writes the canvas to “c1.ps” and closes the postscript file:; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; If the Postscript file name finishes with “(”, the file remains opened (it is not closed). If the Postscript file name finishes with “)” and the file has been opened with “(”, the file is closed.; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop, one needs to detect the special cases of first and last page. The “[” and “]” can be used instead of “(” and “)” as shown in the next example.; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; The following script illustrates how to open a postscript file and draw several pictures. The generation of a new postscript page is automatic when TCanvas::Clear is called by object->Draw().; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:377252,detect,detect,377252,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detect']
Safety,"ction plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(const Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(const Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:18514,safe,safety,18514,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,3,['safe'],['safety']
Safety,"ction.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:293; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::beginTIter begin() constDefinition TCollection.h:292; TCollection::EStatusBitsEStatusBitsDefinition TCollection.h:143; TCollection::kUseRWLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:18825,safe,safe,18825,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['safe'],['safe']
Safety,"ction::kFastTanh;; 615 } else if (strActFnc == ""SYMMRELU"") {; 616 activationFunction = DNN::EActivationFunction::kSymmRelu;; 617 } else if (strActFnc == ""SOFTSIGN"") {; 618 activationFunction = DNN::EActivationFunction::kSoftSign;; 619 } else if (strActFnc == ""SIGMOID"") {; 620 activationFunction = DNN::EActivationFunction::kSigmoid;; 621 } else if (strActFnc == ""LINEAR"") {; 622 activationFunction = DNN::EActivationFunction::kIdentity;; 623 } else if (strActFnc == ""GAUSS"") {; 624 activationFunction = DNN::EActivationFunction::kGauss;; 625 } else if (width == 0) {; 626 // no match found try to parse as text showing the width; 627 // support for input a formula where the variable 'x' is 'N' in the string; 628 // use TFormula for the evaluation; 629 TString strNumNodes = strActFnc;; 630 // number of nodes; 631 TString strN(""x"");; 632 strNumNodes.ReplaceAll(""N"", strN);; 633 strNumNodes.ReplaceAll(""n"", strN);; 634 TFormula fml(""tmp"", strNumNodes);; 635 width = fml.Eval(inputSize);; 636 }; 637 }; 638 // avoid zero width. assume is last layer and give width = output width; 639 // Determine the number of outputs; 640 size_t outputSize = 1;; 641 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 642 outputSize = GetNTargets();; 643 } else if (fAnalysisType == Types::kMulticlass && DataInfo().GetNClasses() >= 2) {; 644 outputSize = DataInfo().GetNClasses();; 645 }; 646 if (width == 0) width = outputSize;; 647 ; 648 // Add the dense layer, initialize the weights and biases and copy; 649 TDenseLayer<Architecture_t> *denseLayer = deepNet.AddDenseLayer(width, activationFunction);; 650 denseLayer->Initialize();; 651 ; 652 // add same layer to fNet; 653 if (fBuildNet) fNet->AddDenseLayer(width, activationFunction);; 654 ; 655 //TDenseLayer<Architecture_t> *copyDenseLayer = new TDenseLayer<Architecture_t>(*denseLayer);; 656 ; 657 // add the copy to all slave nets; 658 //for (size_t i = 0; i < nets.size(); i++) {; 659 // nets[i].AddDenseLayer(copyDenseLayer);; 660 //}; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:25156,avoid,avoid,25156,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ction; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofDraw.h 39173 2011-05-12 18:04:44Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofDraw.html:8313,avoid,avoid,8313,root/html530/TProofDraw.html,https://root.cern,https://root.cern/root/html530/TProofDraw.html,1,['avoid'],['avoid']
Safety,"ction; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofDraw.h 39173 2011-05-12 18:04:44Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDraw.html:8313,avoid,avoid,8313,root/html532/TProofDraw.html,https://root.cern,https://root.cern/root/html532/TProofDraw.html,1,['avoid'],['avoid']
Safety,"ction;}. TGeoVolume * GetCurrentVolume() const; {return fCurrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fCldir;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoNavigator.html:22312,safe,safe,22312,root/html530/TGeoNavigator.html,https://root.cern,https://root.cern/root/html530/TGeoNavigator.html,2,['safe'],['safe']
Safety,"ctions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TGDNDManager Class Reference. . Definition at line 83 of file TGDNDManager.h. Public Member Functions;  TGDNDManager (TGFrame *toplevel, Atom_t *typelist);  TGDNDManager constructor. ;  ;  ~TGDNDManager () override;  TGDNDManager destructor. ;  ; Bool_t Drag (Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp);  Process drag event. ;  ; Bool_t Drop ();  Drop. ;  ; Bool_t EndDrag ();  End dragging. ;  ; TGFrame * GetMainFrame () const;  ; Window_t GetSource () const;  ; Window_t GetTarget () const;  ; Atom_t * GetTypeList () const;  ; Bool_t HandleClientMessage (Event_t *event);  Handle DND related client messages. ;  ; Bool_t HandleSelection (Event_t *event);  Handle selection event. ;  ; Bool_t HandleSelectionRequest (Event_t *event);  Handle selection request event. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle Drop timeout. ;  ; TClass * IsA () const override;  ; Bool_t IsDragging () const;  ; Bool_t RemoveRootProxy ();  Remove root window proxy. ;  ; void SetDragPixmap (Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y);  Set drag window pixmaps and hotpoint. ;  ; void SetMainFrame (TGFrame *main);  ; Bool_t SetRootProxy ();  Set root window proxy. ;  ; Bool_t StartDrag (TGFrame *src, Int_t x_root, Int_t y_root, Window_t grabWin=kNone);  Start dragging. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:1185,timeout,timeout,1185,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['timeout'],['timeout']
Safety,"ctions; Int_t Fill () override;  Fill a Ntuple with current values in fArgs. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:40031,detect,detection,40031,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['detect'],['detection']
Safety,"ctor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoXtru.html:15755,safe,safe,15755,root/html532/TGeoXtru.html,https://root.cern,https://root.cern/root/html532/TGeoXtru.html,1,['safe'],['safe']
Safety,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13945,detect,detected,13945,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,18,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"ctorTypes, . bool ; isSplit, . bool ; isGenreflex, . bool ; isSelXML, . bool ; writeEmptyRootPCM . ). Definition at line 2652 of file rootcling_impl.cxx. ◆ GenerateFwdDeclString(). static std::string GenerateFwdDeclString ; (; const RScanner & ; scan, . const cling::Interpreter & ; interp . ). static . Generate the fwd declarations of the selected entities. ; Definition at line 3302 of file rootcling_impl.cxx. ◆ GenerateLinkdef(). void GenerateLinkdef ; (; llvm::cl::list< std::string > & ; InputFiles, . std::string & ; code_for_parser . ). Definition at line 1847 of file rootcling_impl.cxx. ◆ GenerateNecessaryIncludes(). void GenerateNecessaryIncludes ; (; std::ostream & ; dictStream, . const std::string & ; includeForSource, . const std::string & ; extraIncludes . ). Definition at line 2862 of file rootcling_impl.cxx. ◆ GenerateStringFromHeadersForClasses(). const std::string GenerateStringFromHeadersForClasses ; (; const HeadersDeclsMap_t & ; headersClassesMap, . const std::string & ; detectedUmbrella, . bool ; payLoadOnly = false . ). Generate a string for the dictionary from the headers-classes map. ; Definition at line 3378 of file rootcling_impl.cxx. ◆ GenReflexMain(). int GenReflexMain ; (; int ; argc, . char ** ; argv . ). Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ; These are two typical genreflex and rootcling commandlines 1) genreflex header1.h [header2.h ...] [options] [preprocessor options] 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename] header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}] The rules with which the arguments are translated are (1st column genreflex): –debug -v4 –quiet -v0 -o ofile positional arg after -f -s selection file Last argument of the call –fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; New arguments: -l –library targetLib name (new) -s targetLib name -m pcmname (can be many -m) (new) -m pcmname (can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:38756,detect,detectedUmbrella,38756,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['detect'],['detectedUmbrella']
Safety,"curse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:6428,safe,safe,6428,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['safe'],['safe']
Safety,"cxx:3655; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::CreateParallelWorldTGeoParallelWorld * CreateParallelWorld(const char *name)Create a parallel world for prioritised navigation.Definition TGeoManager.cxx:4277; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoParallelWorld::CloseGeometryBool_t CloseGeometry()The main geometry must be closed.Definition TGeoParallelWorld.cxx:165; TGeoParallelWorld::AddNodevoid AddNode(const char *path)Add a node normally to this world. Overlapping nodes not allowed.Definition TGeoParallelWorld.cxx:92; TGeoParallelWorld::PrintDetectedOverlapsInt_t PrintDetectedOverlaps() constPrint the overlaps which were detected during real tracking.Definition TGeoParallelWorld.cxx:135; TGeoParallelWorld::AddOverlapvoid AddOverlap(TGeoVolume *vol, Bool_t activate=kTRUE)To use this optimization, the user should declare the full list of volumes which may overlap with any...Definition TGeoParallelWorld.cxx:108; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::AddNodeTGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") overrideAdd a componen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:7450,detect,detected,7450,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,1,['detect'],['detected']
Safety,"d Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; RooChi2Var Class ReferenceRooFit » RooFit Core. ; Simple \( \chi^2 \) calculation from a binned dataset and a PDF. ; It calculates:. \begin{align*}; \chi^2 &= \sum_{\mathrm{bins}} \left( \frac{N_\mathrm{PDF,bin} - N_\mathrm{Data,bin}}{\Delta_\mathrm{bin}} \right)^2 \\; N_\mathrm{PDF,bin} &=; \begin{cases}; \mathrm{pdf}(\text{bin centre}) \cdot V_\mathrm{bin} \cdot N_\mathrm{Data,tot} &\text{normal PDF}\\; \mathrm{pdf}(\text{bin centre}) \cdot V_\mathrm{bin} \cdot N_\mathrm{Data,expected} &\text{extended PDF}; \end{cases} \\; \Delta_\mathrm{bin} &=; \begin{cases}; \sqrt{N_\mathrm{PDF,bin}} &\text{if } \mathtt{DataError == RooAbsData::Expected}\\; \mathtt{data{\rightarrow}weightError()} &\text{otherwise} \\; \end{cases}; \end{align*}. If the dataset doesn't have user-defined errors, errors are assumed to be \( \sqrt{N} \). In extended PDF mode, N_tot (total number of data events) is substituted with N_expected, the expected number of events that the PDF predicts.; NoteIf the dataset has errors stored, empty bins will prevent the calculation of \( \chi^2 \), because those have zero error. This leads to messages like: [#0] ERROR:Eval -- RooChi2Var::RooChi2Var(chi2_GenPdf_data_hist) INFINITY ERROR: bin 2 has zero error; RooChi2Var::RooChi2VarRooChi2Var(const char *name, const char *title, RooAbsReal &func, RooDataHist &data, bool extended, RooDataHist::ErrorType etype, RooAbsTestStatistic::Configuration const &cfg=RooAbsTestStatistic::Configuration{})Definition RooChi2Var.cxx:67. In this case, one can use the expected errors of the PDF instead of the data errors: RooChi2Var chi2(..., ..., RooFit::DataError(RooAbsData::Expected), ...);; RooAbsData::Expected@ ExpectedDefinition RooAbsData.h:108; RooChi2VarSimple calculation from a binned dataset and a PDF.Definition RooChi2Var.h:19; RooFit::DataErrorRooCmdArg DataError(Int_t)Definition RooGlobalFunc.cxx:470. PyROOT; Constructor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:1284,predict,predicts,1284,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['predict'],['predicts']
Safety,"d Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. TGeoShape(); constructors. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:22902,safe,safe,22902,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,2,['safe'],['safe']
Safety,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSubtraction.html:8923,safe,safe,8923,root/html528/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html,2,['safe'],"['safe', 'safety']"
Safety,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoSubtraction.html:9023,safe,safe,9023,root/html530/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html530/TGeoSubtraction.html,2,['safe'],"['safe', 'safety']"
Safety,"d SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652 SubVector LowerBlock() const;; 653#endif; 654 ; 655 ; 656 /** @name --- Other Functions --- */; 657 ; 658 /**; 659 Function to check if a matrix is sharing same memory location of the passed pointer; 660 This function is used by the expression templates to avoid the alias problem during; 661 expression evaluation. When the matrix is in use, for example in operations; 662 like A = B * A, a temporary object storing the intermediate result is automatically; 663 created when evaluating the expression.; 664 ; 665 */; 666 bool IsInUse(const T* p) const;; 667 ; 668 // submatrices; 669 ; 670 /// Print: used by operator<<(); 671 std::ostream& Print(std::ostream& os) const;; 672 ; 673 ; 674 ; 675 ; 676public:; 677 ; 678 /** @name --- Data Member --- */; 679 ; 680 /**; 681 Matrix Storage Object containing matrix data; 682 */; 683 R fRep;; 684 ; 685}; // end of class SMatrix; 686 ; 687 ; 688 ; 689 ; 690//==============================================================================; 691// operator<<; 692//==========================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:22813,avoid,avoid,22813,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['avoid'],['avoid']
Safety,"d after the event loop is finished; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop. A conveniece definition kOnce is provided to make this fact more expressive in user code (see snippet below). Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will be executed sequentially. Callbacks are executed in the order they were registered. The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g. auto h = tdf.Histo1D(""x"");; // h.kOnce is 0; // decltype(h)::Value_t is TH1D; When implicit multi-threading is enabled, the callback:; will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from one call to the next; might be executed by a different worker thread at different times: the value of std::this_thread::get_id() might change between calls. To register a callback that is called by each worker thread (concurrently) every N events one can use OnPartialResultSlot(). ; Definition at line 318 of file RResultPtr.hxx. ◆ OnPartialResultSlot(). template<typename T > . RResultPtr< T > & ROOT::RDF::RResultPtr< T >::OnPartialResultSlot ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:11168,safe,safe,11168,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['safe'],['safe']
Safety,"d be considered in an invalid state.\n"";; 341 throw std::runtime_error(msg);; 342 }; 343}; 344 ; 345Long64_t InterpreterCalc(const std::string &code, const std::string &context); 346{; 347 R__LOG_DEBUG(10, RDFLogChannel()) << ""Jitting and executing the following code:\n\n"" << code << '\n';; 348 ; 349 TInterpreter::EErrorCode errorCode(TInterpreter::kNoError); // storage for cling errors; 350 ; 351 auto callCalc = [&errorCode, &context](const std::string &codeSlice) {; 352 gInterpreter->Calc(codeSlice.c_str(), &errorCode);; 353 if (errorCode != TInterpreter::EErrorCode::kNoError) {; 354 std::string msg = ""\nAn error occurred during just-in-time compilation"";; 355 if (!context.empty()); 356 msg += "" in "" + context;; 357 msg +=; 358 "". The lines above might indicate the cause of the crash\nAll RDF objects that have not run their event ""; 359 ""loop yet should be considered in an invalid state.\n"";; 360 throw std::runtime_error(msg);; 361 }; 362 };; 363 ; 364 // Call Calc every 1000 newlines in order to avoid jitting a very large function body, which is slow:; 365 // see https://github.com/root-project/root/issues/9312 and https://github.com/root-project/root/issues/7604; 366 std::size_t substr_start = 0;; 367 std::size_t substr_end = 0;; 368 while (substr_end != std::string::npos && substr_start != code.size() - 1) {; 369 for (std::size_t i = 0u; i < 1000u && substr_end != std::string::npos; ++i) {; 370 substr_end = code.find('\n', substr_end + 1);; 371 }; 372 const std::string subs = code.substr(substr_start, substr_end - substr_start);; 373 substr_start = substr_end;; 374 ; 375 callCalc(subs);; 376 }; 377 ; 378 return 0; // we used to forward the return value of Calc, but that's not possible anymore.; 379}; 380 ; 381bool IsInternalColumn(std::string_view colName); 382{; 383 const auto str = colName.data();; 384 const auto goodPrefix = colName.size() > 3 && // has at least more characters than {r,t}df; 385 ('r' == str[0] || 't' == str[0]) && // starts with r or t; 386 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFUtils_8cxx_source.html:14548,avoid,avoid,14548,doc/master/RDFUtils_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html,1,['avoid'],['avoid']
Safety,"d char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; TBackCompFitterBackward compatible implementation of TVirtualFitter.Definition TBackCompFitter.h:37; TBackCompFitter::GetFitResultconst ROOT::Fit::FitResult & GetFitResult() constGet reference to Fit Result object (NOTE: it will be invalid when class is deleted)Definition TBackCompFitter.h:94; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current FitterDefinition TVirtualFitter.cxx:209; Methods for getting the confidence level or contours are also provided. Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. ; Definition at line 37 of file TBackCompFitter.h. Public Types; enum  EStatusBits { kCanDeleteLast = (1ULL << ( 9 )); };  ;  Public Types inherited from TVirtualFitter; typedef void(* FCNFunc_t) (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TBackCompFitter ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:2115,avoid,avoid,2115,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,1,['avoid'],['avoid']
Safety,"d dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); Create authentication object. void CatchTimeOut(); Called in connection with a timer timeout. Bool_t Authenticate(); Authenticate to remote rootd or proofd server. Return kTRUE if; authentication succeeded. void SetEnvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:11273,timeout,timeout,11273,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['timeout'],['timeout']
Safety,"d documentation in front of method even for methods in the source file (default: """"); Root.Html.DescriptionStyle:; Search path for the source and header files with their default settings:; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Regular background and foreground colors in use:; Gui.BackgroundColor: #c0c0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1260184,detect,detecting,1260184,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety,"d from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Public Member Functions; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; double DoEval (double x) const override;  Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ;  ; virtual double DoEvalPar (double x, const double *p) const =0;  Implementation of the evaluation function using the x value and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IBaseFunctionOneDim ROOT::Math::IParametricFunctionOneDim::BaseFunc. Definition at line 166 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). double R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html:1781,avoid,avoid,1781,doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,1,['avoid'],['avoid']
Safety,"d from TFile.; Definition at line 238 of file TSQLFile.h. ◆ ReadConfigurations(). Bool_t TSQLFile::ReadConfigurations ; (; ). protected . read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84458,recover,recover,84458,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recover']
Safety,"d histograms to the directory ;  ; static Int_t fgBufferSize = 1000;  ! Default buffer size for automatic histograms ;  ; static Bool_t fgDefaultSumw2 = kFALSE;  ! Flag to call TH1::Sumw2 automatically at histogram creation time ;  ; static Bool_t fgStatOverflows = kFALSE;  ! Flag to use under/overflows in statistics ;  . #include <TH3.h>. Inheritance diagram for TH3:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TH3() [1/5]. TH3::TH3 ; (; ). protected . Default constructor. ; Definition at line 74 of file TH3.cxx. ◆ TH3() [2/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . Double_t ; xlow, . Double_t ; xup, . Int_t ; nbinsy, . Double_t ; ylow, . Double_t ; yup, . Int_t ; nbinsz, . Double_t ; zlow, . Double_t ; zup . ). protected . Constructor for fix bin size 3-D histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) ; [in]nbinsznumber of bins along the Z axis ; [in]zlowlow edge of the Z axis first bin ; [in]zupupper edge of the Z axis last bin (not included in last bin) . Definition at line 101 of file TH3.cxx. ◆ TH3() [3/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Float_t * ; xbins, . Int_t ; nbinsy, . const Float_t * ; ybins, . Int_t ; nbinsz, . const Float_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:59474,avoid,avoid,59474,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety,"d in TProofLite.; Definition at line 9612 of file TProof.cxx. ◆ SendLogToWindow(). void TProof::SendLogToWindow ; (; Bool_t ; mode). inline . Definition at line 1017 of file TProof.h. ◆ SendObject(). Int_t TProof::SendObject ; (; const TObject * ; obj, . ESlaves ; list = kActive . ). private . Send object to master or slave servers. ; Returns number of slaves object was sent to, -1 in case of error. ; Definition at line 7054 of file TProof.cxx. ◆ SendPrint(). Int_t TProof::SendPrint ; (; Option_t * ; option = """"). private . Send print command to master server. ; Returns number of slaves message was sent to. Returns -1 in case of error. ; Definition at line 7068 of file TProof.cxx. ◆ SetActive(). void TProof::SetActive ; (; Bool_t ; = kTRUE). inline . Definition at line 988 of file TProof.h. ◆ SetAlias(). void TProof::SetAlias ; (; const char * ; alias = """"). virtual . Set an alias for this session. ; If reconnection is supported, the alias will be communicated to the remote coordinator so that it can be recovered when reconnecting ; Definition at line 10583 of file TProof.cxx. ◆ SetDataPoolUrl(). void TProof::SetDataPoolUrl ; (; const char * ; url). inline . Definition at line 1044 of file TProof.h. ◆ SetDataSetTreeName(). Int_t TProof::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). virtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented in TProofLite.; Definition at line 10766 of file TProof.cxx. ◆ SetDrawFeedbackOption(). void TProof::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). Set draw feedback option. ; Definition at line 10102 of file TProof.cxx. ◆ SetDSet(). void TProof::SetDSet ; (; TDSet * ; dset). inlineprotected . Definition at line 737 of file TProof.h. ◆ SetFeedback(). void TProof::SetFeedback ; (; TString & ; opt, . TString & ; optfb, . Int_t ; action . ). protected . Extra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:141693,recover,recovered,141693,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['recover'],['recovered']
Safety,"d integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup hook for RooSentinel atexit handler. ~RooResolutionModel(); Destructor. RooFormulaVar* identity(); Return identity formula pointer. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; in the title of the object and this expression must be an exact match against the; implemented basis function strings (see derived class implementation of method basisCode(); for those strings. void changeBasis(RooFormulaVar* basis); Change the basis function we convolute with.; For one-time use by convolution() only. const RooRealVar& basisConvVar() const; Return the convolution variable of the selection basis function.; This is, by definition, the first parameter of the basis function. RooRealVar& convVar() const; Return the convolution variable of the resolution model. Double_t getValV(const RooArgSet* nset = 0) const; Modified version of RooAbsPdf::getValF(). If used as regular PDF,; call RooAbsPdf::getValF(), otherwise return unnormalized value; regardless of specified normalization set. Bool_t redirectServersHook(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:45970,avoid,avoid,45970,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['avoid'],['avoid']
Safety,"d is the covariance; 7632/// matrix:; 7633/// - 0= not calculated at all; 7634/// - 1= approximation only, not accurate; 7635/// - 2= full matrix, but forced positive-definite; 7636/// - 3= full accurate covariance matrix; 7637 ; 7638void TMinuit::mnstat(Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat); 7639{; 7640 fmin = fAmin;; 7641 fedm = fEDM;; 7642 errdef = fUp;; 7643 npari = fNpar;; 7644 nparx = fNu;; 7645 istat = fISW[1];; 7646 if (fEDM == fBigedm) fedm = fUp;; 7647 if (fAmin == fUndefi) {; 7648 fmin = 0;; 7649 fedm = fUp;; 7650 istat = 0;; 7651 }; 7652}; 7653 ; 7654////////////////////////////////////////////////////////////////////////////////; 7655/// To find the machine precision; 7656///; 7657/// Compares its argument with the value 1.0, and returns; 7658/// the value .TRUE. if they are equal. To find EPSMAC; 7659/// safely by foiling the Fortran optimiser; 7660 ; 7661void TMinuit::mntiny(Double_t epsp1, Double_t &epsbak); 7662{; 7663 epsbak = epsp1 - 1;; 7664}; 7665 ; 7666////////////////////////////////////////////////////////////////////////////////; 7667/// Returns .TRUE. if CFNAME contains unprintable characters; 7668///; 7669 ; 7670Bool_t TMinuit::mnunpt(TString &cfname); 7671{; 7672 Int_t i, l, ic;; 7673 Bool_t ret_val;; 7674 static const TString cpt = "" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890./;:[]$%*_!@#&+()"";; 7675 ; 7676 ret_val = kFALSE;; 7677 l = strlen((const char*)cfname);; 7678 for (i = 1; i <= l; ++i) {; 7679 for (ic = 1; ic <= 80; ++ic) {; 7680 if (cfname[i-1] == cpt[ic-1]) goto L100;; 7681 }; 7682 return kTRUE;; 7683L100:; 7684 ;; 7685 }; 7686 return ret_val;; 7687}; 7688 ; 7689////////////////////////////////////////////////////////////////////////////////; 7690/// Inverts a symmetric matrix; 7691///; 7692/// inverts a symmetric matrix. matrix is first scaled to; 7693/// have all ones on the diagonal (equivalent to change of units); 7694/// but no pivoting is done since ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:245163,safe,safely,245163,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['safe'],['safely']
Safety,"d of the dataset.; 1587 /// \return a node of the computation graph for which the range is defined.; 1588 ///; 1589 /// See the other Range overload for a detailed description.; 1590 // clang-format on; 1591 RInterface<RDFDetail::RRange<Proxied>, DS_t> Range(unsigned int end) { return Range(0, end, 1); }; 1592 ; 1593 // clang-format off; 1594 ////////////////////////////////////////////////////////////////////////////; 1595 /// \brief Execute a user-defined function on each entry (*instant action*).; 1596 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1597 /// \param[in] columns Names of the columns/branches in input to the user function.; 1598 ///; 1599 /// The callable `f` is invoked once per entry. This is an *instant action*:; 1600 /// upon invocation, an event loop as well as execution of all scheduled actions; 1601 /// is triggered.; 1602 /// Users are responsible for the thread-safety of this callable when executing; 1603 /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; 1604 ///; 1605 /// ### Example usage:; 1606 /// ~~~{.cpp}; 1607 /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; 1608 /// ~~~; 1609 // clang-format on; 1610 template <typename F>; 1611 void Foreach(F f, const ColumnNames_t &columns = {}); 1612 {; 1613 using arg_types = typename TTraits::CallableTraits<decltype(f)>::arg_types_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInternal::AddSlotParameter<ret_type>(f, arg_types()), columns);; 1616 }; 1617 ; 1618 // clang-format off; 1619 ////////////////////////////////////////////////////////////////////////////; 1620 /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; 1621 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:89856,safe,safety,89856,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safety']
Safety,"d(NO_FILES) */; 7735 return;; 7736 ; 7737#if !defined(NO_FILES); 7738/* Reset all outputs */; 7739interpret_cleanup:; 7740 memset(filestat, 0, sizeof(*filestat));; 7741 *filename = 0;; 7742 *is_found = 0;; 7743 *is_script_resource = 0;; 7744 *is_websocket_request = 0;; 7745 *is_put_or_delete_request = 0;; 7746#endif /* !defined(NO_FILES) */; 7747}; 7748 ; 7749 ; 7750/* Check whether full request is buffered. Return:; 7751 * -1 if request or response is malformed; 7752 * 0 if request or response is not yet fully buffered; 7753 * >0 actual request length, including last \r\n\r\n */; 7754static int; 7755get_http_header_len(const char *buf, int buflen); 7756{; 7757 int i;; 7758 for (i = 0; i < buflen; i++) {; 7759 /* Do an unsigned comparison in some conditions below */; 7760 const unsigned char c = (unsigned char)buf[i];; 7761 ; 7762 if ((c < 128) && ((char)c != '\r') && ((char)c != '\n'); 7763 && !isprint(c)) {; 7764 /* abort scan as soon as one malformed character is found */; 7765 return -1;; 7766 }; 7767 ; 7768 if (i < buflen - 1) {; 7769 if ((buf[i] == '\n') && (buf[i + 1] == '\n')) {; 7770 /* Two newline, no carriage return - not standard compliant,; 7771 * but it should be accepted */; 7772 return i + 2;; 7773 }; 7774 }; 7775 ; 7776 if (i < buflen - 3) {; 7777 if ((buf[i] == '\r') && (buf[i + 1] == '\n') && (buf[i + 2] == '\r'); 7778 && (buf[i + 3] == '\n')) {; 7779 /* Two \r\n - standard compliant */; 7780 return i + 4;; 7781 }; 7782 }; 7783 }; 7784 ; 7785 return 0;; 7786}; 7787 ; 7788 ; 7789#if !defined(NO_CACHING); 7790/* Convert month to the month number. Return -1 on error, or month number */; 7791static int; 7792get_month_index(const char *s); 7793{; 7794 size_t i;; 7795 ; 7796 for (i = 0; i < ARRAY_SIZE(month_names); i++) {; 7797 if (!strcmp(s, month_names[i])) {; 7798 return (int)i;; 7799 }; 7800 }; 7801 ; 7802 return -1;; 7803}; 7804 ; 7805 ; 7806/* Parse UTC date-time string, and return the corresponding time_t value. */; 7807static time_t; 7808parse_d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:224434,abort,abort,224434,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"d(NO_FILES) */; 7736 return;; 7737 ; 7738#if !defined(NO_FILES); 7739/* Reset all outputs */; 7740interpret_cleanup:; 7741 memset(filestat, 0, sizeof(*filestat));; 7742 *filename = 0;; 7743 *is_found = 0;; 7744 *is_script_resource = 0;; 7745 *is_websocket_request = 0;; 7746 *is_put_or_delete_request = 0;; 7747#endif /* !defined(NO_FILES) */; 7748}; 7749 ; 7750 ; 7751/* Check whether full request is buffered. Return:; 7752 * -1 if request or response is malformed; 7753 * 0 if request or response is not yet fully buffered; 7754 * >0 actual request length, including last \r\n\r\n */; 7755static int; 7756get_http_header_len(const char *buf, int buflen); 7757{; 7758 int i;; 7759 for (i = 0; i < buflen; i++) {; 7760 /* Do an unsigned comparison in some conditions below */; 7761 const unsigned char c = (unsigned char)buf[i];; 7762 ; 7763 if ((c < 128) && ((char)c != '\r') && ((char)c != '\n'); 7764 && !isprint(c)) {; 7765 /* abort scan as soon as one malformed character is found */; 7766 return -1;; 7767 }; 7768 ; 7769 if (i < buflen - 1) {; 7770 if ((buf[i] == '\n') && (buf[i + 1] == '\n')) {; 7771 /* Two newline, no carriage return - not standard compliant,; 7772 * but it should be accepted */; 7773 return i + 2;; 7774 }; 7775 }; 7776 ; 7777 if (i < buflen - 3) {; 7778 if ((buf[i] == '\r') && (buf[i + 1] == '\n') && (buf[i + 2] == '\r'); 7779 && (buf[i + 3] == '\n')) {; 7780 /* Two \r\n - standard compliant */; 7781 return i + 4;; 7782 }; 7783 }; 7784 }; 7785 ; 7786 return 0;; 7787}; 7788 ; 7789 ; 7790#if !defined(NO_CACHING); 7791/* Convert month to the month number. Return -1 on error, or month number */; 7792static int; 7793get_month_index(const char *s); 7794{; 7795 size_t i;; 7796 ; 7797 for (i = 0; i < ARRAY_SIZE(month_names); i++) {; 7798 if (!strcmp(s, month_names[i])) {; 7799 return (int)i;; 7800 }; 7801 }; 7802 ; 7803 return -1;; 7804}; 7805 ; 7806 ; 7807/* Parse UTC date-time string, and return the corresponding time_t value. */; 7808static time_t; 7809parse_d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:224466,abort,abort,224466,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"d* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerFile(TList* workers, Long64_t, TList* input, TProofProgressStatus* st = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerFile.html:5714,abort,abort,5714,root/html602/TPacketizerFile.html,https://root.cern,https://root.cern/root/html602/TPacketizerFile.html,2,['abort'],['abort']
Safety,"d, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterObj&operator=(const TEventIterObj&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterObj(); TEventIterObj(const TEventIterObj&); TEventIterObj(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterObj.html:4641,abort,abort,4641,root/html602/TEventIterObj.html,https://root.cern,https://root.cern/root/html602/TEventIterObj.html,2,['abort'],['abort']
Safety,"d. TEveTrackList(const char* name, TEveTrackPropagator* prop = 0); Constructor. If track-propagator argument is 0, a new default; one is created. ~TEveTrackList(); Destructor. void SetPropagator(TEveTrackPropagator* prop); Set default propagator for tracks.; This is not enforced onto the tracks themselves but this is the; propagator that is shown in the TEveTrackListEditor. void MakeTracks(Bool_t recurse = kTRUE); Regenerate the visual representations of tracks.; The momentum limits are rescanned during the same traversal. void FindMomentumLimits(Bool_t recurse = kTRUE); Loop over children and find highest pT and p of contained TEveTracks.; These are stored in members fLimPt and fLimP. void FindMomentumLimits(TEveElement* el, Bool_t recurse = kTRUE); Loop over track elements of argument el and find highest pT and p.; These are stored in members fLimPt and fLimP. Float_t RoundMomentumLimit(Float_t x); Round the momentum limit up to a nice value. void SanitizeMinMaxCuts(); Set Min/Max cuts so that they are within detected limits. void SetRnrLine(Bool_t rnr); Set rendering of track as line for the list and the elements. void SetRnrLine(Bool_t rnr, TEveElement* el); Set rendering of track as line for children of el. void SetRnrPoints(Bool_t r); Set rendering of track as points for the list and the elements. void SetRnrPoints(Bool_t r, TEveElement* el); Set rendering of track as points for children of el. void SetMainColor(Color_t c); Set main (line) color for the list and the elements. void SetLineColor(Color_t c, TEveElement* el); Set line color for children of el. void SetLineWidth(Width_t w); Set line width for the list and the elements. void SetLineWidth(Width_t w, TEveElement* el); Set line width for children of el. void SetLineStyle(Style_t s); Set line style for the list and the elements. void SetLineStyle(Style_t s, TEveElement* el); Set line style for children of el. void SetMarkerStyle(Style_t s); Set marker style for the list and the elements. void SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackList.html:23719,detect,detected,23719,root/html528/TEveTrackList.html,https://root.cern,https://root.cern/root/html528/TEveTrackList.html,1,['detect'],['detected']
Safety,"d.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEnt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3297,recover,recovery,3297,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"d.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. ◆ RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25970,safe,safety,25970,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"d.h. ◆ fAverageEvtPerBinVarB. Int_t* TMVA::MethodLikelihood::fAverageEvtPerBinVarB. private . average events per bin; used to calculate fNbins ; Definition at line 147 of file MethodLikelihood.h. ◆ fAverageEvtPerBinVarS. Int_t* TMVA::MethodLikelihood::fAverageEvtPerBinVarS. private . average events per bin; used to calculate fNbins ; Definition at line 146 of file MethodLikelihood.h. ◆ fBorderMethodString. TString TMVA::MethodLikelihood::fBorderMethodString. private . the method to take care about ""border"" effects (string) ; Definition at line 148 of file MethodLikelihood.h. ◆ fDefaultPDFLik. PDF* TMVA::MethodLikelihood::fDefaultPDFLik. private . pdf that contains default definitions ; Definition at line 135 of file MethodLikelihood.h. ◆ fDropVariable. Int_t TMVA::MethodLikelihood::fDropVariable. private . for ranking test ; Definition at line 128 of file MethodLikelihood.h. ◆ fEpsilon. Double_t TMVA::MethodLikelihood::fEpsilon. private . minimum number of likelihood (to avoid zero) ; Definition at line 125 of file MethodLikelihood.h. ◆ fHistBgd. std::vector<TH1*>* TMVA::MethodLikelihood::fHistBgd. private . background PDFs (histograms) ; Definition at line 131 of file MethodLikelihood.h. ◆ fHistBgd_smooth. std::vector<TH1*>* TMVA::MethodLikelihood::fHistBgd_smooth. private . background PDFs (smoothed histograms) ; Definition at line 133 of file MethodLikelihood.h. ◆ fHistSig. std::vector<TH1*>* TMVA::MethodLikelihood::fHistSig. private . signal PDFs (histograms) ; Definition at line 130 of file MethodLikelihood.h. ◆ fHistSig_smooth. std::vector<TH1*>* TMVA::MethodLikelihood::fHistSig_smooth. private . signal PDFs (smoothed histograms) ; Definition at line 132 of file MethodLikelihood.h. ◆ fInterpolateString. TString* TMVA::MethodLikelihood::fInterpolateString. private . which interpolation method used for reference histograms (individual for each variable) ; Definition at line 152 of file MethodLikelihood.h. ◆ fKDEfineFactor. Float_t TMVA::MethodLikelihood::fKDEfin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:41178,avoid,avoid,41178,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['avoid'],['avoid']
Safety,"d::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolumehelper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(TGeoPhysicalNode* pnode); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:02:28 2015 » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParallelWorld.html:8273,safe,safety,8273,root/html602/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html,1,['safe'],['safety']
Safety,"d; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDeltaPhi; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Bool_tfRotateScene; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. void RotateScene(); ""Scene rotation"": either find a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLAutoRotator.html:7381,timeout,timeout,7381,root/html534/TGLAutoRotator.html,https://root.cern,https://root.cern/root/html534/TGLAutoRotator.html,1,['timeout'],['timeout']
Safety,"dData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:3008,safe,safe,3008,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safe']
Safety,"dObjectAnyFile(). virtual TObject * TDirectory::FindObjectAnyFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TROOT, and TDirectoryFile.; Definition at line 202 of file TDirectory.h. ◆ Get() [1/2]. TObject * TDirectory::Get ; (; const char * ; namecycle). virtual . Return pointer to object identified by namecycle. ; namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject. If not, the function TDirectory::GetObject should be called. However, this function will still work for a non-TObject, providing that the calling application cast the return type to the correct type (which is the actual type of the object).; NOTE:; The method GetObject offer better protection and avoid the need for any cast: MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }; VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not as a first inheritance, one must use dynamic_cast<>(). Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; TObjectMother of all ROOT objects.Definition TObject.h:41; then on return, one can do: MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do: MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; Of course, dynamic_cast<> can also be used in the example 1. ; Reimplemented in TDirectoryFile, and TDirectoryFile.; Definition at line 866 of file TDirectory.cxx. ◆ Get() [2/2]. template<class T > . T * TDirectory::Get ; (; const char * ; namecycle). inline . See documentation of TDirectoryFile::Get(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:33952,avoid,avoid,33952,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['avoid'],['avoid']
Safety,"dPathName ROOT-8205. Dictionaries. Do not autoparse headers for classes in the pch.; Avoid autoparse on IsForeign() if possible.; Check for new-style empty pcm with key named “EMPTY” created since commit 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesn’t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] “for e in getSTLLikeCollection()” crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] - TSystem::ExpandPathName is not thread safe; [ROOT-8207] - tmva/tmva/CMakeLists.txt unnecessarily includes TreeViewer; [ROOT-8217] - TMinuit::TMinuit data race; [ROOT-8218] - Detection of TTreeFormula without breaking formula; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6; [ROOT-8226] - CMake 3.5.2: circular dependency libMathMore; [ROOT-8231] - _GLIBCXX_USE_CXX11_ABI=0 should be propagated into root-config –cflags. Release 6.06/08; Released on September 1, 2016; Core. Prevent race condition in the creation of the list of base classes (but avoiding to publish the list too early). Hist. Resolved issues with inconsistent handling of the ‘gaus’ function in TFormula [[ROT-8105]]. Bugs fixed in this release. [ROOT-8105] - TFormula does not always handle ‘gaus’ correctly.; [ROOT-8239] - “python: free(): invalid next size (fast)” in PyROOT 6.06.02 and patches; [ROOT-8270] - C++14; [ROOT-8293] - CMake does not find Castor libraries; [ROOT-8328] - patches used by art; [ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:32247,safe,safe,32247,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safe']
Safety,"dPdf, RooEfficiency, RooEffProd, RooExtendedTerm, RooExtendPdf, RooFFTConvPdf, RooGenericPdf, RooHistPdf, RooMultiVarGaussian, RooNumConvPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooResolutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare.; Definition at line 351 of file RooAbsPdf.h. ◆ isActiveNormSet(). bool RooAbsPdf::isActiveNormSet ; (; RooArgSet const * ; normSet); const. inlineprotected . Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ; Definition at line 299 of file RooAbsPdf.h. ◆ isDirectGenSafe(). bool RooAbsPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. virtual . Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ; Observables on which a PDF depends via more than route are not safe for use with internal generators because they introduce correlations not known to the internal generator ; Reimplemented in RooAbsAnaConvPdf, RooAddModel, RooBinSamplingPdf, and RooProdPdf.; Definition at line 1557 of file RooAbsPdf.cxx. ◆ logBatchComputationErrors(). void RooAbsPdf::logBatchComputationErrors ; (; std::span< const double > & ; outputs, . std::size_t ; begin . ); const. private . Scan through outputs and fix+log all nans and negative values. ; Parameters. [in,out]outputsArray to be scanned & fixed. ; [in]beginBegin of event range. Only needed to print the correct event number where the error occurred. . Definition at line 654 of file RooAbsPdf.cxx. ◆ mustBeExtended(). bool RooAbsPdf::mustBeExtended ; (; ); const. inline . If true PDF must provide extended likelihood term. ; Definition at line 222 of file RooAbsPdf.h. ◆ normalizeWithNaNPacking(). double RooAbsPdf::normalizeWithNaNPacking ; (; double ; rawVal, . double ; normVal . ); const. protected . Definition at line 282 of file RooAbsPdf.cxx. ◆ normRange(). const char * RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:132753,safe,safe,132753,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['safe'],['safe']
Safety,"dPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:10874,predict,predictions,10874,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,2,['predict'],['predictions']
Safety,"dShape.cxx. ◆ MakeBuffer3D(). TBuffer3D * TGeoScaledShape::MakeBuffer3D ; (; ); const. overridevirtual . Creates a TBuffer3D describing this shape. ; Coordinates are in local reference frame. ; Reimplemented from TGeoBBox.; Definition at line 266 of file TGeoScaledShape.cxx. ◆ MakeScaledShape(). TGeoShape * TGeoScaledShape::MakeScaledShape ; (; const char * ; name, . TGeoShape * ; shape, . TGeoScale * ; scale . ). static . Create a scaled shape starting from a non-scaled one. ; Definition at line 277 of file TGeoScaledShape.cxx. ◆ Safety(). Double_t TGeoScaledShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 310 of file TGeoScaledShape.cxx. ◆ Safety_v(). void TGeoScaledShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 424 of file TGeoScaledShape.cxx. ◆ SavePrimitive(). void TGeoScaledShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 322 of file TGeoScaledShape.cxx. ◆ SetPoints() [1/2]. void TGeoScaledShape::SetPoints ; (; Double_t * ; points); const. overridevirtual . Mesh points for scaled shapes. ; Reimplemented from TGeoBBox.; Definition at line 344 of file TGeoScaledShape.cxx. ◆ SetPoints() [2/2]. void TGeoScaledShape::SetPoints ; (; Float_t * ; points); const. overridevirtual . Mesh points for scaled shapes. ; Reimplemented from TGeoBBox.; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:32310,safe,safe,32310,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:13026,timeout,timeout,13026,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TWebFile.html:12670,timeout,timeout,12670,root/html530/TWebFile.html,https://root.cern,https://root.cern/root/html530/TWebFile.html,2,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TWebFile.html:13099,timeout,timeout,13099,root/html534/TWebFile.html,https://root.cern,https://root.cern/root/html534/TWebFile.html,1,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMemFile.html:12999,timeout,timeout,12999,root/html602/TMemFile.html,https://root.cern,https://root.cern/root/html602/TMemFile.html,10,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:13812,timeout,timeout,13812,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,10,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemFile.html:13299,timeout,timeout,13299,root/html534/TMemFile.html,https://root.cern,https://root.cern/root/html534/TMemFile.html,5,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTWebFile::SetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:14970,timeout,timeout,14970,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTWebFile::SetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:13476,timeout,timeout,13476,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['timeout'],['timeout']
Safety,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTWebFile::SetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:15005,timeout,timeout,15005,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['timeout'],['timeout']
Safety,"dTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPacketizer.html:5816,abort,abort,5816,root/html534/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html534/TVirtualPacketizer.html,1,['abort'],['abort']
Safety,"dTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:10639,abort,abort,10639,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"dTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFlushSocket(); voidInit(TSocket* s, Int_t stype); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char*, Int_t); virtual voidSetAlias(const char* alias); voidSetSocket(TSocket* s); virtual voidSetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout); TSlave(). private:. static TSlave*Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); voidInit(const char* host, Int_t port, Int_t stype); Int_tOldAuthSetup(Bool_t master, TString wconf); voidoperator=(const TSlave&); TSlave(const TSlave& s); TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1). Data Members; public:. static TSlave::ESlaveStatuskActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:6305,abort,abort,6305,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"dTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlaveLite.html:6475,abort,abort,6475,root/html528/TSlaveLite.html,https://root.cern,https://root.cern/root/html528/TSlaveLite.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"d[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179546,timeout,timeout,179546,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"d[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179578,timeout,timeout,179578,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"d_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition at line 1883 of file RWebWindow.cxx. ◆ CreateWSHandler(). std::shared_ptr< RWebWindowWSHandler > RWebWindow::CreateWSHandler ; (; std::shared_ptr< RWebWindowsManager > ; mgr, . unsigned ; id, . double ; tmout . ). private . Assigns manager reference, window id and creates websocket handler, used for communication with the clients. ; Definition at line 152 of file RWebWindow.cxx. ◆ EmbedFileDialog(). bool RWebWindow::EmbedFileDialog ; (; const std::shared_ptr< RWebWindow > & ; window, . unsigned ; connid, . const std::string & ; args . ). static . Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embedded() providing received string as second argument. ; Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected ; Definition at line 1977 of file RWebWindow.cxx. ◆ FindConnection(). std::shared_ptr< RWebWindow::WebConn > RWebWindow::FindConnection ; (; unsigned ; wsid). private . Find connection with specified websocket id. ; Find connection with given websocket id. ; Definition at line 264 of file RWebWindow.cxx. ◆ FindHeadlessConnection(). unsigned RWebWindow::FindHeadlessConnection ; (; ). private . Returns connection id of window running in headless mode This can be special connection which may run picture production jobs in background Connection to that job may not be initialized yet If connection does not exists, returns 0. ; Definition at line 221 of file RWebWindow.cxx. ◆ GenerateKey(). std::string RWebWindow::GenerateKey ; (; ); const. private . Generate new unique key for the wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:28568,detect,detect,28568,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['detect'],['detect']
Safety,"d_ptr< RWebWindow > RWebWindow::Create ; (; ). static . Create new RWebWindow Using default RWebWindowsManager. ; Definition at line 1925 of file RWebWindow.cxx. ◆ CreateWSHandler(). std::shared_ptr< RWebWindowWSHandler > RWebWindow::CreateWSHandler ; (; std::shared_ptr< RWebWindowsManager > ; mgr, . unsigned ; id, . double ; tmout . ). private . Assigns manager reference, window id and creates websocket handler, used for communication with the clients. ; Definition at line 152 of file RWebWindow.cxx. ◆ EmbedFileDialog(). bool RWebWindow::EmbedFileDialog ; (; const std::shared_ptr< RWebWindow > & ; window, . unsigned ; connid, . const std::string & ; args . ). static . Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embedded() providing received string as second argument. ; Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected ; Definition at line 2019 of file RWebWindow.cxx. ◆ FindConnection(). std::shared_ptr< RWebWindow::WebConn > RWebWindow::FindConnection ; (; unsigned ; wsid). private . Find connection with specified websocket id. ; Find connection with given websocket id. ; Definition at line 264 of file RWebWindow.cxx. ◆ FindHeadlessConnection(). unsigned RWebWindow::FindHeadlessConnection ; (; ). private . Returns connection id of window running in headless mode This can be special connection which may run picture production jobs in background Connection to that job may not be initialized yet If connection does not exists, returns 0. ; Definition at line 221 of file RWebWindow.cxx. ◆ GenerateKey(). std::string RWebWindow::GenerateKey ; (; ); const. private . Generate new unique key for the wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:28171,detect,detect,28171,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['detect'],['detect']
Safety,"data for a set of ntuple clusters. More...;  ; class  RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  RClusterIndex;  Addresses a column element or field item relative to a particular cluster, instead of a global NTupleSize_t index. More...;  ; struct  RClusterSize;  Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t. More...;  ; class  RColor;  The color class. More...;  ; class  RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  RColumnSwitch;  Holds the index and the tag of a kSwitch column. More...;  ; class  RDirectory;  Key/value store of objects. More...;  ; class  RDirectoryTypeMismatch;  Objects of this class are thrown to signal that the value known under the given name . More...;  ; class  RDirectoryUnknownKey;  Objects of this class are thrown to signal that no key with that name exists. More...;  ; class  RDisplayHistStat;  Object send to client for display of RHistStat, required to avoid sending histogram to the client. More...;  ; class  RDisplayItem;  Base class for painting data for JS. More...;  ; class  RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  RDrawableReply;  Base class for replies on RDrawableRequest. More...;  ; class  RDrawableRequest;  Base class for requests which can be submitted from the clients. More...;  ; class  REntry;  The REntry is a collection of values in an ntuple corresponding to a complete row in the data set. More...;  ; class  REnumField;  The field for an unscoped or scoped enum with dictionary. More...;  ; class  RError;  Captures diagnostics related to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:4540,avoid,avoid,4540,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['avoid'],['avoid']
Safety,"data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (bod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361575,timeout,timeout,361575,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (bod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361608,timeout,timeout,361608,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ddition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV(). ; See also the tutorial for a toy example. ; Definition at line 46 of file TSVDUnfold.h. Public Member Functions;  TSVDUnfold (const TH1D *bdat, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Alternative constructor User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. ;  ;  TSVDUnfold (const TH1D *bdat, TH2D *Bcov, const TH1D *bini, const TH1D *xini, const TH2D *Adet);  Default constructor Initialisation of TSVDUnfold User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. ;  ;  TSVDUnfold (const TSVDUnfold &other);  Copy constructor. ;  ;  ~TSVDUnfold () override;  Destructor. ;  ; Double_t ComputeChiSquared (const TH1D &truspec, const TH1D &unfspec);  Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper. ;  ; TH2D * GetAdetCovMatrix (Int_t ntoys, Int_t seed=1);  Determine covariance matrix of unfolded spectrum from finite statistics in response matrix using pseudo experiments ""ntoys"" - number of pseudo experiments used for the propagation ""seed"" - seed for pseudo experiments. ;  ; TH2D * GetBCov () const;  Returns the covariance matrix. ;  ; TH1D * GetD () const;  Returns d vector (for choosing appropriate regularisation) ;  ; Int_t GetKReg () const;  ; TH1D * GetSV () const;  Returns singular values vector. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:3907,detect,detector,3907,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety,"de the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for align",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114662,detect,detector,114662,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"de;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:6417,safe,safe,6417,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,2,['safe'],['safe']
Safety,"deRepo() [1/2]. RooWorkspace::CodeRepo::CodeRepo ; (; RooWorkspace * ; wspace = nullptr). inline . Definition at line 170 of file RooWorkspace.h. ◆ CodeRepo() [2/2]. RooWorkspace::CodeRepo::CodeRepo ; (; const CodeRepo & ; other, . RooWorkspace * ; wspace = nullptr . ). inline . Definition at line 172 of file RooWorkspace.h. Member Function Documentation. ◆ autoImportClass(). bool RooWorkspace::CodeRepo::autoImportClass ; (; TClass * ; tc, . bool ; doReplace = false . ). Import code of class 'tc' into the repository. ; If code is already in repository it is only imported again if doReplace is false. The names and location of the source files is determined from the information in TClass. If no location is found in the TClass information, the files are searched in the workspace search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation files respectively. If files cannot be found, abort with error status, otherwise update the internal class-to-file map and import the contents of the files, if they are not imported yet. ; Definition at line 1497 of file RooWorkspace.cxx. ◆ Class(). static TClass * RooWorkspace::CodeRepo::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooWorkspace::CodeRepo::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooWorkspace::CodeRepo::Class_Version ; (; ). inlinestaticconstexpr . Flag indicating that classes compiled OK. ; ReturnsVersion of this class ; Definition at line 217 of file RooWorkspace.h. ◆ compileClasses(). bool RooWorkspace::CodeRepo::compileClasses ; (; ). For all classes in the workspace for which no class definition is found in the ROOT class table extract source code stored in code repository into temporary directory set by setClassFileExportDir(), compile classes and link them with current ROOT session. ; If a compilation error occurs print instructions for user how to fix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html:11930,abort,abort,11930,doc/master/classRooWorkspace_1_1CodeRepo.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html,1,['abort'],['abort']
Safety,"default 0). void Color3ub(UChar_t r, UChar_t g, UChar_t b); Wrapper for glColor3ub. void Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); Wrapper for glColor4ub. void Color3ubv(const UChar_t* rgb); Wrapper for glColor3ubv. void Color4ubv(const UChar_t* rgba); Wrapper for glColor4ubv. void Color3f(Float_t r, Float_t g, Float_t b); Wrapper for glColor3f. void Color4f(Float_t r, Float_t g, Float_t b, Float_t a); Wrapper for glColor4f. void Color3fv(const Float_t* rgb); Wrapper for glColor3fv. void Color4fv(const Float_t* rgba); Wrapper for glColor4fv. void PointToViewport(Int_t& x, Int_t& y); Convert from point/screen coordinates to GL viewport coordinates. void PointToViewport(Int_t& x, Int_t& y, Int_t& w, Int_t& h); Convert from point/screen coordinates to GL viewport coordinates. Float_t GetScreenScalingFactor(); Returns scaling factor between screen points and GL viewport pixels.; This is what is returned by gVirtualX->GetOpenGLScalingFactor() but is; cached here to avoid a virtual function call as it is used quite often in; TGLPhysical shape when drawing the selection highlight. Float_t GetPointLineScalingFactor(); Return extra scaling factor for points and lines.; By default this is set to the same value as ScreenScalingFactor to keep; the same appearance. To override use rootrc entry, e.g.:; OpenGL.PointLineScalingFactor: 1.0. Int_t GetPickingRadius(); Returns picking radius. Float_t GetPointSizeScale(); Get global point-size scale. void SetPointSizeScale(Float_t scale); Set global point-size scale. Float_t GetLineWidthScale(); Returns global line-width scale. void SetLineWidthScale(Float_t scale); Set global line-width scale. void PointSize(Float_t point_size); Set the point-size, taking the global scaling into account.; Wrapper for glPointSize. void LineWidth(Float_t line_width); Set the line-width, taking the global scaling into account.; Wrapper for glLineWidth. Float_t PointSize(); Get the point-size, taking the global scaling into account. Float_t Lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLUtil.html:7869,avoid,avoid,7869,root/html534/TGLUtil.html,https://root.cern,https://root.cern/root/html534/TGLUtil.html,3,['avoid'],['avoid']
Safety,"delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonitor&operator=(const TMonitor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:7381,timeout,timeout,7381,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['timeout'],['timeout']
Safety,"der mouse cursor using Cocoa backend in OS X El Capitan; [ROOT-7723] - allow IOCtors to have as argument a ref to a type called void; [ROOT-7725] - MANPATH not correctly set by thisroot.sh; [ROOT-7727] - CMake: include/compiledata.h has empty CXXOPT and CXXDEBUG; [ROOT-7737] - Assert in cling when using undeclared variables; [ROOT-7744] - Crash in llvm::cl::AddLiteralOption. Improvement. [ROOT-7630] - [pcre][PPC64LE][PATCH] Update builtin_pcre to 8.37 version. Task. [ROOT-7773] - find_package(ROOT) should include a set of default libraries. Release 6.04/10; ROOT version 6.04/10 was released on 18 November, 2015.; Core. Resolve issues on SL6, 32bits when during process tear down libCling.so is removed before all the dictionary have been tear down.; Activate interpreter in inspector calls by ShowMembers [ROOT-7779)]. Interpreter. Resolve problem with static intialization related to explicit template instantiation. This fixes [ROOT-7775]. Hist. Improve thread safety of TH1::Fit by making static member of TVirtualFitter thread local. This fixes [ROOT-7791]. TNetXNGFileStager. Fixed ROOT-7703. This restores the behavior of Locate() to that found with TXNetFileStager: Rather than return only the xrootd server’s reply, the endpoint hostname is looked up and Locate() returns the full url, including the path. Release 6.04/12; I/O. Add to the TClass StreamerInfo for non-stl collections. A ‘collection’ here is a class for which there is a TVirtualCollectionProxy. For example this applies to ATLAS’ DataVector.; TWebFile. Fixed ROOT-7809. Returns an error for a redirect which does not specify the new URI, rather than going into a loop. Interpreter. Cache ROOT specials (ROOT-7830 and friends).; Accelerated calls as seen e.g. in PyROOT [ROOT-7840]. This fixes a PyROOT performance regression between 6.02 and 6.04, seen by ATLAS. Documentation. Apply THtml->doxygen transformation for func doc. Eases cherry picking. Bugs and Improvements. [ROOT-7789] - ROOTConfig.cmake should not set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:35209,safe,safety,35209,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['safe'],['safety']
Safety,"der { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id: KDEKernel.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__KDEKernel.html:2273,sanity check,sanity check,2273,root/html530/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html530/TMVA__KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"der(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSysEvtHandler.html:9382,avoid,avoid,9382,root/html528/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html528/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"der(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSysEvtHandler.html:9451,avoid,avoid,9451,root/html530/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html530/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"der(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSysEvtHandler.html:9451,avoid,avoid,9451,root/html532/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html532/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionNoCheckSum(UInt_t* start = 0, UInt_t* bcnt = 0); Read class version from I/O buffer, when the caller knows for sure that; there is no checksum written/involved. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferFile.html:39696,safe,safely,39696,root/html534/TBufferFile.html,https://root.cern,https://root.cern/root/html534/TBufferFile.html,3,['safe'],['safely']
Safety,"des; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, acco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:14235,safe,safe,14235,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['safe'],['safe']
Safety,"describing current object ; Reimplemented from TGeoBBox.; Definition at line 96 of file TGeoSphere.h. ◆ IsCylType(). Bool_t TGeoSphere::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoSphere.h. ◆ IsOnBoundary(). Int_t TGeoSphere::IsOnBoundary ; (; const Double_t * ; point); const. ◆ IsPointInside(). Bool_t TGeoSphere::IsPointInside ; (; const Double_t * ; point, . Bool_t ; checkR = kTRUE, . Bool_t ; checkTh = kTRUE, . Bool_t ; checkPh = kTRUE . ); const. ◆ MakeBuffer3D(). TBuffer3D * TGeoSphere::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoSphere & TGeoSphere::operator= ; (; const TGeoSphere & ; ). protecteddelete . ◆ Safety(). Double_t TGeoSphere::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoSphere::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoSphere::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions() [1/2]. void TGeoSphere::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetDimensions() [2/2]. void TGeoSphere::SetDimensions ; (; Double_t * ; param, . Int_t ; nparam . ). ◆ SetNumberOfDivisions(). virtual void TGeoSphere::SetNumberOfDivisions ; (; Int_t ; p). virtual . ◆ SetPoints() [1/2]. void TGeoSphere::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoSphere::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoSphere::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:30560,safe,safe,30560,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['safe'],['safe']
Safety,df025_RNode.C RNode is a generic type which represents any transformation node in the computation graph ;  df101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a RDataFrame ;  df102_NanoAODDimuonAnalysis.C This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes ;  df103_NanoAODHiggsAnalysis.C This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons ;  ► eve;  alice_esd.CComplex example showing ALICE ESD track visualization ;  alice_esd_html_summary.CHtml table and event summary for alice_esd.C ;  alice_esd_split.CComplex example showing ALICE ESD visualization in several views ;  alice_vsd.CComplex example showing ALICE VSD visualization ;  annotation.CDemonstrates usage of TGLAnnotation class ;  arrow.CDemonstrates usage of TEveArrow class ;  arrow_standalone.CHow to use EVE without the standard window ;  assembly.CGeometry detector assembly example ;  box.CDemonstrates usage of TEveBox class ;  boxset.CDemonstrates usage of TEveBoxSet class ;  boxset_cones.CDemonstrates usage of 'cone' mode in TEveBoxSet class ;  calo_detail.CCalorimeter detailed view by using TEveCaloDataVec as data-source ;  calorimeters.CDemonstrates usage of EVE calorimetry classes ;  camera_restore.C;  compound.CDemonstrates usage of EVE compound objects - class TEveCompound ;  csgdemo.CCombinatorial Solid Geometry example ;  geom_alias.CDemonstrates usage of geometry aliases - merge ALICE ITS with ATLAS MUON ;  geom_alice_its.CShows geometry of ALICE ITS ;  geom_alice_tpc.CShows geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:103345,detect,detector,103345,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,dget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:45324,avoid,avoid,45324,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['avoid'],['avoid']
Safety,"dinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:22598,avoid,avoid,22598,root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,4,['avoid'],['avoid']
Safety,"dinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21165,avoid,avoid,21165,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,1,['avoid'],['avoid']
Safety,"ding within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:27206,safe,safe,27206,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"ding within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34433,safe,safe,34433,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safe']
Safety,"ding within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34221,safe,safe,34221,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safe']
Safety,"disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:116096,recover,recover,116096,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['recover'],['recover']
Safety,"ditional input and the user attention are required by a certain condition.; The TGGroupFrame class presents a very convenient frame which surrounds visually a group of logically connected widgets: radio buttons, related check boxes, two or more functionally related controls. It is a composite frame with a border and a title. The title explains the purpose of the group and should be a noun or noun phrase. Here is an example taken from guitest.C:; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157434,avoid,avoid,1157434,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"dium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43. Shape queries; Note that global queries related to a geometry are handled by the manager class. However, shape-related queries might be sometimes useful.; Bool_t TGeoShape::Contains(const Double_t *point[3]); this method returns true if POINT is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t ia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:4842,safe,safe,4842,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"dius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:17508,safe,safe,17508,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,6,['safe'],['safe']
Safety,"dlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 886 of file TUnixSystem.cxx. ◆ ResetTimer(). void TUnixSystem::ResetTimer ; (; TTimer * ; ti). overridevirtual . Reset a-sync timer. ; Reimplemented from TSystem.; Definition at line 3033 of file TUnixSystem.cxx. ◆ Select() [1/2]. Int_t TUnixSystem::Select ; (; TFileHandler * ; h, . Long_t ; to . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the file handler is 0 or does not have a file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1250 of file TUnixSystem.cxx. ◆ Select() [2/2]. Int_t TUnixSystem::Select ; (; TList * ; act, . Long_t ; to . ). overridevirtual . Select on file descriptors. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the list did not contain any file handlers or file handlers with file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1202 of file TUnixSystem.cxx. ◆ SendBuf(). int TUnixSystem::SendBuf ; (; int ; sock, . const void * ; buf, . int ; length . ). overridevirtual . Send a buffer headed by a length indicator. ; Returns length of sent buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3341 of file TUnixSystem.cxx. ◆ SendRaw(). int TUnixSystem::SendRaw ; (; int ; sock, . const void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:65655,timeout,timeout,65655,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"dlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignr is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:22571,timeout,timeout,22571,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(const Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:13231,safe,safe,13231,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,3,['safe'],['safe']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressDialog.html:4391,abort,aborted,4391,root/html534/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html534/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressDialog.html:4560,abort,aborted,4560,root/html604/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html604/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:4574,abort,aborted,4574,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2010-10-08 16:04; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:4372,abort,aborted,4372,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressDialog.html:4372,abort,aborted,4372,root/html530/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html530/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"dometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressDialog.html:4372,abort,aborted,4372,root/html532/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html532/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"double& A_ki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:11330,predict,predictions,11330,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,2,['predict'],['predictions']
Safety,"dowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStylePreview.h,v 1.0 2005/09/08 » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStylePreview.html:21888,avoid,avoid,21888,root/html528/TStylePreview.html,https://root.cern,https://root.cern/root/html528/TStylePreview.html,1,['avoid'],['avoid']
Safety,"dowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStylePreview.h,v 1.0 2005/09/08 » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStylePreview.html:22041,avoid,avoid,22041,root/html530/TStylePreview.html,https://root.cern,https://root.cern/root/html530/TStylePreview.html,1,['avoid'],['avoid']
Safety,"dowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStylePreview.h,v 1.0 2005/09/08 » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStylePreview.html:22041,avoid,avoid,22041,root/html532/TStylePreview.html,https://root.cern,https://root.cern/root/html532/TStylePreview.html,1,['avoid'],['avoid']
Safety,"dowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStylePreview.h,v 1.0 2005/09/08 » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStylePreview.html:22060,avoid,avoid,22060,root/html534/TStylePreview.html,https://root.cern,https://root.cern/root/html534/TStylePreview.html,1,['avoid'],['avoid']
Safety,"dr, const TConfiguration *config); 931 {; 932 // Read in a TString object.; 933 ; 934 // Idea: We could separate the TString Streamer in its two parts and; 935 // avoid the if (buf.IsReading()) and try having it inlined.; 936 ((TString*)(((char*)addr)+config->fOffset))->TString::Streamer(buf);; 937 return 0;; 938 }; 939 ; 940 INLINE_TEMPLATE_ARGS Int_t ReadTObject(TBuffer &buf, void *addr, const TConfiguration *config); 941 {; 942 // Read in a TObject object part.; 943 ; 944 // Idea: We could separate the TObject Streamer in its two parts and; 945 // avoid the if (buf.IsReading()).; 946 ((TObject*)(((char*)addr)+config->fOffset))->TObject::Streamer(buf);; 947 return 0;; 948 }; 949 ; 950 INLINE_TEMPLATE_ARGS Int_t ReadTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 951 {; 952 // Read in a TNamed object part.; 953 // Since the TNamed streamer is solely delegating back to the StreamerInfo we; 954 // can skip the streamer.; 955 ; 956 // Idea: We could extract the code from ReadClassBuffer and avoid one function; 957 // code.; 958 static const TClass *TNamed_cl = TNamed::Class();; 959 return buf.ReadClassBuffer(TNamed_cl,(((char*)addr)+config->fOffset));; 960 }; 961 ; 962 class TConfigSTL : public TConfiguration {; 963 // Configuration object for the kSTL case; 964 private:; 965 void Init() {; 966 TVirtualCollectionProxy *proxy = fNewClass->GetCollectionProxy();; 967 if (proxy) {; 968 fCreateIterators = proxy->GetFunctionCreateIterators();; 969 fCreateWriteIterators = proxy->GetFunctionCreateIterators(kFALSE);; 970 fCopyIterator = proxy->GetFunctionCopyIterator();; 971 fDeleteIterator = proxy->GetFunctionDeleteIterator();; 972 fDeleteTwoIterators = proxy->GetFunctionDeleteTwoIterators();; 973 }; 974 }; 975 ; 976 public:; 977 TClass *fOldClass; // Class of the content on file; 978 TClass *fNewClass; // Class of the content in memory.; 979 TMemberStreamer *fStreamer;; 980 const char *fTypeName; // Type name of the member as typed by ther user.; 981 Bool_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:38848,avoid,avoid,38848,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:10122,timeout,timeout,10122,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,3,['timeout'],['timeout']
Safety,"ds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 80/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 81/// i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; 82/// a-synchronous. The default is synchronous. Add a timer to the system; 83/// eventloop by calling TurnOn(). Set command to be executed from Notify(); 84/// or set the object whose HandleTimer() method will be called via Notify(),; 85/// derive from TTimer and override Notify() or connect slots to the; 86/// signals Timeout(), TurnOn() and TurnOff().; 87 ; 88TTimer::TTimer(Long_t ms, Bool_t mode) : fTime(ms); 89{; 90 fObject = nullptr;; 91 fCommand = """";; 92 fSync = mode;; 93 fIntSyscalls = kFALSE;; 94 Reset();; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Create timer that times out in ms milliseconds. If mode == kTRUE then; 99/// the timer is synchronous else a-synchronous. The default is synchronous.; 100/// Add a timer to the system eventloop by calling TurnOn().; 101/// The object's HandleTimer() will be ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:2765,timeout,timeout,2765,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,2,['timeout'],['timeout']
Safety,"ds to be send to the server. ; Use the following algorithm:; check if file appears in file map; if yes, get file's modtime and check against time in map, if modtime not same get md5 and compare against md5 in map, if not same return kTRUE.; if no, get file's md5 and modtime and store in file map, ask slave if file exists with specific md5, if yes return kFALSE, if no return kTRUE. Returns kTRUE in case file needs to be send, returns kFALSE in case file is already on remote node. . Definition at line 674 of file TApplicationRemote.cxx. ◆ Class(). static TClass * TApplicationRemote::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationRemote::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationRemote::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 117 of file TApplicationRemote.h. ◆ Collect(). Int_t TApplicationRemote::Collect ; (; Long_t ; timeout = -1). private . Collect responses from the remote server. ; Returns the number of messages received. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). ; Definition at line 326 of file TApplicationRemote.cxx. ◆ CollectInput(). Int_t TApplicationRemote::CollectInput ; (; ). private . Collect and analyze available input from the socket. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 394 of file TApplicationRemote.cxx. ◆ DeclFileName(). static const char * TApplicationRemote::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 117 of file TApplicationRemote.h. ◆ Interrupt(). void TApplicationRemote::Interrupt ; (; Int_t ; type = kRRI_Hard). Send interrupt OOB byte to server. ; Returns 0 if ok, -1 in case of error ; Definition at line 937 of file TApplicationRemote.cxx. ◆ IsA(). TClass * TApplicationRemote::IsA ; (; ); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:27086,timeout,timeout,27086,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['timeout'],['timeout']
Safety,"ds/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TGContainerScrollTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGContainerScrollTimer(). TGContainerScrollTimer::TGContainerScrollTimer ; (; TGContainer * ; t). inline . Definition at line 118 of file TGCanvas.cxx. Member Function Documentation. ◆ Notify(). Bool_t TGContainerScrollTimer::Notify ; (; ). overridevirtual . on-timeout ; Implements TSysEvtHandler.; Definition at line 125 of file TGCanvas.cxx. Member Data Documentation. ◆ fContainer. TGContainer* TGContainerScrollTimer::fContainer. private . Definition at line 116 of file TGCanvas.cxx. gui/gui/src/TGCanvas.cxx. TGContainerScrollTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:57 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGContainerScrollTimer.html:17534,timeout,timeout,17534,doc/master/classTGContainerScrollTimer.html,https://root.cern,https://root.cern/doc/master/classTGContainerScrollTimer.html,1,['timeout'],['timeout']
Safety,"dx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);; 1817 ndivy = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsHNDC());; 1818 // coverity [Calling risky function]; 1819 strlcat(choptaxis, ""N"",10);; 1820 }; 1821 ndiv =TMath::Abs(ndivy);; 1822 if (gPad->GetGridy()) {; 1823 // coverity [Calling risky function]; 1824 strlcat(choptaxis, ""W"",10);; 1825 }; 1826 if (gPad->GetLogy()) {; 1827 rwmin = TMath::Power(10,rwymin);; 1828 rwmax = TMath::Power(10,rwymax);; 1829 // coverity [Calling risky function]; 1830 strlcat(choptaxis,""G"",10);; 1831 }; 1832 axis.SetLineColor(gStyle->GetAxisColor(""Y""));; 1833 axis.SetTextColor(gStyle->GetLabelColor(""Y""));; 1834 axis.SetTextFont(gStyle->GetLabelFont(""Y""));; 1835 axis.SetLabelSize(gStyle->GetLabelSize(""Y""));; 1836 axis.SetLabelOffset(gStyle->GetLabelOffset(""Y""));; 1837 axis.SetTickSize(gStyle->GetTickLength(""Y""));; 1838 ; 1839 axis.PaintAxis(rwxmin,rwymin,rwxmin,rwymax,rwmin,rwmax,ndiv,choptaxis);; 1840 }; 1841 ; 1842 ; 1843 // Set attributes; 1844 theGraph->TAttLine::Modify();; 1845 theGraph->TAttFill::Modify();; 1846 theGraph->TAttMarker::Modify();; 1847 ; 1848 // Min-Max scope; 1849 ; 1850 if (!optionRot) {wmin = x[0]; wmax = x[1];}; 1851",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:67175,risk,risky,67175,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,3,['risk'],['risky']
Safety,"dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd2.html:13969,safe,safe,13969,root/html534/TGeoTrd2.html,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html,6,['safe'],['safe']
Safety,"dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:16139,safe,safe,16139,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['safe'],['safe']
Safety,"d ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; virtual Double_t GetA () const;  ; virtual Double_t GetB () const;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:1212,safe,safe,1212,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"d Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:8662,safe,safe,8662,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,16,['safe'],['safe']
Safety,"e * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ;  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:15755,safe,safety,15755,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"e . Definition at line 207 of file REveTrack.hxx. ◆ MakeTracks(). void REveTrackList::MakeTracks ; (; Bool_t ; recurse = kTRUE). Regenerate the visual representations of tracks. ; The momentum limits are rescanned during the same traversal. ; Definition at line 635 of file REveTrack.cxx. ◆ operator=(). REveTrackList & ROOT::Experimental::REveTrackList::operator= ; (; const REveTrackList & ; ). privatedelete . ◆ ProjectedClass(). TClass * REveTrackList::ProjectedClass ; (; const REveProjection * ; p); const. overridevirtual . Virtual from REveProjectable, returns REveTrackListProjected class. ; Implements ROOT::Experimental::REveProjectable.; Definition at line 1136 of file REveTrack.cxx. ◆ RoundMomentumLimit(). Double_t REveTrackList::RoundMomentumLimit ; (; Double_t ; x). protected . Round the momentum limit up to a nice value. ; Definition at line 706 of file REveTrack.cxx. ◆ SanitizeMinMaxCuts(). void REveTrackList::SanitizeMinMaxCuts ; (; ). protected . Set Min/Max cuts so that they are within detected limits. ; Definition at line 719 of file REveTrack.cxx. ◆ SelectByP() [1/2]. void REveTrackList::SelectByP ; (; Double_t ; min_p, . Double_t ; max_p . ). Select visibility of tracks by momentum. ; If data-member fRecurse is set, the selection is applied recursively to all children. ; Definition at line 1007 of file REveTrack.cxx. ◆ SelectByP() [2/2]. void REveTrackList::SelectByP ; (; Double_t ; min_p, . Double_t ; max_p, . REveElement * ; el . ). Select visibility of el's children tracks by momentum. ; Definition at line 1027 of file REveTrack.cxx. ◆ SelectByPt() [1/2]. void REveTrackList::SelectByPt ; (; Double_t ; min_pt, . Double_t ; max_pt . ). Select visibility of tracks by transverse momentum. ; If data-member fRecurse is set, the selection is applied recursively to all children. ; Definition at line 965 of file REveTrack.cxx. ◆ SelectByPt() [2/2]. void REveTrackList::SelectByPt ; (; Double_t ; min_pt, . Double_t ; max_pt, . REveElement * ; el . ). Select v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html:28876,detect,detected,28876,doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,1,['detect'],['detected']
Safety,"e . returns configured window height (0 - default) ; Definition at line 282 of file RWebWindow.hxx. ◆ GetId(). unsigned ROOT::RWebWindow::GetId ; (; ); const. inline . Returns ID for the window - unique inside window manager. ; Definition at line 248 of file RWebWindow.hxx. ◆ GetManager(). std::shared_ptr< RWebWindowsManager > ROOT::RWebWindow::GetManager ; (; ); const. inline . Returns window manager. ; Definition at line 251 of file RWebWindow.hxx. ◆ GetMasterConnections(). std::vector< RWebWindow::MasterConn > RWebWindow::GetMasterConnections ; (; unsigned ; connid = 0); const. private . Get list of master connections. ; Definition at line 325 of file RWebWindow.cxx. ◆ GetMaxQueueLength(). unsigned ROOT::RWebWindow::GetMaxQueueLength ; (; ); const. inline . Return maximal queue length of data which can be held by window. ; Definition at line 304 of file RWebWindow.hxx. ◆ GetOperationTmout(). float ROOT::RWebWindow::GetOperationTmout ; (; ); const. inline . Returns timeout for synchronous WebWindow operations. ; Definition at line 351 of file RWebWindow.hxx. ◆ GetRelativeAddr() [1/2]. std::string RWebWindow::GetRelativeAddr ; (; const RWebWindow & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1270 of file RWebWindow.cxx. ◆ GetRelativeAddr() [2/2]. std::string RWebWindow::GetRelativeAddr ; (; const std::shared_ptr< RWebWindow > & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1260 of file RWebWindow.cxx. ◆ GetSendQueueLength(). int RWebWindow::GetSendQueueLength ; (; unsigned ; connid); const. Returns send queue length for specified connection. ; Parameters. connidconnection id, 0 - maximal value for all ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:32377,timeout,timeout,32377,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety,"e . returns configured window height (0 - default) ; Definition at line 285 of file RWebWindow.hxx. ◆ GetId(). unsigned ROOT::RWebWindow::GetId ; (; ); const. inline . Returns ID for the window - unique inside window manager. ; Definition at line 251 of file RWebWindow.hxx. ◆ GetManager(). std::shared_ptr< RWebWindowsManager > ROOT::RWebWindow::GetManager ; (; ); const. inline . Returns window manager. ; Definition at line 254 of file RWebWindow.hxx. ◆ GetMasterConnections(). std::vector< RWebWindow::MasterConn > RWebWindow::GetMasterConnections ; (; unsigned ; connid = 0); const. private . Get list of master connections. ; Definition at line 326 of file RWebWindow.cxx. ◆ GetMaxQueueLength(). unsigned ROOT::RWebWindow::GetMaxQueueLength ; (; ); const. inline . Return maximal queue length of data which can be held by window. ; Definition at line 307 of file RWebWindow.hxx. ◆ GetOperationTmout(). float ROOT::RWebWindow::GetOperationTmout ; (; ); const. inline . Returns timeout for synchronous WebWindow operations. ; Definition at line 354 of file RWebWindow.hxx. ◆ GetSendQueueLength(). int RWebWindow::GetSendQueueLength ; (; unsigned ; connid); const. Returns send queue length for specified connection. ; Parameters. connidconnection id, 0 - maximal value for all connections is returned If wrong connection id specified, -1 is return . Definition at line 1551 of file RWebWindow.cxx. ◆ GetServer(). THttpServer * RWebWindow::GetServer ; (; ). Return THttpServer instance serving requests to the window. ; Definition at line 181 of file RWebWindow.cxx. ◆ GetUrl(). std::string RWebWindow::GetUrl ; (; bool ; remote = true). Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ; Parameters. remoteis true, real HTTP server will be started automatically and widget can be connected from the web browser. If; remoteis false, HTTP server will no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:31980,timeout,timeout,31980,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety,"e 259 of file TF1Convolution.cxx. ◆ operator()(). Double_t TF1Convolution::operator() ; (; const Double_t * ; x, . const Double_t * ; p . ). overridevirtual . Used in TF1 when doing the fit, will be evaluated at each point. ; Implements TF1AbsComposition.; Definition at line 367 of file TF1Convolution.cxx. ◆ operator=(). TF1Convolution & TF1Convolution::operator= ; (; const TF1Convolution & ; rhs). Operator =. ; Definition at line 249 of file TF1Convolution.cxx. ◆ SetDefaultExtraRange(). Double_t TF1Convolution::SetDefaultExtraRange ; (; Double_t ; fraction). static . Set the default extra range fraction used when doing a FFT convolution. ; By default the value is 0.1 (10%). The function return the previous default defined value. ; Definition at line 477 of file TF1Convolution.cxx. ◆ SetExtraRange(). void TF1Convolution::SetExtraRange ; (; Double_t ; percentage). Set the fraction of extra range used when doing an FFT convolution. ; The extra range is often needed to avoid mirroring effect of the resulting convolution function at the borders. By default an extra range of 0.1 is used. ; Definition at line 438 of file TF1Convolution.cxx. ◆ SetNofPointsFFT(). void TF1Convolution::SetNofPointsFFT ; (; Int_t ; n). Set the number of points used for the FFT convolution. ; Definition at line 382 of file TF1Convolution.cxx. ◆ SetNumConv(). void TF1Convolution::SetNumConv ; (; Bool_t ; flag = true). inline . Definition at line 64 of file TF1Convolution.h. ◆ SetParameters() [1/2]. void TF1Convolution::SetParameters ; (; const Double_t * ; params). overridevirtual . Set the vector of parameters p for the convolution function g(x,p) = f1 * f2. ; Implements TF1AbsComposition.; Definition at line 393 of file TF1Convolution.cxx. ◆ SetParameters() [2/2]. void TF1Convolution::SetParameters ; (; Double_t ; p0, . Double_t ; p1, . Double_t ; p2 = 0., . Double_t ; p3 = 0., . Double_t ; p4 = 0., . Double_t ; p5 = 0., . Double_t ; p6 = 0., . Double_t ; p7 = 0. . ). Set the parameter values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1Convolution.html:19996,avoid,avoid,19996,doc/master/classTF1Convolution.html,https://root.cern,https://root.cern/doc/master/classTF1Convolution.html,1,['avoid'],['avoid']
Safety,"e ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:35698,detect,detection,35698,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['detect'],['detection']
Safety,"e ; (; TGeoShape * ; shape). static . Factory creating TGeoVGShape from a Root shape. ; Returns nullptr if the shape cannot be converted ; Definition at line 93 of file TGeoVGShape.cxx. ◆ CreateVecGeomSolid(). vecgeom::cxx::VPlacedVolume * TGeoVGShape::CreateVecGeomSolid ; (; TGeoShape * ; shape). staticprivate . Conversion method to create VecGeom solid corresponding to TGeoShape. ; Definition at line 104 of file TGeoVGShape.cxx. ◆ DistancetoPrimitive(). Int_t TGeoVGShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). inlineoverridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Definition at line 52 of file TGeoVGShape.h. ◆ DistFromInside(). Double_t TGeoVGShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 448 of file TGeoVGShape.cxx. ◆ DistFromOutside(). Double_t TGeoVGShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 458 of file TGeoVGShape.cxx. ◆ Divide(). TGeoVolume * TGeoVGShape::Divide ; (; TGeoVolume * ; , . const char * ; , . Int_t ; , . Int_t ; , . Double_t ; , . Double_t ;  . ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoVGShape.h. ◆ Draw(). void TGeoVGShape::Draw ; (; Option_t * ; option = """"). inlineoverridevirtual . Draw this shape. ; Reimplemented from TGeoShape.; Definition at line 58 of file TGeoVGShape.h. ◆ GetAxisName(). const char * TGeoVGShape::GetAxisName ; (; Int_t ; iaxis); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:25660,safe,safe,25660,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['safe'],['safe']
Safety,"e ; Definition at line 165 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 137 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 138 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 156 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 168 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 140 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 149 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 144 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 171 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:57181,timeout,timeout,57181,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety,"e ; Definition at line 168 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 140 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 141 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 159 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 171 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 143 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 152 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 147 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 177 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:56065,timeout,timeout,56065,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['timeout'],['timeout']
Safety,"e = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TEventIter ();  Default constructor. ;  ;  TEventIter (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num);  Constructor. ;  ;  ~TEventIter () override;  Destructor. ;  ; virtual Long64_t GetCacheSize ()=0;  ; virtual Long64_t GetEntryNumber (Long64_t);  ; virtual Int_t GetLearnEntries ()=0;  ; virtual Long64_t GetNextEvent ()=0;  ; virtual Int_t GetNextPacket (Long64_t &first, Long64_t &num)=0;  ; TList * GetPackets ();  ; virtual void InvalidatePacket ();  Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ;  ; TClass * IsA () const override;  ; virtual void StopProcess (Bool_t abort);  Set flag to stop the process. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIter.html:1843,abort,abort,1843,doc/master/classTEventIter.html,https://root.cern,https://root.cern/doc/master/classTEventIter.html,1,['abort'],['abort']
Safety,"e Chart:. TObject. ←; TNamed. ←; TDataSet. ←; TTable. ←; TTableDescriptor. Function documentation; TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. void SetCommentsSetName(const char* name = "".comments""); set comments name. void Streamer(TBuffer& ); The custom Streamer for this table. TTableDescriptor(const TTable* parentTable); to be documented. TTableDescriptor(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_struture only !!!. ~TTableDescriptor(); class destructor. Int_t AddAt(const void* c); Append one row pointed by ""c"" to the descriptor. void AddAt(const void* c, Int_t i); Add one row pointed by ""c"" to the ""i""-th row of the descriptor. void AddAt(TDataSet* dataset, Int_t idx = 0); Add one dataset to the descriptor.; There is no new implementation here.; One needs it to avoid the ""hidden method"" compilation warning. void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx); Add the descriptor element followed by its commentText; at the indx-th position of the descriptor (counted from zero). TString CreateLeafList() const; Create a list of leaf to be useful for TBranch::TBranch ctor. void Init(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_structure only !!!. void LearnTable(const TTable* parentTable); to be documented. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableDescriptor.html:17942,avoid,avoid,17942,root/html602/TTableDescriptor.html,https://root.cern,https://root.cern/root/html602/TTableDescriptor.html,1,['avoid'],['avoid']
Safety,"e Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TGeometry Class ReferenceGraphics » 3D Graphics » Basic 3D graphics. ; TGeometry description. ; The Geometry class describes the geometry of a detector. The current implementation supports the GEANT3 style description. A special program provided in the ROOT utilities (toroot) can be used to automatically translate a GEANT detector geometry into a ROOT geometry.; a Geometry object is entered into the list of geometries into the ROOT main object (see TROOT description) when the TGeometry constructor is invoked. Several geometries may coexist in memory. / A Geometry object consist of the following linked lists:. the TMaterial list (material definition only).; the TRotmatrix list (Rotation matrices definition only).; the TShape list (volume definition only).; the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported.; The conversion program from Geant to Root has been added in the list of utilities in utils directory.(see g2root) The executable module of g2root can be found in $ROOTSYS/bin/g2root.; To use this conversion program, type the shell command:; g2root geant_rzfile macro_name; for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C; To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewer); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); d#define d(i)Definition RSha256.hxx:102; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; Note: all keys are also",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeometry.html:1070,detect,detector,1070,doc/master/classTGeometry.html,https://root.cern,https://root.cern/doc/master/classTGeometry.html,1,['detect'],['detector']
Safety,"e RooAbsArg.cxx. ◆ replaceServer(). void RooAbsArg::replaceServer ; (; RooAbsArg & ; oldServer, . RooAbsArg & ; newServer, . bool ; propValue, . bool ; propShape . ). Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ; WarningThis function should not be used! This method is quite unsafe for many reasons. For once, the new server will be put at the end of the server list, no matter the position of the original server. This might mess up code that expects the servers to be in a certain order. Furthermore, the proxy objects corresponding to the server are not updated, leaving the object in an invalid state where the servers are out of sync with the proxies. This can have very bad consequences. Finally, by having to manually specify the value and shape server properties, it is very easy to get them wrong.; If you want to safely replace a server, you should use RooAbsArg::redirectServers(), which replaces the server in-place at the same position of the server list, keeps the same value and shape server properties, and also updates the corresponding proxies. ; Definition at line 421 of file RooAbsArg.cxx. ◆ resetDataToken(). void RooAbsArg::resetDataToken ; (; ). inline . Definition at line 681 of file RooAbsArg.h. ◆ serverNameChangeHook(). virtual void RooAbsArg::serverNameChangeHook ; (; const RooAbsArg * ; , . const RooAbsArg * ;  . ). inlinevirtual . Definition at line 248 of file RooAbsArg.h. ◆ servers(). const RefCountList_t & RooAbsArg::servers ; (; ); const. inline . List of all servers of this object. ; Definition at line 180 of file RooAbsArg.h. ◆ setAttribute(). void RooAbsArg::setAttribute ; (; const Text_t * ; name, . bool ; value = true . ). Set (default) or clear a named boolean attribute of this object. ; Definition at line 222 of file RooAbsArg.cxx. ◆ setCacheAndTrackHints(). virtual void RooAbsArg::setCacheAndTrackHints ; (; RooArgSet & ; ). inlinevirtual . Reimplemented in RooLagrangianMorphFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:94952,safe,safely,94952,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['safe'],['safely']
Safety,"e THttpServer.cxx. ◆ IsA(). TClass * THttpServer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 198 of file THttpServer.h. ◆ IsAnyEngine(). Bool_t THttpServer::IsAnyEngine ; (; ); const. inline . Definition at line 86 of file THttpServer.h. ◆ IsCors(). Bool_t THttpServer::IsCors ; (; ); const. inline . Returns kTRUE if CORS was configured. ; Definition at line 112 of file THttpServer.h. ◆ IsCorsCredentials(). Bool_t THttpServer::IsCorsCredentials ; (; ); const. inline . Returns kTRUE if Access-Control-Allow-Credentials header should be used. ; Definition at line 121 of file THttpServer.h. ◆ IsFileRequested(). Bool_t THttpServer::IsFileRequested ; (; const char * ; uri, . TString & ; res . ); const. Check if file is requested, thread safe. ; Verifies that request is just file name.; File names typically contains prefix like ""jsrootsys/"" If true, method returns real name of the file, which should be delivered to the client Method is thread safe and can be called from any thread ; Definition at line 612 of file THttpServer.cxx. ◆ IsReadOnly(). Bool_t THttpServer::IsReadOnly ; (; ); const. returns read-only mode ; Definition at line 285 of file THttpServer.cxx. ◆ IsTerminated(). Bool_t THttpServer::IsTerminated ; (; ); const. inline . returns kTRUE, if server was terminated ; Definition at line 105 of file THttpServer.h. ◆ IsWSOnly(). Bool_t THttpServer::IsWSOnly ; (; ); const. returns true if only websockets are handled by the server ; Typically used by WebGui ; Definition at line 307 of file THttpServer.cxx. ◆ MissedRequest(). void THttpServer::MissedRequest ; (; THttpCallArg * ; arg). protectedvirtual . Method called when THttpServer cannot process request. ; By default such requests replied with 404 code One could overwrite with method in derived class to process all kinds of such non-standard requests ; Definition at line 788 of file THttpServer.cxx. ◆ operator=(). THttpServer & T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:27328,safe,safe,27328,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['safe'],['safe']
Safety,"e and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter ta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:54381,risk,risk,54381,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['risk'],['risk']
Safety,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:42135,recover,recovered,42135,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['recover'],['recovered']
Safety,"e bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:40763,recover,recovered,40763,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['recover'],['recovered']
Safety,"e bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromize; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occured while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scrip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:38618,recover,recovered,38618,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['recover'],['recovered']
Safety,"e called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 134/// effectively optimized away from the computation graph.; 135///; 136/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 137// clang-format on; 138template <typename NodeType>; 139void SaveGraph(NodeType node, const std::string &outputFile); 140{; 141 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 142 std::string dotGraph = helper.RepresentGraph(node);; 143 ; 144 std::ofstream out(outputFile);; 145 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct comput",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:6250,safe,safe,6250,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"e called on the top master only. Int_t RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:28572,abort,abort,28572,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,1,['abort'],['abort']
Safety,"e class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::ZVarRooCmdArg ZVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:850; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf309_ndimplotDefinition rf309_ndimplot.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf309__ndimplot_8C.html:5828,safe,safe,5828,doc/master/rf309__ndimplot_8C.html,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8C.html,1,['safe'],['safe']
Safety,"e computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:24017,avoid,avoid,24017,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e d1 = DistFromInside and move the point on the boundary. Compute DistFromOutside and propagate with d2 making sure that the shape is not re-entered. Swap direction and call DistFromOutside that should fall back on the same point on the boundary (at d2). Propagate back on boundary then compute DistFromInside that should be bigger than d1. Plot d-(d1+d2) ; Definition at line 1771 of file TGeoChecker.cxx. ◆ ShapeNormal(). void TGeoChecker::ShapeNormal ; (; TGeoShape * ; shape, . Int_t ; nsamples, . Option_t * ; option . ). Check of validity of the normal for a given shape. ; Sample points inside the shape. Generate directions randomly in cos(theta) and propagate to boundary. Compute normal and safety at crossing point, plot the point and generate a random direction so that (dir) dot (norm) <0. ; Definition at line 2014 of file TGeoChecker.cxx. ◆ ShapeSafety(). void TGeoChecker::ShapeSafety ; (; TGeoShape * ; shape, . Int_t ; nsamples, . Option_t * ; option . ). Check of validity of safe distance for a given shape. ; Sample points inside the 2x bounding box and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety. ; Definition at line 1940 of file TGeoChecker.cxx. ◆ ShootRay(). Double_t * TGeoChecker::ShootRay ; (; Double_t * ; start, . Double_t ; dirx, . Double_t ; diry, . Double_t ; dirz, . Double_t * ; array, . Int_t & ; nelem, . Int_t & ; dim, . Double_t * ; endpoint = nullptr . ); const. Shoot one ray from start point with direction (dirx,diry,dirz). ; Fills input array with points just after boundary crossings. ; Definition at line 2614 of file TGeoChecker.cxx. ◆ Streamer(). void TGeoChecker::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoChecker::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGeoChecker.h. ◆ Test(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:27763,safe,safe,27763,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safe']
Safety,"e default arguments as requested by the user); 3219 std::string alternative;; 3220 gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);; 3221 if (alternative.empty()); 3222 return nullptr;; 3223 const char *altname = alternative.c_str();; 3224 if (strncmp(altname, ""std::"", 5) == 0) {; 3225 // For namespace (for example std::__1), GetInterpreterTypeName does; 3226 // not strip std::, so we must do it explicitly here.; 3227 altname += 5;; 3228 }; 3229 if (altname != normalizedName && strcmp(altname, name) != 0) {; 3230 // altname now contains the full name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waitin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:123676,avoid,avoid,123676,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e default arguments as requested by the user); 3286 std::string alternative;; 3287 gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);; 3288 if (alternative.empty()); 3289 return nullptr;; 3290 const char *altname = alternative.c_str();; 3291 if (strncmp(altname, ""std::"", 5) == 0) {; 3292 // For namespace (for example std::__1), GetInterpreterTypeName does; 3293 // not strip std::, so we must do it explicitly here.; 3294 altname += 5;; 3295 }; 3296 if (altname != normalizedName && strcmp(altname, name) != 0) {; 3297 // altname now contains the full name of the class including a possible; 3298 // namespace if there has been a using namespace statement.; 3299 ; 3300 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3301 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3302 // two different space layout. To avoid an infinite recursion, we also; 3303 // add the test on (altname != name); 3304 ; 3305 return GetClass(altname, load);; 3306 }; 3307 ; 3308 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3309 if (!ncl->IsZombie()) {; 3310 return ncl;; 3311 }; 3312 delete ncl;; 3313 }; 3314 }; 3315 return nullptr;; 3316}; 3317 ; 3318////////////////////////////////////////////////////////////////////////////////; 3319/// Return pointer to class with name.; 3320 ; 3321TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3322{; 3323 if (!gROOT->GetListOfClasses()); 3324 return nullptr;; 3325 ; 3326 //protect access to TROOT::GetIdMap; 3327 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3328 ; 3329 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3330 ; 3331 if (cl && cl->IsLoaded()) return cl;; 3332 ; 3333 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3334 ; 3335 // Now that we got the write lock, another thread may have constructed the; 3336 // TClass while we were waitin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:126427,avoid,avoid,126427,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e fBuffer after a connection attempt. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSlave.html:10544,recover,recovered,10544,root/html534/TXSlave.html,https://root.cern,https://root.cern/root/html534/TXSlave.html,1,['recover'],['recovered']
Safety,"e factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Reader.html:14484,avoid,avoid,14484,root/html534/TMVA__Reader.html,https://root.cern,https://root.cern/root/html534/TMVA__Reader.html,1,['avoid'],['avoid']
Safety,"e factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Reader.html:15062,avoid,avoid,15062,root/html602/TMVA__Reader.html,https://root.cern,https://root.cern/root/html602/TMVA__Reader.html,2,['avoid'],['avoid']
Safety,"e from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  . Protected Member Functions;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:17956,detect,detection,17956,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['detect'],['detection']
Safety,"e given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:15109,safe,safe,15109,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety,"e has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:88867,recover,recovered,88867,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety,"e have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187028,timeout,timeout,187028,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"e have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187060,timeout,timeout,187060,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"e information. ; Definition at line 1043 of file RInterface.hxx. ◆ Vary() [7/11]. template<typename Proxied , typename DataSource = void> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::initializer_list< std::string > ; colNames, . std::string_view ; expression, . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using auto-generated variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona string containing valid C++ code that evaluates to an RVec containing the varied values for the specified column. ; [in]nVariationsnumber of variations returned by the expression. The corresponding tags will be ""0"", ""1"", etc. ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". colName is used if none is provided. NoteThis overload ensures that the ambiguity between C++20 string, vector<string> construction from init list is avoided.; See alsoThis Vary() overload for more information. ; Definition at line 1168 of file RInterface.hxx. ◆ Vary() [8/11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::string_view ; colName, . F && ; expression, . const ColumnNames_t & ; inputColumns, . const std::vector< std::string > & ; variationTags, . std::string_view ; variationName = """" . ). inline . Register systematic variations for a single existing column using custom variation tags. ; Parameters. [in]colNamename of the column for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:147842,avoid,avoided,147842,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['avoid'],['avoided']
Safety,"e input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:17332,predict,prediction,17332,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['predict'],['prediction']
Safety,"e input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:16160,predict,prediction,16160,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,3,['predict'],['prediction']
Safety,"e is opened and can be accessed ;  ; Bool_t IsOracle () const;  checks, if Oracle database ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; TString MakeSelectQuery (TClass *cl);  Produce SELECT statement which can be used to get all data of class cl in one SELECT statement. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ; Bool_t Rollback ();  Rollback all operations, done after StartTransaction() call. ;  ; void Seek (Long64_t, ERelativeTo=kBeg) final;  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; void SetArrayLimit (Int_t limit=20);  Defines maximum number of columns for array representation If array size bigger than limit, array data will be converted to raw format This is usefull to prevent tables with very big number of columns If limit==0, all arrays will be stored in raw format If limit<0, all array values will be stored in column form Default value is 21. ;  ; void SetEND (Long64_t) final;  ; void SetTablesType (const char *table_type);  Defines tables type, which is used in CREATE TABLE statements Now is only used for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:12894,recover,recover,12894,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recover']
Safety,"e know how to convert them, if we know how to convert their content.; 2967 // NOTE: we need to extend this to std::pair ...; 2968 ; 2969 TClass *onfileValueClass = expectedClass->GetCollectionProxy()->GetValueClass();; 2970 TClass *inmemValueClass = ptrClass->GetCollectionProxy()->GetValueClass();; 2971 ; 2972 if (inmemValueClass->GetSchemaRules() &&; 2973 inmemValueClass->GetSchemaRules()->HasRuleWithSourceClass(onfileValueClass->GetName() ) ); 2974 {; 2975 TBranchElement* bEl = (TBranchElement*)branch;; 2976 bEl->SetTargetClass( ptrClass->GetName() );; 2977 return kMatchConversionCollection;; 2978 }; 2979 }; 2980 ; 2981 Error(""SetBranchAddress"", ""The pointer type given (%s) does not correspond to the class needed (%s) by the branch: %s"", ptrClass->GetName(), expectedClass->GetName(), branch->GetName());; 2982 if (isBranchElement) {; 2983 TBranchElement* bEl = (TBranchElement*)branch;; 2984 bEl->SetTargetClass( expectedClass->GetName() );; 2985 }; 2986 return kClassMismatch;; 2987 ; 2988 } else if ((expectedType != kOther_t) && (datatype != kOther_t) && (expectedType != kNoType_t) && (datatype != kNoType_t) && (expectedType != datatype)) {; 2989 if (datatype != kChar_t) {; 2990 // For backward compatibility we assume that (char*) was just a cast and/or a generic address; 2991 Error(""SetBranchAddress"", ""The pointer type given \""%s\"" (%d) does not correspond to the type needed \""%s\"" (%d) by the branch: %s"",; 2992 TDataType::GetTypeName(datatype), datatype, TDataType::GetTypeName(expectedType), expectedType, branch->GetName());; 2993 return kMismatch;; 2994 }; 2995 } else if ((expectedClass && (datatype != kOther_t && datatype != kNoType_t && datatype != kInt_t)) ||; 2996 (ptrClass && (expectedType != kOther_t && expectedType != kNoType_t && datatype != kInt_t)) ) {; 2997 // Sometime a null pointer can look an int, avoid complaining in that case.; 2998 if (expectedClass) {; 2999 Error(""SetBranchAddress"", ""The pointer type given \""%s\"" (%d) does not correspond to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:119795,avoid,avoid,119795,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e last three entries on the output of TFile::Map() are the list of keys, the list of free segments, and the address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440420,recover,recover,440420,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recover']
Safety,"e mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t GetB() const; {return fRmax;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 05/06/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:17122,safe,safe,17122,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,2,['safe'],['safe']
Safety,"e mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t GetB() const; {return fRmax;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 05/06/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoEltu.html:18876,safe,safe,18876,root/html604/TGeoEltu.html,https://root.cern,https://root.cern/root/html604/TGeoEltu.html,2,['safe'],['safe']
Safety,"e mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t GetB() const; {return fRmax;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 05/06/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoEltu.html:18876,safe,safe,18876,root/html602/TGeoEltu.html,https://root.cern,https://root.cern/root/html602/TGeoEltu.html,2,['safe'],['safe']
Safety,"e mode); voidSetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:15947,timeout,timeout,15947,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['timeout'],['timeout']
Safety,"e of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlow,Double_t zup); 104 :TH1(name,title,nbinsx,xlow,xup); 105{; 106 fDimension = 3;; 107 if (nbinsy <= 0) {; 108 Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1"");; 109 nbinsy = 1;; 110 }; 111 if (nbinsz <= 0) {; 112 Warning(""TH3"",""nbinsz is <=0 - set to nbinsz = 1"");; 113 nbinsz = 1;; 114 }; 115 fYaxis.Set(nbinsy,ylow,yup);; 116 fZaxis.Set(nbinsz,zlow,zup);; 117 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 118 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 119 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 120}; 121 ; 122 ; 123////////////////////////////////////////////////////////////////////////////////; 124/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 125/// arrays of type float.; 126///; 127/// \param[in] name name of histogram (avoid blanks); 128/// \param[in] title histogram title.; 129/// If title is of the form `stringt;stringx;stringy;stringz`; 130/// the histogram title is set to `stringt`,; 131/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 132/// \param[in] nbinsx number of bins; 133/// \param[in] xbins array of low-edges for each bin.; 134/// This is an array of type float and size nbinsx+1; 135/// \param[in] nbinsy number of bins; 136/// \param[in] ybins array of low-edges for each bin.; 137/// This is an array of type float and size nbinsy+1; 138/// \param[in] nbinsz number of bins; 139/// \param[in] zbins array of low-edges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 143 ,Int_t nbinsy,const Float_t *ybins; 144 ,Int_t nbinsz,const Float_t *zbins); 145 :TH1(name,title,nbinsx,xbins); 146{; 147 fDimension = 3;; 148 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0 - set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:5670,avoid,avoid,5670,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e of the derived class.; 69///; 70/// Note that the directory name cannot contain slashes.; 71 ; 72TDirectory::TDirectory(const char *name, const char *title, Option_t * /*classname*/, TDirectory* initMotherDir); 73 : TNamed(name, title); 74{; 75 // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition; 76 std::atomic_flag_clear( &fSpinLock );; 77 ; 78 if (!initMotherDir) initMotherDir = gDirectory;; 79 ; 80 if (strchr(name,'/')) {; 81 ::Error(""TDirectory::TDirectory"",""directory name (%s) cannot contain a slash"", name);; 82 gDirectory = nullptr;; 83 return;; 84 }; 85 if (strlen(GetName()) == 0) {; 86 ::Error(""TDirectory::TDirectory"",""directory name cannot be \""\"""");; 87 gDirectory = nullptr;; 88 return;; 89 }; 90 ; 91 BuildDirectory(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////////; 95/// Destructor.; 96 ; 97TDirectory::~TDirectory(); 98{; 99 // Use gROOTLocal to avoid triggering undesired initialization of gROOT.; 100 // For example in compiled C++ programs that don't use it directly.; 101 if (!ROOT::Internal::gROOTLocal) {; 102 delete fList;; 103 return; //when called by TROOT destructor; 104 }; 105 ; 106 if (fList) {; 107 if (!fList->IsUsingRWLock()); 108 Fatal(""~TDirectory"",""In %s:%p the fList (%p) is not using the RWLock\n"",; 109 GetName(),this,fList);; 110 fList->Delete(""slow"");; 111 SafeDelete(fList);; 112 }; 113 ; 114 TDirectory::CleanTargets();; 115 ; 116 TDirectory* mom = GetMotherDir();; 117 ; 118 if (mom) {; 119 mom->Remove(this);; 120 }; 121 ; 122 if (gDebug) {; 123 Info(""~TDirectory"", ""dtor called for %s"", GetName());; 124 }; 125}; 126 ; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Set the current directory to null.; 130/// This is called from the TContext destructor. Since the destructor is; 131/// inline, we do not want to have it directly use a global variable.; 132 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:3342,avoid,avoid,3342,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"e of this. Pointers are preserved. void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoUnion.html:9507,safe,safe,9507,root/html534/TGeoUnion.html,https://root.cern,https://root.cern/root/html534/TGeoUnion.html,2,['safe'],"['safe', 'safety']"
Safety,"e opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a function of the protocol field in 'name'. ;  ; static void IncrementFileCounter ();  ; static TFile * Open (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create / open a file. ;  ; static TFile * Open (TFileOpenHandle *handle);  Waits for the completion of an asynchronous open request. ;  ; static Bool_t SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE);  Sets the directory where to locally stage/cache remote files. ;  ; static void SetFileBytesRead (Long64_t bytes=0);  ; static void SetFileBytesWritten (Long64_t bytes=0);  ; static void SetFileReadCalls (Int_t readcalls=0);  ; static Bool_t SetOnlyStaged (Bool_t onlystaged);  Sets only staged flag. ;  ; static UInt_t SetOpenTimeout (UInt_t timeout);  Sets open timeout time (in ms). Returns previous timeout value. ;  ; static void SetReadaheadSize (Int_t bufsize=256000);  ; static void SetReadStreamerInfo (Bool_t readinfo=kTRUE);  Specify if the streamerinfos must be read at file opening. ;  ; static Bool_t ShrinkCacheFileDir (Long64_t shrinkSize, Long_t cleanupInteval=0);  Try to shrink the cache to the desired size. ;  ;  Static Public Member Functions inherited from TDirectoryFile; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:29652,timeout,timeout,29652,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,30,['timeout'],['timeout']
Safety,"e preserved. void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoIntersection.html:9396,safe,safe,9396,root/html534/TGeoIntersection.html,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html,1,['safe'],['safe']
Safety,"e preserved. void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoIntersection& ). EGeoBoolType GetBooleanOperator() const. TGeoIntersection(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoIntersection.html:10022,safe,safe,10022,root/html604/TGeoIntersection.html,https://root.cern,https://root.cern/root/html604/TGeoIntersection.html,1,['safe'],['safe']
Safety,"e preserved. void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoIntersection& ). EGeoBoolType GetBooleanOperator() const. TGeoIntersection(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoIntersection.html:10022,safe,safe,10022,root/html602/TGeoIntersection.html,https://root.cern,https://root.cern/root/html602/TGeoIntersection.html,1,['safe'],['safe']
Safety,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:23082,timeout,timeout,23082,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:22698,timeout,timeout,22698,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22360,timeout,timeout,22360,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"e screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114480,detect,detector,114480,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"e specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42337,timeout,timeout,42337,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['timeout'],['timeout']
Safety,"e specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; them. Returns the number of new workers found, or <0 on errors. void CleanGDirectory(TList* ol); Remove links to objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:46193,timeout,timeout,46193,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['timeout'],['timeout']
Safety,"e to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:15442,safe,safe,15442,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['safe'],['safe']
Safety,"e to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterised so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning message, may make both the function minimum and parameter errors unreliable. See the discussion above `‘Getting the right parameter errors with limits’'. The best way to be absolutely sure of the errors, is to use independent'' calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for aphysical'' function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; A non-physical region:; On its way to the minimum, MIGRAD may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem:; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well-defined, for example that there are more unknowns than there are data points, or that the parameterisation of the fit contains a linear dependence. If this is the case, then MINUIT (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parameterisation. MINUIT cannot do this itself.; Numerical inaccuracies:; It is possible that the apparent lack of positive-definiteness is in fact only due to excessive roundoff errors in numerical calculations in the user function or not enough precision. This is unlikely in general, but becomes more likely if the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:10145,recover,recovers,10145,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['recover'],['recovers']
Safety,"e to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12701,timeout,timeout,12701,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,12,['timeout'],['timeout']
Safety,"e two defined versions: MSB <---; Version 4-Bit Code Description; ------------------------------------------------------------; | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value; ------------------------------------------------------------; a#define a(i)Definition RSha256.hxx:99; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Clock Sequence; The clock sequence value must be changed whenever:; The UUID generator detects that the local value of UTC has gone backward; this may be due to re-syncing of the system clock.; While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.; The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. Clock Adjustment; UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented, and then added to the UTC time field of the UUID. Clock Overrun; The 100-nanosecond granularity of time should prove sufficient even for bursts of UUID production in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:3492,avoid,avoiding,3492,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['avoid'],['avoiding']
Safety,"e window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1370; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:725; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:351; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:693; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWeb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:34385,timeout,timeout,34385,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"e window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1412; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:726; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:694; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWeb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:34774,timeout,timeout,34774,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"e() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIter&operator=(const TEventIter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIter.html:4562,abort,abort,4562,root/html530/TEventIter.html,https://root.cern,https://root.cern/root/html530/TEventIter.html,2,['abort'],['abort']
Safety,"e(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:13411,safe,safe,13411,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,3,['safe'],['safe']
Safety,"e(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:45633,avoid,avoided,45633,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['avoid'],['avoided']
Safety,"e));; }; if (!f) return;; ; TArrayF *data = new TArrayF[nrStocks];; for (Int_t i = 0; i < nrStocks; i++) {; const TString symbol = stocks[i];; data[i] = StockReturn(f,symbol,sDay,eDay);; }; ; const Int_t nrData = data[0].GetSize();; ; TVectorD r(nrStocks);; for (Int_t i = 0; i < nrStocks; i++); r[i] = data[i].GetSum()/nrData;; ; TMatrixDSym Covar(nrStocks);; for (Int_t i = 0; i < nrStocks; i++) {; for (Int_t j = 0; j <= i; j++) {; Double_t sum = 0.;; for (Int_t k = 0; k < nrData; k++) {; sum += (data[i][k] - r[i]) * (data[j][k] - r[j]);; }; Covar(i,j) = Covar(j,i) = sum/nrData;; }; }; ; const TVectorD weight1 = OptimalInvest(2.0,r,Covar);; const TVectorD weight2 = OptimalInvest(10.,r,Covar);; ; cout << ""stock daily daily w1 w2"" <<endl;; cout << ""symb return sdv "" <<endl;; for (Int_t i = 0; i < nrStocks; i++); printf(""%s\t: %.3f %.3f %.3f %.3f\n"",stocks[i],r[i],TMath::Sqrt(Covar[i][i]),weight1[i],weight2[i]);; ; TCanvas *c1 = new TCanvas(""c1"",""Portfolio Optimizations"",10,10,800,900);; c1->Divide(1,2);; ; // utility function / risk profile; ; c1->cd(1);; gPad->SetGridx();; gPad->SetGridy();; ; TF1 *f1 = new TF1(""f1"",RiskProfile,0,2.5,1);; f1->SetParameter(0,2.0);; f1->SetLineColor(49);; f1->Draw(""AC"");; f1->GetHistogram()->SetXTitle(""dollar"");; f1->GetHistogram()->SetYTitle(""utility"");; f1->GetHistogram()->SetMinimum(0.0);; f1->GetHistogram()->SetMaximum(1.0);; TF1 *f2 = new TF1(""f2"",RiskProfile,0,2.5,1);; f2->SetParameter(0,10.);; f2->SetLineColor(50);; f2->Draw(""CSAME"");; ; TLegend *legend1 = new TLegend(0.50,0.65,0.70,0.82);; legend1->AddEntry(f1,""1-exp(-2.0*x)"",""l"");; legend1->AddEntry(f2,""1-exp(-10.*x)"",""l"");; legend1->Draw();; ; // vertical bar chart of portfolio distribution; ; c1->cd(2);; TH1F *h1 = new TH1F(""h1"",""Portfolio Distribution"",nrStocks,0,0);; TH1F *h2 = new TH1F(""h2"",""Portfolio Distribution"",nrStocks,0,0);; h1->SetStats(0);; h1->SetFillColor(49);; h2->SetFillColor(50);; h1->SetBarWidth(0.45);; h1->SetBarOffset(0.1);; h2->SetBarWidth(0.4);; h2->SetBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:12195,risk,risk,12195,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risk']
Safety,"e); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf302_utilfuncs.py. tutorialsroofitrf302_utilfuncs.py. ROOT master - Reference Guide Generated on Tue ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3746,safe,safe,3746,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"e);; 348 virtual void SetDisplay();; 349 void SetErrorStr(const char *errstr);; 350 const char *GetErrorStr() const { return GetLastErrorString(); }; 351 virtual const char *GetError();; 352 virtual Int_t GetCryptoRandom(void *buf, Int_t len);; 353 void RemoveOnExit(TObject *obj);; 354 virtual const char *HostName();; 355 virtual void NotifyApplicationCreated();; 356 ; 357 static Int_t GetErrno();; 358 static void ResetErrno();; 359 void Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);; 360 void GetBeepDefaults(Int_t &freq, Int_t &duration) const { freq = fBeepFreq; duration = fBeepDuration; }; 361 ; 362 //---- EventLoop; 363 virtual void Run();; 364 virtual Bool_t ProcessEvents();; 365 virtual void DispatchOneEvent(Bool_t pendingOnly = kFALSE);; 366 virtual void ExitLoop();; 367 Bool_t InControl() const { return fInControl; }; 368 virtual void InnerLoop();; 369 virtual Int_t Select(TList *active, Long_t timeout);; 370 virtual Int_t Select(TFileHandler *fh, Long_t timeout);; 371 ; 372 //---- Handling of system events; 373 virtual void AddSignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHandler; }; 386 ; 387 //---- Floating Point Exceptions Control;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:15484,timeout,timeout,15484,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"e, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:14216,safe,safe,14216,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,3,['safe'],['safe']
Safety,"e->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:30796,avoid,avoids,30796,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoids']
Safety,"e-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12151,timeout,timeout,12151,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety,"e. The; size of the cluster in this range is given by the value of fAutoFlush. For example printing the beginning and end of each the ranges can be done by:. Printf(""%-16s %-16s %-16s %5s"",; ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; Int_t index= 0;; Long64_t clusterRangeStart = 0;; if (fNClusterRange) {; for( ; index < fNClusterRange; ++index) {; Printf(""%-16d %-16lld %-16lld %5lld"",; index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; clusterRangeStart = fClusterRangeEnd[index] + 1;; }; }; Printf(""%-16d %-16lld %-16lld %5lld"",; index, prevEntry, fEntries - 1, fAutoFlush);. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:122041,recover,recover,122041,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['recover'],['recover']
Safety,"e. ◆ GetAxisRange(). virtual Double_t TGeoShape::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape. ◆ GetBasicColor(). Int_t TGeoShape::GetBasicColor ; (; ); const. protected . Get the basic color (0-7). ; Definition at line 718 of file TGeoShape.cxx. ◆ GetBoundingCylinder(). virtual void TGeoShape::GetBoundingCylinder ; (; Double_t * ; param); const. pure virtual . Implemented in TGeoCompositeShape, TGeoHalfSpace, TGeoArb8, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, and TGeoVGShape. ◆ GetBuffer3D(). const TBuffer3D & TGeoShape::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. virtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented in TGeoTessellated, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, TGeoVGShape, TEveGeoPolyShape, and ROOT::Experimental::REveGeoPolyShape.; Definition at line 735 of file TGeoShape.cxx. ◆ GetByteCount(). virtual Int_t TGeoShape::GetByteCount ; (; ); const. pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape. ◆ GetFittingBox(). virtual Int_t TGeoShape::GetFittingBox ; (; const TGeoBBox * ; parambox, . TGeoMatrix * ; mat, . Double_t & ; dx, . Double_t & ; dy, . Double_t & ; dz . ); const. pure virtual . Implemented in TGeoArb8, TGeoBBox, TGeoPara, TGeoTrd1, TGeoTrd2, and TGeoVGShape. ◆ GetId(). Int_t TGeoShape::GetId ; (; ); const. inline . Definition at line 123 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:37449,avoid,avoid,37449,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['avoid'],['avoid']
Safety,"e...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions, inherit. More...;  ; class  ROOT::Minuit2::Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  ROOT::Minuit2::MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  ROOT::Minuit2::MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  ROOT::Minuit2::MnParabolaPoint;  A point of a parabola. More...;  ; class  ROOT::Minuit2::ParametricFunction;  Function which has parameters. More...;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Minuit.html:1926,predict,predicted,1926,doc/master/group__Minuit.html,https://root.cern,https://root.cern/doc/master/group__Minuit.html,1,['predict'],['predicted']
Safety,"e.; 370 /// The idea is to populate the event entries in the *fSampleNameToEventEntries* map; 371 /// by selecting the greater of the two values:; 372 /// *id.EntryRange().second* which is the upper event entry range of the processed sample; 373 /// and the current value of the event entries in the *fSampleNameToEventEntries* map.; 374 /// In the single threaded case, the two numbers are the same as the entry range corresponds; 375 /// to the number of events in an individual file (each sample is simply a single file).; 376 /// In the multithreaded case, the idea is to accumulate the higher event entry value until; 377 /// the total number of events in a given file is reached.; 378 void registerNewSample(unsigned int /*slot*/, const ROOT::RDF::RSampleInfo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:18363,safe,safe,18363,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"e.; 900 T *OldEnd = this->end();; 901 this->set_size(this->size() + NumToInsert);; 902 size_t NumOverwritten = OldEnd - I;; 903 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 904 ; 905 // Replace the overwritten part.; 906 for (T *J = I; NumOverwritten > 0; --NumOverwritten) {; 907 *J = *From;; 908 ++J;; 909 ++From;; 910 }; 911 ; 912 // Insert the non-overwritten middle part.; 913 this->uninitialized_copy(From, To, OldEnd);; 914 return I;; 915 }; 916 ; 917 void insert(iterator I, std::initializer_list<T> IL) { insert(I, IL.begin(), IL.end()); }; 918 ; 919 template <typename... ArgTypes>; 920 reference emplace_back(ArgTypes &&...Args); 921 {; 922 if (R__unlikely(this->size() >= this->capacity())); 923 this->grow();; 924 ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);; 925 this->set_size(this->size() + 1);; 926 return this->back();; 927 }; 928 ; 929 RVecImpl &operator=(const RVecImpl &RHS);; 930 ; 931 RVecImpl &operator=(RVecImpl &&RHS);; 932};; 933 ; 934template <typename T>; 935void RVecImpl<T>::swap(RVecImpl<T> &RHS); 936{; 937 if (this == &RHS); 938 return;; 939 ; 940 // We can only avoid copying elements if neither vector is small.; 941 if (!this->isSmall() && !RHS.isSmall()) {; 942 std::swap(this->fBeginX, RHS.fBeginX);; 943 std::swap(this->fSize, RHS.fSize);; 944 std::swap(this->fCapacity, RHS.fCapacity);; 945 return;; 946 }; 947 ; 948 // This block handles the swap of a small and a non-owning vector; 949 // It is more efficient to first move the non-owning vector, hence the 2 cases; 950 if (this->isSmall() && !RHS.Owns()) { // the right vector is non-owning; 951 RVecImpl<T> temp(0);; 952 temp = std::move(RHS);; 953 RHS = std::move(*this);; 954 *this = std::move(temp);; 955 return;; 956 } else if (RHS.isSmall() && !this->Owns()) { // the left vector is non-owning; 957 RVecImpl<T> temp(0);; 958 temp = std::move(*this);; 959 *this = std::move(RHS);; 960 RHS = std::move(temp);; 961 return;; 962 }; 963 ; 964 if (RHS.size() > thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:32898,avoid,avoid,32898,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"e.; Definition at line 287 of file TFile.h. ◆ SetFileBytesRead(). void TFile::SetFileBytesRead ; (; Long64_t ; bytes = 0). static . Definition at line 4608 of file TFile.cxx. ◆ SetFileBytesWritten(). void TFile::SetFileBytesWritten ; (; Long64_t ; bytes = 0). static . Definition at line 4611 of file TFile.cxx. ◆ SetFileReadCalls(). void TFile::SetFileReadCalls ; (; Int_t ; readcalls = 0). static . Definition at line 4614 of file TFile.cxx. ◆ SetOffset(). void TFile::SetOffset ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Definition at line 2253 of file TFile.cxx. ◆ SetOnlyStaged(). Bool_t TFile::SetOnlyStaged ; (; Bool_t ; onlystaged). static . Sets only staged flag. ; Returns previous value of flag. When true we check before opening the file if it is staged, if not, the open fails. ; Definition at line 4744 of file TFile.cxx. ◆ SetOpenTimeout(). UInt_t TFile::SetOpenTimeout ; (; UInt_t ; timeout). static . Sets open timeout time (in ms). Returns previous timeout value. ; Definition at line 4724 of file TFile.cxx. ◆ SetOption(). virtual void TFile::SetOption ; (; Option_t * ; option = "">""). inlinevirtual . Definition at line 289 of file TFile.h. ◆ SetReadaheadSize(). void TFile::SetReadaheadSize ; (; Int_t ; bufsize = 256000). static . Definition at line 4605 of file TFile.cxx. ◆ SetReadCalls(). virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:95067,timeout,timeout,95067,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"e.h. ◆ GetEntry(). Long64_t TEntryListFromFile::GetEntry ; (; Long64_t ; index). overridevirtual . Returns entry #index See also Next() for a faster alternative. ; Reimplemented from TEntryList.; Definition at line 90 of file TEntryListFromFile.cxx. ◆ GetEntryAndTree(). Long64_t TEntryListFromFile::GetEntryAndTree ; (; Long64_t ; index, . Int_t & ; treenum . ). overridevirtual . Return the entry corresponding to the index parameter and the number of the tree, where this entry is. ; Reimplemented from TEntryList.; Definition at line 155 of file TEntryListFromFile.cxx. ◆ GetEntryList(). TEntryList * TEntryListFromFile::GetEntryList ; (; const char * ; treename, . const char * ; filename, . Option_t * ; opt . ). inlineoverridevirtual . Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again. ; To avoid it, use option ""ne"" ; Reimplemented from TEntryList.; Definition at line 68 of file TEntryListFromFile.h. ◆ GetFileName(). const char * TEntryListFromFile::GetFileName ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 77 of file TEntryListFromFile.h. ◆ GetN(). Long64_t TEntryListFromFile::GetN ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 75 of file TEntryListFromFile.h. ◆ GetTreeName(). const char * TEntryListFromFile::GetTreeName ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 76 of file TEntryListFromFile.h. ◆ GetTreeNumber(). Int_t TEntryListFromFile::GetTreeNumber ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 78 of file TEntryListFromFile.h. ◆ IsA(). TClass * TEntryListFromFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEntryList.; Definition at line 97 of file TEntryList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:25080,avoid,avoid,25080,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,1,['avoid'],['avoid']
Safety,"e2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(5); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_s1f.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_s1f.Draw(""box""); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_a1.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_a1.Draw(""box""); c.cd(7); ROOT.gPad.SetLeftMargin(0.15); corrHist000.GetYaxis().SetTitleOffset(1.4); corrHist000.Draw(""colz""); c.cd(8); ROOT.gPad.SetLeftMargin(0.15); corrHist127.GetYaxis().SetTitleOffset(1.4); corrHist127.Draw(""colz""); c.cd(9); ROOT.gPad.SetLeftMargin(0.15); corrHist953.GetYaxis().SetTitleOffset(1.4); corrHist953.Draw(""colz""); ; c.SaveAs(""rf801_mcstudy.png""); ; # Make ROOT.RooMCStudy object available on command line after; # macro finishes; ROOT.gDirectory.Add(mcstudy); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8py.html:4920,safe,safe,4920,doc/master/rf801__mcstudy_8py.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html,1,['safe'],['safe']
Safety,"e::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStart; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGRecorder.html:22025,timeout,timeouts,22025,root/html528/TGRecorder.html,https://root.cern,https://root.cern/root/html528/TGRecorder.html,1,['timeout'],['timeouts']
Safety,"e::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStart; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGRecorder.html:22178,timeout,timeouts,22178,root/html530/TGRecorder.html,https://root.cern,https://root.cern/root/html530/TGRecorder.html,1,['timeout'],['timeouts']
Safety,"e::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStart; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGRecorder.html:22178,timeout,timeouts,22178,root/html532/TGRecorder.html,https://root.cern,https://root.cern/root/html532/TGRecorder.html,1,['timeout'],['timeouts']
Safety,"e; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9283,abort,aborted,9283,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,2,['abort'],['aborted']
Safety,"e; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfCurcurrent entry; TDSet*fDSetdata set over which to iterate; TDirectory*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIter.html:6655,abort,abort,6655,root/html530/TEventIter.html,https://root.cern,https://root.cern/root/html530/TEventIter.html,1,['abort'],['abort']
Safety,"e; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfCurcurrent entry; TDSet*fDSetdata set over which to iterate; TDirectory*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEventIter.html:6655,abort,abort,6655,root/html532/TEventIter.html,https://root.cern,https://root.cern/root/html532/TEventIter.html,1,['abort'],['abort']
Safety,"e; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9428,abort,abort,9428,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,3,['abort'],['abort']
Safety,"e; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←. TFileHandler; ←. TXSocketHandler. TSignalHandler. TStdExceptionHandler; ←. TEveManager::TExceptionHandler. TTimer; ←. TProcessEventTimer. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. TSysEvtHandler(); { }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSysEvtHandler.html:10185,avoid,avoid,10185,root/html604/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"e; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←. TFileHandler; ←. TXSocketHandler. TSignalHandler. TStdExceptionHandler; ←. TEveManager::TExceptionHandler. TTimer; ←. TProcessEventTimer. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. TSysEvtHandler(); { }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSysEvtHandler.html:10185,avoid,avoid,10185,root/html602/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html602/TSysEvtHandler.html,1,['avoid'],['avoid']
Safety,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:171360,abort,abort,171360,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['abort'],['abort']
Safety,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:171536,abort,abort,171536,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['abort'],['abort']
Safety,"eAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components with cache-and-track. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:6469,safe,safe,6469,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,5,['safe'],['safe']
Safety,"eAttributes();; ; // Set Node attributes; CAVE1->SetVisibility(2); //node is not drawn but its sons are drawn; VT1_1->SetVisibility(-4); //Node is not drawn. Its immediate sons are drawn; VT2_1->SetVisibility(-4);; MTL_1->SetVisibility(-4);; MTR_1->SetVisibility(-4);; TOFR1->SetVisibility(-4);; ; gBenchmark->Show(""na49"");; }; TBRIK.h; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TGeometry.h; TMaterial.h; TMixture.h; TNode.h; TRotMatrix.h; TTRAP.h; TTUBE.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TBRIKA box with faces perpendicular to the axes.Definition TBRIK.h:26; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TGeometryTGeometry description.Definition TGeometry.h:39; TMaterialManages a detector material.Definition TMaterial.h:28; TMixtureManages a detector mixture.Definition TMixture.h:27; TMixture::DefineElementvirtual void DefineElement(Int_t n, Float_t a, Float_t z, Float_t w)Define one mixture element.Definition TMixture.cxx:86; TNodeTNode description.Definition TNode.h:33; TNode::cdvirtual void cd(const char *path=nullptr)Change Current Reference node to this.Definition TNode.cxx:249; TNode::ImportShapeAttributesvirtual void ImportShapeAttributes()Copy shape attributes as node attributes.Definition TNode.cxx:409; TNode::SetVisibilityvirtual void SetVisibility(Int_t vis=1)Set visibility for this node and its sons.Definition TNode.cxx:758; TRotMatrixManages a detector rotation matrix.Definition TRotMatrix.h:28; TShape::SetVisibilityvirtual void SetVisibility(Int_t vis)Definition TShape.h:62; TTRAPA general trapezoid.Definition TTRAP.h:33; TTUBEA tube.Definition TTUBE.h:32; AuthorRene Brun ; Definition in file na49.C. tutorialsgeomna49.C. ROOT master - Reference",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49_8C.html:948452,detect,detector,948452,doc/master/na49_8C.html,https://root.cern,https://root.cern/doc/master/na49_8C.html,1,['detect'],['detector']
Safety,"eBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:1434,safe,safe,1434,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,9,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"eBBox() override;; 123 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 124 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 125 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 126 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2);; 127 Bool_t Contains(const Double_t *point) const override;; 128 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 129 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 130 static Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 131 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 132 Double_t sm, Double_t cdfi);; 133 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 134 Double_t *safe = nullptr) const override;; 135 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 136 Double_t *step) const override;; 137 static Double_t DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 138 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 139 Double_t sm, Double_t cdfi);; 140 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 141 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 142 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 143 Double_t *step) const override;; 144 TGeoVolume *; 145 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:6938,safe,safe,6938,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"eBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:3199,safe,safe,3199,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"eBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the que",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:14102,detect,detection,14102,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['detect'],['detection']
Safety,"eCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:25255,safe,safe,25255,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['safe'],['safe']
Safety,"eDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2236 of file TBufferFile.cxx. ◆ WriteFastArray() [4/15]. void TBufferFile::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). overridevirtual . Write array of n floats into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2203 of file TBufferFile.cxx. ◆ WriteFastArray() [5/15]. void TBufferFile::WriteFastArray ; (; const Int_t * ; ii, . Long64_t ; n . ). overridevirtual . Write array of n ints into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2096 of file TBufferFile.cxx. ◆ WriteFastArray() [6/15]. void TBufferFile::WriteFastArray ; (; const Long64_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n long longs into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:82838,abort,aborts,82838,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"eEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TF1.cxx:1536; TF1::GetSavevirtual Double_t GetSave(const Double_t *x)Get value corresponding to X in array of fSave values.Definition TF1.cxx:2344; TF1::fgAbsValuestatic std::atomic< Bool_t > fgAbsValueDefinition TF1.h:324; TF1::TF1TF1()TF1 default constructor.Definition TF1.cxx:489; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::fParMaxstd::vector< Double_t > fParMaxArray of upper limits of the fNpar parameters.Definition TF1.h:276; TF1::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TF1.cxx:3218; TF1::IsValidvirtual Bool_t IsValid() constReturn kTRUE if the function is valid.Definition TF1.cxx:2882; TF1::DefaultAddToGlobalListstatic Bool_t DefaultAddToGlobalList(Bool_t on=kTRUE)Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctio...Definition TF1.cxx:838; TF1::fSavestd::vector< Double_t > fSaveArray of fNsave function values.Definition TF1.h:277; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::DefineNSUMTermvoid DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula, int termStart, int termEnd, Double_t xmin, Double_t xmax)Helper functions for NSUM parsing.Definition TF1.cxx:883; TF1::fGammastd::vector< Double_t > fGamma! Array gamma.Definition TF1.h:281; TF1::fParentTObject * fParent! Parent object hooking this function (if one)Definition TF1.h:282; TF1::GetMinMaxNDimvirtual Double_t GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constFind the minimum of a function of whatever dimension.Definition TF1.cxx:1723; TF1::DrawF1virtual void DrawF1(Double_t xmin, Double_t xmax, Option_t *optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:187461,avoid,avoid,187461,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"eMsg; kSmall2WelcomeMsg; kOriginalWelcomeMsgColor; kOriginalWelcomeMsgBW; };; enum ECitation { kPlainText; kBibTeX; kLaTeX; kHtmlLink; };. public:. TMVA::MsgLogger*fLogger; const TStringfRegexp; TXMLEngine*fXMLEngine; static TMVA::Tools*fgTools. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(); { return fgTools?*(fgTools): *(fgTools = new Tools()); }. void DestroyInstance(). Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.0); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* ,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Tools.html:6026,sanity check,sanity check,6026,root/html534/TMVA__Tools.html,https://root.cern,https://root.cern/root/html534/TMVA__Tools.html,1,['sanity check'],['sanity check']
Safety,"eMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43. Shape queries; Note that global queries related to a geometry are handled by the manager class. However, shape-related queries might be sometimes useful.; Bool_t TGeoShape::Contains(const Double_t *point[3]); this method returns true if POINT is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside); compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.; Double_t *Normal(Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:5155,safe,safe,5155,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"eNormal_v(). void TGeoArb8::ComputeNormal_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; norms, . Int_t ; vecsize . ). overridevirtual . Reimplemented from TGeoShape. ◆ ComputeTwist(). void TGeoArb8::ComputeTwist ; (; ). ◆ Contains(). Bool_t TGeoArb8::Contains ; (; const Double_t * ; point); const. overridevirtual . Implements TGeoShape. ◆ Contains_v(). void TGeoArb8::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape. ◆ CopyTwist(). void TGeoArb8::CopyTwist ; (; Double_t * ; twist = nullptr). protected . ◆ DeclFileName(). static const char * TGeoArb8::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TGeoArb8.h. ◆ DistFromInside(). Double_t TGeoArb8::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ DistFromInside_v(). void TGeoArb8::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ DistFromOutside(). Double_t TGeoArb8::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ DistFromOutside_v(). void TGeoArb8::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ DistToPlane(). Double_t TGeoArb8::DistToP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:27590,safe,safe,27590,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety,"eShape & ; ). protecteddelete . ◆ PaintComposite(). Bool_t TGeoCompositeShape::PaintComposite ; (; Option_t * ; option = """"); const. virtual . Paint this composite shape into the current 3D viewer Returns bool flag indicating if the caller should continue to paint child objects. ; Definition at line 429 of file TGeoCompositeShape.cxx. ◆ RegisterYourself(). void TGeoCompositeShape::RegisterYourself ; (; ). Register the shape and all components to TGeoManager class. ; Definition at line 475 of file TGeoCompositeShape.cxx. ◆ Safety(). Double_t TGeoCompositeShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 521 of file TGeoCompositeShape.cxx. ◆ Safety_v(). void TGeoCompositeShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 629 of file TGeoCompositeShape.cxx. ◆ SavePrimitive(). void TGeoCompositeShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 531 of file TGeoCompositeShape.cxx. ◆ SetDimensions(). void TGeoCompositeShape::SetDimensions ; (; Double_t * ; ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoCompositeShape.h. ◆ SetPoints() [1/2]. void TGeoCompositeShape::SetPoints ; (; Double_t * ; points); const. overridevirtual . create points for a composite shape ; Reimplemented from TGeoBBox.; Definition at line 548 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:43115,safe,safe,43115,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"eTherefore, no explicit attempt should be made to normalize the function output in evaluate(). In particular, normalisation constants can be omitted to speed up the function evaluations, and included later in the integration of the PDF (see below), which is rarely called in comparison to the evaluate() function.; In addition, RooAbsPdf objects do not have a static concept of what variables are parameters, and what variables are dependents (which need to be integrated over for a correct PDF normalization). Instead, the choice of normalization is always specified each time a normalized value is requested from the PDF via the getVal() method.; RooAbsPdf manages the entire normalization logic of each PDF with the help of a RooRealIntegral object, which coordinates the integration of a given choice of normalization. By default, RooRealIntegral will perform an entirely numeric integration of all dependents. However, PDFs can advertise one or more (partial) analytical integrals of their function, and these will be used by RooRealIntegral, if it determines that this is safe (i.e., no hidden Jacobian terms, multiplication with other PDFs that have one or more dependents in common, etc).; Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; int; should return the analytical integrals that are supported. integSet is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:2602,safe,safe,2602,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['safe'],['safe']
Safety,"eTime). Expects as input a string in SQL date/time compatible format, like: yyyy-mm-dd hh:mm:ss. ; Definition at line 78 of file TDatime.cxx. ◆ ~TDatime(). virtual TDatime::~TDatime ; (; ). inlinevirtual . Definition at line 53 of file TDatime.h. Member Function Documentation. ◆ AsSQLString(). const char * TDatime::AsSQLString ; (; ); const. Return the date & time in SQL compatible string format, like: 1997-01-15 20:16:28. ; The returned string buffer is static and will be reused. ; Definition at line 152 of file TDatime.cxx. ◆ AsString() [1/2]. const char * TDatime::AsString ; (; ); const. Return the date & time as a string (ctime() format). ; Copy result because it points to a statically allocated string. ; Definition at line 102 of file TDatime.cxx. ◆ AsString() [2/2]. const char * TDatime::AsString ; (; char * ; out); const. Return the date & time as a string (ctime() format). ; Result is copied into out (and out is returned). Make sure out can at least contain 26 characters. Thread safe. ; Definition at line 121 of file TDatime.cxx. ◆ Class(). static TClass * TDatime::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDatime::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDatime::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TDatime.h. ◆ Convert(). UInt_t TDatime::Convert ; (; Bool_t ; toGMT = kFALSE); const. Convert fDatime from TDatime format to the standard time_t format. ; If toGMT is true, the time offset of the current local time zone is subtracted from the returned time_t. One use of such a non-standard time_t value is to convert a TDatime object that contains local time to GMT, as in this example: TDatime now;; now.Set(now.Convert(kTRUE));; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatime.html:6627,safe,safe,6627,doc/master/classTDatime.html,https://root.cern,https://root.cern/doc/master/classTDatime.html,1,['safe'],['safe']
Safety,"e_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *) override;  ; void SetPoints (Double_t *points) const override;  create points for a composite shape ;  ; void SetPoints (Float_t *points) const override;  create points for a composite shape ;  ; void Sizeof3D () const override;  compute size of this 3D object ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void SetBoxDimensions (Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:15075,avoid,avoid,15075,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['avoid'],['avoid']
Safety,"e_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:4421,safe,safe,4421,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,"e_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:32378,safe,safe,32378,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"e_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2). void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:20089,avoid,avoid,20089,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,1,['avoid'],['avoid']
Safety,"e_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2). void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. TGeoShape(); constructors. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:21635,avoid,avoid,21635,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,2,['avoid'],['avoid']
Safety,"e_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:15927,safe,safe,15927,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['safe'],['safe']
Safety,"e_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:15597,safe,safe,15597,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,6,['safe'],['safe']
Safety,"e_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& ); Stream an object of class TGeoManager. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Outpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:17390,safe,safety,17390,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safety']
Safety,"e_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:2749,safe,safe,2749,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,3,['safe'],['safe']
Safety,"e_t, Layer_t, DeepNet_t >.; Definition at line 141 of file Adam.h. Member Data Documentation. ◆ fBeta1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta1. protected . The Beta1 constant used by the optimizer. ; Definition at line 51 of file Adam.h. ◆ fBeta2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta2. protected . The Beta2 constant used by the optimizer. ; Definition at line 52 of file Adam.h. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 53 of file Adam.h. ◆ fFirstMomentBiases. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fFirstMomentBiases. protected . The decaying average of the first moment of the past bias gradients associated with the deep net. ; Definition at line 57 of file Adam.h. ◆ fFirstMomentWeights. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fFirstMomentWeights. protected . The decaying average of the first moment of the past weight gradients associated with the deep net. ; Definition at line 55 of file Adam.h. ◆ fSecondMomentBiases. template<typename Architecture_t , typename Layer_t =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:11076,avoid,avoid,11076,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['avoid'],['avoid']
Safety,"e_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:2458,safe,safe,2458,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,1,['safe'],['safe']
Safety,"ead () const;  ; TList * GetConfigParams (Bool_t steal=kFALSE);  ; Double_t GetCumProcTime () const;  ; virtual Float_t GetCurrentRate (Bool_t &all);  ; Long64_t GetEntriesProcessed () const;  ; virtual Int_t GetEstEntriesProcessed (Float_t, Long64_t &ent, Long64_t &bytes, Long64_t &calls);  ; TList * GetFailedPackets ();  ; Float_t GetInitTime () const;  ; virtual TDSetElement * GetNextPacket (TSlave *sl, TMessage *r);  Get next packet. ;  ; Float_t GetProcTime () const;  ; TNtuple * GetProgressPerf (Bool_t steal=kFALSE);  ; Long64_t GetReadCalls () const;  ; TMap * GetSlaveStats () const;  ; TProofProgressStatus * GetStatus ();  ; Long64_t GetTotalEntries () const;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; virtual void MarkBad (TSlave *, TProofProgressStatus *, TList **);  ; void SetFailedPackets (TList *list);  ; virtual void SetInitTime ();  Set the initialization time. ;  ; void SetProgressStatus (TProofProgressStatus *st);  ; void SetTotalEntries (Long64_t ent);  ; virtual void StopProcess (Bool_t abort, Bool_t stoptimer=kFALSE);  Stop process. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPacketizer.html:3440,abort,abort,3440,doc/master/classTVirtualPacketizer.html,https://root.cern,https://root.cern/doc/master/classTVirtualPacketizer.html,1,['abort'],['abort']
Safety,"ead of ""("" and "")"". Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close. As before, the same macro is valid for PDF files. It is possible to print a canvas into an animated GIF file by specifying the; file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; between the subimages' display. If NN is ommitted the delay between; subimages is zero. Each picture is added in the animation thanks to a loop; similar to the following one:. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop. The delay between each frame must be specified in each Print() statement.; If the file ""myfile.gif"" already exists, the new frame are appended at; the end of the file. To avoid this, delete it first with gSystem->Unlink(myfile.gif);; If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad.; Emits signal ""RangeChanged()"", in the slot get the range; via GetRange(). void RangeAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); Set axis coordinate system for the pad.; The axis coordinate system is a subset of the world coordinate system; xmin,ymin is the origin of the current coordinate system,; xmax is the end of the X axis, ymax is the end of the Y axis.; By default a margin of 10 per cent is left on all sides of the pad; Emits signal ""RangeAxisChanged()"", in the slot get the axis range; via GetRangeAxis(). void RecursiveRemove(TObject* obj); Recursively remove object from a pad and its subpads. void RedrawAxis(Option_t* option = """"); Redraw the frame axis; Redrawing axis may be necessary in case of superimposed histograms; whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:53598,avoid,avoid,53598,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,2,['avoid'],['avoid']
Safety,"ead of ""("" and "")"".; Example: c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close.; As before, the same macro is valid for PDF files.; It is possible to print a canvas into an animated GIF file by specifying the file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay between the subimages' display. If NN is omitted the delay between subimages is zero. Each picture is added in the animation thanks to a loop similar to the following one: for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop; The delay between each frame must be specified in each Print() statement. If the file ""myfile.gif"" already exists, the new frame are appended at the end of the file. To avoid this, delete it first with gSystem->Unlink(myfile.gif); If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation ; Implements TVirtualPad.; Definition at line 4979 of file TPad.cxx. ◆ Print() [2/2]. void TPad::Print ; (; const char * ; filename = """"); const. overridevirtual . This method is equivalent to SaveAs(""filename""). See TPad::SaveAs for details. ; Implements TVirtualPad.; Definition at line 4798 of file TPad.cxx. ◆ Range(). void TPad::Range ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Set world coordinate system for the pad. ; Emits signal ""RangeChanged()"", in the slot get the range via GetRange(). ; Implements TVirtualPad.; Definition at line 5331 of file TPad.cxx. ◆ RangeAxis(). void TPad::RangeAxis ; (; Double_t ; xmin, . Double_t ; ymin, . Double_t ; xmax, . Double_t ; ymax . ). overridevirtual . Set axis coordinate system for the pad. ; The axis coordinate system is a subset of the world coordinate system xmin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:106394,avoid,avoid,106394,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety,"ead safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();; 92}; 93 ; 94class TROOT : public TDirectory {; 95 ; 96friend class TCling;; 97friend TROOT *ROOT::Internal::GetROOT2();; 98 ; 99private:; 100 Int_t fLineIsProcessing; ///< To synchronize multi-threads; 101 ; 102 static Int_t fgDirLevel; ///< Indentation level for ls(); 103 static Bool_t fgRootInit; ///< Singleton initialization flag; 104 ; 105 TROOT(const TROOT&) = delete;; 106 TROOT& operator=(const TROOT&) = delete;; 107 ; 108protected:; 109 typedef std::atomic<TListOfEnums*> AListOfEnums_t;; 110 ; 111 TString fConfigOptions; ///< ROOT ./configure set build options; 112 TString fConfigFeatures; ///< ROOT ./configure detected build features; 113 TString fVersion; ///< ROOT version (from CMZ VERSQQ) ex 0.05/01; 114 Int_t fVersionInt; ///< ROOT version in integer format (501); 115 Int_t fVersionCode; ///< ROOT version code as used in RVersion.h; 116 Int_t fVersionDate; ///< Date of ROOT version (ex 951226); 117 Int_t fVersionTime; ///< Time of ROOT version (ex 1152); 118 Int_t fBuiltDate; ///< Date of ROOT built; 119 Int_t fBuiltTime; ///< Time of ROOT built; 120 TString fGitCommit; ///< Git commit SHA1 of built; 121 TString fGitBranch; ///< Git branch; 122 TString fGitDate; ///< Date and time when make was run; 123 Int_t fTimer; ///< Timer flag; 124 std::atomic<TApplication*> fApplication; ///< Pointer to current application; 125 TInterpreter *fInterpreter; ///< Command interpreter; 126 Bool_t fBatch; ///< True if session without graphics; 127 TString fWebDisplay; ///< If not empty it defines where web graphics should be rendered (cef, qt5, browser...); 128 Bool_t fIsWebDisplay; ///< True if session uses web widgets; 129 Bool_t fIsWebDis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:3661,detect,detected,3661,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['detect'],['detected']
Safety,"eads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(const Double_t* point, const Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:16380,safe,safe,16380,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['safe'],['safe']
Safety,"eam ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetVertex (Double_t *vertex) const;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:3957,avoid,avoid,3957,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,2,['avoid'],['avoid']
Safety,"eamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algori",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:2457,avoid,avoids,2457,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,3,['avoid'],['avoids']
Safety,"ean2(""mean2"", ""mean of gaussian 2"", 2.);; RooGaussian gauss2(""gauss2"", ""gaussian PDF2"", x, mean2, sigma);; ; // Create study manager with separate generation and fit model. This configuration; // is set up to generate biased fits as the fit and generator model have different means,; // and the mean parameter is limited to [-2., 1.8], so it just misses the optimal; // mean value of 2 in the data.; RooMCStudy *mcs2 = new RooMCStudy(gauss2, x, FitModel(gauss), Silence(), Binned());; ; // Add chi^2 calculator module to mcs; RooChi2MCSModule chi2mod2;; mcs2->addModule(chi2mod2);; ; // Generate 1000 samples of 1000 events; mcs2->generateAndFit(2000, 1000);; ; // Request a the pull plot of mean. The pulls will be one-sided because; // `mean` is limited to 1.8.; // Note that RooFit will have trouble to compute the pulls because the parameters; // are called `mean` in the fit, but `mean2` in the generator model. It is not obvious; // that these are related. RooFit will nevertheless compute pulls, but complain that; // this is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; TH1 *hist2_prob = mcs2->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist2_chi2->SetLineColor(kRed);; hist2_prob->SetLineColor(kRed);; ; TLegend leg;; leg.AddEntry(hist_chi2, ""Optimal fit"", ""L"");; leg.AddEntry(hist2_chi2, ""Biased fit"", ""L"");; leg.SetBorderSize(0);; leg.SetFillStyle(0);; ; TCanvas *c = new TCanvas(""rf802_mcstudy_addons"", ""rf802_mcstudy_addons"", 800, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; hist_chi2->GetYaxis()->SetTitleOffset(1.4);; hist_chi2->Draw();; hist2_chi2->Draw(""esame"");; leg.DrawClone();; c->cd(2);; gPad->SetLeftMargin(0.15);; hist_prob->GetYaxis()->SetTitleOffset(1.4);; hist_prob->Draw();; hist2_prob->Draw(""esame"");; c->cd(3);; pullMeanFrame->Draw();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html:3313,risk,risky,3313,doc/master/rf802__mcstudy__addons_8C.html,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html,1,['risk'],['risky']
Safety,"eap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// TObject destructor. Removes object from all canvases and object browsers; 162/// if observer bit is on and remove from the global object table.; 163 ; 164TObject::~TObject(); 165{; 166 // if (!TestBit(kNotDeleted)); 167 // Fatal(""~TObject"", ""object deleted twice"");; 168 ; 169 ROOT::CallRecursiveRemoveIfNeeded(*this);; 170 ; 171 fBits &= ~kNotDeleted;; 172 ; 173 if (fgObjectStat && gObjectTable) gObjectTable->RemoveQuietly(this);; 174}; 175 ; 176////////////////////////////////////////////////////////////////////////////////; 177/// Private helper function which will dispatch to; 178/// TObjectTable::AddObj.; 179/// Included here to avoid circular dependency between header files.; 180 ; 181void TObject::AddToTObjectTable(TObject *op); 182{; 183 TObjectTable::AddObj(op);; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Append graphics object to current pad. In case no current pad is set; 188/// yet, create a default canvas with the name ""c1"".; 189 ; 190void TObject::AppendPad(Option_t *option); 191{; 192 if (!gPad); 193 gROOT->MakeDefCanvas();; 194 ; 195 if (!gPad->IsEditable()); 196 return;; 197 ; 198 gPad->Add(this, option);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Browse object. May be overridden for another default action; 203 ; 204void TObject::Browse(TBrowser *b); 205{; 206 //Inspect();; 207 TClass::AutoBrowse(this,b);; 208}; 209 ; 210////////////////////////////////////////////////////////////////////////////////; 211/// Returns name of class to which the object belongs.; 212 ; 213const char *TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:6444,avoid,avoid,6444,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['avoid'],['avoid']
Safety,"earch. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeMulti. class TGeoVolumeMulti: public TGeoVolume. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:1108,avoid,avoid,1108,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,3,['avoid'],['avoid']
Safety,"eated via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUDPSocket.html:13216,timeout,timeout,13216,root/html532/TUDPSocket.html,https://root.cern,https://root.cern/root/html532/TUDPSocket.html,1,['timeout'],['timeout']
Safety,"eates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:27045,safe,safe,27045,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"eates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34272,safe,safe,34272,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safe']
Safety,"eates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34060,safe,safe,34060,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safe']
Safety,"ebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31390,timeout,timeout,31390,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"ebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:31779,timeout,timeout,31779,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"ecified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can configure this directly (default no) WebGui.WSLongpoll: no; Following parameter controls browser max-age caching parameter for files (default 3600) When 0 is specified, browser cache will be disabled WebGui.HttpMaxAge: 3600; Also one can provide extra URL options for, see TCivetweb::Create for list of supported options WebGui.HttpExtraArgs: winsymlinks=no; O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:8987,timeout,timeouts,8987,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['timeout'],['timeouts']
Safety,"ecified list. Returns the number of slaves the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Broadcast a raw buffer of specified length to all slaves in the; specified list. Returns the number of slaves the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile, TList* wrks); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Colle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:41624,timeout,timeout,41624,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['timeout'],['timeout']
Safety,"ecker.h. ◆ ShapeDistances(). void TGeoChecker::ShapeDistances ; (; TGeoShape * ; shape, . Int_t ; nsamples, . Option_t * ; option . ). Test TGeoShape::DistFromInside/Outside. ; Sample points inside the shape. Generate directions randomly in cos(theta). Compute d1 = DistFromInside and move the point on the boundary. Compute DistFromOutside and propagate with d2 making sure that the shape is not re-entered. Swap direction and call DistFromOutside that should fall back on the same point on the boundary (at d2). Propagate back on boundary then compute DistFromInside that should be bigger than d1. Plot d-(d1+d2) ; Definition at line 1771 of file TGeoChecker.cxx. ◆ ShapeNormal(). void TGeoChecker::ShapeNormal ; (; TGeoShape * ; shape, . Int_t ; nsamples, . Option_t * ; option . ). Check of validity of the normal for a given shape. ; Sample points inside the shape. Generate directions randomly in cos(theta) and propagate to boundary. Compute normal and safety at crossing point, plot the point and generate a random direction so that (dir) dot (norm) <0. ; Definition at line 2014 of file TGeoChecker.cxx. ◆ ShapeSafety(). void TGeoChecker::ShapeSafety ; (; TGeoShape * ; shape, . Int_t ; nsamples, . Option_t * ; option . ). Check of validity of safe distance for a given shape. ; Sample points inside the 2x bounding box and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety. ; Definition at line 1940 of file TGeoChecker.cxx. ◆ ShootRay(). Double_t * TGeoChecker::ShootRay ; (; Double_t * ; start, . Double_t ; dirx, . Double_t ; diry, . Double_t ; dirz, . Double_t * ; array, . Int_t & ; nelem, . Int_t & ; dim, . Double_t * ; endpoint = nullptr . ); const. Shoot one ray from start point with direction (dirx,diry,dirz). ; Fills input array with points just after boundary crossings. ; Definition at line 2614 of file TGeoChecker.cxx. ◆ Streamer(). void TGeoChecker::Streamer ; (; TBuffer & ; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:27469,safe,safety,27469,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"ect *obj)TObjectvirtual; RecvBuf(int sock, void *buffer, int length)TSystemvirtual; RecvRaw(int sock, void *buffer, int length, int flag)TSystemvirtual; RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)TSystemvirtual; RemoveFileHandler(TFileHandler *fh)TSystemvirtual; RemoveOnExit(TObject *obj)TSystem; RemoveSignalHandler(TSignalHandler *sh)TSystemvirtual; RemoveStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; RemoveTimer(TTimer *t)TSystemvirtual; Rename(const char *from, const char *to)TSystemvirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno()TSystemstatic; ResetSignal(ESignals sig, Bool_t reset=kTRUE)TSystemvirtual; ResetSignals()TSystemvirtual; ResetTimer(TTimer *)TSysteminlinevirtual; Run()TSystemvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; Select(TList *active, Long_t timeout)TSystemvirtual; Select(TFileHandler *fh, Long_t timeout)TSystemvirtual; SendBuf(int sock, const void *buffer, int length)TSystemvirtual; SendRaw(int sock, const void *buffer, int length, int flag)TSystemvirtual; SetAclicMode(EAclicMode mode)TSystemvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)TSystemvirtual; SetDisplay()TSystemvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetDynamicPath(const char *pathname)TSystemvirtual; Setenv(const char *name, const char *value)TSystemvirtual; SetErrorStr(const char *errstr)TSystem; SetFlagsDebug(const char *)TSystemvirtual; SetFlagsOpt(const char *)TSystemvirtual; SetFPEMask(Int_t mask=kDefaultMask)TSystemvirtual; SetIncludePath(const char *includePath)TSystemvirtual; SetLinkdefSuffix(const char *suffix)TSystemvirtual; SetLinkedLibs(const char *linkedLibs)TSystemvirtual; SetMakeExe(const char *directives)TSystemvirtual; SetMakeSharedLib(const char *directives)TSys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:13558,timeout,timeout,13558,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['timeout'],['timeout']
Safety,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8412,timeout,timeout,8412,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:8563,timeout,timeout,8563,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"ect to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsLValue; virtual ~RooAbsLValue ()=default;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void cleanup ();  Explicitly deletes the shared properties list on exit to avoid problems with the initialization order. ;  ; static const char * DeclFileName ();  ; static void printScientific (bool flag=false);  If true, contents of RooRealVars will be printed in scientific notation. ;  ; static void printSigDigits (Int_t ndig=5);  Set number of digits to show when printing RooRealVars. ;  ;  Static Public Member Functions inherited from RooAbsRealLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, const RooAbsBinning **bins);  Create a 1,2, or 3D-histogram with appropriate scale and labels. ;  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, double *xlo, double *xhi, Int_t *nBins);  Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:54789,avoid,avoid,54789,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['avoid'],['avoid']
Safety,"ect::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Atom_tfAcceptedActionaccepted and local actions; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotxhot point coordinates; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSourcelocal source and target; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPicpixmap used for the drag window; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSourcesource and target windows; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelistlists of DND types; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDND",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDNDManager.html:7963,timeout,timeout,7963,root/html602/TGDNDManager.html,https://root.cern,https://root.cern/root/html602/TGDNDManager.html,2,['timeout'],['timeout']
Safety,"ect::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl. ; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:16796,detect,detected,16796,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,2,['detect'],['detected']
Safety,"ect::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl. ; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TStringfGitBranchGit branch; TStringfGitCommitGit commit SHA1 of built; TStringfGitDateDate and time when make was run; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobals",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:17077,detect,detected,17077,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['detect'],['detected']
Safety,"ect::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveHit(); TEveHit(const TEveHit&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveHit.html:4813,detect,detector,4813,root/html602/TEveHit.html,https://root.cern,https://root.cern/root/html602/TEveHit.html,2,['detect'],['detector']
Safety,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignore, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). » Author: Nenad Buncic 18/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: THtml.h 27910 2009-03-21 17:26:55Z axel $ » Last generated: 2010-09-23 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml__TFileSysDB.html:6378,detect,detect,6378,root/html528/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html528/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignore, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). » Author: Nenad Buncic 18/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: THtml.h 27910 2009-03-21 17:26:55Z axel $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THtml__TFileSysDB.html:6449,detect,detect,6449,root/html530/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignore, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). » Author: Nenad Buncic 18/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: THtml.h 27910 2009-03-21 17:26:55Z axel $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THtml__TFileSysDB.html:6449,detect,detect,6449,root/html532/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html532/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"ect::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDeltaPhi; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Bool_tfRotateScene; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. void RotateScene(); ""Scene rotation"": either find a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLAutoRotator.html:7812,timeout,timeout,7812,root/html602/TGLAutoRotator.html,https://root.cern,https://root.cern/root/html602/TGLAutoRotator.html,2,['timeout'],['timeout']
Safety,"ectPtr TEveElement with external TObject as a holder of visualization data.; TEveEventManager Base class for event management and navigation.; TEveException Exception-type thrown by Eve classes.; TEveFrameBox Description of a 2D or 3D frame that can be used to visually group a set of objects.; TEveFrameBoxGL GL-renderer for TEveFrameBox class.; TEveGDoubleValuator Composite GUI element for selection of range (label, two number-entries and double-slider).; TEveGListTreeEditorFrame Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.; TEveGTriVecValuator Composite GUI element for setting three numerical values (label, three number-entries).; TEveGValuator Composite GUI element for single value selection (supports label, number-entry and slider).; TEveGValuatorBase Base class for composite GUI elements for setting of numeric values.; TEveGedEditor Specialization of TGedEditor for proper update propagation to TEveManager.; TEveGeoManagerHolder Exception-safe wrapper for temporary setting of gGeoManager variable.; TEveGeoNode Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.; TEveGeoNodeEditor Editor for TEveGeoNode class.; TEveGeoPolyShape A shape with arbitrary tesselation for visualization of CSG shapes.; TEveGeoShape Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).; TEveGeoShapeExtract Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.; TEveGeoTopNode Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.; TEveGeoTopNodeEditor Editor for TEveGeoTopNode class.; TEveGridStepper Provide discrete position coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:57023,safe,safe,57023,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['safe'],['safe']
Safety,"ectShape(). void TGeoHype::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoHype::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoHype.h. ◆ IsCylType(). Bool_t TGeoHype::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoHype.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoHype::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoHype & TGeoHype::operator= ; (; const TGeoHype & ; ). privatedelete . ◆ RadiusHypeSq(). Double_t TGeoHype::RadiusHypeSq ; (; Double_t ; z, . Bool_t ; inner . ); const. ◆ Safety(). Double_t TGeoHype::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoHype::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToHype(). Double_t TGeoHype::SafetyToHype ; (; const Double_t * ; point, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoHype::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoHype::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetHypeDimensions(). void TGeoHype::SetHypeDimensions ; (; Double_t ; rin, . Double_t ; stin, . Double_t ; rout, . Double_t ; stout, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoHype::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoHype::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoHype::SetSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:33352,safe,safe,33352,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['safe'],['safe']
Safety,"ectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TProofServ.h>. Inheritance diagram for TShutdownTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TShutdownTimer(). TShutdownTimer::TShutdownTimer ; (; TProofServ * ; p, . Int_t ; delay . ). Construtor. ; Definition at line 404 of file TProofServ.cxx. Member Function Documentation. ◆ Notify(). Bool_t TShutdownTimer::Notify ; (; ). overridevirtual . Handle expiration of the shutdown timer. ; In the case of low activity the process will be aborted. ; Implements TSysEvtHandler.; Definition at line 416 of file TProofServ.cxx. Member Data Documentation. ◆ fProofServ. TProofServ* TShutdownTimer::fProofServ. private . Definition at line 418 of file TProofServ.h. ◆ fTimeout. Int_t TShutdownTimer::fTimeout. private . Definition at line 419 of file TProofServ.h. proof/proof/inc/TProofServ.h; proof/proof/src/TProofServ.cxx. TShutdownTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTShutdownTimer.html:17684,abort,aborted,17684,doc/master/classTShutdownTimer.html,https://root.cern,https://root.cern/doc/master/classTShutdownTimer.html,1,['abort'],['aborted']
Safety,"ection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:13219,safe,safeDeleteList,13219,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,1,['safe'],['safeDeleteList']
Safety,"ectionMode to refine the calculation of correlations (e.g. restrict the calcuation to the signal distribution and/or exclude underflow and overflow bins). See the documentation of GetScanVariable() for details. Alternative scan variables may be defined by overriding the GetScanVariable() method. ; Automatic choice of scan range: if (tauMin,tauMax) do not correspond to a valid tau range (e.g. tauMin=tauMax=0.0) then the tau range is determined automatically. Use with care! ; Definition at line 1354 of file TUnfoldDensity.cxx. ◆ Streamer(). void TUnfoldDensity::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TUnfold. ◆ StreamerNVirtual(). void TUnfoldDensity::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 205 of file TUnfoldDensity.h. Member Data Documentation. ◆ fConstInputBins. const TUnfoldBinning* TUnfoldDensity::fConstInputBins. protected . binning scheme for the input (detector level) ; Definition at line 57 of file TUnfoldDensity.h. ◆ fConstOutputBins. const TUnfoldBinning* TUnfoldDensity::fConstOutputBins. protected . binning scheme for the output (truth level) ; Definition at line 55 of file TUnfoldDensity.h. ◆ fOwnedInputBins. TUnfoldBinning* TUnfoldDensity::fOwnedInputBins. protected . pointer to input binning scheme if owned by this class ; Definition at line 61 of file TUnfoldDensity.h. ◆ fOwnedOutputBins. TUnfoldBinning* TUnfoldDensity::fOwnedOutputBins. protected . pointer to output binning scheme if owned by this class ; Definition at line 59 of file TUnfoldDensity.h. ◆ fRegularisationConditions. TUnfoldBinning* TUnfoldDensity::fRegularisationConditions. protected . binning scheme for the regularisation conditions ; Definition at line 63 of file TUnfoldDensity.h. hist/unfold/inc/TUnfoldDensity.h; hist/unfold/src/TUnfoldDensity.cxx. TUnfoldDensity. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:42 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:70799,detect,detector,70799,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['detect'],['detector']
Safety,"ector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberInspector(); Construct a member inspector. ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void Inspect(TClass* cl, const char* parent, const char* name, const void* addr); Obsolete signature. void GenericShowMembers(const char* topClassName, const void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(const TObject& obj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. void InspectMember(const char* topclassname, const void* pobj, const char* name, Bool_t transient); Routine driving the visiting of the class information/data members. void InspectMember(TClass* cl, const void* pobj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. kUnset, // No Inspect(). TMemberInspector(const TMemberInspector& ). TMemberInspector & operator=(const TMemberInspector& ). EObjectPointerState GetObjectValidity() const; { return fObjectPointerState; }. void SetObjectValidity(TMemberInspector::EObjectPointerState val); { fObjectPointerState = val; }. obj. IsA(). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMemberInspector.html:3011,avoid,avoid,3011,root/html602/TMemberInspector.html,https://root.cern,https://root.cern/root/html602/TMemberInspector.html,2,['avoid'],['avoid']
Safety,"ectorNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1530; R__CreateValuestatic TGenCollectionProxy::Value * R__CreateValue(const std::string &name, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Utility routine to issue a Fatal error is the Value object is not valid.Definition TGenCollectionProxy.cxx:830; TGenCollectionProxy__StagingDeleteSingleIteratorsvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1589; TGenCollectionProxy__SlowCreateIteratorsvoid TGenCollectionProxy__SlowCreateIterators(void *, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1462; TGenCollectionProxy__SlowNextvoid * TGenCollectionProxy__SlowNext(void *iter, const void *end)Definition TGenCollectionProxy.cxx:1470; TGenCollectionProxy__VectorCreateIteratorsvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)We can safely assume that the std::vector layout does not really depend on the content!Definition TGenCollectionProxy.cxx:1509; TGenCollectionProxy__StagingCopyIteratorvoid * TGenCollectionProxy__StagingCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1580; TGenCollectionProxy__StagingNextvoid * TGenCollectionProxy__StagingNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1572; TGenCollectionProxy__VectorDeleteSingleIteratorsvoid TGenCollectionProxy__VectorDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1547; TGenCollectionProxy__SlowCopyIteratorvoid * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1484; TGenCollectionProxy__StagingCreateIteratorsvoid TGenCollectionProxy__StagingCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TGenCollectionProxy.cxx:1562; TGenC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:67208,safe,safely,67208,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['safe'],['safely']
Safety,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:24498,safe,safely,24498,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,12,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"ecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:10856,timeout,timeout,10856,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,1,['timeout'],['timeout']
Safety,"ed Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id: PDEFoamKernelGauss.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__PDEFoamKernelGauss.html:7336,avoid,avoid,7336,root/html532/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html532/TMVA__PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"ed Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id: PDEFoamKernelGauss.h 40020 2011-06-27 16:46:42Z stelzer $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamKernelGauss.html:7336,avoid,avoid,7336,root/html530/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"ed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:14723,safe,safe,14723,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety,"ed every time a new TTree is; attached. void TSelector::SlaveBegin(). Create e.g. histograms in this method.; This method is called (with or without PROOF) before looping on the; entries in the Tree. When using PROOF, this method is called on; each worker node.; void TSelector::Begin(). Mostly for backward compatibility; use; SlaveBegin() instead. Both methods are called before looping on the; entries in the Tree. When using PROOF, Begin() is called on the; client only. Bool_t TSelector::Notify(). This method is called at the first entry; of a new file in a chain. Bool_t TSelector::Process(Long64_t entry). This method is called; to process an entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; entry is selected histograms can be filled. Processing stops; when this function returns kFALSE. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected entries. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all entries. When using PROOF Terminate() is call on; the cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelector.html:1468,avoid,avoiding,1468,root/html532/TSelector.html,https://root.cern,https://root.cern/root/html532/TSelector.html,4,['avoid'],['avoiding']
Safety,"ed for binary Classifications where y = {+1,-1} for (sig,bkg) ; Definition at line 302 of file RuleFitParams.cxx. ◆ MakeGDPath(). void TMVA::RuleFitParams::MakeGDPath ; (; ). The following finds the gradient directed path in parameter space. ; More work is needed... FT, 24/9/2006; The algorithm is currently as follows (if not otherwise stated, the sample used below is [fPathIdx1,fPathIdx2]):. Set offset to -average(y(true)) and all coefs=0 => average of F(x)==0; FindGDTau() : start scanning using several paths defined by different tau choose the tau yielding the best path; start the scanning the chosen path; check error rate at a given frequency data used for check: [fPerfIdx1,fPerfIdx2]; stop when either of the following conditions are fullfilled:; loop index==fGDNPathSteps; error > fGDErrScale*errmin; only in DEBUG mode: risk is not monotonously decreasing. The algorithm will warn if:; the error rate was still decreasing when loop finished -> increase fGDNPathSteps!; minimum was found at an early stage -> decrease fGDPathStep; DEBUG: risk > previous risk -> entered chaotic region (regularization is too small) . Definition at line 538 of file RuleFitParams.cxx. ◆ MakeGradientVector(). void TMVA::RuleFitParams::MakeGradientVector ; (; ). protected . make gradient vector ; Definition at line 1375 of file RuleFitParams.cxx. ◆ MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:15415,risk,risk,15415,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,2,['risk'],['risk']
Safety,"ed on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files needed by your build tool (GNU make, Ninja, Visual Studio, etc) for building ROOT. The classic build with configure/make is is still available but it will not be evolving with the new features of ROOT.; We added full support for C++14.; Minor changes in the build system:. Renamed build option POSTGRESQL_LIBRARIES to POSTGRESQL_LIBRARY; Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the latest Mac OSX (El Capitan). Patch Releases; Release 6.06/02; Core. Make TListOfFunctions::Get thread-safe; Make TPluginManager thread-safe ROOT-7927; Properly handle the case of an executable with a space in its full pathname when search for linked in library. This fixes ROOT-8019. Dictionaries. Fix ROOT-7879: Prevent LinkDef files to be listed in a rootmap file and use (as the user actually expects) the header files #included in the linkdef file, if any, as the top level headers. Interpreter. Ignore access check when evaluating ROOT-7426. Meta Library; Add a new mode for TClass::SetCanSplit (2) which indicates that this class and any derived class should not be split. This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:24318,safe,safe,24318,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,2,['safe'],['safe']
Safety,"ed proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?; static TVirtualPacketizer::EUseEstOptkEstAverage; static TVirtualPacketizer::EUseEstOptkEstCurrent; static TVirtualPacketizer::EUseEstOptkEstOff. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPacketizer. ←. TPacketizer. TPacketizerAdaptive. TPacketizerFile. TPacketizerMulti. TPacketizerUnit. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. Int_t AddWorkers(TList* workers); Adds new workers. Must be implemented by each real packetizer properly.; Returns the number of workers added, or -1 on failure. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Int_t AssignWork(TDSet* , Long64_t , Long64_t ); { return -1; }. Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPacketizer.html:9863,abort,abort,9863,root/html602/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html602/TVirtualPacketizer.html,2,['abort'],['abort']
Safety,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:23379,timeout,timeout,23379,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:22995,timeout,timeout,22995,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22657,timeout,timeout,22657,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"ed to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:972791,safe,safety,972791,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"ed will be lost. ; Definition at line 153 of file TFileCacheWrite.cxx. ◆ Streamer(). void TFileCacheWrite::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileCacheWrite::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file TFileCacheWrite.h. ◆ WriteBuffer(). Int_t TFileCacheWrite::WriteBuffer ; (; const char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Write buffer at position pos in the write buffer. ; The function returns 1 if the buffer has been successfully entered into the write buffer. The function returns 0 in case WriteBuffer() was recusively called via Flush(). The function returns -1 in case of error. ; Definition at line 121 of file TFileCacheWrite.cxx. Member Data Documentation. ◆ fBuffer. char* TFileCacheWrite::fBuffer. protected . [fBufferSize] buffer of contiguous prefetched blocks ; Definition at line 26 of file TFileCacheWrite.h. ◆ fBufferSize. Int_t TFileCacheWrite::fBufferSize. protected . Allocated size of fBuffer. ; Definition at line 23 of file TFileCacheWrite.h. ◆ fFile. TFile* TFileCacheWrite::fFile. protected . Pointer to file. ; Definition at line 25 of file TFileCacheWrite.h. ◆ fNtot. Int_t TFileCacheWrite::fNtot. protected . Total size of cached blocks. ; Definition at line 24 of file TFileCacheWrite.h. ◆ fRecursive. Bool_t TFileCacheWrite::fRecursive. protected . flag to avoid recursive calls ; Definition at line 27 of file TFileCacheWrite.h. ◆ fSeekStart. Long64_t TFileCacheWrite::fSeekStart. protected . Seek value of first block in cache. ; Definition at line 22 of file TFileCacheWrite.h. Libraries for TFileCacheWrite:. [legend]; The documentation for this class was generated from the following files:; io/io/inc/TFileCacheWrite.h; io/io/src/TFileCacheWrite.cxx. TFileCacheWrite. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:15827,avoid,avoid,15827,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['avoid'],['avoid']
Safety,"ed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); Bool_tPing(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidRemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tSendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidSendUrgent(Int_t type, Int_t int1, Int_t int2); voidSetAWait(Bool_t w = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:6415,timeout,timeout,6415,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,1,['timeout'],['timeout']
Safety,"ed. Returns -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4508 of file TUnixSystem.cxx. ◆ UnixResetSignal(). void TUnixSystem::UnixResetSignal ; (; ESignals ; sig). staticprotected . Restore old signal handler for specified signal. ; Definition at line 3821 of file TUnixSystem.cxx. ◆ UnixResetSignals(). void TUnixSystem::UnixResetSignals ; (; ). staticprotected . Restore old signal handlers. ; Definition at line 3836 of file TUnixSystem.cxx. ◆ UnixSelect(). int TUnixSystem::UnixSelect ; (; Int_t ; nfds, . TFdSet * ; readready, . TFdSet * ; writeready, . Long_t ; timeout . ). staticprotected . Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ; Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of file TUnixSystem.cxx. ◆ UnixSigAlarmInterruptsSyscalls(). void TUnixSystem::UnixSigAlarmInterruptsSyscalls ; (; Bool_t ; set). staticprotected . When the argument is true the SIGALRM signal handler is set so that interrupted sys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:75030,timeout,timeout,75030,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"edded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:9230,avoid,avoid,9230,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['avoid'],['avoid']
Safety,"ee ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:88772,recover,recover,88772,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recover']
Safety,"ee TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:19942,safe,safe,19942,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['safe'],['safe']
Safety,"ee) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 85 of file TXMLFile.h. ◆ ReadFromFile(). Bool_t TXMLFile::ReadFromFile ; (; ). protected . read document from file Now full content of document reads into the memory Then document decomposed to separate keys and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:66509,recover,recover,66509,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recover']
Safety,"een y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j W is obtained as from TProfile::GetBinEntries(ibin) This errors corresponds to the standard deviation of weighted mean where each measurement Y is uncorrelated and has an error sigma, which is expressed in the weight used to fill the Profile: w = 1/sigma^2 The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ). In the case of Profile filled weights and with TProfile::Sumw2() called, STD(Y) is the standard deviation of the weighted sample Y and N is in this case the number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); If a bin has N data points all with the same value Y (especially possible when dealing with integers), the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. To avoid this problem one can use an approximation for the standard deviation S(Y), by using the average of all the S(Y) of the other Profile bins. To use this approximation one must call before TProfile::Approximate This approximation applies only for the default and the 's' options ; Definition at line 227 of file TProfile.cxx. ◆ Class(). static TClass * TProfile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProfile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProfile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 138 of file TProfile.h. ◆ Copy(). void TProfile::Copy ; (; TObject & ; hnew); const. overridevirtual . Copy a Profile histogram to a new profile histogram. ; Reimplemented from TH1D.; Definition at line 423 of file TProfile.cxx. ◆ DeclFileName(). static const char * TProfile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:66132,avoid,avoid,66132,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['avoid'],['avoid']
Safety,"eepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fBeta1;  The Beta1 constant used by the optimizer. ;  ; Scalar_t fBeta2;  The Beta2 constant used by the optimizer. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentBiases;  The decaying average of the first moment of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentWeights;  The decaying average of the first moment of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fSecondMomentBiases;  The decaying average of the second moment of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fSecondMomentWeights;  The decaying average of the second moment of the past weight gradients associated with the deep net. ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:3042,avoid,avoid,3042,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['avoid'],['avoid']
Safety,"eepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; std::vector< std::vector< Matrix_t > > fBiasUpdates;  The accumulation of the past Biases for performing updates. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWeightUpdates;  The accumulation of the past Weights for performing updates. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:3094,avoid,avoid,3094,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['avoid'],['avoid']
Safety,"efault constructor definition that can not be compiled due; 866 // to the template parameter]; 867 if (valcl) {; 868 Bool_t wantBuild = kTRUE;; 869 if (valcl->Property() & kIsAbstract) wantBuild = kFALSE;; 870 if ( (isTransient); 871 && (dmclass->GetCollectionProxy()->GetProperties() & TVirtualCollectionProxy::kIsEmulated); 872 && (!valcl->IsLoaded()) ) {; 873 // Case where the collection dictionary was not requested and; 874 // the content's dictionary was also not requested.; 875 // [This is a super set of what we need, but we can't really detect it :(]; 876 wantBuild = kFALSE;; 877 }; 878 ; 879 if (wantBuild) valcl->BuildRealData(nullptr, isTransient);; 880 }; 881 } else {; 882 void* addrForRecursion = nullptr;; 883 if (GetObjectValidity() == kValidObjectGiven); 884 addrForRecursion = const_cast<void*>(add);; 885 ; 886 dmclass->BuildRealData(addrForRecursion, isTransient);; 887 }; 888 }; 889 }; 890 }; 891 fRealDataClass->GetListOfRealData()->Add(rd);; 892 }; 893}; 894 ; 895//______________________________________________________________________________; 896//______________________________________________________________________________; 897//______________________________________________________________________________; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900 ; 901class TAutoInspector : public TMemberInspector {; 902public:; 903 Int_t fCount;; 904 TBrowser *fBrowser;; 905 ; 906 TAutoInspector(TBrowser *b); 907 {; 908 // main constructor.; 909 fBrowser = b; fCount = 0;; 910 }; 911 virtual ~TAutoInspector() {}; 912 using TMemberInspector::Inspect;; 913 void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) override;; 914 Bool_t IsTreatingNonAccessibleTypes() override { return kFALSE; }; 915};; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// This method is called from ShowMembers() via AutoBrowse().; 919 ; 920void TAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:30575,detect,detect,30575,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['detect'],['detect']
Safety,"efault constructor definition that can not be compiled due; 933 // to the template parameter]; 934 if (valcl) {; 935 Bool_t wantBuild = kTRUE;; 936 if (valcl->Property() & kIsAbstract) wantBuild = kFALSE;; 937 if ( (isTransient); 938 && (dmclass->GetCollectionProxy()->GetProperties() & TVirtualCollectionProxy::kIsEmulated); 939 && (!valcl->IsLoaded()) ) {; 940 // Case where the collection dictionary was not requested and; 941 // the content's dictionary was also not requested.; 942 // [This is a super set of what we need, but we can't really detect it :(]; 943 wantBuild = kFALSE;; 944 }; 945 ; 946 if (wantBuild) valcl->BuildRealData(nullptr, isTransient);; 947 }; 948 } else {; 949 void* addrForRecursion = nullptr;; 950 if (GetObjectValidity() == kValidObjectGiven); 951 addrForRecursion = const_cast<void*>(add);; 952 ; 953 dmclass->BuildRealData(addrForRecursion, isTransient);; 954 }; 955 }; 956 }; 957 }; 958 fRealDataClass->GetListOfRealData()->Add(rd);; 959 }; 960}; 961 ; 962//______________________________________________________________________________; 963//______________________________________________________________________________; 964//______________________________________________________________________________; 965 ; 966////////////////////////////////////////////////////////////////////////////////; 967 ; 968class TAutoInspector : public TMemberInspector {; 969public:; 970 Int_t fCount;; 971 TBrowser *fBrowser;; 972 ; 973 TAutoInspector(TBrowser *b); 974 {; 975 // main constructor.; 976 fBrowser = b; fCount = 0;; 977 }; 978 virtual ~TAutoInspector() {}; 979 using TMemberInspector::Inspect;; 980 void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) override;; 981 Bool_t IsTreatingNonAccessibleTypes() override { return kFALSE; }; 982};; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This method is called from ShowMembers() via AutoBrowse().; 986 ; 987void TAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:33259,detect,detect,33259,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['detect'],['detect']
Safety,"efaultCanvasSize;; 565 ; 566 fDISPLAY = ""$DISPLAY"";; 567 fUpdating = kFALSE;; 568 fRetained = kTRUE;; 569 fSelected = nullptr;; 570 fClickSelected = nullptr;; 571 fSelectedX = 0;; 572 fSelectedY = 0;; 573 fSelectedPad = nullptr;; 574 fClickSelectedPad= nullptr;; 575 fPadSave = nullptr;; 576 fEvent = -1;; 577 fEventX = -1;; 578 fEventY = -1;; 579 fContextMenu = nullptr;; 580 fDrawn = kFALSE;; 581 fUpdated = kFALSE;; 582}; 583 ; 584////////////////////////////////////////////////////////////////////////////////; 585/// Build a canvas. Called by all constructors.; 586 ; 587void TCanvas::Build(); 588{; 589 // Get window identifier; 590 if (fCanvasID == -1 && fCanvasImp); 591 fCanvasID = fCanvasImp->InitWindow();; 592 if (fCanvasID == -1) return;; 593 ; 594 if (fCw !=0 && fCh !=0) {; 595 if (fCw < fCh) fXsizeReal = fYsizeReal*Float_t(fCw)/Float_t(fCh);; 596 else fYsizeReal = fXsizeReal*Float_t(fCh)/Float_t(fCw);; 597 }; 598 ; 599 // Set Pad parameters; 600 gPad = this;; 601 fCanvas = this;; 602 fMother = (TPad*)gPad;; 603 ; 604 if (IsBatch()) {; 605 // Make sure that batch interactive canvas sizes are the same; 606 fCw -= 4;; 607 fCh -= 28;; 608 } else if (IsWeb()) {; 609 // mark canvas as batch - avoid gVirtualX in many places; 610 SetBatch(kTRUE);; 611 } else {; 612 //normal mode with a screen window; 613 // Set default physical canvas attributes; 614 //Should be done via gVirtualX, not via fPainter (at least now). No changes here.; 615 gVirtualX->SelectWindow(fCanvasID);; 616 gVirtualX->SetFillColor(1); //Set color index for fill area; 617 gVirtualX->SetLineColor(1); //Set color index for lines; 618 gVirtualX->SetMarkerColor(1); //Set color index for markers; 619 gVirtualX->SetTextColor(1); //Set color index for text; 620 // Clear workstation; 621 gVirtualX->ClearWindow();; 622 ; 623 // Set Double Buffer on by default; 624 SetDoubleBuffer(1);; 625 ; 626 // Get effective window parameters (with borders and menubar); 627 fCanvasImp->GetWindowGeometry(fWindowTopX, fWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:19575,avoid,avoid,19575,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety,"efaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:224881,timeout,timeout,224881,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['timeout'],['timeout']
Safety,"eference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_RSofieReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:1018,predict,predict,1018,doc/master/TMVA__SOFIE__RSofieReader_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html,1,['predict'],['predict']
Safety,"efined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:598995,abort,abort,598995,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:599028,abort,abort,599028,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"efinition at line 105 of file TGeoHalfSpace.cxx. ◆ DistFromInside(). Double_t TGeoHalfSpace::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 113 of file TGeoHalfSpace.cxx. ◆ DistFromInside_v(). void TGeoHalfSpace::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 269 of file TGeoHalfSpace.cxx. ◆ DistFromOutside(). Double_t TGeoHalfSpace::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 142 of file TGeoHalfSpace.cxx. ◆ DistFromOutside_v(). void TGeoHalfSpace::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 279 of file TGeoHalfSpace.cxx. ◆ Divide(). TGeoVolume * TGeoHalfSpace::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Divide the shape along one axis. ; Reimplemented from TGeoBBox.; Definition at line 171 of file TGeoHalfSpace.cxx. ◆ GetBoundingCylinder(). void TGeoHalfSpace::GetBoundingCylinder ; (; Double_t * ; ); const. inlineoverridevirtual . Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:28065,safe,safe,28065,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety,"efinition at line 159 of file TSlave.h. ◆ SetSessionTag(). void TSlave::SetSessionTag ; (; const char * ; st). inline . Definition at line 161 of file TSlave.h. ◆ SetSocket(). void TSlave::SetSocket ; (; TSocket * ; s). inlineprotected . Definition at line 112 of file TSlave.h. ◆ SetStatus(). virtual void TSlave::SetStatus ; (; Int_t ; st). inlineprotectedvirtual . Definition at line 113 of file TSlave.h. ◆ SetTXSlaveHook(). void TSlave::SetTXSlaveHook ; (; TSlave_t ; xslavehook). static . Set hook to TXSlave ctor. ; Definition at line 665 of file TSlave.cxx. ◆ SetupServ(). Int_t TSlave::SetupServ ; (; Int_t ; stype, . const char * ; conffile . ). virtual . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Reimplemented in TSlaveLite.; Definition at line 178 of file TSlave.cxx. ◆ StopProcess(). void TSlave::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout . ). protectedvirtual . Sent stop/abort request to PROOF server. ; Definition at line 629 of file TSlave.cxx. ◆ Streamer(). void TSlave::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TSlaveLite. ◆ StreamerNVirtual(). void TSlave::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 167 of file TSlave.h. ◆ Touch(). virtual void TSlave::Touch ; (; ). inlinevirtual . Definition at line 165 of file TSlave.h. Friends And Related Symbol Documentation. ◆ TProof. friend class TProof. friend . Definition at line 48 of file TSlave.h. ◆ TProofLite. friend class TProofLite. friend . Definition at line 49 of file TSlave.h. ◆ TSlaveLite. friend class TSlaveLite. friend . Definition at line 50 of file TSlave.h. ◆ TXSlave. friend class TXSlave. friend . Definition at line 51 of file TSlave.h. Member Data Documentation. ◆ fArchComp. TString TSlave::fArchComp. protected . Definition at line 102 of file TSlave.h. ◆ fBytesR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:23695,abort,abort,23695,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['abort'],['abort']
Safety,"eflex. For backward compatibility with the previous versions of ROOT, where all classes were in the global namespace, we have by default using namespace ROOT; in all headers. However, this can be turned off by defining the USE_ROOT_NAMESPACE macro.; Using comments to document the code; ROOT chose Doxygen for its code documentation: please refer to this how-to for all the details.; Source file layout; Each source file, header or implementation file starts with a module identification line and an author line, e.g.:; / @(#)root/net / Author: Fons Rademakers 18/12/96 ; Where in the module identification line the file package is described by root/package, in this case the net package.; Header file layout; Each header file has the following layout:. Module identification line; Author line; Copyright notice; Mulitple inclusion protection macro; Headers file includes; Forward declarations; Actual class definition. For a typical example see TObject.h.; Note the explicit checks to avoid unnecessarily opening already included header files. For large systems this kind of defensive measures can make quite a difference in compile time. Also never include a header file when a forward declaration is enough. On include header files for base classes or classes that are used by value in the class definition.; Implementation file layout; Each implementation file has the following layout:. Module identification line; Author line; Copyright notice; Class description comments (see above); Header file includes; Actual method implementation. For a typical example see TObject.cxx.; Note the mandatory method separator line:; ////////////////////////////////////////; exactly 80 characters long.; Preferred Coding Style; Here we describe our preferred coding style. Coding style is very personal and we don't want to force our views on anybody. But for any contributions to the ROOT system that we have to maintain we would like you to follow our coding style.; Indentation; To be able to keep as muc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:5775,avoid,avoid,5775,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['avoid'],['avoid']
Safety,"eforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning “step approved”. The default value for stepmax is TGeoShape::Bigwith the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary. According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big() ; The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1026916,safe,safe,1026916,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"egative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28333,detect,detected,28333,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['detect'],['detected']
Safety,"egin, ItTarget itTargetEnd);  ; template<bool HasDropOut, typename ItSource , typename ItWeight , typename ItTarget , typename ItDrop > ; void applyWeights (ItSource itSourceBegin, ItSource itSourceEnd, ItWeight itWeight, ItTarget itTargetBegin, ItTarget itTargetEnd, ItDrop itDrop);  apply weights using drop-out; for no drop out, provide (&bool = true) to itDrop such that *itDrop becomes ""true"" ;  ; template<typename ItSource , typename ItWeight , typename ItPrev > ; void applyWeightsBackwards (ItSource itCurrBegin, ItSource itCurrEnd, ItWeight itWeight, ItPrev itPrevBegin, ItPrev itPrevEnd);  ; template<bool HasDropOut, typename ItSource , typename ItWeight , typename ItPrev , typename ItDrop > ; void applyWeightsBackwards (ItSource itCurrBegin, ItSource itCurrEnd, ItWeight itWeight, ItPrev itPrevBegin, ItPrev itPrevEnd, ItDrop itDrop);  apply weights backwards (for backprop); for no drop out, provide (&bool = true) to itDrop such that *itDrop becomes ""true"" ;  ; template<typename LAYERDATA > ; void backward (LAYERDATA &prevLayerData, LAYERDATA &currLayerData);  backward application of the weights (back-propagation of the error) ;  ; template<EnumRegularization Regularization> ; double computeRegularization (double weight, const double &factorWeightDecay);  compute the regularization (L1, L2) ;  ; template<> ; double computeRegularization< EnumRegularization::L1 > (double weight, const double &factorWeightDecay);  ; template<> ; double computeRegularization< EnumRegularization::L2 > (double weight, const double &factorWeightDecay);  ; template<typename ItProbability , typename ItTruth , typename ItDelta , typename ItInvActFnc > ; double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc, double patternWeight);  cross entropy error function ;  ; void cudaError (cudaError_t code, const char *file, int line, bool abort=true);  Function to check cuda return code.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:9329,abort,abort,9329,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['abort'],['abort']
Safety,"eights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedvirtual . Update the weights, given the current weight gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 152 of file RMSProp.h. Member Data Documentation. ◆ fBiasUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fBiasUpdates. protected . The accumulation of the past Biases for performing updates. ; Definition at line 60 of file RMSProp.h. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 53 of file RMSProp.h. ◆ fMomentum. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fMomentum. protected . The momentum used for training. ; Definition at line 51 of file RMSProp.h. ◆ fPastSquaredBiasGradients. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredBiasGradients. protected . The sum of the square of the past bias gradients associated with the deep net. ; Definition at line 57 of file RMSProp.h. ◆ fPastSquaredWeightGradients. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:11435,avoid,avoid,11435,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['avoid'],['avoid']
Safety,"eimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoGtra::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoGtra::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetTwistAngle(). Double_t TGeoGtra::GetTwistAngle ; (; ); const. inline . Definition at line 171 of file TGeoArb8.h. ◆ IsA(). TClass * TGeoGtra::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 177 of file TGeoArb8.h. ◆ Safety(). Double_t TGeoGtra::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Safety_v(). void TGeoGtra::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ SavePrimitive(). void TGeoGtra::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoArb8. ◆ SetDimensions(). void TGeoGtra::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoArb8. ◆ Streamer(). void TGeoGtra::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoArb8. ◆ StreamerNVirtual(). void TGeoGtra::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 177 of file TGeoArb8.h. Member Data Documentation. ◆ fTwistAngle. Double_t TGeoGtra::fTwistAngle. protected . Definition at line 152 of file TGeoArb8.h. Libraries for TGeoGtra:. [legend]; The documentation for this class was generated from the following file:; geom/geom/inc/TGeoArb8.h. TGeoGtra. RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:30199,safe,safe,30199,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety,"eimplemented from TGeoBBox.; Definition at line 191 of file TGeoHalfSpace.cxx. ◆ IsA(). TClass * TGeoHalfSpace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoHalfSpace.h. ◆ IsCylType(). Bool_t TGeoHalfSpace::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoHalfSpace.h. ◆ operator=(). TGeoHalfSpace & TGeoHalfSpace::operator= ; (; const TGeoHalfSpace & ; ). privatedelete . ◆ Safety(). Double_t TGeoHalfSpace::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 202 of file TGeoHalfSpace.cxx. ◆ Safety_v(). void TGeoHalfSpace::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 291 of file TGeoHalfSpace.cxx. ◆ SavePrimitive(). void TGeoHalfSpace::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 215 of file TGeoHalfSpace.cxx. ◆ SetDimensions(). void TGeoHalfSpace::SetDimensions ; (; Double_t * ; param). overridevirtual . Set half-space parameters as stored in an array. ; Reimplemented from TGeoBBox.; Definition at line 234 of file TGeoHalfSpace.cxx. ◆ SetPoints() [1/2]. void TGeoHalfSpace::SetPoints ; (; Double_t * ; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 62 of file TGeoHalfSpace.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:31212,safe,safe,31212,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety,"eimplemented in TUnixSystem, TWinNTSystem, and TWebSystem.; Definition at line 558 of file TSystem.h. ◆ IsAbsoluteFileName(). Bool_t TSystem::IsAbsoluteFileName ; (; const char * ; dir). virtual . Return true if dir is an absolute pathname. ; Reimplemented in TWinNTSystem.; Definition at line 951 of file TSystem.cxx. ◆ IsFileInIncludePath(). Bool_t TSystem::IsFileInIncludePath ; (; const char * ; name, . char ** ; fullpath = nullptr . ). virtual . Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ; If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]), it will be striped off 'name'. If fullpath is != 0, the full path to the file is returned in *fullpath, which must be deleted by the caller. ; Definition at line 966 of file TSystem.cxx. ◆ IsPathLocal(). Bool_t TSystem::IsPathLocal ; (; const char * ; path). virtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, and TNetXNGSystem.; Definition at line 1305 of file TSystem.cxx. ◆ Link(). int TSystem::Link ; (; const char * ; from, . const char * ; to . ). virtual . Create a link from file1 to file2. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1359 of file TSystem.cxx. ◆ ListLibraries(). void TSystem::ListLibraries ; (; const char * ; regexp = """"). virtual . List the loaded shared libraries. ; regexp is a regular expression allowing to filter the list.; Examples:; The following line lists all the libraries currently loaded: gSystem->ListLibraries(); TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; The following line lists all the libraries currently loaded having ""RIO"" in their names: gSystem->ListLibraries("".*RIO.*""). Reimplemented in TUnixSystem.; Definition at line 2085 of file TSystem.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:71710,avoid,avoid,71710,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['avoid'],['avoid']
Safety,"ekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, date, time);; 1671 if (!forComp) {; 1672 if (objlen != nbytes - keylen) {; 1673 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1674 Printf(""%d/%06d At:%-*lld N=%-8d %-14s CX = %5.2f %s"", date, time, nDigits + 1, idcur, nbytes, classname,; 1675 cx, extrainfo.Data());; 1676 } else {; 1677 Printf(""%d/%06d At:%-*lld N=%-8d %-14s %s"", date, time, nDigits + 1, idcur, nbytes, classname, extrainfo.Data());; 1678 }; 1679 } else {; 1680 // Printing to help compare two files.; 1681 if (objlen != nbytes - keylen) {; 1682 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1683 Printf(""At:%-*lld N=%-8d K=%-3d O=%-8d %-14s CX = %5.2f %s"", nDigits+1, idcur, nbytes, keylen, objlen, classname, cx, extrainfo.Data());; 1684 } else {; 1685 Printf(""At:%-*lld N=%-8d K=%-3d O=%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:60734,avoid,avoid,60734,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"el assigned to each bin and a bin width of 1. More...;  ; class  RBitsetField;  Template specializations for C++ std::bitset. More...;  ; class  RCanvas;  A window's topmost RPad. More...;  ; class  RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  RCanvasPainter;  Implementation of painter for ROOT::Experimental::RCanvas, using RWebWindow. More...;  ; class  RCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection sizes. More...;  ; class  RChangeAttrRequest;  ; class  RClassField;  The field for a class with dictionary. More...;  ; class  RClusterDescriptor;  Meta-data for a set of ntuple clusters. More...;  ; class  RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  RClusterIndex;  Addresses a column element or field item relative to a particular cluster, instead of a global NTupleSize_t index. More...;  ; struct  RClusterSize;  Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t. More...;  ; class  RColor;  The color class. More...;  ; class  RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  RColumnSwitch;  Holds the index and the tag of a kSwitch column. More...;  ; class  RDirectory;  Key/value store of objects. More...;  ; class  RDirectoryTypeMismatch;  Objects of this class are thrown to signal that the value known under the given name . More...;  ; class  RDirectoryUnknownKey;  Objects of this class are thrown to signal that no key with that name exists. More...;  ; class  RDisplayHistStat;  Object send to client for display of RHistStat, required to avoid sending histogram to the client. More...;  ; class  RDisplayItem;  Base class for painting data for JS. More...;  ; class  RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:3859,avoid,avoid,3859,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['avoid'],['avoid']
Safety,"el branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The split level is decreased by 1 every time a new collection is found. For example if list is a TObjArray*. If splitlevel = 1, one top level branch is created for each element of the TObjArray.; If splitlevel = 2, one top level branch is created for each array element. If one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:550540,avoid,avoid,550540,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"el""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:3490,safe,safe,3490,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,1,['safe'],['safe']
Safety,"eleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_ARGS Int_t WriteTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 284 {; 285 void *x = (void *)(((char *)addr) + config->fOffset);; 286 TMemberStreamer *pstreamer = config->fCompInfo->fStreamer;; 287 UInt_t pos = buf.WriteVersion(config->fInfo->IsA(), kTRUE);; 288 (*pstreamer)(buf, x, config->fCompInfo->fLength);; 289 buf.SetByteCount(pos, kTRUE);; 290 return 0;; 291 }; 292 ; 293 INLINE_TEMPLATE_ARGS Int_t ReadTextObject(TBuffer &buf, void *addr, const TConfiguration *config); 294 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:9953,avoid,avoid,9953,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"else {; 2339 // recalculate the statistics; 2340 h2->ResetStats();; 2341 }; 2342 ; 2343 if (resetEntries) {; 2344 // use the effective entries for the entries; 2345 // since this is the only way to estimate them; 2346 Double_t entries = h2->GetEffectiveEntries();; 2347 if (!computeErrors) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2348 h2->SetEntries( entries );; 2349 }; 2350 else {; 2351 h2->SetEntries( fEntries );; 2352 }; 2353 ; 2354 ; 2355 return h2;; 2356}; 2357 ; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Project a 3-d histogram into 1 or 2-d histograms depending on the; 2361/// option parameter, which may contain a combination of the characters x,y,z,e; 2362/// - option = ""x"" return the x projection into a TH1D histogram; 2363/// - option = ""y"" return the y projection into a TH1D histogram; 2364/// - option = ""z"" return the z projection into a TH1D histogram; 2365/// - option = ""xy"" return the x versus y projection into a TH2D histogram; 2366/// - option = ""yx"" return the y versus x projection into a TH2D histogram; 2367/// - option = ""xz"" return the x versus z projection into a TH2D histogram; 2368/// - option = ""zx"" return the z versus x projection into a TH2D histogram; 2369/// - option = ""yz"" return the y versus z projection into a TH2D histogram; 2370/// - option = ""zy"" return the z versus y projection into a TH2D histogram; 2371///; 2372/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2373///; 2374/// option = ""o"" original axis range of the target axes will be; 2375/// kept, but only bins inside the selected range will be filled.; 2376///; 2377/// If option contains the string ""e"", errors are computed; 2378///; 2379/// The projection is made for the selected bins only.; 2380/// To select a bin range along an axis, use TAxis::SetRange, eg; 2381/// h3.GetYaxis()->SetRange(23,56);; 2382///; 2383/// NOTE 1: The generated histogram is named th3name + opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:92549,avoid,avoid,92549,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch. Make sure your \(\mbox{FCN}\) uses internally the same precision as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on postive–definiteness. Other mathematical problems which can arise are: excessive numerical roundoff — be especially careful of exponential and factorial functions which get big very quickly and lose accuracy; starting too far from the solution — the function may have unphysical local minima, especially at infinity in some variables; incorrect normalization — in likelihood functions, the probability distributions must be normalized or at least have an integral which is independent of the values of the variable parameters.; A bug in M . This is unlikely, but it happens. If a bug is suspected, and all other possible causes can be eliminated, please try to save a copy of the input and output files, listin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:79163,detect,detects,79163,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['detect'],['detects']
Safety,"ely on ROOT_INCLUDE_PATH only at runtime to find headers. Interpreter Library. Resolve memory hoarding in some case of looking up functions ROOT-8145. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file ROOT-8055.; Repaired the automatic conversion on read back into an STL collection of a on file object of a class that was inheriting from the STL collection. Meta. Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name ROOT-7972.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048; Fix a problem reading ROOT pcm files using gcc 6 optimized build ROOT-8097; Fix the detection of inheritance from an STL collection of an emulated class. Core. Reduce memory consumption (autoparsing) of plugins TXNetSystem/TNetXNGSystem and TGQt. Minuit. Improve thread safety of TMinuit constructor and destructor ROOT-7992. Bug fixes. ROOT-6923 - Memory leak with circular TTree; ROOT-7593 - Memory leak TROOT::RegisterModule; ROOT-7867 - memprobe script is broken when using CMake; ROOT-7992 - Destructor of TMinuit is not thread safe; ROOT-8048 - ShortTypes doesn’t always strip default stdlib template args; ROOT-8055 - File corruption after TTree deletion; ROOT-8066 - problems creating dictionaries in pyROOT; ROOT-8067 - Source code tree left “polluted” with “interpreter/llvm/src/utils/llvm-build/llvmbuild/*.pyc; ROOT-8068 - Fix file flags for bin/setxrd.* bin/thisroot.*; ROOT-8097 - null pointer dereference in TProtoClass::FillTClass with gcc6 build; ROOT-8117 - Particle in TPDGCode.h but not in TDatabasePDG; ROOT-8145 - TMethodCall::InitWithPrototype keeps accumulating memory on successive calls; ROOT-8149 - Memory leak in TList I/O. Release 6.06/06; Released on July 6, 2016; Cling. Properly handle try-catch functions. ROOT-8034; Fix handling of template parameter pack ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:30047,safe,safety,30047,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safety']
Safety,"em. ; Leaf fields contain just data, collection fields resolve to offset columns, record fields have no materialization on the primitive column layer. . EnumeratorkLeaf ; kCollection ; kRecord ; kVariant ; kReference ; kInvalid . Definition at line 38 of file RNTupleUtil.hxx. Function Documentation. ◆ Add(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT_TO, template< int D_, class P_ > class... STAT_FROM> . void ROOT::Experimental::Add ; (; RHist< DIMENSIONS, PRECISION, STAT_TO... > & ; to, . const RHist< DIMENSIONS, PRECISION, STAT_FROM... > & ; from . ). Add two histograms. ; This operation may currently only be performed if the two histograms have the same axis configuration, use the same precision, and if from records at least the same statistics as to (recording more stats is fine).; Adding histograms with incompatible axis binning will be reported at runtime with an std::runtime_error. Insufficient statistics in the source histogram will be detected at compile-time and result in a compiler error.; In the future, we may either adopt a more relaxed definition of histogram addition or provide a mechanism to convert from one histogram type to another. We currently favor the latter path. ; Definition at line 342 of file RHist.hxx. ◆ CanMap(). ROOT::Experimental::EAxisCompatibility ROOT::Experimental::CanMap ; (; const RAxisEquidistant & ; target, . const RAxisEquidistant & ; source . ). noexcept . Whether (and how) the source axis can be merged into the target axis. ; Definition at line 126 of file RAxis.cxx. ◆ FitPanelLog(). ROOT::Experimental::RLogChannel & ROOT::Experimental::FitPanelLog ; (; ). Log channel for FitPanel diagnostics. ; Definition at line 22 of file RFitPanelModel.cxx. ◆ FitTo(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT> . RFitResult ROOT::Experimental::FitTo ; (; const RHist< DIMENSIONS, PRECISION, STAT... > & ; hist, . const RFunction< DIMENSIONS > & ; func, . st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:42761,detect,detected,42761,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['detect'],['detected']
Safety,"embly.cxx. ◆ DistFromInside(). Double_t TGeoShapeAssembly::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from inside point to surface of the hyperboloid. ; Reimplemented from TGeoBBox.; Definition at line 251 of file TGeoShapeAssembly.cxx. ◆ DistFromInside_v(). void TGeoShapeAssembly::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 595 of file TGeoShapeAssembly.cxx. ◆ DistFromOutside(). Double_t TGeoShapeAssembly::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from outside point to surface of the hyperboloid. ; fVolume->SetNextNodeIndex(-1); ; Reimplemented from TGeoBBox.; Definition at line 262 of file TGeoShapeAssembly.cxx. ◆ DistFromOutside_v(). void TGeoShapeAssembly::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 605 of file TGeoShapeAssembly.cxx. ◆ Divide(). TGeoVolume * TGeoShapeAssembly::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Cannot divide assemblies. ; Reimplemented from TGeoBBox.; Definition at line 434 of file TGeoShapeAssembly.cxx. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoShapeAssembly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:27329,safe,safe,27329,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"ement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 241 buf >> *x;; 242 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_ARGS Int_t WriteTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 284 {; 285 void *x = (void *)(((char *)addr) + config->fOffset);; 286 TMemberStreamer *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:9620,avoid,avoid,9620,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ement->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 3529 } else {; 3530 if (element->GetArrayLength() <= 1) {; 3531 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3532 else fprintf(file,"" , "");; 3533 if (R__IsUniquePtr(element)) {; 3534 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s.release() )\n"",element->GetName(),protoname.Data(),element->GetName());; 3535 } else {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:143628,risk,risk,143628,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,"['avoid', 'risk']","['avoid', 'risk']"
Safety,"ement.; 439 fType = 1;; 440 TClass* clOfElement = element->GetClassPointer();; 441 Int_t nbranches = fBranches.GetEntriesFast();; 442 // Note: The following code results in base class branches; 443 // having two different cases for what their parent; 444 // class will be, this is very annoying. It is also; 445 // very annoying that the naming conventions for the; 446 // sub-branch names are different as well.; 447 if (!strcmp(name, clOfElement->GetName())) {; 448 // -- If the branch's name is the same as the base class name,; 449 // which happens when we are a child branch of a top-level; 450 // branch whose name does not end in a dot and also has no; 451 // internal dots, elide the branch name, and keep the branch; 452 // hierarchy rooted at the ultimate parent, this keeps the base; 453 // class part of the branch name from propagating downwards.; 454 // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; 455 // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.; 456 Unroll("""", fBranchClass.GetClass(), clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 457 SetReadLeavesPtr();; 458 SetFillLeavesPtr();; 459 return;; 460 }; 461 // If the branch's name is not the same as the base class name,; 462 // keep the branch name as a prefix (i.e., continue the branch; 463 // hierarchy), but start a new class hierarchy at the base class.; 464 //; 465 // Note: If the parent branch was created by the branch constructor; 466 // which takes a folder as a parameter, then this case will; 467 // be used, because the branch name will be the same as the; 468 // parent branch name.; 469 // Note: This means that the sub-branches of a base class branch; 470 // created by TTree::Bronch() have the base class name as; 471 // as part of the branch name, while those created by; 472 // Unroll() do not, ouch!!!; 473 //; 474 Unroll(name, clOfElement, clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 475 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:15892,detect,detection,15892,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['detect'],['detection']
Safety,"emented from TBufferFile.; Definition at line 152 of file TBufferSQL.cxx. ◆ WriteChar(). void TBufferSQL::WriteChar ; (; Char_t ; c). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 162 of file TBufferSQL.cxx. ◆ WriteCharP(). void TBufferSQL::WriteCharP ; (; const Char_t * ; c). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 415 of file TBufferSQL.cxx. ◆ WriteCharStar(). void TBufferSQL::WriteCharStar ; (; char * ; s). finalvirtual . Write a char* string. ; Reimplemented from TBufferFile.; Definition at line 344 of file TBufferSQL.cxx. ◆ WriteDouble(). void TBufferSQL::WriteDouble ; (; Double_t ; d). finalvirtual . Operator<<. ; Reimplemented from TBufferFile.; Definition at line 212 of file TBufferSQL.cxx. ◆ WriteFastArray() [1/15]. void TBufferSQL::WriteFastArray ; (; const bool * ; b, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 427 of file TBufferSQL.cxx. ◆ WriteFastArray() [2/15]. void TBufferSQL::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 447 of file TBufferSQL.cxx. ◆ WriteFastArray() [3/15]. void TBufferSQL::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:50744,abort,aborts,50744,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,"emory and directory structure itself.; 641/// if option is ""slow"", iterate through the containers in a way to can handle; 642/// 'external' modification (induced by recursions); 643/// if option is ""nodelete"", write the TDirectory but do not delete the contained; 644/// objects.; 645void TDirectory::Close(Option_t *option); 646{; 647 if (!fList) {; 648 return;; 649 }; 650 ; 651 // Save the directory key list and header; 652 Save();; 653 ; 654 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 655 ; 656 if (!nodelete) {; 657 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 658 if (!slow) {; 659 // Check if it is wise to use the fast deletion path.; 660 TObjLink *lnk = fList->FirstLink();; 661 while (lnk) {; 662 if (lnk->GetObject()->IsA() == TDirectory::Class()) {; 663 slow = kTRUE;; 664 break;; 665 }; 666 lnk = lnk->Next();; 667 }; 668 }; 669 ; 670 // Delete objects from directory list, this in turn, recursively closes all; 671 // sub-directories (that were allocated on the heap); 672 // if this dir contains subdirs, we must use the slow option for Delete!; 673 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 674 // with a large number of objects (eg >10^5) would take for ever.; 675 if (slow) fList->Delete(""slow"");; 676 else fList->Delete();; 677 }; 678 ; 679 TDirectory::CleanTargets();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Delete all objects from memory.; 684 ; 685void TDirectory::DeleteAll(Option_t *); 686{; 687 fList->Delete(""slow"");; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Delete Objects or/and keys in a directory.; 692///; 693/// - namecycle has the format name;cycle; 694/// - namecycle = """" same as namecycle =""T*""; 695/// - name = * means all; 696/// - cycle = * means all cycles (memory and keys); 697/// - cycle = """" or cycle = 9999 ==> apply to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:23439,avoid,avoid,23439,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"emove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGeoNavigator(); TGeoNavigator(TGeoManager* geom); voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:8261,safe,safe,8261,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,2,['safe'],['safe']
Safety,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:15231,timeout,timeout,15231,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,6,['timeout'],['timeout']
Safety,"en < vec->len) ? vec->ptr[len] : '\0';; 14885 so->is_ssl = (ch == 's');; 14886 so->ssl_redir = (ch == 'r');; 14887 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14888 return 1;; 14889 }; 14890 }; 14891 ; 14892 /* Reset ip_version to 0 if there is an error */; 14893 *ip_version = 0;; 14894 return 0;; 14895}; 14896 ; 14897 ; 14898/* Is there any SSL port in use? */; 14899static int; 14900is_ssl_port_used(const char *ports); 14901{; 14902 if (ports) {; 14903 /* There are several different allowed syntax variants:; 14904 * - ""80"" for a single port using every network interface; 14905 * - ""localhost:80"" for a single port using only localhost; 14906 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14907 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14908 * to IPv4 localhost, one to IPv6 localhost; 14909 * - ""+80"" use port 80 for IPv4 and IPv6; 14910 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14911 * for both: IPv4 and IPv4; 14912 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14913 * additionally port 8080 bound to localhost connections; 14914 *; 14915 * If we just look for 's' anywhere in the string, ""localhost:80""; 14916 * will be detected as SSL (false positive).; 14917 * Looking for 's' after a digit may cause false positives in; 14918 * ""my24service:8080"".; 14919 * Looking from 's' backward if there are only ':' and numbers; 14920 * before will not work for ""24service:8080"" (non SSL, port 8080); 14921 * or ""24s"" (SSL, port 24).; 14922 *; 14923 * Remark: Initially hostnames were not allowed to start with a; 14924 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14925 * Section 2.1).; 14926 *; 14927 * To get this correct, the entire string must be parsed as a whole,; 14928 * reading it as a list element for element and parsing with an; 14929 * algorithm equivalent to parse_port_string.; 14930 *; 14931 * In fact, we use local interface names here, not arbitrary; 14932 * hos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:441457,detect,detected,441457,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['detect'],['detected']
Safety,"en < vec->len) ? vec->ptr[len] : '\0';; 14886 so->is_ssl = (ch == 's');; 14887 so->ssl_redir = (ch == 'r');; 14888 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14889 return 1;; 14890 }; 14891 }; 14892 ; 14893 /* Reset ip_version to 0 if there is an error */; 14894 *ip_version = 0;; 14895 return 0;; 14896}; 14897 ; 14898 ; 14899/* Is there any SSL port in use? */; 14900static int; 14901is_ssl_port_used(const char *ports); 14902{; 14903 if (ports) {; 14904 /* There are several different allowed syntax variants:; 14905 * - ""80"" for a single port using every network interface; 14906 * - ""localhost:80"" for a single port using only localhost; 14907 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14908 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14909 * to IPv4 localhost, one to IPv6 localhost; 14910 * - ""+80"" use port 80 for IPv4 and IPv6; 14911 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14912 * for both: IPv4 and IPv4; 14913 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14914 * additionally port 8080 bound to localhost connections; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:441490,detect,detected,441490,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['detect'],['detected']
Safety,"en extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:86162,safe,safety,86162,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"en on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree heade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:88896,recover,recovered,88896,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety,"en speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:54134,safe,safer,54134,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['safe'],['safer']
Safety,"en successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 2630 of file TWinNTSystem.cxx. ◆ ResetSignal(). void TWinNTSystem::ResetSignal ; (; ESignals ; sig, . Bool_t ; reset = kTRUE . ). overridevirtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 1425 of file TWinNTSystem.cxx. ◆ ResetSignals(). void TWinNTSystem::ResetSignals ; (; ). overridevirtual . Reset signals handlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 1433 of file TWinNTSystem.cxx. ◆ Select() [1/2]. Int_t TWinNTSystem::Select ; (; TFileHandler * ; h, . Long_t ; to . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4628 of file TWinNTSystem.cxx. ◆ Select() [2/2]. Int_t TWinNTSystem::Select ; (; TList * ; active, . Long_t ; timeout . ). overridevirtual . Select on file descriptors. The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4591 of file TWinNTSystem.cxx. ◆ SendBuf(). int TWinNTSystem::SendBuf ; (; int ; sock, . const void * ; buf, . int ; length . ). overridevirtual . Send a buffer headed by a length indicator. ; Returns length of sent buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 4945 of file TWinNTSystem.cxx. ◆ SendRaw(). int TWinNTSystem::SendRaw ; (; int ; sock, . const void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 5010 of file TWinNTSystem.cxx. ◆ SetDynamicPath(). void TWinNTSystem::SetDynamicPath",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:68648,timeout,timeout,68648,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"ences for citation; 2211 gTools().TMVACitation(Log(), Tools::kHtmlLink);; 2212}; 2213 ; 2214////////////////////////////////////////////////////////////////////////////////; 2215/// Evaluate Variable Importance; 2216 ; 2217TH1F *TMVA::Factory::EvaluateImportance(DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle,; 2218 const char *theOption); 2219{; 2220 fModelPersistence = kFALSE;; 2221 fSilentFile = kTRUE; // we need silent file here because we need fast classification results; 2222 ; 2223 // getting number of variables and variable names from loader; 2224 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2225 if (vitype == VIType::kShort); 2226 return EvaluateImportanceShort(loader, theMethod, methodTitle, theOption);; 2227 else if (vitype == VIType::kAll); 2228 return EvaluateImportanceAll(loader, theMethod, methodTitle, theOption);; 2229 else if (vitype == VIType::kRandom) {; 2230 if ( nbits > 10 && nbits < 30) {; 2231 // limit nbits to less than 30 to avoid error converting from double to uint and also cannot deal with too many combinations; 2232 return EvaluateImportanceRandom(loader, static_cast<UInt_t>( pow(2, nbits) ), theMethod, methodTitle, theOption);; 2233 } else if (nbits < 10) {; 2234 Log() << kERROR << ""Error in Variable Importance: Random mode require more that 10 variables in the dataset.""; 2235 << Endl;; 2236 } else if (nbits > 30) {; 2237 Log() << kERROR << ""Error in Variable Importance: Number of variables is too large for Random mode""; 2238 << Endl;; 2239 }; 2240 }; 2241 return nullptr;; 2242}; 2243 ; 2244////////////////////////////////////////////////////////////////////////////////; 2245 ; 2246TH1F *TMVA::Factory::EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle,; 2247 const char *theOption); 2248{; 2249 ; 2250 uint64_t x = 0;; 2251 uint64_t y = 0;; 2252 ; 2253 // getting number of variables and variable names from loader; 2254 const int nbits = loader->GetDataSetInfo(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:94141,avoid,avoid,94141,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"enerates various kind of axis.; ; void gaxis(){; auto c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; ; auto axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"""");; axis1->Draw();; ; auto axis2 = new TGaxis(-4.5,0.2,5.5,0.2,0.001,10000,510,""G"");; axis2->Draw();; ; auto axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"""");; axis3->SetTitle(""axis3"");; axis3->SetTitleOffset(0.5);; axis3->Draw();; ; auto axis4 = new TGaxis(-7,-0.8,-7,0.8,1,10000,50510,""G"");; axis4->SetTitle(""axis4"");; axis4->Draw();; ; auto axis5 = new TGaxis(-4.5,-0.6,5.5,-0.6,1.2,1.32,80506,""-+"");; axis5->SetLabelSize(0.03);; axis5->SetTextFont(72);; axis5->Draw();; ; auto axis6 = new TGaxis(-4.5,0.5,5.5,0.5,100,900,50510,""-"");; axis6->Draw();; ; auto axis7 = new TGaxis(-5.5,0.85,5.5,0.85,0,4.3e-6,510,"""");; axis7->Draw();; ; auto axis8 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis8->Draw();; ; // One can make a vertical axis going top->bottom. However the two x values should be; // slightly different to avoid labels overlapping.; auto axis9 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis9->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; c1return c1Definition legend1.C:41; . Definition with a function; Instead of the wmin,wmax arguments of the normal definition, the name of a TF1 function can be specified. This function will be used to map the user coordinates to the axis values and ticks.; A TGaxis is defined the following way: TGaxis::TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; const char *func, Int_t ndiv, Option_t *chopt,; Double_t gridlength); Where:. xmin : X origin coordinate in user's coordinates space.; xmax : X end axis coordinate in user's coordinates space.; ymin : Y origin coordinate in user's coordinates space.; ymax : Y end axis coordinate in user's coordinates space.; func : function defining axis labels and tick marks.; ndiv : Number of divisions.; ndiv=N1 + 100*N2 + 10000*N3; N1=number of 1st divisions.; N2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:3814,avoid,avoid,3814,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['avoid'],['avoid']
Safety,"ensor = deepNet.GetLayerAt(0)->GetBiases();; 1647 for (size_t l = 0; l < weights_tensor.size(); ++l); 1648 weights_tensor[l].Print();; 1649 bias_tensor[0].Print();; 1650 }; 1651 ; 1652 }; 1653 ; 1654 trainingPhase++;; 1655 } // end loop on training Phase; 1656}; 1657 ; 1658////////////////////////////////////////////////////////////////////////////////; 1659void MethodDL::Train(); 1660{; 1661 if (fInteractive) {; 1662 Log() << kFATAL << ""Not implemented yet"" << Endl;; 1663 return;; 1664 }; 1665 ; 1666 // using for training same scalar type defined for the prediction; 1667 if (this->GetArchitectureString() == ""GPU"") {; 1668#ifdef R__HAS_TMVAGPU; 1669 Log() << kINFO << ""Start of deep neural network training on GPU."" << Endl << Endl;; 1670#ifdef R__HAS_CUDNN; 1671 TrainDeepNet<DNN::TCudnn<ScalarImpl_t> >();; 1672#else; 1673 TrainDeepNet<DNN::TCuda<ScalarImpl_t>>();; 1674#endif; 1675#else; 1676 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 1677 ""you have CUDA installed and it was successfully ""; 1678 ""detected by CMAKE.""; 1679 << Endl;; 1680 return;; 1681#endif; 1682 } else if (this->GetArchitectureString() == ""CPU"") {; 1683#ifdef R__HAS_TMVACPU; 1684 // note that number of threads used for BLAS might be different; 1685 // e.g use openblas_set_num_threads(num_threads) for OPENBLAS backend; 1686 Log() << kINFO << ""Start of deep neural network training on CPU using MT, nthreads = ""; 1687 << gConfig().GetNCpu() << Endl << Endl;; 1688#else; 1689 Log() << kINFO << ""Start of deep neural network training on single thread CPU (without ROOT-MT support) "" << Endl; 1690 << Endl;; 1691#endif; 1692 TrainDeepNet<DNN::TCpu<ScalarImpl_t> >();; 1693 return;; 1694 }; 1695 else {; 1696 Log() << kFATAL << this->GetArchitectureString() <<; 1697 "" is not a supported architecture for TMVA::MethodDL""; 1698 << Endl;; 1699 }; 1700 ; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704void TMVA::MethodDL::FillInputTensor(); 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:66454,detect,detected,66454,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['detect'],['detected']
Safety,"ent 1 in signal"", 0.8, 0.0, 1.0); sigsum = ROOT.RooAddPdf(""sigsum"", ""sig+sig2"", [sig, sig2], [sig1frac]); ; # Construct a customizer utility to customize model; cust = ROOT.RooCustomizer(model, ""cust""); ; # Instruct the customizer to replace node 'sig' with node 'sigsum'; cust.replaceArg(sig, sigsum); ; # Build a clone of the input pdf according to the above customization; # instructions. Each node that requires modified is clone so that the; # original pdf remained untouched. The name of each cloned node is that; # of the original node suffixed by the name of the customizer object; #; # The returned head node own all nodes that were cloned as part of; # the build process so when cust_clone is deleted so will all other; # nodes that were created in the process.; cust_clone = cust.build(ROOT.kTRUE); ROOT.SetOwnership(cust_clone, True); ; # Print structure of clone of model with sig.sigsum replacement.; cust_clone.Print(""t""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; 1) 0x8241e40 RooRealVar:: x = 5 L(0 - 10) ""x""; 1) 0x847fc10 RooRealVar:: a0 = 0.5 L(0 - 1) ""a0""; 2) 0x84f2330 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x87f3060 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x8782390 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x8926120 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x82654f0 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ef2000 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x8a01230 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x898ff20 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x891da50 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4) 0x8948240 RooExponential:: bkg2[ x=x c=alpha ] = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8py.html:4266,safe,safe,4266,doc/master/rf207__comptools_8py.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html,1,['safe'],['safe']
Safety,"ent block.; Depending on its needs, the function is free to choose whether to; analyze all data or just the newly arrived data. If TERMINATOR; returns 0, it means that the terminator has not been seen.; Otherwise it should return a pointer to the character immediately; following the terminator. The idea is to be able to read a line of input, or otherwise a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. TWebFile(); { }. » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TWebFile.h 34712 2010-08-03 09:27:19Z rdm $ » Last generated: 2010-09-26 20:32; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:30142,safe,safely,30142,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,1,['safe'],['safely']
Safety,"ent block.; Depending on its needs, the function is free to choose whether to; analyze all data or just the newly arrived data. If TERMINATOR; returns 0, it means that the terminator has not been seen.; Otherwise it should return a pointer to the character immediately; following the terminator. The idea is to be able to read a line of input, or otherwise a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. TWebFile(); { }. » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TWebFile.h 34712 2010-08-03 09:27:19Z rdm $ » Last generated: 2011-07-04 15:39; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TWebFile.html:30396,safe,safely,30396,root/html530/TWebFile.html,https://root.cern,https://root.cern/root/html530/TWebFile.html,1,['safe'],['safely']
Safety,"ent block.; Depending on its needs, the function is free to choose whether to; analyze all data or just the newly arrived data. If TERMINATOR; returns 0, it means that the terminator has not been seen.; Otherwise it should return a pointer to the character immediately; following the terminator. The idea is to be able to read a line of input, or otherwise a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. TWebFile(); { }. » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TWebFile.h 40671 2011-08-23 12:18:37Z rdm $ » Last generated: 2011-12-02 14:29; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:30930,safe,safely,30930,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,1,['safe'],['safely']
Safety,"ent block.; Depending on its needs, the function is free to choose whether to; analyze all data or just the newly arrived data. If TERMINATOR; returns 0, it means that the terminator has not been seen.; Otherwise it should return a pointer to the character immediately; following the terminator. The idea is to be able to read a line of input, or otherwise a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. void ProcessHttpHeader(const TString& headerLine); Process the HTTP header in the argument. This method is intended to be; overwritten by subclasses that exploit the information contained in the; HTTP headers. TWebFile(); { }. TWebFile(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:32307,safe,safely,32307,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['safe'],['safely']
Safety,"ent block.; Depending on its needs, the function is free to choose whether to; analyze all data or just the newly arrived data. If TERMINATOR; returns 0, it means that the terminator has not been seen.; Otherwise it should return a pointer to the character immediately; following the terminator. The idea is to be able to read a line of input, or otherwise a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. void ProcessHttpHeader(const TString& headerLine); Process the HTTP header in the argument. This method is intended to be; overwritten by subclasses that exploit the information contained in the; HTTP headers. TWebFile(); { }. » Author: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TWebFile.html:31271,safe,safely,31271,root/html534/TWebFile.html,https://root.cern,https://root.cern/root/html534/TWebFile.html,1,['safe'],['safely']
Safety,"ent cannot be split if the corresponding class member has; the special characters ""||"" as the first characters in the; comment field. TClass * GetClassPointer() const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to Streamer function for this element. void Streamer(TBuffer& b); Stream an object of class TStreamerElement. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. TStreamerElement(const TStreamerElement& ). TStreamerElement& operator=(const TStreamerElement& ). Int_t GetArrayDim() const; {return fArrayDim;}. Int_t GetArrayLength() const; {return fArrayLength;}. TClass * GetClass() const; {return GetClassPointer();}. const char * GetInclude() const; {return """";}. Int_t GetMaxI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerElement.html:9265,detect,detected,9265,root/html528/TStreamerElement.html,https://root.cern,https://root.cern/root/html528/TStreamerElement.html,3,['detect'],['detected']
Safety,"ent event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop; ; // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Performance considerations; To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible. For instance, Filter(""x > 0"") requires just-in-time compilation of the corresponding C++ logic, while the equivalent Filter([](float x) { return x > 0.; }, {""x""}) does not. Similarly, Histo1D(""x"") requires just-in-time compilation after the type of x is retrieved from the dataset, while Histo1D<float>(""x"") does not; the latter spelling should be preferred for performance-critical applications.; Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See Efficient analysis in Python for possible ways to speed up hot paths in this case.; Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:49356,avoid,avoid,49356,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['avoid'],['avoid']
Safety,"ent location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:132151,safe,safe,132151,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safe']
Safety,ent node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:11235,safe,safety,11235,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,8,['safe'],"['safe', 'safety']"
Safety,"entDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TFile.h>. Inheritance diagram for TFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkStartBigFile . Definition at line 200 of file TFile.h. ◆ EAsyncOpenStatus. enum TFile::EAsyncOpenStatus. Asynchronous open request status. . EnumeratorkAOSNotAsync ; kAOSFailure ; kAOSInProgress ; kAOSSuccess . Definition at line 64 of file TFile.h. ◆ ECacheAction. enum TFile::ECacheAction. TTreeCache flushing semantics. . EnumeratorkDisconnect ; kDoNotDisconnect . Definition at line 70 of file TFile.h. ◆ EFileType. enum TFile::EFileType. File type. . EnumeratorkDefault ; kLocal ; kNet ; kWeb ; kFile ; kMerge . Definition at line 202 of file TFile.h. ◆ EOpenTimeOut. enum TFile::EOpenTimeOut. Open timeout constants. . EnumeratorkInstantTimeout ; kEternalTimeout . Definition at line 67 of file TFile.h. ◆ ERelativeTo. enum TFile::ERelativeTo. EnumeratorkBeg ; kCur ; kEnd . Definition at line 199 of file TFile.h. ◆ EStatusBits. enum TFile::EStatusBits. TFile status bits. BIT(13) is taken up by TObject. . Enumeratork630forwardCompatibility ; kRecovered ; kHasReferences ; kDevNull ; kWriteError ; kBinaryFile ; kRedirected ; kReproducible . Definition at line 183 of file TFile.h. Constructor & Destructor Documentation. ◆ TFile() [1/3]. TFile::TFile ; (; const TFile & ; ). privatedelete . ◆ TFile() [2/3]. TFile::TFile ; (; ). File default Constructor. ; Definition at line 201 of file TFile.cxx. ◆ TFile() [3/3]. TFile::TFile ; (; const char * ; fname1, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Opens or creates a local ROOT file. ; Parameters. [in]fname1The name of the file ; [in]optionSpecifies",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:46511,timeout,timeout,46511,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"entation. ◆ All(). constexpr bool ROOT::Internal::VecOps::All ; (; const bool * ; vals, . std::size_t ; size . ). constexpr . Definition at line 79 of file RVec.hxx. ◆ GetVectorsSize(). template<typename... T> . std::size_t ROOT::Internal::VecOps::GetVectorsSize ; (; const std::string & ; id, . const RVec< T > &... ; vs . ). Definition at line 88 of file RVec.hxx. ◆ MapFromTuple(). template<typename Tuple_t , std::size_t... Is> . auto ROOT::Internal::VecOps::MapFromTuple ; (; Tuple_t && ; t, . std::index_sequence< Is... > ;  . ); -> decltype(MapImpl(std::get<std::tuple_size<Tuple_t>::value - 1>(t), std::get<Is>(t)...)). Definition at line 117 of file RVec.hxx. ◆ MapImpl(). template<typename F , typename... RVecs> . auto ROOT::Internal::VecOps::MapImpl ; (; F && ; f, . RVecs &&... ; vs . ); -> RVec<decltype(f(vs[0]...))>. Definition at line 105 of file RVec.hxx. ◆ NextPowerOf2(). uint64_t ROOT::Internal::VecOps::NextPowerOf2 ; (; uint64_t ; A). inline . Return the next power of two (in 64-bits) that is strictly greater than A. ; Return zero on overflow. ; Definition at line 126 of file RVec.hxx. ◆ ResetView(). template<typename T > . void ROOT::Internal::VecOps::ResetView ; (; RVec< T > & ; v, . T * ; addr, . std::size_t ; sz . ). An unsafe function to reset the buffer for which this RVec is acting as a view. ; NoteThis is a low-level method that must be called on RVecs that are already non-owning:; it does not put the RVec in ""non-owning mode"" (fCapacity == -1); it does not free any owned buffer . Definition at line 546 of file RVec.hxx. ◆ UninitializedValueConstruct(). template<typename ForwardIt > . void ROOT::Internal::VecOps::UninitializedValueConstruct ; (; ForwardIt ; first, . ForwardIt ; last . ). Definition at line 530 of file RVec.hxx. ◆ void(). template<typename T , bool TriviallyCopyable> . ROOT::Internal::VecOps::void ; (; off ; ). ROOTInternalVecOps. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html:3883,unsafe,unsafe,3883,doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,1,['unsafe'],['unsafe']
Safety,"entities at the end of the process.; Resolved several memory leaks. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. Interpreter Library. Resolve memory hoarding in some case of looking up functions ROOT-8145. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file ROOT-8055.; Repaired the automatic conversion on read back into an STL collection of a on file object of a class that was inheriting from the STL collection. Meta. Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name ROOT-7972.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048; Fix a problem reading ROOT pcm files using gcc 6 optimized build ROOT-8097; Fix the detection of inheritance from an STL collection of an emulated class. Core. Reduce memory consumption (autoparsing) of plugins TXNetSystem/TNetXNGSystem and TGQt. Minuit. Improve thread safety of TMinuit constructor and destructor ROOT-7992. Bug fixes. ROOT-6923 - Memory leak with circular TTree; ROOT-7593 - Memory leak TROOT::RegisterModule; ROOT-7867 - memprobe script is broken when using CMake; ROOT-7992 - Destructor of TMinuit is not thread safe; ROOT-8048 - ShortTypes doesn’t always strip default stdlib template args; ROOT-8055 - File corruption after TTree deletion; ROOT-8066 - problems creating dictionaries in pyROOT; ROOT-8067 - Source code tree left “polluted” with “interpreter/llvm/src/utils/llvm-build/llvmbuild/*.pyc; ROOT-8068 - Fix file flags for bin/setxrd.* bin/thisroot.*; ROOT-8097 - null pointer dereference in TProtoClass::FillTClass with gcc6 build; ROOT-8117 - Particle in TPDGCode.h but not in TDatabasePDG; ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:29861,detect,detection,29861,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['detect'],['detection']
Safety,"entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:84750,safe,safe,84750,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['safe'],['safe']
Safety,"entry);`; 74*/; 75 ; 76#include ""TROOT.h""; 77#include ""TSystem.h""; 78#include ""TTree.h""; 79#include ""TError.h""; 80#include ""TSelector.h""; 81#include ""TClass.h""; 82#include ""TInterpreter.h""; 83 ; 84ClassImp(TSelector);; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4486,abort,aborted,4486,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,2,['abort'],['aborted']
Safety,"entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:46229,avoid,avoid,46229,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['avoid'],['avoid']
Safety,"entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:44857,avoid,avoid,44857,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['avoid'],['avoid']
Safety,"eoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoSubtraction::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 203 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoSubtraction::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1031 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoSubtraction::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1039 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoSubtraction::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1072 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoSubtraction::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 193 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoSubtraction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 203 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoSubtraction::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 875 of file TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:17086,safe,safe,17086,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safe']
Safety,"eoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:1970,safe,safe,1970,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,1,['safe'],['safe']
Safety,"eoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr);  Constructor providing left and right shapes and matrices (in the Boolean operation). ;  ;  ~TGeoBoolNode () override;  Destructor. ;  ; void ClearThreadData () const;  ; virtual void ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)=0;  ; virtual void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm)=0;  ; virtual Bool_t Contains (const Double_t *point) const =0;  ; void CreateThreadData (Int_t nthreads);  Create thread data for n threads max. ;  ; virtual Int_t DistanceToPrimitive (Int_t px, Int_t py)=0;  ; virtual Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const =0;  ; virtual Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const =0;  ; virtual EGeoBoolType GetBooleanOperator () const =0;  ; TGeoMatrix * GetLeftMatrix () const;  ; TGeoShape * GetLeftShape () const;  ; virtual Int_t GetNpoints ()=0;  ; TGeoMatrix * GetRightMatrix () const;  ; TGeoShape * GetRightShape () const;  ; ThreadData_t & GetThreadData () const;  ; TClass * IsA () const override;  ; virtual TGeoBoolNode * MakeClone () const =0;  ; void Paint (Option_t *option) override;  Special schema for feeding the 3D buffers to the painter client. ;  ; void RegisterMatrices ();  Register all matrices of the boolean node and descendents. ;  ; Bool_t ReplaceMatrix (TGeoMatrix *mat, TGeoMatrix *newmat);  Replace one of the matrices. ;  ; virtual Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const =0;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; virtual void SetPoints (Double_t *points) const;  Fill buffer with shape vertices. ;  ; virtual void SetPoints (Float_t *points) const;  Fill buffer with shape vertices. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:3114,safe,safe,3114,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,2,['safe'],['safe']
Safety,"eoShape. ◆ DeclFileName(). static const char * TGeoXtru::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file TGeoXtru.h. ◆ DefinePolygon(). Bool_t TGeoXtru::DefinePolygon ; (; Int_t ; nvert, . const Double_t * ; xv, . const Double_t * ; yv . ). ◆ DefineSection(). virtual void TGeoXtru::DefineSection ; (; Int_t ; snum, . Double_t ; z, . Double_t ; x0 = 0., . Double_t ; y0 = 0., . Double_t ; scale = 1. . ). virtual . ◆ DistancetoPrimitive(). Int_t TGeoXtru::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoXtru::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoXtru::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoXtru::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoXtru::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToPlane(). Double_t TGeoXtru::DistToPlane ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iz, . Int_t ; ivert, . Double_t ; stepmax, . Bool_t ; in . ); const. protected . ◆ D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:26205,safe,safe,26205,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['safe'],['safe']
Safety,"eoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTubeSeg::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:3269,safe,safe,3269,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['safe'],['safe']
Safety,"eoXtru, and TGeoVGShape. ◆ DistFromInside_v(). void TGeoBBox::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ DistFromOutside() [1/2]. static Double_t TGeoBBox::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . const Double_t * ; origin, . Double_t ; stepmax = TGeoShape::Big() . ). static . ◆ DistFromOutside() [2/2]. Double_t TGeoBBox::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromOutside_v(). void TGeoBBox::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ Divide(). TGeoVolume * TGeoBBox::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iax",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:27788,safe,safe,27788,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['safe'],['safe']
Safety,"eoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TStreamerLoop, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAnyPointer, TStreamerString, TStreamerSTL, and TStreamerSTLstring.; Definition at line 146 of file TStreamerElement.h. ◆ IsaPointer(). virtual Bool_t TStreamerElement::IsaPointer ; (; ); const. inlinevirtual . Reimplemented in TStreamerBasicPointer, TStreamerLoop, TStreamerObjectPointer, TStreamerObjectAnyPointer, and TStreamerSTL.; Definition at line 128 of file TStreamerElement.h. ◆ IsBase(). Bool_t TStreamerElement::IsBase ; (; ); const. virtual . Return kTRUE if the element represent a base class. ; Reimplemented in TStreamerBase, and TStreamerSTL.; Definition at line 431 of file TStreamerElement.cxx. ◆ IsOldFormat(). Bool_t TStreamerElement::IsOldFormat ; (; const char * ; newTypeName). virtual . The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ; Definition at line 419 of file TStreamerElement.cxx. ◆ IsTransient(). Bool_t TStreamerElement::IsTransient ; (; ); const. virtual . Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ; Definition at line 440 of file TStreamerElement.cxx. ◆ ls(). void TStreamerElement::ls ; (; Option_t * ; option = """"); const. overridevirtual . Print the content of the element. ; Reimplemented from TNamed.; Reimplemented in TStreamerSTL.; Definition at line 458 of file TStreamerElement.cxx. ◆ operator=(). TStreamerElement & TStreamerElement::operator= ; (; const TStreamerElement & ; ). privatedelete . ◆ SetArrayDim(). void TStreamerElement::SetArrayDim ; (; Int_t ; dim). virtual . Set number of array dimensions. ; Reimplemented in TStreamerBasicPointer, TStreamerObjectPointer, and TStreamerObjectAnyPointer.; Definition at line 480 of file TStreamerEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerElement.html:24508,detect,detected,24508,doc/master/classTStreamerElement.html,https://root.cern,https://root.cern/doc/master/classTStreamerElement.html,1,['detect'],['detected']
Safety,"epNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate rnn layer. ; Definition at line 931 of file MethodDL.cxx. ◆ ParseReshapeLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseReshapeLayer ; (; DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate reshape layer. ; Definition at line 829 of file MethodDL.cxx. ◆ PredictDeepNet(). template<typename Architecture_t > . std::vector< Double_t > TMVA::MethodDL::PredictDeepNet ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . size_t ; batchSize, . Bool_t ; logProgress . ). private . perform prediction of the deep neural network using batches (called by GetMvaValues) ; Evaluate the DeepNet on a vector of input values stored in the TMVA Event class. ; Definition at line 1828 of file MethodDL.cxx. ◆ ProcessOptions(). void TMVA::MethodDL::ProcessOptions ; (; ). privatevirtual . Implements TMVA::MethodBase.; Definition at line 219 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [1/3]. void TMVA::MethodDL::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase.; Definition at line 2330 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [2/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Methods for writing and reading weights. ; Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Methods for writing and reading weights. ; Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodDL::ReadWeightsFromXML ; (; void * ; wghtnod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:47772,predict,prediction,47772,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['predict'],['prediction']
Safety,"epmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1028339,safe,safety,1028339,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],"['safe', 'safety']"
Safety,"epresents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107471,detect,detector,107471,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety,"epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBase.html:3687,detect,detect,3687,root/html528/TDecompBase.html,https://root.cern,https://root.cern/root/html528/TDecompBase.html,6,['detect'],['detect']
Safety,"eq /*=-1*/, Int_t duration /*=-1*/,; 325 Bool_t setDefault /*=kFALSE*/); 326{; 327 if (setDefault) {; 328 fBeepFreq = freq;; 329 fBeepDuration = duration;; 330 return;; 331 }; 332 if (fBeepDuration < 0 || fBeepFreq < 0) return; // silence; 333 if (freq < 0) freq = fBeepFreq;; 334 if (duration < 0) duration = fBeepDuration;; 335 DoBeep(freq, duration);; 336}; 337 ; 338//---- EventLoop ---------------------------------------------------------------; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// System event loop.; 342 ; 343void TSystem::Run(); 344{; 345 fInControl = kTRUE;; 346 fDone = kFALSE;; 347 ; 348loop_entry:; 349 try {; 350 RETRY {; 351 while (!fDone) {; 352 gApplication->StartIdleing();; 353 InnerLoop();; 354 gApplication->StopIdleing();; 355 }; 356 } ENDTRY;; 357 }; 358 catch (std::exception& exc) {; 359 TIter next(fStdExceptionHandler);; 360 TStdExceptionHandler* eh = nullptr;; 361 while ((eh = (TStdExceptionHandler*) next())) {; 362 switch (eh->Handle(exc)); 363 {; 364 case TStdExceptionHandler::kSEProceed:; 365 break;; 366 case TStdExceptionHandler::kSEHandled:; 367 goto loop_entry;; 368 break;; 369 case TStdExceptionHandler::kSEAbort:; 370 Warning(""Run"", ""instructed to abort"");; 371 goto loop_end;; 372 break;; 373 }; 374 }; 375 throw;; 376 }; 377 catch (const char *str) {; 378 printf(""%s\n"", str);; 379 }; 380 // handle every exception; 381 catch (...) {; 382 Warning(""Run"", ""handle uncaught exception, terminating"");; 383 }; 384 ; 385loop_end:; 386 fInControl = kFALSE;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Exit from event loop.; 391 ; 392void TSystem::ExitLoop(); 393{; 394 fDone = kTRUE;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Inner event loop.; 399 ; 400void TSystem::InnerLoop(); 401{; 402 fLevel++;; 403 DispatchOneEvent();; 404 fLevel--;; 405}; 406 ; 407//////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:11245,abort,abort,11245,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['abort'],['abort']
Safety,"eq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:19641,timeout,timeout,19641,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['timeout'],['timeout']
Safety,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:45681,timeout,timeout,45681,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,['timeout'],['timeout']
Safety,"er and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for THttpTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THttpTimer(). THttpTimer::THttpTimer ; (; Long_t ; milliSec, . Bool_t ; mode, . THttpServer & ; serv . ). inline . !< server processing requests ; constructor ; Definition at line 51 of file THttpServer.cxx. Member Function Documentation. ◆ IsSlow(). Bool_t THttpTimer::IsSlow ; (; ); const. inline . Definition at line 69 of file THttpServer.cxx. ◆ SetSlow(). void THttpTimer::SetSlow ; (; Bool_t ; flag). inline . Definition at line 53 of file THttpServer.cxx. ◆ Timeout(). void THttpTimer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process http requests in main ROOT thread ; Reimplemented from TTimer.; Definition at line 73 of file THttpServer.cxx. Member Data Documentation. ◆ fNormalTmout. Long_t THttpTimer::fNormalTmout {0}. private . Definition at line 43 of file THttpServer.cxx. ◆ fServer. THttpServer& THttpTimer::fServer. Definition at line 48 of file THttpServer.cxx. ◆ fSlow. Bool_t THttpTimer::fSlow {kFALSE}. private . Definition at line 44 of file THttpServer.cxx. ◆ fSlowCnt. Int_t THttpTimer::fSlowCnt {0}. private . Definition at line 45 of file THttpServer.cxx. net/http/src/THttpServer.cxx. THttpTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpTimer.html:18023,timeout,timeout,18023,doc/master/classTHttpTimer.html,https://root.cern,https://root.cern/doc/master/classTHttpTimer.html,1,['timeout'],['timeout']
Safety,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:37270,timeout,timeout,37270,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,6,['timeout'],['timeout']
Safety,er of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTest,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:40747,avoid,avoids,40747,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,2,['avoid'],['avoids']
Safety,"er of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:14918,safe,safety,14918,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,3,['safe'],['safety']
Safety,"er of registered PDFs, but getVal() will assert if when called for an unregistered index state. ; Definition at line 115 of file RooSimultaneous.cxx. ◆ RooSimultaneous() [3/7]. RooSimultaneous::RooSimultaneous ; (; const char * ; name, . const char * ; title, . std::map< std::string, RooAbsPdf * > ; pdfMap, . RooAbsCategoryLValue & ; inIndexCat . ). Definition at line 148 of file RooSimultaneous.cxx. ◆ RooSimultaneous() [4/7]. RooSimultaneous::RooSimultaneous ; (; const char * ; name, . const char * ; title, . RooFit::Detail::FlatMap< std::string, RooAbsPdf * > const & ; pdfMap, . RooAbsCategoryLValue & ; inIndexCat . ). For internal use in RooFit. ; Definition at line 155 of file RooSimultaneous.cxx. ◆ RooSimultaneous() [5/7]. RooSimultaneous::RooSimultaneous ; (; const char * ; name, . const char * ; title, . const RooArgList & ; inPdfList, . RooAbsCategoryLValue & ; inIndexCat . ). Constructor from index category and full list of PDFs. ; In this constructor form, a PDF must be supplied for each indexCat state to avoid ambiguities. The PDFs are associated with the states of the index category as they appear when iterating through the category states with RooAbsCategory::begin() and RooAbsCategory::end(). This usually means they are associated by ascending index numbers.; PDFs may not overlap (i.e. share any variables) with the index category (function) ; Definition at line 132 of file RooSimultaneous.cxx. ◆ RooSimultaneous() [6/7]. RooSimultaneous::RooSimultaneous ; (; const RooSimultaneous & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 339 of file RooSimultaneous.cxx. ◆ ~RooSimultaneous(). RooSimultaneous::~RooSimultaneous ; (; ). override . Destructor. ; Definition at line 358 of file RooSimultaneous.cxx. ◆ RooSimultaneous() [7/7]. RooSimultaneous::RooSimultaneous ; (; const char * ; name, . const char * ; title, . RooSimultaneous::InitializationOutput && ; initInfo . ). private . Private internal constructor. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:80222,avoid,avoid,80222,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['avoid'],['avoid']
Safety,"er supported environment.Definition RWebWindow.hxx:52; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:36; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:44; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:51; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:351; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:61; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:167; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:50; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:201; ROOT::RWebWindowsManager::WaitForint WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1)Waits until provided check function or lambdas return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:6258,timeout,timeout,6258,doc/v632/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html,1,['timeout'],['timeout']
Safety,"er timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimer.html:13740,timeout,timeout,13740,root/html534/TTimer.html,https://root.cern,https://root.cern/root/html534/TTimer.html,6,['timeout'],['timeout']
Safety,"er to save the partial results; Bool_tfSaveResultsPerPacketWhether to save partial results after each packet; TStatus*fSelStatus! status of query in progress; TSelector*fSelector! the latest selector; TClass*fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*fStopTimerTimer associated with a stop request; TMutex*fStopTimerMtxTo protect the stop timer; Long64_tfTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fAutoBinsMap of min/max values by name for slaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPlayer(TProof* proof = 0); Default ctor. ~TProofPlayer(); Destructor. void SetProcessing(Bool_t on = kTRUE); Set processing bit according to 'on'. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop the process after this event. If timeout is positive, start; a timer firing after timeout seconds to hard-stop time-expensive; events. void SetDispatchTimer(Bool_t on = kTRUE); Enable/disable the timer to dispatch pening events while processing. void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); Enable/disable the timer to stop/abort processing.; The 'timeout' is in seconds. void AddQueryResult(TQueryResult* q); Add query result to the list, making sure that there are no; duplicates. void RemoveQueryResult(const char* ref); Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:15458,abort,abort,15458,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"er { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id: KDEKernel.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__KDEKernel.html:2273,sanity check,sanity check,2273,root/html532/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html532/TMVA__KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"er"",""Old formula read from file is NOT valid"");; 3699 Print(""v"");; 3700 }; 3701 delete fold;; 3702 return;; 3703 }; 3704 else if (v > 8) {; 3705 // new TFormula class; 3706 b.ReadClassBuffer(TFormula::Class(), this, v, R__s, R__c);; 3707 ; 3708 //std::cout << ""reading npar = "" << GetNpar() << std::endl;; 3709 ; 3710 // initialize the formula; 3711 // need to set size of fClingVariables which is transient; 3712 //fClingVariables.resize(fNdim);; 3713 ; 3714 // case of formula contains only parameters; 3715 if (fFormula.IsNull() ) return;; 3716 ; 3717 ; 3718 // store parameter values, names and order; 3719 std::vector<double> parValues = fClingParameters;; 3720 auto paramMap = fParams;; 3721 fNpar = fParams.size();; 3722 ; 3723 fLazyInitialization = true; // when reading we initialize the formula later to avoid problem of recursive Jitting; 3724 ; 3725 if (!TestBit(TFormula::kLambda) ) {; 3726 ; 3727 // save dimension read from the file (stored for V >=12); 3728 // and we check after initializing if it is the same; 3729 int ndim = fNdim;; 3730 fNdim = 0;; 3731 ; 3732 //std::cout << ""Streamer::Reading preprocess the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3733 // for ( auto &p : fParams); 3734 // std::cout << ""parameter "" << p.first << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:141465,avoid,avoid,141465,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['avoid'],['avoid']
Safety,"er(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); voidIndicateStop(Bool_t aborted); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:8909,abort,aborted,8909,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,6,['abort'],['aborted']
Safety,"er). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find an object in this list usi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:3293,safe,safe,3293,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['safe'],['safe']
Safety,"er). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object before object before in the list. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:3623,safe,safe,3623,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['safe'],['safe']
Safety,"er. void ReadFastArray(UShort_t *h, Int_t n); read array of UShort_t from buffer. void ReadFastArray(Int_t *i, Int_t n); read array of Int_t from buffer. void ReadFastArray(UInt_t *i, Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t *l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t *l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t *l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t *l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t *f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t *d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t *b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t *c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t *c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t *h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t *h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t *i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t *i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:35338,avoid,avoid,35338,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['avoid'],['avoid']
Safety,"er. void ReadFastArray(UShort_t* h, Int_t n); read array of UShort_t from buffer. void ReadFastArray(Int_t* i, Int_t n); read array of Int_t from buffer. void ReadFastArray(UInt_t* i, Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:37269,avoid,avoid,37269,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,3,['avoid'],['avoid']
Safety,"er; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:9035,timeout,timeout,9035,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,12,['timeout'],['timeout']
Safety,"er; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. Int_t AddWorkers(TList* workers); Adds new workers. Must be implemented by each real packetizer properly.; Returns the number of workers added, or -1 on failure. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcessed(); bytes = GetBytesRead(); calls = GetReadCalls(); return 0; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPacketizer.html:9081,abort,abort,9081,root/html534/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html534/TVirtualPacketizer.html,1,['abort'],['abort']
Safety,"er; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcessed(); bytes = GetBytesRead(); calls = GetReadCalls(); return 0; }. Float_t GetCurrentRate(Bool_t& all); { all = kTRUE; return (fProgressStatus? fProgressStatus->GetCurrentRate() : 0.); }. Long64_t GetTotalEntries() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualPacketizer.html:8997,abort,abort,8997,root/html530/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html530/TVirtualPacketizer.html,2,['abort'],['abort']
Safety,"erAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColor (Color_t mcolor=1);  Set the marker color. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; virtual void SetMarkerSize (Size_t msize=1);  Set the marker size. ;  ; virtual void SetMarkerStyle (Style_t mstyle=1);  Set the marker style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static void AbsValue (Bool_t reject=kTRUE);  Static function: set the fgAbsValue flag. ;  ; static void CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11);  Type safe interface (static method) The number of sampling points are taken from the TGraph. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Bool_t DefaultAddToGlobalList (Bool_t on=kTRUE);  Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ;  ; static Double_t DerivativeError ();  Static function returning the error of the last call to the of Derivative's functions. ;  ; static TF1 * GetCurrent ();  Static function returning the current function being processed. ;  ; static void InitStandardFunctions ();  Create the basic function objects. ;  ; static Bool_t RejectedPoint ();  See TF1::RejectPoint above. ;  ; static void RejectPoint (Bool_t reject=kTRUE);  Static function to set the global flag to reject points the fgRejectPoint global flag is tested by all fit functions if TRUE the point is not included in the fit. ;  ; static void SetCurrent (TF1 *f1);  Static function setting the current function. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:41556,avoid,avoid,41556,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['avoid'],['avoid']
Safety,"erDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:10759,avoid,avoid,10759,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['avoid'],['avoid']
Safety,"erInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:6245,avoid,avoid,6245,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,1,['avoid'],['avoid']
Safety,"erInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); TXSlave(const TXSlave&); TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype); voidParseBuffer(). Data Members; public:. static TSlave::ESlaveStatusTSlave::kActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TSlave::ESlaveStatusTSlave::kInactive; static TSlave::ESlaveStatusTSlave::kInvalid; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TSlave::ESlaveTypeTSlave::kMaster; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:6760,abort,abort,6760,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"erNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:2405,avoid,avoids,2405,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,2,['avoid'],['avoids']
Safety,"erSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fClusterSize[i];; 8314 R__ASSERT(size >= 0);; 8315 if (fClusterSize[i] == 0); 8316 continue;; 8317 const auto nClusters = (1 + fClusterRangeEnd[i] - clusterRangeStart) / fClusterSize[i];; 8318 nClustersInRange.emplace_back(nClusters);; 8319 clusterRangeStart = fClusterRangeEnd[i] + 1;; 8320 }; 8321 ; 8322 R__ASSERT(nClustersInRange.size() == clusterSizesPerRange.size());; 8323 const auto medianClusterSize =; 8324 TMath::Median(nClustersInRange.size(), clusterSizesPerRange.data(), nClustersInRange.data());; 8325 return medianClusterSize;; 8326}; 8327 ; 8328////////////////////////////////////////////////////////////////////////////////; 8329/// In case of a program crash, it will be possible to recover the data in the; 8330/// tree up to the last AutoSave point.; 8331/// This function may be called before filling a TTree to specify when the; 8332/// branch buffers and TTree header are flushed to disk as part of; 8333/// TTree::Fill().; 8334/// The default is -300000000, ie the TTree will write data to disk once it; 8335/// exceeds 300 MBytes.; 8336/// CASE 1: If fAutoSave is positive the watermark is reached when a multiple of; 8337/// fAutoSave entries have been filled.; 8338/// CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave; 8339/// bytes can be written to the file.; 8340/// CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically; 8341/// as part of TTree::Fill().; 8342 ; 8343void TTree::SetAutoSave(Long64_t autos); 8344{; 8345 fAutoSave = autos;; 8346}; 8347 ; 8348////////////////////////////////////////////////////////////////////////////////; 8349/// Set a branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:324939,recover,recover,324939,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recover']
Safety,"erator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSSLSocket.html:5990,timeout,timeout,5990,root/html532/TSSLSocket.html,https://root.cern,https://root.cern/root/html532/TSSLSocket.html,2,['timeout'],['timeout']
Safety,"erator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:9533,recover,recover,9533,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"ere N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:54383,sanity check,sanity check,54383,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,14,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"ere. As you see, TPad defines log scale for the two directions x and y plus z if you want to draw a 3D representation of some function or histogram.; The way to set log scale in the x direction for the active pad is:; root[] gPad->SetLogx(1); To reset log in the z direction:; root[] gPad->SetLogz(0); If you have a divided pad, you need to set the scale on each of the sub-pads. Setting it on the containing pad does not automatically propagate to the sub-pads. Here is an example of how to set the log scale for the x-axis on a canvas with four sub-pads:; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient when executing a macro. By adding statements like:; canvas->WaitPrimitive();; You can monitor the progress of a running macro, stop it at convenient places with the possibility to interact with the canvas and resume the execution with a double click or a key press.; 9.3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more informat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:318406,avoid,avoid,318406,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"ere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:15421,safe,safe,15421,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['safe'],['safe']
Safety,"eread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t maxCacheSize = 10, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:13927,timeout,timeout,13927,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,['timeout'],['timeout']
Safety,"ered into TSystem and is processed; 17 within the standard ROOT event-loop.; 182. asynchronous timer is passed to the operating system which sends; 19 an external signal to ROOT and thus interrupts its event-loop.; 20 ; 21You can use this class in one of the following ways:; 22 - Sub-class TTimer and override the Notify() method.; 23 - Re-implement the TObject::HandleTimer() method in your class; 24 and pass a pointer to this object to timer, see the SetObject(); 25 method.; 26 - Pass an interpreter command to timer, see SetCommand() method.; 27 - Create a TTimer, connect its Timeout() signal to the; 28 appropriate methods. Then when the time is up it will emit a; 29 Timeout() signal and call connected slots.; 30 ; 31Minimum timeout interval is defined in TSystem::ESysConstants as; 32`kItimerResolution` (currently 10 ms).; 33 ; 34Signal/slots example:; 35~~~{.cpp}; 36 TTimer *timer = new TTimer();; 37 timer->Connect(""Timeout()"", ""myObjectClassName"",; 38 myObject, ""TimerDone()"");; 39 timer->Start(2000, kTRUE); // 2 seconds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:1861,timeout,timeout,1861,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety,"erence Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriousl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1119,recover,recover,1119,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recover']
Safety,"ergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranch.html:23842,avoid,avoid,23842,root/html532/TBranch.html,https://root.cern,https://root.cern/root/html532/TBranch.html,4,['avoid'],['avoid']
Safety,"eritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const; Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCompositeShape.html:18380,safe,safe,18380,root/html532/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html,1,['safe'],['safe']
Safety,"erived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:108476,detect,detector,108476,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"erly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441631,recover,recover,441631,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['recover'],"['recover', 'recovered']"
Safety,"ernally, randomly, and by accept/reject sampling; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Sat Sep 5 17:29:32 2015 » Last generated: 2015-09-05 17:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooGenContext.html:11590,unsafe,unsafe,11590,root/html604/RooGenContext.html,https://root.cern,https://root.cern/root/html604/RooGenContext.html,1,['unsafe'],['unsafe']
Safety,"ernative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:19989,detect,detects,19989,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,3,['detect'],['detects']
Safety,"err) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; void ResetTimer (TTimer *ti) override;  Reset a-sync timer. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDisplay () override;  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; void SetDynamicPath (const char *lib) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int option, int val) override;  Set socket option. ;  ; void SigAlarmInterruptsSyscalls (Bool_t set) override;  When the argument is true the SIGALRM sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:10259,timeout,timeout,10259,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['timeout'],['timeout']
Safety,"erride=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoShape::SetPointsvirtual void SetPoints(Double_t *points) const =0; TGeoShape::IsATClass * IsA() const overrideDefinition TGeoShape.h:171; TGeoTrackDefinition TGeoTrack.h:26; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::IsVisContainersBool_t IsVisContainers() constDefinition TGeoVolume.h:157; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::GetMaterialTGeoMaterial * GetMaterial() constDefinition TGeoVolume.h:174; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:110466,safe,safe,110466,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safe']
Safety,"errideTUnixSystemvirtual; RecvRaw(int sock, void *buffer, int length, int flag) overrideTUnixSystemvirtual; RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideTUnixSystemvirtual; RemoveFileHandler(TFileHandler *fh) overrideTUnixSystemvirtual; RemoveOnExit(TObject *obj)TSystem; RemoveSignalHandler(TSignalHandler *sh) overrideTUnixSystemvirtual; RemoveStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; RemoveTimer(TTimer *ti) overrideTUnixSystemvirtual; Rename(const char *from, const char *to) overrideTUnixSystemvirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno()TSystemstatic; ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideTUnixSystemvirtual; ResetSignals() overrideTUnixSystemvirtual; ResetTimer(TTimer *ti) overrideTUnixSystemvirtual; Run()TSystemvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; Select(TList *active, Long_t timeout) overrideTUnixSystemvirtual; Select(TFileHandler *fh, Long_t timeout) overrideTUnixSystemvirtual; SendBuf(int sock, const void *buffer, int length) overrideTUnixSystemvirtual; SendRaw(int sock, const void *buffer, int length, int flag) overrideTUnixSystemvirtual; SetAclicMode(EAclicMode mode)TSystemvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)TSystemvirtual; SetDisplay() overrideTUnixSystemvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetDynamicPath(const char *lib) overrideTUnixSystemvirtual; Setenv(const char *name, const char *value) overrideTUnixSystemvirtual; SetErrorStr(const char *errstr)TSystem; SetFlagsDebug(const char *)TSystemvirtual; SetFlagsOpt(const char *)TSystemvirtual; SetFPEMask(Int_t mask=kDefaultMask) overrideTUnixSystemvirtual; SetIncludePath(const char *includePath)TSystemvirtual; SetLinkdefSuffix(const char *suffix)TSystemv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:14942,timeout,timeout,14942,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['timeout'],['timeout']
Safety,"error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ; Definition at line 290 of file RuleFitParams.cxx. ◆ LossFunction() [3/3]. Double_t TMVA::RuleFitParams::LossFunction ; (; UInt_t ; evtidx, . UInt_t ; itau . ); const. Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ; Definition at line 302 of file RuleFitParams.cxx. ◆ MakeGDPath(). void TMVA::RuleFitParams::MakeGDPath ; (; ). The following finds the gradient directed path in parameter space. ; More work is needed... FT, 24/9/2006; The algorithm is currently as follows (if not otherwise stated, the sample used below is [fPathIdx1,fPathIdx2]):. Set offset to -average(y(true)) and all coefs=0 => average of F(x)==0; FindGDTau() : start scanning using several paths defined by different tau choose the tau yielding the best path; start the scanning the chosen path; check error rate at a given frequency data used for check: [fPerfIdx1,fPerfIdx2]; stop when either of the following conditions are fullfilled:; loop index==fGDNPathSteps; error > fGDErrScale*errmin; only in DEBUG mode: risk is not monotonously decreasing. The algorithm will warn if:; the error rate was still decreasing when loop finished -> increase fGDNPathSteps!; minimum was found at an early stage -> decrease fGDPathStep; DEBUG: risk > previous risk -> entered chaotic region (regularization is too small) . Definition at line 538 of file RuleFitParams.cxx. ◆ MakeGradientVector(). void TMVA::RuleFitParams::MakeGradientVector ; (; ). protected . make gradient vector ; Definition at line 1375 of file RuleFitParams.cxx. ◆ MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:15198,risk,risk,15198,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety,"ers are preserved. void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSubtraction.html:9383,safe,safe,9383,root/html534/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"ers are preserved. void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoSubtraction& ). EGeoBoolType GetBooleanOperator() const. TGeoSubtraction(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoSubtraction.html:10005,safe,safe,10005,root/html604/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html604/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"ers are preserved. void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoSubtraction& ). EGeoBoolType GetBooleanOperator() const. TGeoSubtraction(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSubtraction.html:10005,safe,safe,10005,root/html602/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html602/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"ers are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1301ROOT::EnableImplicitMT();; 1302const unsigned int nSlots = df.GetNSlots();; 1303std::vector<double> sumSqs(nSlots, 0.);; 1304std::vector<unsigned int> ns(nSlots, 0);; 1305 ; 1306df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1307double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1308unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1309std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1310~~~; 1311Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1312 ; 1313 ; 1314\anchor friends; 1315### Dataset joins with friend trees; 1316 ; 1317Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; 1318more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:75612,safe,safe,75612,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ers are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1341ROOT::EnableImplicitMT();; 1342const unsigned int nSlots = df.GetNSlots();; 1343std::vector<double> sumSqs(nSlots, 0.);; 1344std::vector<unsigned int> ns(nSlots, 0);; 1345 ; 1346df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1347double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1348unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1349std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1350~~~; 1351Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1352 ; 1353 ; 1354\anchor friends; 1355### Dataset joins with friend trees; 1356 ; 1357Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; 1358more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:77292,safe,safe,77292,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ers to components. ;  ;  ~TGeoSubtraction () override;  Destructor — deletion of components handled by TGeoManager class. ;  ; void ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override;  Compute bounding box corresponding to a subtraction of two shapes. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ;  ; Bool_t Contains (const Double_t *point) const override;  Find if a subtraction of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point inside to the shape boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given point outside to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this subtraction. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:1608,safe,safe,1608,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safe']
Safety,"ers to join a progressing process.; Returns kTRUE on success, kFALSE otherwise. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(Bool_t savememvalues = kFALSE); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:19593,abort,abort,19593,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:22955,timeout,timeout,22955,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"ers; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2314,detect,detector,2314,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['detect'],['detector']
Safety,"ers; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html:8339,predict,predictions,8339,root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,"ersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. Bool_t IsServProofd(). void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. void SetSessionID(Int_t id). Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(); Interrupt the low level socket. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocket.h 34428 2010-07-15 12:35:34Z ganis $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocket.html:14880,timeout,timeout,14880,root/html528/TXSocket.html,https://root.cern,https://root.cern/root/html528/TXSocket.html,1,['timeout'],['timeout']
Safety,"ertices () const override;  Return number of vertices of the mesh representation. ;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsComposite () const override;  ; Bool_t IsCylType () const override;  ; void MakeNode (const char *expression);  Make a boolean node according to the top level boolean operation of expression. ;  ; virtual Bool_t PaintComposite (Option_t *option="""") const;  Paint this composite shape into the current 3D viewer Returns bool flag indicating if the caller should continue to paint child objects. ;  ; void RegisterYourself ();  Register the shape and all components to TGeoManager class. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *) override;  ; void SetPoints (Double_t *points) const override;  create points for a composite shape ;  ; void SetPoints (Float_t *points) const override;  create points for a composite shape ;  ; void Sizeof3D () const override;  compute size of this 3D object ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:13745,safe,safe,13745,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,2,['safe'],['safe']
Safety,"es = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoArb8.html:2779,safe,safe,2779,root/html530/TGeoArb8.html,https://root.cern,https://root.cern/root/html530/TGeoArb8.html,1,['safe'],['safe']
Safety,"es and Tasks. [ROOT-7426] - Cannot print elements of vector on Mac; [ROOT-7739] - TVectorD times double returns a TH1 on ROOT command line; [ROOT-7825] - wrong value passed to function expecting “const T*&""; [ROOT-7830] - Cling automatic RooFit objects always reloaded from file; [ROOT-7862] - CMake Error: CMake can not determine linker language for target: g2root; [ROOT-7864] - Segfault in __cf_15 and FastCall (c++ exception in a constructor is not propagated to python); [ROOT-7865] - root commandline tools are not executable after installation; [ROOT-7872] - PyROOT: wrong return value when calling a c++ function returning short; [ROOT-7879] - Autoloader (parser?) tries to follow #includes from LinkDef.h; [ROOT-7881] - Uninitialized member access in TFormula => undefined behaviour; [ROOT-7891] - installation instructions for root notebooks incomplete; [ROOT-7892] - Incoherent version of Python when building tmva/pymva; [ROOT-7896] - CMake: visibility inconsistency; [ROOT-7901] - Double-free in TROOT::EndOfProcessCleanups redux; [ROOT-7912] - Failure with -Dbuiltin_davix=ON on 64bit Ubuntu; [ROOT-7916] - pyroot problem with std::vector of enum; [ROOT-7927] - TPluginHandler::CheckForExecPlugin is not thread safe; [ROOT-7935] - Need a better way stop PyROOT from reading .rootlogon.(py|C); [ROOT-7940] - Incorrect handling of LLVM Threading; [ROOT-8003] - Root 6.06 slow to; [ROOT-8015] - cmake not honoring -Dbuiltin_lzma=OFF; [ROOT-8019] - Warning with spaces in the binary name; [ROOT-8031] - TTree auto (read) cache setup during Fill; [ROOT-7776] - Integrate GSL 2.0 in ROOT. Release 6.06/04; Released on May 4, 2016; General. Significant update of the valgrind suppression file to hide intentional lack of delete of some entities at the end of the process.; Resolved several memory leaks. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:28286,safe,safe,28286,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safe']
Safety,"es the given list of new workers to join a progressing process.; Returns kTRUE on success, kFALSE otherwise. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:20206,abort,abort,20206,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"es, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 1002 // Clone trees should no longer be removed from fClones when they are deleted.; 1003 {; 1004 R__LOCKGUARD(gROOTMutex);; 1005 gROOT->GetListOfCleanups()->Remove(fClones);; 1006 }; 1007 // Note: fClones does not own its content.; 1008 delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:35244,detect,detect,35244,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detect']
Safety,"es. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(RooStats::HistFactory::Measurement& Meas). void ConfigureWorkspaceForMeasurement(const string& ModelName, RooWorkspace* ws_single, RooStats::HistFactory::Measurement& measurement). RooWorkspace* MakeSingleChannelModel(RooStats::HistFactory::Measurement& measurement, RooStats::HistFactory::Channel& channel). RooWorkspace* MakeCombinedModel(RooStats::HistFactory::Measurement& measurement). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<RooStats::HistFactory::HistoSys> , string prefix, string productPrefix, string systTerm, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* proto, string& channel, string& sigmaEpsilon, RooStats::HistFactory::Sample& sample, bool doRatio). void AddConstraintTerms(RooWorkspace* proto, RooStats::HistFactory::Measurement& measurement, string prefix, string interpName, vector<RooStats::HistFactory::OverallSys>& systList, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page). void MakeTotalExpected(RooWorkspace* proto, string totName, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:10235,predict,predictions,10235,root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"es. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(RooStats::HistFactory::Measurement& Meas). void ConfigureWorkspaceForMeasurement(const string& ModelName, RooWorkspace* ws_single, RooStats::HistFactory::Measurement& measurement). RooWorkspace* MakeSingleChannelModel(RooStats::HistFactory::Measurement& measurement, RooStats::HistFactory::Channel& channel). RooWorkspace* MakeCombinedModel(RooStats::HistFactory::Measurement& measurement). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<RooStats::HistFactory::HistoSys> , string prefix, string productPrefix, string systTerm, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* proto, string& channel, string& sigmaEpsilon, RooStats::HistFactory::Sample& sample, bool doRatio). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, vector<RooStats::HistFactory::OverallSys>& systList, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page). void MakeTotalExpected(RooWorkspace* proto, string totName, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:10186,predict,predictions,10186,root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"es: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""passed.root"",""update"");; TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; TH1* copy = pEff->GetCopyPassedHisto();; copy->SetDirectory(gDirectory);; pFile->Write();. TH1* GetCopyTotalHisto() const; returns a cloned version of fTotalHistogram. Notes: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""total.root"",""update"");; TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; TH1* copy = pEff->GetCopyTotalHisto();; copy->SetDirectory(gDirectory);; pFile->Write();. Int_t GetDimension() const; returns the dimension of the current TEfficiency object. Double_t GetEfficiency(Int_t bin) const; returns the efficiency in the given global bin. Note: - The estimated efficiency depends on the chosen statistic option:; for frequentist ones:; ; for bayesian ones the expectation value of the resulting posterior; distribution is returned:; ; If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; mode (most probable value) of the posterior is returned:; . - If the denominator is equal to 0, an efficiency of 0 is returned.; - When or t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:54740,avoid,avoid,54740,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,6,['avoid'],['avoid']
Safety,"es; UsePoission Nvars use UseNvars not as fixed number but as mean of a possion distribution; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~Met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:28229,avoid,avoided,28229,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,3,['avoid'],['avoided']
Safety,"eset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:37067,timeout,timeout,37067,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"espect to the parameters at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual IBaseFunctionMultiDimTempl< T > * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; virtual unsigned int NDim () const =0;  Retrieve the dimension of the function. ;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; T DoEval (const T *x) const override;  Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ;  ; T DoEvalPar (const T *x, const double *p) const override=0;  Implementation of the evaluation function using the x values and the parameters. ;  ; virtual T DoParameterDerivative (const T *x, const double *p, unsigned int ipar) const =0;  Evaluate the partial derivative w.r.t a parameter ipar , to be implemented by the derived classes. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricGradFunctionMultiDimTempl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html:3813,avoid,avoid,3813,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,1,['avoid'],['avoid']
Safety,"essage *mess)=0;  ; TClass * IsA () const override;  ; virtual Bool_t IsClient () const =0;  ; virtual Bool_t JoinProcess (TList *workers)=0;  ; virtual void MergeOutput (Bool_t=kFALSE)=0;  ; virtual Long64_t Process (TDSet *set, const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0)=0;  ; virtual Long64_t Process (TDSet *set, TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0)=0;  ; virtual void Progress (Long64_t total, Long64_t processed)=0;  ; virtual void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)=0;  ; virtual void Progress (TProofProgressInfo *)=0;  ; virtual void Progress (TSlave *, Long64_t total, Long64_t processed)=0;  ; virtual void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)=0;  ; virtual void Progress (TSlave *, TProofProgressInfo *)=0;  ; virtual Int_t ReinitSelector (TQueryResult *qr)=0;  ; virtual void RemoveQueryResult (const char *ref)=0;  ; virtual void RestorePreviousQuery ()=0;  ; virtual Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE)=0;  ; virtual void SetCurrentQuery (TQueryResult *q)=0;  ; virtual void SetDispatchTimer (Bool_t on=kTRUE)=0;  ; virtual void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt)=0;  ; virtual void SetExitStatus (EExitStatus)=0;  ; virtual void SetInitTime ()=0;  ; virtual void SetMaxDrawQueries (Int_t max)=0;  ; virtual void SetMerging (Bool_t on=kTRUE)=0;  ; virtual void SetOutputFilePath (const char *fp)=0;  ; virtual void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0)=0;  ; virtual void StopProcess (Bool_t abort, Int_t timeout=-1)=0;  ; virtual void StoreFeedback (TObject *slave, TList *out)=0;  ; virtual void StoreOutput (TList *out)=0;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualProofPlayer.html:4686,abort,abort,4686,doc/master/classTVirtualProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"estNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCone.html:2290,safe,safe,2290,root/html530/TGeoCone.html,https://root.cern,https://root.cern/root/html530/TGeoCone.html,1,['safe'],['safe']
Safety,"estatic llvm::cl::opt< std::string > gOptDictionaryFileName(llvm::cl::Positional, llvm::cl::desc(""<output dictionary file>""), llvm::cl::cat(gRootclingOptions)); IsSelectionXmlbool IsSelectionXml(const char *filename)Definition rootcling_impl.cxx:454; IsGoodLibraryNamebool IsGoodLibraryName(const std::string &name)Definition rootcling_impl.cxx:5563; GrabIndexllvm::StringRef GrabIndex(const cling::Interpreter &interp, const clang::FieldDecl &member, int printError)GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in t...Definition rootcling_impl.cxx:1352; gOptMultiDictstatic llvm::cl::opt< bool > gOptMultiDict(""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions)); IsSelectionFilebool IsSelectionFile(const char *filename)Definition rootcling_impl.cxx:474; GenerateStringFromHeadersForClassesconst std::string GenerateStringFromHeadersForClasses(const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false)Generate a string for the dictionary from the headers-classes map.Definition rootcling_impl.cxx:3378; IsSupportedClassNamebool IsSupportedClassName(const char *name)Definition rootcling_impl.cxx:3439; gOptIgnoreExistingDictstatic llvm::cl::opt< bool > gOptIgnoreExistingDict(""r"", llvm::cl::desc(""Deprecated. Similar to -f but it ignores the dictionary generation. \; When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions)); gOptForcestatic llvm::cl::opt< bool > gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""), llvm::cl::cat(gRootclingOptions)); AnnotateFieldDeclstatic void AnnotateFieldDecl(clang::FieldDecl &decl, const std::list< VariableSelectionRule > &fieldSelRules)Definition rootcling_impl.cxx:253; CallWriteStreamervoid CallWriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:299010,detect,detectedUmbrella,299010,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety,"estcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:128842,redund,redundant,128842,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['redund'],['redundant']
Safety,"ested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development ROOT 7. For the first time since 20 year (i.e. ever), the ROOT team plans to break backward compatibility for crucial interfaces - once.; This new major version of ROOT will make ROOT much simpler and safer to use: we want to increase clarity and usability.; If you are a physicist, please read on - this is about your ROOT.; The ROOT team will be releasing parts of ROOT 7 throughout the coming years.; Previews will gradually sneak into the ROOT sources, in the namespace ROOT::Experimental for those parts that are not yet cast in stone, and in the namespace ROOT for those that are.; We will use standard C++ types, standard interface behavior (e.g. with respect to ownership and thread safety), good documentation and tests: we are trying to be nice!; Feedback; The main point of the meeting and this page is to solicit your feedback. Most of it has been taken care of in the code already.; Building ROOT 7; Pre-requisites; Support for the c++14 standard is required. Usage of g++ >= 5 or clang >= 3.4 is recommended.; Relevant cmake variables; The CMAKE_CXX_STANDARD cmake variables must be set to at least 14.; Building from source would look similar to this:; $ mkdir root7_build; $ cd root7_build; $ cmake -DCMAKE_CXX_STANDARD=14 path/to/root/source; $ cmake --build . -- -j4. Examples; See the relevant tutorials, for instance for drawing and styling the new histograms.; The new interfaces are not about shortening your code - but about robustness. Here are a few examples of what can go wrong with the ROOT6 interfaces:; ROOT6 interfaces, showing what can go wrong.; #include ""TFile.h""#include ""TH2.h""#include ""TTreeReader.h""#include ""TTreeReaderArray.h""#include ""TTree.h"" // Another function. Who knows what it does in a month from n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-7.html:2546,safe,safety,2546,d/root-7.html,https://root.cern,https://root.cern/d/root-7.html,1,['safe'],['safety']
Safety,"estore previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22233,timeout,timeout,22233,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"ests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110443,safe,safe,1110443,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"esult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerLocal.html:10775,abort,abort,10775,root/html528/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html528/TProofPlayerLocal.html,8,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"et the interpreter lock to the state it had before interpreter-related calls happened. ; Definition at line 9664 of file TCling.cxx. ◆ SaveContext(). void TCling::SaveContext ; (; ). finalvirtual . Save the current Cling state. ; Implements TInterpreter.; Definition at line 3859 of file TCling.cxx. ◆ SaveGlobalsContext(). void TCling::SaveGlobalsContext ; (; ). finalvirtual . Save the current Cling state of global objects. ; Implements TInterpreter.; Definition at line 3872 of file TCling.cxx. ◆ SetAlloclockfunc(). void TCling::SetAlloclockfunc ; (; void(*)() ; ); const. finalvirtual . [Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect critical section of its code (non-thread safe parts). ; Reimplemented from TInterpreter.; Definition at line 7536 of file TCling.cxx. ◆ SetAllocunlockfunc(). void TCling::SetAllocunlockfunc ; (; void(*)() ; ); const. finalvirtual . [Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect critical section of its code (non-thread safe parts). ; Reimplemented from TInterpreter.; Definition at line 7546 of file TCling.cxx. ◆ SetAutoLoadCallBack(). void * TCling::SetAutoLoadCallBack ; (; void * ; cb). inlinefinalvirtual . Reimplemented from TInterpreter.; Definition at line 199 of file TCling.h. ◆ SetClassAutoLoading(). int TCling::SetClassAutoLoading ; (; int ; autoload); const. finalvirtual . Enable/Disable the AutoLoading of libraries. ; Returns the old value, i.e whether it was enabled or not. ; Reimplemented from TInterpreter.; Definition at line 7567 of file TCling.cxx. ◆ SetClassAutoparsing(). int TCling::SetClassAutoparsing ; (; int ; autoparse). finalvirtual . Enable/Disable the Autoparsing of headers. ; Returns the old value, i.e whether it was enabled or not. ; Reimplemented from TInterpreter.; Definition at line 7585 of file TCling.cxx. ◆ SetClassInfo(). void TCling::SetClassInfo ; (; TClass * ; cl, . Bool_t ; reload = kFALSE, . Bool_t ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:130638,safe,safe,130638,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['safe'],['safe']
Safety,"et visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:50075,avoid,avoid,50075,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['avoid'],['avoid']
Safety,"et) ); break;; 3577 case TStreamerInfo::kUInt: writeSequence->AddAction( WriteBasicType<UInt_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3578 case TStreamerInfo::kULong: writeSequence->AddAction( WriteBasicType<ULong_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3579 case TStreamerInfo::kULong64: writeSequence->AddAction( WriteBasicType<ULong64_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3580 // case TStreamerInfo::kBits: writeSequence->AddAction( WriteBasicType<BitsMarker>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3581 /*case TStreamerInfo::kFloat16: {; 3582 if (element->GetFactor() != 0) {; 3583 writeSequence->AddAction( WriteBasicType_WithFactor<float>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3584 } else {; 3585 Int_t nbits = (Int_t)element->GetXmin();; 3586 if (!nbits) nbits = 12;; 3587 writeSequence->AddAction( WriteBasicType_NoFactor<float>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3588 }; 3589 break;; 3590 } */; 3591 /*case TStreamerInfo::kDouble32: {; 3592 if (element->GetFactor() != 0) {; 3593 writeSequence->AddAction( WriteBasicType_WithFactor<double>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3594 } else {; 3595 Int_t nbits = (Int_t)element->GetXmin();; 3596 if (!nbits) {; 3597 writeSequence->AddAction( ConvertBasicType<float,double>, new TConfiguration(this,i,compinfo,compinfo->fOffset) );; 3598 } else {; 3599 writeSequence->AddAction( WriteBasicType_NoFactor<double>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3600 }; 3601 }; 3602 break;; 3603 } */; 3604 //case TStreamerInfo::kTNamed: writeSequence->AddAction( WriteTNamed, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3605 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 3606 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:166077,avoid,avoid,166077,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"et. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. Bool_t IsLearning() const; {return kFALSE;}. void SetSkipZip(Bool_t = kTRUE); {}. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheRead.h 31503 2009-12-02 10:36:50Z brun $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:8623,avoid,avoid,8623,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['avoid'],['avoid']
Safety,"et.GetLayerAt(i)->CopyParameters(*fNet->GetLayerAt(i));; 1288 }; 1289 }; 1290 ; 1291 // when fNet is built create also input matrix that will be used to evaluate it; 1292 if (fBuildNet) {; 1293 //int n1 = batchHeight;; 1294 //int n2 = batchWidth;; 1295 // treat case where batchHeight is the batchSize in case of first Dense layers (then we need to set to fNet batch size); 1296 //if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1) n1 = fNet->GetBatchSize();; 1297 //fXInput = TensorImpl_t(1,n1,n2);; 1298 fXInput = ArchitectureImpl_t::CreateTensor(fNet->GetBatchSize(), GetInputDepth(), GetInputHeight(), GetInputWidth() );; 1299 if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1); 1300 fXInput = TensorImpl_t( fNet->GetBatchSize(), GetInputWidth() );; 1301 fXInputBuffer = HostBufferImpl_t( fXInput.GetSize() );; 1302 ; 1303 ; 1304 // create pointer to output matrix used for the predictions; 1305 fYHat = std::unique_ptr<MatrixImpl_t>(new MatrixImpl_t(fNet->GetBatchSize(), fNet->GetOutputWidth() ) );; 1306 ; 1307 // print the created network; 1308 Log() << ""***** Deep Learning Network *****"" << Endl;; 1309 if (Log().GetMinType() <= kINFO); 1310 deepNet.Print();; 1311 }; 1312 Log() << ""Using "" << nTrainingSamples << "" events for training and "" << nValidationSamples << "" for testing"" << Endl;; 1313 ; 1314 // Loading the training and validation datasets; 1315 TMVAInput_t trainingTuple = std::tie(eventCollectionTraining, DataInfo());; 1316 TensorDataLoader_t trainingData(trainingTuple, nTrainingSamples, batchSize,; 1317 {inputDepth, inputHeight, inputWidth},; 1318 {deepNet.GetBatchDepth(), deepNet.GetBatchHeight(), deepNet.GetBatchWidth()} ,; 1319 deepNet.GetOutputWidth(), nThreads);; 1320 ; 1321 TMVAInput_t validationTuple = std::tie(eventCollectionValidation, DataInfo());; 1322 TensorDataLoader_t validationData(validationTuple, nValidationSamples, batchSize,; 1323 {inputDepth, inputHeight, inputWidth},; 1324 { deepNet.GetBatchDepth(),deepNet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:51190,predict,predictions,51190,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['predictions']
Safety,"etBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveCluster& ); { *((TParticle*)this) = p; return *this; }. TEveCluster(); TEveVector fW; // Cluster widths.; Coord system? Errors and/or widths Wz, Wy?. { fLabel[0] = fLabel[1] = fLabel[2] = 0; }. virtual ~TEveCluster(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 31517 2009-12-03 11:56:23Z matevz $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCluster.html:5040,detect,detector,5040,root/html528/TEveCluster.html,https://root.cern,https://root.cern/root/html528/TEveCluster.html,2,['detect'],['detector']
Safety,"etBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveCluster& ); { *((TParticle*)this) = p; return *this; }. TEveCluster(); TEveVector fW; // Cluster widths.; Coord system? Errors and/or widths Wz, Wy?. { fLabel[0] = fLabel[1] = fLabel[2] = 0; }. virtual ~TEveCluster(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveCluster.html:5109,detect,detector,5109,root/html530/TEveCluster.html,https://root.cern,https://root.cern/root/html530/TEveCluster.html,2,['detect'],['detector']
Safety,"etBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveCluster& ); { *((TParticle*)this) = p; return *this; }. TEveCluster(); TEveVector fW; // Cluster widths.; Coord system? Errors and/or widths Wz, Wy?. { fLabel[0] = fLabel[1] = fLabel[2] = 0; }. virtual ~TEveCluster(); {}. » Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCluster.html:5109,detect,detector,5109,root/html532/TEveCluster.html,https://root.cern,https://root.cern/root/html532/TEveCluster.html,2,['detect'],['detector']
Safety,"etCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePathMarkT<float> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class for TEvePlot3D.; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:63044,safe,safe,63044,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,3,['safe'],['safe']
Safety,etCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending on radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> ; TEvePathMarkT<float> ; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class for TEvePlot3D.; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.; TEvePointSetArray Array of TEvePointSet's filled via a common point-source; range of displayed ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:63475,safe,safe,63475,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['safe'],['safe']
Safety,"etCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending on radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMarkT<double> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePathMarkT<float> Template for a special point on a track: position/momentum reference, daughter creation or decay.; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class for TEvePlot3D.; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:66796,safe,safe,66796,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['safe'],['safe']
Safety,"etLong64_Name(const char* original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. string GetLong64_Name(const string& original); Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. const char * GetUnqualifiedName(const char* name); Return the start of the unqualified name include in 'original'. int GetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). Stores in output (after emptying it) the splited type.; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail).; Return the number of elements stored. First in list is the template name or is empty; ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**""; or ""TNamed*"" to """" ""TNamed"" ""*"". string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). Cleanup type description, redundant blanks removed; and redundant tail ignored; return *tail = pointer to last used character; if (mode==0) keep keywords; if (mode==1) remove keywords outside the template params; if (mode>=2) remove the keywords everywhere.; if (tail!=0) cut before the trailing *. The keywords currently are: ""const"" , ""volatile"" removed. CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"". string ShortType(const char* typeDesc, int mode). Return the absolute type of typeDesc.; E.g.: typeDesc = ""class const volatile TNamed**"", returns ""TNamed**"".; if (mode&1) remove last ""*""s returns ""TNamed""; if (mode&2) remove default allocators from STL containers; if (mode&4) remove all allocators from STL containers; if (mode&8) return inner class of stl container. list<innerClass>; if (mode&16) return deapest class of stl container. vector<list<deapest>>; if (mode&kDropAllDefault) remove default template arguments. bool IsInterpreterDetail(const char* type); Return true if the type is one the interpreter details which are; only forward declared (ClassInfo_t etc..). bool IsSTLBitset(const char* typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassEdit.html:3820,redund,redundant,3820,root/html602/TClassEdit.html,https://root.cern,https://root.cern/root/html602/TClassEdit.html,4,['redund'],['redundant']
Safety,"etPhi2 ; (; ); const. inline . Definition at line 155 of file TGeoTube.h. ◆ GetPointsOnSegments(). Bool_t TGeoTubeSeg::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ InitTrigonometry(). void TGeoTubeSeg::InitTrigonometry ; (; ). protected . ◆ InspectShape(). void TGeoTubeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoTube. ◆ IsA(). TClass * TGeoTubeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoTube.; Definition at line 170 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTubeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoTube. ◆ Safety(). Double_t TGeoTubeSeg::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ Safety_v(). void TGeoTubeSeg::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ SafetyS(). static Double_t TGeoTubeSeg::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTubeSeg::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoTube. ◆ SetDimensions(). void TGeoTubeSeg::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoTube. ◆ SetPoints() [1/2]. void TGeoTubeSeg::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoTube. ◆ SetPoints() [2/2]. void TGeoTubeSeg::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoTube. ◆ SetSegsAndPols(). void TGeoTubeSeg::SetSegsAndPols ; (; TBuffer3D & ; buff); const. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:31829,safe,safe,31829,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['safe'],['safe']
Safety,"etPhi2 ; (; ); const. inline . Definition at line 167 of file TGeoCone.h. ◆ GetPointsOnSegments(). Bool_t TGeoConeSeg::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ InitTrigonometry(). void TGeoConeSeg::InitTrigonometry ; (; ). protected . ◆ InspectShape(). void TGeoConeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoCone. ◆ IsA(). TClass * TGeoConeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoCone.; Definition at line 183 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoConeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoCone. ◆ Safety(). Double_t TGeoConeSeg::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ Safety_v(). void TGeoConeSeg::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ SafetyS(). static Double_t TGeoConeSeg::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoConeSeg::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoCone. ◆ SetConsDimensions(). void TGeoConeSeg::SetConsDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ SetDimensions(). void TGeoConeSeg::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoCone. ◆ SetPoints() [1/2]. void TGeoConeSeg::SetPoints ; (; Double_t * ; points); const. overridevirtual . R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:33245,safe,safe,33245,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['safe'],['safe']
Safety,"etProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset in range 'rangeName'. ; If cache element does not exist, create and fill it on the fly. The cache contains suplemental normalization terms (in case not all added p.d.f.s have the same observables), projection integrals to calculated transformed fraction coefficients when a frozen reference frame is provided and projection integrals for similar transformations when a frozen reference range is provided. ; Definition at line 308 of file RooAddModel.cxx. ◆ IsA(). TClass * RooAddModel::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 131 of file RooAddModel.h. ◆ isDirectGenSafe(). bool RooAddModel::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Direct generation is safe if all components say so. ; Reimplemented from RooAbsPdf.; Definition at line 646 of file RooAddModel.cxx. ◆ pdfList(). const RooArgList & RooAddModel::pdfList ; (; ); const. inline . Return list of component p.d.fs. ; Definition at line 66 of file RooAddModel.h. ◆ printMetaArgs(). void RooAddModel::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 702 of file RooAddModel.cxx. ◆ resetErrorCounters(). void RooAddModel::resetErrorCounters ; (; Int_t ; resetValue = 10). overridevirtual . Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ; Reimplemented from RooAbsPdf.; Definition at line 420 of file RooAddModel.cxx. ◆ selectNormalization(). void RooAddModel::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:88336,safe,safe,88336,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['safe'],['safe']
Safety,"ete RVariation, which forwards all calls to it RJittedVariation is a placeholder that is inserted in the computation graph in place of a RVariation that will be just-in-time compiled. More...;  ; struct  RMetaDataJson;  ; struct  RNewSampleFlag;  ; class  RNewSampleNotifier;  ; class  ROneTimeCallback;  ; struct  RootConversionTraits;  ; struct  RootConversionTraits< bool >;  ; struct  RootConversionTraits< double >;  ; struct  RootConversionTraits< float >;  ; struct  RootConversionTraits< int16_t >;  ; struct  RootConversionTraits< int32_t >;  ; struct  RootConversionTraits< int8_t >;  ; struct  RootConversionTraits< Long64_t >;  ; struct  RootConversionTraits< std::string >;  ; struct  RootConversionTraits< uint16_t >;  ; struct  RootConversionTraits< uint32_t >;  ; struct  RootConversionTraits< uint8_t >;  ; struct  RootConversionTraits< ULong64_t >;  ; class  RRootDS;  This class is unused and it has only been implemented as a proof of concept. More...;  ; class  RStringCache;  A Thread-safe cache for strings. More...;  ; class  RTreeColumnReader;  RTreeColumnReader specialization for TTree values read via TTreeReaderValues. More...;  ; class  RTreeColumnReader< RVec< bool > >;  RTreeColumnReader specialization for arrays of boolean values read via TTreeReaderArrays. More...;  ; class  RTreeColumnReader< RVec< T > >;  RTreeColumnReader specialization for TTree values read via TTreeReaderArrays. More...;  ; class  RTreeColumnReader< std::array< T, N > >;  RTreeColumnReader specialization for TTree values read via TTreeReaderArrays. ;  ; class  RTreeOpaqueColumnReader;  ; class  RVariation;  ; class  RVariationBase;  This type includes all parts of RVariation that do not depend on the callable signature. More...;  ; class  RVariationReader;  Column reader that reads the value for a specific column, variation and slot. More...;  ; class  RVariationsWithReaders;  ; class  RVariedAction;  Just like an RAction, but it has N action helpers and N previous nodes (N is th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:3259,safe,safe,3259,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['safe'],['safe']
Safety,"ete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHype.html:9909,safe,safe,9909,root/html602/TGeoHype.html,https://root.cern,https://root.cern/root/html602/TGeoHype.html,2,['safe'],['safe']
Safety,"eted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. Int_t GetPort() const; { return fPort; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetPerfIdx() const; { return fPerfIdx; }. Int_t GetProtocol() const; { return fProtocol; }. TSocket * GetSocket() const; { return fSocket; }. TProof ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:10420,recover,recovered,10420,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,4,['recover'],['recovered']
Safety,"eter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:16521,safe,safe,16521,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,"['risk', 'safe']","['risk', 'safe']"
Safety,"eter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:33386,safe,safe,33386,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['safe'],['safe']
Safety,"eter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5162,recover,recovery,5162,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"eters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4417,recover,recovery,4417,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"eters, nanoseconds and MegaElectronVolts was better suited for the LHC experiments. All LHC experiments use Geant4 and effectively adopted this convention for all areas of data processing: simulation, reconstruction and data analysis. Hence experiments using the ROOT geometry toolkit to describe the geometry had two different system of units in the application code.; To allow users having the same system of units in the geometry description and the application it is now possible to choose the system of units at startup of the application:; TGeoManager::SetDefaultUnits(xx); xx = kG4Units, kRootUnits; TGeoManager::SetDefaultUnitsstatic void SetDefaultUnits(EDefaultUnits new_value)Definition TGeoManager.cxx:4319; To ensure backwards compatibility ROOT's default system of units is - as it was before - based on centimeters, seconds and GigaElectronVolts, ie. the defaults are equivalent to:; TGeoManager::SetDefaultUnits(kRootUnits);; To avoid confusion between materials described in ROOT units and materials described in Geant4 units, this switch should by all means be set once, before any element or material is constructed. If for whatever reason it is necessary to change the system of units later, this is feasible disabling the otherwise fatal exception:; TGeoManager::LockDefaultUnits(kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TGeoManager::LockDefaultUnitsstatic Bool_t LockDefaultUnits(Bool_t new_value)Definition TGeoManager.cxx:4307; followed later by a corresponding call to again lock the system of units:; TGeoManager::LockDefaultUnits(kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93. Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:16723,avoid,avoid,16723,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"ethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:1235,avoid,avoid,1235,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,6,['avoid'],['avoid']
Safety,"etitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 3938 return UnixHomedirectory(name, path, mydir);; 3939}; 3940 ; 3941////////////////////////////////////////////////////////////////////////////; 3942/// Returns the user's home directory.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125425,timeout,timeout,125425,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"etting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; In the above example, a call to fWebHistogram.GetObject() executes the script with the function GetWebHistogram. This script connects a file with histograms: pippa.root on the ROOT Web site and returns the object h6 to TRef::GetObject.; Note that if the definition of the TRef fWebHistogram had been: TRef fWebHistogram; //EXEC:GetWebHistogram(); then, the compiled or interpreted function GetWebHistogram() would have been called instead of the C++ script GetWebHistogram.C. Special case of a TRef pointing to an object with a TUUID; If the referenced object has a TUUID, its bit kHasUUID has been set. This case is detected by the TRef assignment operator. (For example, TFile and TDirectory have a TUUID) The TRef fPID points directly to the single object TProcessUUID (deriving from TProcessID) and managing the list of TUUIDs for a process. The TRef kHasUUID bit is set and its fUniqueID is set to the fUniqueID of the referenced object.; When the TRef is streamed to a buffer, the corresponding TUUID is also streamed with the TRef. When a TRef is read from a buffer, the corresponding TUUID is also read and entered into the global list of TUUIDs (if not already there). The TRef fUniqueID is set to the UUIDNumber. see TProcessUUID for more details. Array of TRef; The special class TRefArray should be used to store multiple references. A TRefArray has one single pointer fPID for all objects in the array. It has a dynamic compact table of fUniqueIDs. Use a TRefArray rather then a collection of TRefs if all TRefs stem from the same process.; Example:; Suppose a TObjArray *mytracks containing a list of Track objects Su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:9643,detect,detected,9643,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['detect'],['detected']
Safety,"etupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSlave.h 25734 2008-10-07 22:40:37Z ganis $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSlave.html:10180,recover,recovered,10180,root/html528/TXSlave.html,https://root.cern,https://root.cern/root/html528/TXSlave.html,1,['recover'],['recovered']
Safety,"etupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSlave.h 38580 2011-03-23 15:24:54Z ganis $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSlave.html:10476,recover,recovered,10476,root/html530/TXSlave.html,https://root.cern,https://root.cern/root/html530/TXSlave.html,1,['recover'],['recovered']
Safety,"etupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. void FlushSocket(); Clean any input on the socket. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSlave.h 38580 2011-03-23 15:24:54Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSlave.html:10476,recover,recovered,10476,root/html532/TXSlave.html,https://root.cern,https://root.cern/root/html532/TXSlave.html,1,['recover'],['recovered']
Safety,"eturn value is a unique identifier code, that will be passed to coefficient() to identify the basis function for which the coefficient is requested. If the resolution model used does not support the declared basis function, code -1 is returned. ; Definition at line 159 of file RooAbsAnaConvPdf.cxx. ◆ DeclFileName(). static const char * RooAbsAnaConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 120 of file RooAbsAnaConvPdf.h. ◆ evaluate(). double RooAbsAnaConvPdf::evaluate ; (; ); const. overrideprotectedvirtual . Calculate the current unnormalized value of the PDF. ; PDF = sum_k coef_k * [ basis_k (x) ResModel ] ; Implements RooAbsReal.; Definition at line 329 of file RooAbsAnaConvPdf.cxx. ◆ forceAnalyticalInt(). bool RooAbsAnaConvPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ; due to hidden Jacobian terms).; RooAbsAnaConvPdf will not attempt to actually integrate all these dependents but feed them to the resolution models integration interface, which will make the final determination on how to integrate these dependents. ; Reimplemented from RooAbsReal.; Definition at line 566 of file RooAbsAnaConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooAbsAnaConvPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overridevirtual . Create a generator context for this p.d.f. ; If both the p.d.f and the resolution model support internal generation of the convolution observable on an infinite domain, deploy a specialized convolution generator context, which generates the physics distribution and the smearing separately, adding them a posteriori.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:85031,unsafe,unsafe,85031,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['unsafe'],['unsafe']
Safety,"eturns -1 in case of error. ;  ; Int_t GetPort () const;  ; Int_t GetRemoteProtocol () const;  ; TSecContext * GetSecContext () const;  ; const char * GetService () const;  ; Int_t GetServType () const;  ; Int_t GetTcpWindowSize () const;  ; const char * GetUrl () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsAuthenticated () const;  ; virtual Bool_t IsValid () const;  ; virtual Int_t Reconnect ();  ; virtual Int_t Recv (char *mess, Int_t max);  Receive a character string message of maximum max length. ;  ; virtual Int_t Recv (char *mess, Int_t max, Int_t &kind);  Receive a character string message of maximum max length. ;  ; virtual Int_t Recv (Int_t &status, Int_t &kind);  Receives a status and a message type. ;  ; virtual Int_t Recv (TMessage *&mess);  Receive a TMessage object. ;  ; virtual Int_t RecvRaw (void *buffer, Int_t length, ESendRecvOptions opt=kDefault);  Receive a raw buffer of specified length bytes. ;  ; virtual Int_t Select (Int_t interest=kRead, Long_t timeout=-1);  Waits for this socket to change status. ;  ; virtual Int_t Send (const char *mess, Int_t kind=kMESS_STRING);  Send a character string buffer. ;  ; virtual Int_t Send (const TMessage &mess);  Send a TMessage object. ;  ; virtual Int_t Send (Int_t kind);  Send a single message opcode. ;  ; virtual Int_t Send (Int_t status, Int_t kind);  Send a status and a single message opcode. ;  ; virtual Int_t SendObject (const TObject *obj, Int_t kind=kMESS_OBJECT);  Send an object. ;  ; virtual Int_t SendRaw (const void *buffer, Int_t length, ESendRecvOptions opt=kDefault);  Send a raw buffer of specified length. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:3741,timeout,timeout,3741,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['timeout'],['timeout']
Safety,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:7799,safe,safe,7799,doc/master/rf608__fitresultaspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html,1,['safe'],['safe']
Safety,"evel () const;  ; Long64_t GetMsgSizeHWM () const;  ; TDSetElement * GetNextPacket (Long64_t totalEntries=-1);  Get next range of entries to be processed on this server. ;  ; void GetOptions (Int_t *argc, char **argv) override;  Get and handle command line options. ;  ; const char * GetOrdinal () const;  ; TPackMgr * GetPackMgr () const;  ; const char * GetPrefix () const;  ; TProof * GetProof () const;  ; Int_t GetProtocol () const;  ; Int_t GetQuerySeqNum () const;  ; Float_t GetRealTime () const;  ; const char * GetService () const;  ; const char * GetSessionDir () const;  ; const char * GetSessionTag () const;  ; TSocket * GetSocket () const;  ; const char * GetTopSessionTag () const;  ; Int_t GetTotSessions () const;  ; const char * GetUser () const;  ; const char * GetWorkDir () const;  ; virtual EQueryAction GetWorkers (TList *workers, Int_t &prioritychange, Bool_t resume=kFALSE);  Get list of workers to be used from now on. ;  ; void HandleException (Int_t sig) override;  Exception handler: we do not try to recover here, just exit. ;  ; virtual void HandleSigPipe ();  Called when the client is not alive anymore (i.e. ;  ; virtual void HandleSocketInput ();  Handle input coming from the client or from the master server. ;  ; virtual Int_t HandleSocketInput (TMessage *mess, Bool_t all);  Process input coming from the client or from the master server. ;  ; virtual void HandleTermination ();  ; virtual void HandleUrgentData ();  Handle Out-Of-Band data sent by the master or client. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsEndMaster () const;  ; Bool_t IsMaster () const;  ; Bool_t IsParallel () const;  True if in parallel mode. ;  ; Bool_t IsTopMaster () const;  ; void LogToMaster (Bool_t on=kTRUE);  ; void Print (Option_t *option="""") const override;  Print status of slave server. ;  ; Int_t ReceiveFile (const char *file, Bool_t bin, Long64_t size);  Receive a file, either sent by a client or a master server. ;  ; virtual void Releas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:3768,recover,recover,3768,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['recover'],['recover']
Safety,"evel () const;  ; Long64_t GetMsgSizeHWM () const;  ; TDSetElement * GetNextPacket (Long64_t totalEntries=-1);  Get next range of entries to be processed on this server. ;  ; void GetOptions (Int_t *argc, char **argv) override;  Get and handle command line options. ;  ; const char * GetOrdinal () const;  ; TPackMgr * GetPackMgr () const;  ; const char * GetPrefix () const;  ; TProof * GetProof () const;  ; Int_t GetProtocol () const;  ; Int_t GetQuerySeqNum () const;  ; Float_t GetRealTime () const;  ; const char * GetService () const;  ; const char * GetSessionDir () const;  ; const char * GetSessionTag () const;  ; TSocket * GetSocket () const;  ; const char * GetTopSessionTag () const;  ; Int_t GetTotSessions () const;  ; const char * GetUser () const;  ; const char * GetWorkDir () const;  ; virtual EQueryAction GetWorkers (TList *workers, Int_t &prioritychange, Bool_t resume=kFALSE);  Get list of workers to be used from now on. ;  ; void HandleException (Int_t sig) override;  Exception handler: we do not try to recover here, just exit. ;  ; virtual void HandleSocketInput ();  Handle input coming from the client or from the master server. ;  ; virtual Int_t HandleSocketInput (TMessage *mess, Bool_t all);  Process input coming from the client or from the master server. ;  ; virtual void HandleUrgentData ();  Handle Out-Of-Band data sent by the master or client. ;  ; void Interrupt ();  ; Bool_t IsEndMaster () const;  ; Bool_t IsMaster () const;  ; Bool_t IsParallel () const;  True if in parallel mode. ;  ; Bool_t IsTopMaster () const;  ; void LogToMaster (Bool_t on=kTRUE);  ; void Print (Option_t *option="""") const override;  Print status of slave server. ;  ; Int_t ReceiveFile (const char *file, Bool_t bin, Long64_t size);  Receive a file, either sent by a client or a master server. ;  ; virtual void ReleaseWorker (const char *);  ; void Reset (const char *dir);  Reset PROOF environment to be ready for execution of next command. ;  ; void RestartComputeTime ();  R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:3337,recover,recover,3337,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['recover'],['recover']
Safety,"evel, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent.cxx. ◆ Clear(). void JetEvent::Clear ; (; Option_t * ; option = """"). overridevirtual . Reimplemented from TObject.; Definition at line 143 of file JetEvent.cxx. ◆ GetJets(). TClonesArray * JetEvent::GetJets ; (; ); const. inline . Definition at line 96 of file JetEvent.h. ◆ GetNhitA(). Int_t JetEvent::GetNhitA ; (; ); const. inline . Definition at line 90 of file JetEvent.h. ◆ GetNhitB(). Int_t JetEvent::GetNhitB ; (; ); const. inline . Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classJetEvent.html:11508,detect,detector,11508,doc/master/classJetEvent.html,https://root.cern,https://root.cern/doc/master/classJetEvent.html,1,['detect'],['detector']
Safety,"evel, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSelector.h>. Inheritance diagram for TSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15506,abort,aborted,15506,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['abort'],['aborted']
Safety,"ex of this TEntryList in the TTree or TChain; See also Next(). Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the index of ""index""-th non-zero entry in the TTree or TChain; and the # of the corresponding tree in the chain. void GetFileName(const char* filename, TString& fn, Bool_t* = 0); To be able to re-localize the entry-list we identify the file by just the; name and the anchor, i.e. we drop protocol, host, options, ...; The result in the form 'file#anchor' (or 'file', if no anchor is present); is saved in 'fn'.; The function optionally (is 'local' is defined) checks file locality (i.e.; protocol 'file://') returning the result in '*local' . TEntryList * GetEntryList(const char* treename, const char* filename, Option_t* opt = """"); return the entry list, correspoding to treename and filename; By default, the filename is first tried as is, and then, if the corresponding list; is not found, the filename is expanded to the absolute path, and compared again.; To avoid it, use option ""ne"". Int_t Merge(TCollection* list); Merge this list with the lists from the collection. Long64_t Next(); return the next non-zero entry index (next after fLastIndexQueried); this function is faster than GetEntry(). void OptimizeStorage(); Checks if the array representation is more economical and if so, switches to it. void Print(Option_t* option = """") const; Print this list; option = """" - default - print the name of the tree and file; option = ""all"" - print all the entry numbers. void Reset(); Reset this list. void SetDirectory(TDirectory* dir); Add reference to directory dir. dir can be 0. void SetTree(const char* treename, const char* filename); If a list for a tree with such name and filename exists, sets it as the current sublist; If not, creates this list and sets it as the current sublist. ! the filename is taken as provided, no extensions to full path or url !. void SetTree(const TTree* tree); If a list for a tree with such name and filename exists, sets it as the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:20266,avoid,avoid,20266,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,1,['avoid'],['avoid']
Safety,"ex of this TEntryList in the TTree or TChain; See also Next(). Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the index of ""index""-th non-zero entry in the TTree or TChain; and the # of the corresponding tree in the chain. void GetFileName(const char* filename, TString& fn, Bool_t* = 0); To be able to re-localize the entry-list we identify the file by just the; name and the anchor, i.e. we drop protocol, host, options, ...; The result in the form 'file#anchor' (or 'file', if no anchor is present); is saved in 'fn'.; The function optionally (is 'local' is defined) checks file locality (i.e.; protocol 'file://') returning the result in '*local' . TEntryList * GetEntryList(const char* treename, const char* filename, Option_t* opt = """"); return the entry list, correspoding to treename and filename; By default, the filename is first tried as is, and then, if the corresponding list; is not found, the filename is expanded to the absolute path, and compared again.; To avoid it, use option ""ne"". Int_t Merge(TCollection* list); Merge this list with the lists from the collection. Long64_t Next(); return the next non-zero entry index (next after fLastIndexQueried); this function is faster than GetEntry(). void OptimizeStorage(); Checks if the array representation is more economical and if so, switches to it. void Print(const Option_t* option = """") const; Print this list; option = """" - default - print the name of the tree and file; option = ""all"" - print all the entry numbers. void Reset(); Reset this list. void SetDirectory(TDirectory* dir); Add reference to directory dir. dir can be 0. void SetTree(const char* treename, const char* filename); If a list for a tree with such name and filename exists, sets it as the current sublist; If not, creates this list and sets it as the current sublist. ! the filename is taken as provided, no extensions to full path or url !. void SetTree(const TTree* tree); If a list for a tree with such name and filename exists, sets it as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:20718,avoid,avoid,20718,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,2,['avoid'],['avoid']
Safety,"ex() (preferred) or lookupName() instead. ; Member RooAbsCategory::typeIterator () const; Use begin() and end() instead. ; Class RooAbsCategoryLegacyIterator ; Legacy class to iterate through legacy RooAbsCategory states. Use RooAbsCategory::begin(), RooAbsCategory::end() or range-based for loops instead. Member RooAbsData::statOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Classing parameter formatting options, provided for backward compatibility ; Member RooCategoryProxy ; Use RooTemplateProxy<RooAbsCategory> or more appropriate template parameters. ; Member RooDataHist::binVolume () const; Use binVolume(std::size_t) const. ; Member RooDataHist::calcTreeIndex () const; Use calcTreeIndex(const RooArgSet&,bool) const. ; Member RooDataHist::set (double wgt, double wgtErr=-1); Use set(std::size_t,double,double) ; Member RooDataHist::weight () const override; Use the safer weight(std::size_t) const. ; Member RooDataHist::weightSquared () const override; Use the safer weightSquared(std::size_t) const. ; Member RooRealProxy ; Use RooTemplateProxy<RooAbsReal> or more appropriate template parameters. ; Member RooStats::HistFactory::FitModel (RooWorkspace *, std::string data_name=""obsData"") R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FitModelAndPlot (const std::string &measurementName, const std::string &fileNamePrefix, RooWorkspace &, std::string, std::string, TFile &, std::ostream &) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/deprecated.html:3130,safe,safer,3130,doc/master/deprecated.html,https://root.cern,https://root.cern/doc/master/deprecated.html,1,['safe'],['safer']
Safety,"exp1);; 2407 }; 2408 }; 2409 }; 2410 }; 2411 ; 2412 if (m) {; 2413 igood += 1;; 2414 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2415 }; 2416 if (n) {; 2417 igood += 2;; 2418 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2419 }; 2420 ; 2421 Double_t prob = TMath::Prob(chi2, ndf);; 2422 ; 2423 return prob;; 2424 }; 2425 ; 2426 // weighted - weighted comparison; 2427 if (comparisonWW) {; 2428 for (Int_t i = i_start; i <= i_end; ++i) {; 2429 for (Int_t j = j_start; j <= j_end; ++j) {; 2430 for (Int_t k = k_start; k <= k_end; ++k) {; 2431 ; 2432 Int_t bin = GetBin(i, j, k);; 2433 Double_t cnt1 = RetrieveBinContent(bin);; 2434 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2435 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2436 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2437 ; 2438 // case both histogram have zero bin contents; 2439 // (use square of content to avoid numerical errors); 2440 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2441 --ndf; //no data means one degree of freedom less; 2442 continue;; 2443 }; 2444 ; 2445 if (e1sq == 0 && e2sq == 0) {; 2446 // cannot treat case of booth histogram have zero zero errors; 2447 Error(""Chi2TestX"",""h1 and h2 both have bin %d,%d,%d with all zero errors\n"", i,j,k);; 2448 chi2 = 0; return 0;; 2449 }; 2450 ; 2451 Double_t sigma = sum1 * sum1 * e2sq + sum2 * sum2 * e1sq;; 2452 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2453 chi2 += delta * delta / sigma;; 2454 ; 2455 if (res) {; 2456 Double_t temp = cnt1 * sum1 * e2sq + cnt2 * sum2 * e1sq;; 2457 Double_t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:96860,avoid,avoid,96860,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ey.cxx. ◆ ReadObject(). template<typename T > . T * TKey::ReadObject ; (; ). inline . To read an object (non deriving from TObject) from the file. ; This is more user friendly version of TKey::ReadObjectAny. See TKey::ReadObjectAny for more details. ; Definition at line 103 of file TKey.h. ◆ ReadObjectAny(). void * TKey::ReadObjectAny ; (; const TClass * ; expectedClass). virtual . To read an object (non deriving from TObject) from the file. ; If expectedClass is not null, we checked that that actual class of the object stored is suitable to be stored in a pointer pointing to an object of class 'expectedClass'. We also adjust the value of the returned address so that it is suitable to be cast (C-Style) a pointer pointing to an object of class 'expectedClass'.; So for example if the class Bottom inherits from Top and the object stored is of type Bottom you can safely do: auto TopClass = TClass::GetClass(""Top"");; auto ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; The object associated to this key is read from the file into memory. Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the TClass object for this class. A TClass object contains a full description (i.e. dictionary) of the associated class. In particular the TClass object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself. ; Reimplemented in TKeySQL, and TKeyXML.; Definition at line 1024 of file TKey.cxx. ◆ ReadObjWithBuffer(). TObject * TKey::ReadObjWithBuffer ; (; char * ; bufferRead). virtual . To read a TObject* from bufferRead. ; This function is identical to TKey::ReadObj, but it re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:29997,safe,safely,29997,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['safe'],['safely']
Safety,"f ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFont.html:14336,sanity check,sanity check,14336,root/html528/TGFont.html,https://root.cern,https://root.cern/root/html528/TGFont.html,1,['sanity check'],['sanity check']
Safety,"f (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,; 20069 NULL, /* No truncation check for error buffers */; 20070 error->text,; 20071 error->text_buffer_size,; 20072 ""%s"",; 20073 err_msg);; 20074 }; 20075 free_context(ctx);; 20076 pthread_setspecific(sTlsKey, NULL);; 20077 return NULL;; 20078 }; 20079 ; 20080 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:599549,abort,abort,599549,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:599582,abort,abort,599582,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"f ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:174812,timeout,timeout,174812,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"f ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:174844,timeout,timeout,174844,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"f (index >= 0) {; 3748 fReadActionSequence->AddToOffset( - parent->fBranchOffset[index] );; 3749 }; 3750 }; 3751 ; 3752 fInitOffsets = true;; 3753}; 3754 ; 3755////////////////////////////////////////////////////////////////////////////////; 3756/// Return true if more than one leaf, false otherwise.; 3757 ; 3758bool TBranchElement::IsFolder() const; 3759{; 3760 Int_t nbranches = fBranches.GetEntriesFast();; 3761 if (nbranches >= 1) {; 3762 return true;; 3763 }; 3764 TList* browsables = const_cast<TBranchElement*>(this)->GetBrowsables();; 3765 return browsables && browsables->GetSize();; 3766}; 3767 ; 3768////////////////////////////////////////////////////////////////////////////////; 3769/// Detect a collection written using a zero pointer in old versions of root.; 3770/// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; 3771/// or STL container) was split but the pointer to the collection was zeroed; 3772/// out, nothing was saved. Hence there is no __easy__ way to detect the; 3773/// case. In newer versions, a zero is written so that a 'missing' collection; 3774/// appears to be an empty collection.; 3775 ; 3776bool TBranchElement::IsMissingCollection() const; 3777{; 3778 bool ismissing = false;; 3779 TBasket* basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);; 3780 if (basket && fTree) {; 3781 Long64_t entry = fTree->GetReadEntry();; 3782 Long64_t first = fBasketEntry[fReadBasket];; 3783 Long64_t last;; 3784 if (fReadBasket == fWriteBasket) {; 3785 last = fEntryNumber - 1;; 3786 } else {; 3787 last = fBasketEntry[fReadBasket+1] - 1;; 3788 }; 3789 Int_t* entryOffset = basket->GetEntryOffset();; 3790 Int_t bufbegin;; 3791 Int_t bufnext;; 3792 if (entryOffset) {; 3793 bufbegin = entryOffset[entry-first];; 3794 ; 3795 if (entry < last) {; 3796 bufnext = entryOffset[entry+1-first];; 3797 } else {; 3798 bufnext = basket->GetLast();; 3799 }; 3800 if (bufnext == bufbegin) {; 3801 ismissing = true;; 3802 } else {; 3803 // fixed length buffer so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:138790,detect,detect,138790,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['detect'],['detect']
Safety,"f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poisson; 2067/// probability that given a number of entries in a particular bin,; 2068/// the fit would predict it's value. This is then done for each bin,; 2069/// and the sum of the logs is taken as the likelihood.; 2070/// PDF: P=exp(-f(x_i))/[F_i]!*(f(x_i))^[F_i]; 2071/// where F_i - experimental value, f(x_i) - expected theoretical value; 2072/// [F_i] - integer part of F_i.; 2073/// drawback is that if F_i>Int_t - GetSumLog will fail; 2074/// for big F_i is faster to use Euler's Gamma-function; 2075 ; 2076void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:60421,predict,predict,60421,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['predict'],['predict']
Safety,"f TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:68313,safe,safety,68313,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34638,recover,recovered,34638,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:1723,detect,detects,1723,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['detect'],['detects']
Safety,"f extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If correctForBinSize is true the RooDataHist; 1116/// is filled with the functions density (function value times the; 1117/// bin volume) rather than function value.; 1118///; 1119/// If showProgress is true; 1120/// a process indicator is printed on stdout in steps of one percent,; 1121/// which is mostly useful for the sampling of expensive functions; 1122/// such as likelihoods; 1123 ; 1124RooDataHist* RooAbsReal::fillDataHist(RooDataHist *hist, const RooArgSet* normSet, double scaleFactor,; 1125 bool correctForBinSize, bool showProgress) const; 1126{; 1127 // Do we have a valid histogram to use?; 1128 if(nullptr == hist) {; 1129 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillDataHist: no valid RooDataHist to fill"" << std::endl;; 1130 return nullptr;; 1131 }; 1132 ; 1133 // Call checkObservables; 1134 RooArgSet allDeps(*hist->get()) ;; 1135 if (checkObservables(&allDeps)) {; 1136 coutE(InputArguments) << ""RooAbsReal::fillDataHist("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1137 return hist ;; 1138 }; 1139 ; 1140 // Make deep clone of self and attach to dataset observables; 1141 //RooArgSet* origObs = getObservables(hist) ;; 1142 RooArgSet cloneSet;; 1143 RooArgSet(*this).snapshot(cloneSet, true);; 1144 RooAbsReal* theClone = static_cast<RooAbsReal*>(cloneSet.find(GetName()));; 1145 theClone->recursiveRedirectServers(*hist->get()) ;; 1146 //const_cast<RooAbsReal*>(this)->recursiveRedirectServers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:46078,abort,abort,46078,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety,"f file THttpServer.h. ◆ Hide(). Bool_t THttpServer::Hide ; (; const char * ; fullname, . Bool_t ; hide = kTRUE . ). Hides folder or element from web gui. ; Definition at line 1436 of file THttpServer.cxx. ◆ IsA(). TClass * THttpServer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 198 of file THttpServer.h. ◆ IsAnyEngine(). Bool_t THttpServer::IsAnyEngine ; (; ); const. inline . Definition at line 86 of file THttpServer.h. ◆ IsCors(). Bool_t THttpServer::IsCors ; (; ); const. inline . Returns kTRUE if CORS was configured. ; Definition at line 112 of file THttpServer.h. ◆ IsCorsCredentials(). Bool_t THttpServer::IsCorsCredentials ; (; ); const. inline . Returns kTRUE if Access-Control-Allow-Credentials header should be used. ; Definition at line 121 of file THttpServer.h. ◆ IsFileRequested(). Bool_t THttpServer::IsFileRequested ; (; const char * ; uri, . TString & ; res . ); const. Check if file is requested, thread safe. ; Verifies that request is just file name.; File names typically contains prefix like ""jsrootsys/"" If true, method returns real name of the file, which should be delivered to the client Method is thread safe and can be called from any thread ; Definition at line 612 of file THttpServer.cxx. ◆ IsReadOnly(). Bool_t THttpServer::IsReadOnly ; (; ); const. returns read-only mode ; Definition at line 285 of file THttpServer.cxx. ◆ IsTerminated(). Bool_t THttpServer::IsTerminated ; (; ); const. inline . returns kTRUE, if server was terminated ; Definition at line 105 of file THttpServer.h. ◆ IsWSOnly(). Bool_t THttpServer::IsWSOnly ; (; ); const. returns true if only websockets are handled by the server ; Typically used by WebGui ; Definition at line 307 of file THttpServer.cxx. ◆ MissedRequest(). void THttpServer::MissedRequest ; (; THttpCallArg * ; arg). protectedvirtual . Method called when THttpServer cannot process request. ; By default such requests replied with 404",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:27119,safe,safe,27119,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['safe'],['safe']
Safety,"f not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89733,recover,recovered,89733,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety,"f not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85479,recover,recovered,85479,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"f not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67530,recover,recovered,67530,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"f option ==""i"", a TGraph is created with points computed with the integral at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral at the fNpx+1 points of f and the integral is normalized to 1. . Definition at line 374 of file TGraph.cxx. ◆ TGraph() [12/12]. TGraph::TGraph ; (; const char * ; filename, . const char * ; format = ""%lg %lg"", . Option_t * ; option = """" . ). Graph constructor reading input from filename. ; filename is assumed to contain at least two columns of numbers. The string format is by default ""%lg %lg"". This is a standard c formatting for scanf(). For example, set format to ""%lg,%lg"" for a comma-separated file.; If columns of numbers should be skipped, a ""%*lg"" or ""%*s"" for each column can be added, e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files) you can avoid using %*s to bypass this delimiter by explicitly specify the option argument, e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';') used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1""). Note in that case, the instantiation is about two times slower. ; Definition at line 439 of file TGraph.cxx. ◆ ~TGraph(). TGraph::~TGraph ; (; ). override . Graph default destructor. ; Definition at line 566 of file TGraph.cxx. Member Function Documentation. ◆ Add(). void TGraph::Add ; (; TF1 * ; f, . Double_t ; c1 = 1 . ). virtual . Performs the operation: y = y + c1*f(x,y) Errors are not recalculated. ; Parameters. fmay be a 1-D function TF1 or 2-d function TF2 ; c1a scaling factor, 1 by default . Definition at line 622 of file TGraph.cxx. ◆ AddPoint(). virtual void TGraph::AddPoint ; (; Double_t ; x, . Double_t ; y . ). inlinevirtual . Append a new point to the graph. ; Definition at line 98 of file TGraph.h. ◆ Allocate(). Double_t ** TGraph::Allocate ; (; Int_t ; newsize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:35557,avoid,avoid,35557,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['avoid'],['avoid']
Safety,"f special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:26356,avoid,avoid,26356,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['avoid'],['avoid']
Safety,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:39829,safe,safe,39829,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['safe'],['safe']
Safety,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromize; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:37684,safe,safe,37684,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['safe'],['safe']
Safety,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:41110,safe,safe,41110,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['safe'],['safe']
Safety,"f the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatime::GetDateTimestatic void GetDateTime(UInt_t datetime, Int_t &date, Int_t &time)Static function that returns the date and time.Definition TDati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:202993,safe,safe,202993,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['safe'],['safe']
Safety,"f this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186283,timeout,timeout,186283,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"f this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186315,timeout,timeout,186315,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"f twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:16229,safe,safe,16229,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,1,['safe'],['safe']
Safety,"f();; 3205 if (fEntryOffsetLen > 10 && (4*nevbuf) < fEntryOffsetLen ) {; 3206 // Make sure that the fEntryOffset array does not stay large unnecessarily.; 3207 fEntryOffsetLen = nevbuf < 3 ? 10 : 4*nevbuf; // assume some fluctuations.; 3208 } else if (fEntryOffsetLen && nevbuf > fEntryOffsetLen) {; 3209 // Increase the array ...; 3210 fEntryOffsetLen = 2*nevbuf; // assume some fluctuations.; 3211 }; 3212 ; 3213 // Note: captures `basket`, `where`, and `this` by value; modifies the TBranch and basket,; 3214 // as we make a copy of the pointer. We cannot capture `basket` by reference as the pointer; 3215 // itself might be modified after `WriteBasketImpl` exits.; 3216 auto doUpdates = [this, basket, where]() {; 3217 Int_t nout = basket->WriteBuffer(); // Write buffer; 3218 if (nout < 0); 3219 Error(""WriteBasketImpl"", ""basket's WriteBuffer failed."");; 3220 fBasketBytes[where] = basket->GetNbytes();; 3221 fBasketSeek[where] = basket->GetSeekKey();; 3222 Int_t addbytes = basket->GetObjlen() + basket->GetKeylen();; 3223 TBasket *reusebasket = nullptr;; 3224 if (nout>0) {; 3225 // The Basket was written so we can now safely reuse it.; 3226 fBaskets[where] = nullptr;; 3227 ; 3228 reusebasket = basket;; 3229 reusebasket->WriteReset();; 3230 ; 3231 fZipBytes += nout;; 3232 fTotBytes += addbytes;; 3233 fTree->AddTotBytes(addbytes);; 3234 fTree->AddZipBytes(nout);; 3235#ifdef R__TRACK_BASKET_ALLOC_TIME; 3236 fTree->AddAllocationTime(reusebasket->GetResetAllocationTime());; 3237#endif; 3238 fTree->AddAllocationCount(reusebasket->GetResetAllocationCount());; 3239 }; 3240 ; 3241 if (where==fWriteBasket) {; 3242 ++fWriteBasket;; 3243 if (fWriteBasket >= fMaxBaskets) {; 3244 ExpandBasketArrays();; 3245 }; 3246 if (reusebasket && reusebasket == fCurrentBasket) {; 3247 // The 'current' basket has Reset, so if we need it we will need; 3248 // to reload it.; 3249 fCurrentBasket = nullptr;; 3250 fFirstBasketEntry = -1;; 3251 fNextBasketEntry = -1;; 3252 }; 3253 fBaskets.AddAtAndExpand(re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:114711,safe,safely,114711,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['safe'],['safely']
Safety,"f(x,y,em,tau,sde) Background: Poisson; Efficiency: Gaussian; when the background is simultaneously measured from sidebands (or MC), and the efficiency is modeled as Gaussian; 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb) Background: Gaussian; Efficiency: Gaussian; when background and efficiency can both be modeled as Gaussian.; 4: SetPoissonBkgKnownEff(x,y,tau,e) Background: Poisson; Efficiency: Known; when the background is simultaneously measured from sidebands (or MC).; 5: SetGaussBkgKnownEff(x,bm,sdb,e) Background: Gaussian; Efficiency: Known; when background is Gaussian; 6: SetKnownBkgBinomEff(x,z,b,m) Background: Known; Efficiency: Binomial; when signal efficiency was determined from Monte Carlo; 7: SetKnownBkgGaussEff(x,em,sde,b) Background: Known; Efficiency: Gaussian; when background is known and efficiency Gaussian. Parameters and further explanation; For all models:; x = number of observed events in the experiment; xDouble_t x[n]Definition legend1.C:17; Efficiency (e or em) is the detection probability for signal. A low efficiency hence generally means weaker limits. If the efficiency of an experiment (with analysis cuts) is dealt with elsewhere, em or e can be set to one.; For Poisson background measurements (sideband or MC):; y = number of observed events in background region; tau =; Either: the ratio between signal and background region; in case background is observed.; Or: the ratio between observed and simulated live-time; in case background is determined from MC.; yDouble_t y[n]Definition legend1.C:17; For Gaussian efficiency or background:; bm = estimate of the background; sdb = corresponding standard deviation; ; em = estimate of the efficiency; sde = corresponding standard deviation; If the efficiency scale of dealt with elsewhere, set em to 1 and sde to the relative uncertainty.; For Binomial signal efficiency:; m = number of MC events generated; z = number of MC events observed; mTMarker mDefinition textangle.C:8; For the case of known background expe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRolke.html:2577,detect,detection,2577,doc/master/classTRolke.html,https://root.cern,https://root.cern/doc/master/classTRolke.html,1,['detect'],['detection']
Safety,"f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSlave.html:11415,abort,abort,11415,root/html604/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSlave.html,1,['abort'],['abort']
Safety,"f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; void h1analysisTreeReader::SlaveBegin(TTree *myTree){; ; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Init(myTree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.Data(), myTree);; ; //create histograms; hdmd = new TH1F(""hdmd"",""Dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs Dm_d"",30,0.135,0.165,30,-3,6);; ; fOutput->Add(hdmd);; fOutput->Add(h2);; ; // Entry list stuff (re-parse option because on PROOF only SlaveBegin is called); if (option.Contains(""fillList"")) {; fillList = kTRUE;; // Get the list; if (fInput) {; if ((elist = (TEntryList *) fInput->FindObject(""elist""))); // Need to clone to avoid problems when destroying the selector; elist = (TEntryList *) elist->Clone();; if (elist); fOutput->Add(elist);; else; fillList = kFALSE;; }; }; if (fillList) Info(""SlaveBegin"", ""creating an entry-list"");; if (option.Contains(""useList"")) useList = kTRUE;; }; ; void h1analysisTreeReader::Terminate() {; // function called at the end of the event loop; ; hdmd = dynamic_cast<TH1F*>(fOutput->FindObject(""hdmd""));; h2 = dynamic_cast<TH2F*>(fOutput->FindObject(""h2""));; ; if (hdmd == nullptr || h2 == nullptr) {; Error(""Terminate"", ""hdmd = %p , h2 = %p"", hdmd, h2);; return;; }; ; //create the canvas for the h1analysis fit; gStyle->SetOptFit();; TCanvas *c1 = new TCanvas(""c1"",""h1analysis analysis"",10,10,800,600);; c1->SetBottomMargin(0.15);; hdmd->GetXaxis()->SetTitle(""m_{K#pi#pi} - m_{K#pi}[GeV/c^{2}]"");; hdmd->GetXaxis()->SetTitleOffset(1.4);; ; //fit histogram hdmd with function f5 using the loglfIkelihood option; if (gROOT->GetListOfFunctions()->FindObject(""f5"")); delete gROOT->GetFunction(""f5"");; TF1 *f5 = new TF1(""f5""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:4692,avoid,avoid,4692,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['avoid'],['avoid']
Safety,"fArch (std::vector< TMatrixT< Scalar_t > > &A, const std::vector< AMatrix_t > &B);  ; Activation Functions; For each activation function, the low-level interface contains two routines.; One that applies the activation function to a matrix and one that evaluate the derivatives of the activation function at the elements of a given matrix and writes the results into the result matrix. . static void Identity (TMatrixT< AReal > &B);  ; static void IdentityDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Relu (TMatrixT< AReal > &B);  ; static void ReluDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Sigmoid (TMatrixT< AReal > &B);  ; static void SigmoidDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Tanh (TMatrixT< AReal > &B);  ; static void TanhDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void FastTanh (Tensor_t &B);  ; static void FastTanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SymmetricRelu (TMatrixT< AReal > &B);  ; static void SymmetricReluDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void SoftSign (TMatrixT< AReal > &B);  ; static void SoftSignDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Gauss (TMatrixT< AReal > &B);  ; static void GaussDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; Loss Functions; Loss functions compute a scalar value given the output of the network for a given training input and the expected network prediction Y that quantifies the quality of the prediction.; For each function also a routing that computes the gradients (suffixed by Gradients) must be provided for the starting of the backpropagation algorithm. . static AReal MeanSquaredError (const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  ; static void MeanSquaredErrorGradients (TMatrixT< AReal > &dY, const TMatrixT< AReal > &Y, const TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:10479,predict,prediction,10479,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,2,['predict'],['prediction']
Safety,"fBuildingROOTStage1) {; 4959 rootclingRetCode += FinalizeStreamerInfoWriting(interp);; 4960 }; 4961 } else {; 4962 rootclingRetCode += GenerateFullDict(*splitDictStream,; 4963 interp,; 4964 scan,; 4965 constructorTypes,; 4966 gOptSplit,; 4967 isGenreflex,; 4968 isSelXML,; 4969 gOptWriteEmptyRootPCM);; 4970 }; 4971 ; 4972 if (rootclingRetCode != 0) {; 4973 return rootclingRetCode;; 4974 }; 4975 ; 4976 // Now we have done all our looping and thus all the possible; 4977 // annotation, let's write the pcms.; 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203423,detect,detectedUmbrella,203423,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety,"fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;; 2114 classname = new char[nwhc+1];; 2115 int i, nwhci = nwhc;; 2116 for (i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 2117 classname[nwhci] = '\0';; 2118 TDatime::GetDateTime(datime, date, time);; 2119 TClass *tclass = TClass::GetClass(classname);; 2120 if (seekpdir == fSeekDir && tclass && !tclass->InheritsFrom(TFile::Class()); 2121 && strcmp(classname,""TBasket"")) {; 2122 key = new TKey(this);; 2123 key->ReadKeyBuffer(bufread);; 2124 if (!strcmp(key->GetName(),""StreamerInfo"")) {; 2125 fSeekInfo = seekkey;; 2126 SafeDelete(fInfoCache);; 2127 fNbytesInfo = nbytes;; 2128 } else {; 2129 AppendKey(key);; 2130 nrecov++;; 2131 SetBit(kRecovered);; 2132 Info(""Recover"", ""%s, recovered key %s:%s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:76031,recover,recovered,76031,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety,"fGamma. protected . Definition at line 111 of file MethodRSVM.h. ◆ fKernel. TString TMVA::MethodRSVM::fKernel. protected . Definition at line 104 of file MethodRSVM.h. ◆ fModel. ROOT::R::TRObject* TMVA::MethodRSVM::fModel. protected . Definition at line 131 of file MethodRSVM.h. ◆ fMvaCounter. UInt_t TMVA::MethodRSVM::fMvaCounter. protected . Definition at line 83 of file MethodRSVM.h. ◆ fNu. Float_t TMVA::MethodRSVM::fNu. protected . Definition at line 115 of file MethodRSVM.h. ◆ fProbability. Bool_t TMVA::MethodRSVM::fProbability. protected . Definition at line 124 of file MethodRSVM.h. ◆ fProbResultForTestSig. std::vector<Float_t> TMVA::MethodRSVM::fProbResultForTestSig. protected . Definition at line 85 of file MethodRSVM.h. ◆ fProbResultForTrainSig. std::vector<Float_t> TMVA::MethodRSVM::fProbResultForTrainSig. protected . Definition at line 84 of file MethodRSVM.h. ◆ fScale. Bool_t TMVA::MethodRSVM::fScale. protected . Definition at line 88 of file MethodRSVM.h. ◆ fShrinking. Bool_t TMVA::MethodRSVM::fShrinking. protected . Definition at line 119 of file MethodRSVM.h. ◆ fTolerance. Float_t TMVA::MethodRSVM::fTolerance. protected . Definition at line 117 of file MethodRSVM.h. ◆ fType. TString TMVA::MethodRSVM::fType. protected . Definition at line 93 of file MethodRSVM.h. ◆ IsModuleLoaded. Bool_t MethodRSVM::IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""e1071""). staticprotected . Definition at line 127 of file MethodRSVM.h. ◆ predict. ROOT::R::TRFunctionImport TMVA::MethodRSVM::predict. protected . Definition at line 129 of file MethodRSVM.h. ◆ svm. ROOT::R::TRFunctionImport TMVA::MethodRSVM::svm. protected . Definition at line 128 of file MethodRSVM.h. Libraries for TMVA::MethodRSVM:. [legend]; The documentation for this class was generated from the following files:; tmva/rmva/inc/TMVA/MethodRSVM.h; tmva/rmva/src/MethodRSVM.cxx. TMVAMethodRSVM. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html:35099,predict,predict,35099,doc/master/classTMVA_1_1MethodRSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html,2,['predict'],['predict']
Safety,"fPlayer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerLocal.html:10844,abort,abort,10844,root/html530/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html530/TProofPlayerLocal.html,16,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"fPlayerRemote::SetMerging ; (; Bool_t ; on = kTRUE). overridevirtual . Switch on/off merge timer. ; Reimplemented from TProofPlayer.; Definition at line 1814 of file TProofPlayer.cxx. ◆ SetSelectorDataMembersFromOutputList(). void TProofPlayerRemote::SetSelectorDataMembersFromOutputList ; (; ). protected . Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster. ◆ StreamerNVirtual(). void TProofPlayerRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 366",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37217,abort,abort,37217,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['abort'],['abort']
Safety,"fSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Mar 10 17:13:55 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:26739,safe,safe,26739,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['safe'],['safe']
Safety,fTitleTextColortitle text color selection widget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTit,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:45280,avoid,avoid,45280,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['avoid'],['avoid']
Safety,"fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMC.html:35141,abort,aborted,35141,root/html534/TVirtualMC.html,https://root.cern,https://root.cern/root/html534/TVirtualMC.html,1,['abort'],['aborted']
Safety,"fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualMC.html:36130,abort,aborted,36130,root/html604/TVirtualMC.html,https://root.cern,https://root.cern/root/html604/TVirtualMC.html,1,['abort'],['aborted']
Safety,"fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMC.html:36130,abort,aborted,36130,root/html602/TVirtualMC.html,https://root.cern,https://root.cern/root/html602/TVirtualMC.html,1,['abort'],['aborted']
Safety,"fault value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:19745,timeout,timeout,19745,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['timeout'],['timeout']
Safety,"faultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21190,avoid,avoid,21190,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['avoid'],['avoid']
Safety,"fd[1];; 9202 int pollres;; 9203 int ms_wait = 10000; /* 10 second timeout */; 9204 stop_flag_t nonstop;; 9205 STOP_FLAG_ASSIGN(&nonstop, 0);; 9206 ; 9207 /* For a non-blocking socket, the connect sequence is:; 9208 * 1) call connect (will not block); 9209 * 2) wait until the socket is ready for writing (select or poll); 9210 * 3) check connection state with getsockopt; 9211 */; 9212 pfd[0].fd = *sock;; 9213 pfd[0].events = POLLOUT;; 9214 pollres = mg_poll(pfd, 1, ms_wait, ctx ? &(ctx->stop_flag) : &nonstop);; 9215 ; 9216 if (pollres != 1) {; 9217 /* Not connected */; 9218 mg_snprintf(NULL,; 9219 NULL, /* No truncation check for ebuf */; 9220 ebuf,; 9221 ebuf_len,; 9222 ""connect(%s:%d): timeout"",; 9223 host,; 9224 port);; 9225 closesocket(*sock);; 9226 *sock = INVALID_SOCKET;; 9227 return 0;; 9228 }; 9229 ; 9230#if defined(_WIN32); 9231 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);; 9232#else; 9233 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);; 9234#endif; 9235 ; 9236 if ((ret == 0) && (sockerr == 0)) {; 9237 conn_ret = 0;; 9238 }; 9239 }; 9240 ; 9241 if (conn_ret != 0) {; 9242 /* Not connected */; 9243 mg_snprintf(NULL,; 9244 NULL, /* No truncation check for ebuf */; 9245 ebuf,; 9246 ebuf_len,; 9247 ""connect(%s:%d): error %s"",; 9248 host,; 9249 port,; 9250 strerror(sockerr));; 9251 closesocket(*sock);; 9252 *sock = INVALID_SOCKET;; 9253 return 0;; 9254 }; 9255 ; 9256 return 1;; 9257}; 9258 ; 9259 ; 9260int; 9261mg_url_encode(const char *src, char *dst, size_t dst_len); 9262{; 9263 static const char *dont_escape = ""._-$,;~()"";; 9264 static const char *hex = ""0123456789abcdef"";; 9265 char *pos = dst;; 9266 const char *end = dst + dst_len - 1;; 9267 ; 9268 for (; ((*src != '\0') && (pos < end)); src++, pos++) {; 9269 if (isalnum((unsigned char)*src); 9270 || (strchr(dont_escape, *src) != NULL)) {; 9271 *pos = *src;; 9272 } else if (pos + 2 < end) {; 9273 pos[0] = '%';; 9274 pos[1] = hex[(unsigned char)*src >> 4];; 9275 pos[2] = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:264569,timeout,timeout,264569,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"fd[1];; 9203 int pollres;; 9204 int ms_wait = 10000; /* 10 second timeout */; 9205 stop_flag_t nonstop;; 9206 STOP_FLAG_ASSIGN(&nonstop, 0);; 9207 ; 9208 /* For a non-blocking socket, the connect sequence is:; 9209 * 1) call connect (will not block); 9210 * 2) wait until the socket is ready for writing (select or poll); 9211 * 3) check connection state with getsockopt; 9212 */; 9213 pfd[0].fd = *sock;; 9214 pfd[0].events = POLLOUT;; 9215 pollres = mg_poll(pfd, 1, ms_wait, ctx ? &(ctx->stop_flag) : &nonstop);; 9216 ; 9217 if (pollres != 1) {; 9218 /* Not connected */; 9219 mg_snprintf(NULL,; 9220 NULL, /* No truncation check for ebuf */; 9221 ebuf,; 9222 ebuf_len,; 9223 ""connect(%s:%d): timeout"",; 9224 host,; 9225 port);; 9226 closesocket(*sock);; 9227 *sock = INVALID_SOCKET;; 9228 return 0;; 9229 }; 9230 ; 9231#if defined(_WIN32); 9232 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);; 9233#else; 9234 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);; 9235#endif; 9236 ; 9237 if ((ret == 0) && (sockerr == 0)) {; 9238 conn_ret = 0;; 9239 }; 9240 }; 9241 ; 9242 if (conn_ret != 0) {; 9243 /* Not connected */; 9244 mg_snprintf(NULL,; 9245 NULL, /* No truncation check for ebuf */; 9246 ebuf,; 9247 ebuf_len,; 9248 ""connect(%s:%d): error %s"",; 9249 host,; 9250 port,; 9251 strerror(sockerr));; 9252 closesocket(*sock);; 9253 *sock = INVALID_SOCKET;; 9254 return 0;; 9255 }; 9256 ; 9257 return 1;; 9258}; 9259 ; 9260 ; 9261int; 9262mg_url_encode(const char *src, char *dst, size_t dst_len); 9263{; 9264 static const char *dont_escape = ""._-$,;~()"";; 9265 static const char *hex = ""0123456789abcdef"";; 9266 char *pos = dst;; 9267 const char *end = dst + dst_len - 1;; 9268 ; 9269 for (; ((*src != '\0') && (pos < end)); src++, pos++) {; 9270 if (isalnum((unsigned char)*src); 9271 || (strchr(dont_escape, *src) != NULL)) {; 9272 *pos = *src;; 9273 } else if (pos + 2 < end) {; 9274 pos[0] = '%';; 9275 pos[1] = hex[(unsigned char)*src >> 4];; 9276 pos[2] = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:264601,timeout,timeout,264601,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"fer object is filled via the class::Streamer function. -If the file is compressed (default) a second buffer is created to; hold the compressed buffer. -Reservation of the corresponding space in the file by looking; in the TFree list of free blocks of the file. -The buffer is written to the file. By default, the buffersize will be taken from the average buffer size; of all objects written to the current file so far.; Use TDirectoryFile::SetBufferSize to force a given buffer size. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by obj->GetName(). The option can be a combination of:; ""SingleKey"", ""Overwrite"" or ""WriteDelete""; Using the ""Overwrite"" option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the ""WriteDelete"" option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The ""SingleKey"" option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory.; It returns 0 if the object cannot be written. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). Int_t WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object from pointer of class classname in this directory; obj may not derive from TObject; see TDirectoryFile::WriteTObject for comments. VERY IMPORTANT NOTE:; The value passed as 'obj' needs to be from a pointer to the type described by classname; For example with:; TopClass *top;; BottomClass *bottom;; top = bottom;; you can do:; directory->WriteObjectAny(top,""top"",""name of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:26473,safe,safer,26473,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,6,['safe'],['safer']
Safety,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:4223,predict,predict,4223,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['predict'],['predict']
Safety,"fer, . int ; length, . int ; flag . ). staticprotected . Receive exactly length bytes into buffer. ; Returns number of bytes received. Returns -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4508 of file TUnixSystem.cxx. ◆ UnixResetSignal(). void TUnixSystem::UnixResetSignal ; (; ESignals ; sig). staticprotected . Restore old signal handler for specified signal. ; Definition at line 3821 of file TUnixSystem.cxx. ◆ UnixResetSignals(). void TUnixSystem::UnixResetSignals ; (; ). staticprotected . Restore old signal handlers. ; Definition at line 3836 of file TUnixSystem.cxx. ◆ UnixSelect(). int TUnixSystem::UnixSelect ; (; Int_t ; nfds, . TFdSet * ; readready, . TFdSet * ; writeready, . Long_t ; timeout . ). staticprotected . Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ; Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of file TUnixSystem.cxx. ◆ UnixSigAlarmInterruptsSyscalls(). void TUnixSystem::UnixSigAlarmInterrupts",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:74935,timeout,timeout,74935,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"ferMergerFile (const TBufferMergerFile &);  TBufferMergerFile has no copy constructor. ;  ;  TBufferMergerFile (TBufferMerger &m);  Constructor. ;  ; TBufferMergerFile & operator= (const TBufferMergerFile &);  TBufferMergerFile has no copy operator. ;  . Private Attributes; TBufferMerger & fMerger;  . Friends; class TBufferMerger;  . Additional Inherited Members;  Public Types inherited from TMemFile; using ExternalDataPtr_t = std::shared_ptr< const std::vector< char > >;  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:32136,timeout,timeout,32136,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,2,['timeout'],['timeout']
Safety,"ffect on each lego-bar. . ""TEXT"" Draw bin contents as text (format set via gStyle->SetPaintTextFormat). . ""TEXTnn"" Draw bin contents as text at angle nn (0 < nn <= 90). . ""X+"" The X-axis is drawn on the top side of the plot. . ""Y+"" The Y-axis is drawn on the right side of the plot. . ""MIN0"" Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). . Options supported for 1D histograms. Option Description . "" "" Default. . ""AH"" Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis. . ""]["" When this option is selected the first and last vertical lines of the histogram are not drawn. . ""B"" Bar chart option. . ""BAR"" Like option ""B"", but bars can be drawn with a 3D effect. . ""HBAR"" Like option ""BAR"", but bars are drawn horizontally. . ""C"" Draw a smooth Curve through the histogram bins. . ""E0"" Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping . ""E1"" Draw error bars with perpendicular lines at the edges. . ""E2"" Draw error bars with rectangles. . ""E3"" Draw a fill area through the end points of the vertical error bars. . ""E4"" Draw a smoothed filled area through the end points of the error bars. . ""E5"" Like E3 but ignore the bins with 0 contents. . ""E6"" Like E4 but ignore the bins with 0 contents. . ""X0"" When used with one of the ""E"" option, it suppress the error bar along X as gStyle->SetErrorX(0) would do. . ""L"" Draw a line through the bin contents. . ""P"" Draw current marker at each bin except empty bins. . ""P*"" Draw a star marker at each bin except empty bins. . ""P0"" Draw current marker at each bin including empty bins. . ""PIE"" Draw histogram as a Pie Chart. . ""*H"" Draw histogram with a * at each bin. . ""LF2"" Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour. . Options su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:7494,avoid,avoids,7494,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avoid'],['avoids']
Safety,"ffer.; 826///; 827/// - Reservation of the corresponding space in the file by looking; 828/// in the TFree list of free blocks of the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of byte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:30744,safe,safer,30744,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['safe'],['safer']
Safety,"fferent between Windows and Linux.; 6089 * Currently there is no problem with failing send calls,; 6090 * if there is a reproducible situation, it should be; 6091 * investigated in detail.; 6092 */; 6093 return -2;; 6094 }; 6095 ; 6096 /* Only in case n=0 (timeout), repeat calling the write function */; 6097 ; 6098 /* If send failed, wait before retry */; 6099 if (fp != NULL) {; 6100 /* For files, just wait a fixed time.; 6101 * Maybe it helps, maybe not. */; 6102 mg_sleep(5);; 6103 } else {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:178828,timeout,timeout,178828,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"fferent between Windows and Linux.; 6090 * Currently there is no problem with failing send calls,; 6091 * if there is a reproducible situation, it should be; 6092 * investigated in detail.; 6093 */; 6094 return -2;; 6095 }; 6096 ; 6097 /* Only in case n=0 (timeout), repeat calling the write function */; 6098 ; 6099 /* If send failed, wait before retry */; 6100 if (fp != NULL) {; 6101 /* For files, just wait a fixed time.; 6102 * Maybe it helps, maybe not. */; 6103 mg_sleep(5);; 6104 } else {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:178860,timeout,timeout,178860,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"fied through setCacheObservables(). In case the cache observable is _not_ in nset, then it is; - the convolution observable plus; - all member of nset are observables of this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters on which the cache depends given normalization; set nset. For this p.d.f these are the parameters of the input p.d.f.; but never the convolution variable, it case it is not part of nset. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; Return p.d.f. observable (which can be a function) to substitute given; p.d.f. observable. Substitute x by xprime if xprime is set. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create appropriate generator context for this convolution. If both input p.d.f.s support; internal generation, if it is safe to use them and if no observables other than the convolution; observable are requested for generation, use the specialized convolution generator context; which implements a smearing strategy in the convolution observable. If not return the; regular accept/reject generator context. void setBufferFraction(Double_t frac); Change the size of the buffer on either side of the observable range to frac times the; size of the range of the convolution observable. void setBufferStrategy(RooFFTConvPdf::BufStrat bs); Change strategy to fill the overflow buffer on either side of the convolution observable range. 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range; 'Flat' means that the buffer is filled with the p.d.f. value at the boundary of the observable range; 'Mirror' means that the buffer is filled with a ,irror image of the p.d.f. around the convolution observable boundary. The default strategy is extend. If one of the input p.d.f.s is a RooAddPdf, it is configured so that the interpretation; range of the fraction coefficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:49685,safe,safe,49685,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['safe'],['safe']
Safety,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:36550,recover,recovery,36550,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,5,['recover'],['recovery']
Safety,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionLevel(Int_t level = 1); Set level of compression for this file:; level = 0 objects written to this file will not be compressed.; level = 1 minimal compression level but fast. level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35824,recover,recovery,35824,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['recover'],['recovery']
Safety,"fields contain just data, collection fields resolve to offset columns, record fields have no materialization on the primitive column layer. . EnumeratorkInvalid ; kLeaf ; kCollection ; kRecord ; kVariant ; kStreamer ; kUnknown . Definition at line 112 of file RNTupleUtil.hxx. Function Documentation. ◆ Add(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT_TO, template< int D_, class P_ > class... STAT_FROM> . void ROOT::Experimental::Add ; (; RHist< DIMENSIONS, PRECISION, STAT_TO... > & ; to, . const RHist< DIMENSIONS, PRECISION, STAT_FROM... > & ; from . ). Add two histograms. ; This operation may currently only be performed if the two histograms have the same axis configuration, use the same precision, and if from records at least the same statistics as to (recording more stats is fine).; Adding histograms with incompatible axis binning will be reported at runtime with an std::runtime_error. Insufficient statistics in the source histogram will be detected at compile-time and result in a compiler error.; In the future, we may either adopt a more relaxed definition of histogram addition or provide a mechanism to convert from one histogram type to another. We currently favor the latter path. ; Definition at line 342 of file RHist.hxx. ◆ CanMap(). ROOT::Experimental::EAxisCompatibility ROOT::Experimental::CanMap ; (; const RAxisEquidistant & ; target, . const RAxisEquidistant & ; source . ). noexcept . Whether (and how) the source axis can be merged into the target axis. ; Definition at line 126 of file RAxis.cxx. ◆ FitPanelLog(). ROOT::Experimental::RLogChannel & ROOT::Experimental::FitPanelLog ; (; ). Log channel for FitPanel diagnostics. ; Definition at line 22 of file RFitPanelModel.cxx. ◆ FitTo(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT> . RFitResult ROOT::Experimental::FitTo ; (; const RHist< DIMENSIONS, PRECISION, STAT... > & ; hist, . const RFunction< DIMENSIONS > & ; func, . st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:44138,detect,detected,44138,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['detect'],['detected']
Safety,"fier code, that will be passed to coefficient(); to identify the basis function for which the coefficient is requested. If the; resolution model used does not support the declared basis function, code -1 is; returned. Bool_t changeModel(const RooResolutionModel& newModel); Change the current resolution model to newModel. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:43513,safe,safe,43513,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,7,['safe'],['safe']
Safety,"figure1.C:7; RooFit::ParametersRooCmdArg Parameters(const RooArgSet &params)Definition RooGlobalFunc.cxx:787; RooFit::ConditionalRooCmdArg Conditional(const RooArgSet &pdfSet, const RooArgSet &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf709_BarlowBeestonDefinition rf709_BarlowBeeston.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:11583,safe,safe,11583,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['safe'],['safe']
Safety,"file DataSetFactory.h. ◆ Streamer(). virtual void TMVA::DataSetFactory::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::DataSetFactory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 238 of file DataSetFactory.h. ◆ Verbose(). Bool_t TMVA::DataSetFactory::Verbose ; (; ). inlineprotected . Definition at line 209 of file DataSetFactory.h. Member Data Documentation. ◆ fComputeCorrelations. Bool_t TMVA::DataSetFactory::fComputeCorrelations = kFALSE. protected . Whether to force computation of correlations or not. ; Definition at line 219 of file DataSetFactory.h. ◆ fCorrelations. Bool_t TMVA::DataSetFactory::fCorrelations = kFALSE. protected . Whether to print correlations or not. ; Definition at line 218 of file DataSetFactory.h. ◆ fCurrentEvtIdx. UInt_t TMVA::DataSetFactory::fCurrentEvtIdx. protected . the current event (to avoid reading of the same event) ; Definition at line 225 of file DataSetFactory.h. ◆ fCurrentTree. TTree* TMVA::DataSetFactory::fCurrentTree. protected . the tree, events are currently read from ; Definition at line 224 of file DataSetFactory.h. ◆ fCutFormulas. std::vector<TTreeFormula*> TMVA::DataSetFactory::fCutFormulas. protected . cuts ; Definition at line 231 of file DataSetFactory.h. ◆ fInputFormulas. std::vector<TTreeFormula*> TMVA::DataSetFactory::fInputFormulas. protected . input variables ; Definition at line 228 of file DataSetFactory.h. ◆ fInputTableFormulas. std::vector<std::pair<TTreeFormula*, Int_t> > TMVA::DataSetFactory::fInputTableFormulas. protected . ! input variables expression for arrays ; Definition at line 229 of file DataSetFactory.h. ◆ fLogger. MsgLogger* TMVA::DataSetFactory::fLogger. protected . ! message logger ; Definition at line 235 of file DataSetFactory.h. ◆ fScaleWithPreselEff. Bool_t TMVA::DataSetFactory::fScaleWithPreselEff. protected . how to deal with requested #events in co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html:21759,avoid,avoid,21759,doc/master/classTMVA_1_1DataSetFactory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetFactory.html,1,['avoid'],['avoid']
Safety,"file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:6415,recover,recover,6415,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['recover'],['recover']
Safety,"file, Bool_t bin, Long64_t size); Receive a file, either sent by a client or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. Int_t GetProtocol() const; { return fProtocol; }. Int_t GetPort() const; { return fUrl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:15045,abort,abort,15045,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,5,['abort'],['abort']
Safety,"file, Bool_t bin, Long64_t size); Receive a file, either sent by a client or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. Int_t SendCanvases(); Send any created canvas to client. Int_t BrowseDirectory(const char* dirname); Browse directory and send back its content to client. Int_t BrowseFile(const char* fname); Browse root file and send back its content;; if fname is null, send the full list of files. Int_t BrowseKey(const char* keyname); Read key object and send it back to client. void Terminate(Int_t status); Terminate the proof server. void HandleCheckFile(TMessage* mess); Handle file checking request. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The error handler function. It prints the message on stderr and; if abort is set it aborts the application. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* err = 0); Parse a command line received from the client, making sure that the files; needed for the execution, if any, are available. The line is either a C++; statement or an interpreter command starting with a ""."".; Return the return value of the command casted to a long. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile). Int_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:16140,abort,abort,16140,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,2,['abort'],['abort']
Safety,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:1064,timeout,timeout,1064,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,4,['timeout'],['timeout']
Safety,"final;  Write array of Long64_t to buffer. ;  ; void WriteFastArray (const Long_t *l, Long64_t n) final;  Write array of Long_t to buffer. ;  ; void WriteFastArray (const Short_t *h, Long64_t n) final;  Write array of Short_t to buffer. ;  ; void WriteFastArray (const UChar_t *c, Long64_t n) final;  Write array of UChar_t to buffer. ;  ; void WriteFastArray (const UInt_t *i, Long64_t n) final;  Write array of UInt_t to buffer. ;  ; void WriteFastArray (const ULong64_t *l, Long64_t n) final;  Write array of ULong64_t to buffer. ;  ; void WriteFastArray (const ULong_t *l, Long64_t n) final;  Write array of ULong_t to buffer. ;  ; void WriteFastArray (const UShort_t *h, Long64_t n) final;  Write array of UShort_t to buffer. ;  ; Int_t WriteFastArray (void **startp, const TClass *cl, Long64_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr) final;  Recall TBuffer function to avoid gcc warning message. ;  ; void WriteFastArray (void *start, const TClass *cl, Long64_t n=1, TMemberStreamer *s=nullptr) final;  Recall TBuffer function to avoid gcc warning message. ;  ; void WriteFastArrayString (const Char_t *c, Long64_t n) final;  Write array of Char_t to buffer. ;  ; void WriteFloat (Float_t f) final;  Writes Float_t value to buffer. ;  ; void WriteInt (Int_t i) final;  Writes Int_t value to buffer. ;  ; void WriteLong (Long_t l) final;  Writes Long_t value to buffer. ;  ; void WriteLong64 (Long64_t l) final;  Writes Long64_t value to buffer. ;  ; void WriteShort (Short_t s) final;  Writes Short_t value to buffer. ;  ; void WriteStdString (const std::string *s) final;  Writes a std::string. ;  ; virtual void WriteStdString (const std::string *s)=0;  ; virtual void WriteStdString (std::string &s);  ; void WriteTString (const TString &s) final;  Writes a TString. ;  ; void WriteUChar (UChar_t c) final;  Writes UChar_t value to buffer. ;  ; void WriteUInt (UInt_t i) final;  Writes UInt_t value to buffer. ;  ; void WriteULong (ULong_t l) final;  Writes ULong_t value t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:17738,avoid,avoid,17738,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"finition at line 12247 of file civetweb.c. ◆ print_dir_entry(). static int print_dir_entry ; (; struct de * ; de). static . Definition at line 9289 of file civetweb.c. ◆ print_props(). static int print_props ; (; struct mg_connection * ; conn, . const char * ; uri, . const char * ; name, . struct mg_file_stat * ; filep . ). static . Definition at line 12190 of file civetweb.c. ◆ process_new_connection(). static void process_new_connection ; (; struct mg_connection * ; conn). static . Definition at line 18516 of file civetweb.c. ◆ produce_socket(). static void produce_socket ; (; struct mg_context * ; ctx, . const struct socket * ; sp . ). static . Definition at line 18809 of file civetweb.c. ◆ pull_all(). static int pull_all ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len . ). static . Definition at line 6413 of file civetweb.c. ◆ pull_inner(). static int pull_inner ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 6184 of file civetweb.c. ◆ push_all(). static int push_all ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len . ). static . Definition at line 6136 of file civetweb.c. ◆ push_inner(). static int push_inner ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 5970 of file civetweb.c. ◆ put_dir(). static int put_dir ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 10267 of file civetweb.c. ◆ put_file(). static void put_file ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 11670 of file civetweb.c. ◆ read_auth_file(). static int read_auth_file ; (; struct mg_file * ; filep, . struct read_auth_file_struct * ; workdata, . int ; depth . ). static . Definition at line 8505 of file civetweb.c. ◆ rea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:81298,timeout,timeout,81298,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"finition at line 2435 of file TBufferFile.cxx. ◆ WriteFastArray() [15/15]. void TBufferFile::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; streamer = nullptr . ). overridevirtual . Write an array of object starting at the address 'start' and of length 'n' the objects in the array are assumed to be of class 'cl'. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2404 of file TBufferFile.cxx. ◆ WriteFastArrayDouble32(). void TBufferFile::WriteFastArrayDouble32 ; (; const Double_t * ; d, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n doubles (as float) into the I/O buffer. ; see comments about Double32_t encoding at TBufferFile::WriteDouble32 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n floats (as truncated float) into the I/O buffer. ; see comments about Float16_t encoding at TBufferFile::WriteFloat16 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2265 of file TBufferFile.cxx. ◆ WriteFastArrayString(). void TBufferFile::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:87644,abort,aborts,87644,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"finition at line 880 of file TBranchProxy.h. ◆ TUShortProxy. typedef TImpProxy<UShort_t> ROOT::Internal::TUShortProxy. Definition at line 882 of file TBranchProxy.h. Enumeration Type Documentation. ◆ ELocation. enum ROOT::Internal::ELocation. 0 for the general case, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. . EnumeratorkOut ; kClones ; kSTL . Definition at line 38 of file TTreeReaderGenerator.h. Function Documentation. ◆ CastToTG(). tbb::isolated_task_group * ROOT::Internal::CastToTG ; (; void * ; p). Definition at line 43 of file TTaskGroup.cxx. ◆ ContaineeInheritsFrom(). bool ROOT::Internal::ContaineeInheritsFrom ; (; TClass * ; cl, . TClass * ; base . ). Return true if 'cl' inherits from 'base'. ; Definition at line 831 of file TCollection.cxx. ◆ DefaultStreamer(). void ROOT::Internal::DefaultStreamer ; (; TBuffer & ; R__b, . const TClass * ; cl, . void * ; objpointer . ). Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ; Definition at line 30 of file TBuffer.cxx. ◆ DefineBehavior() [1/2]. const TQObjectInitBehavior * ROOT::Internal::DefineBehavior ; (; TQObject * ; , . TQObject * ;  . ). inline . Definition at line 74 of file TQClass.h. ◆ DefineBehavior() [2/2]. const TInitBehavior * ROOT::Internal::DefineBehavior ; (; void * ; , . void * ;  . ). Definition at line 44 of file TGenericClassInfo.cxx. ◆ DeleteChangesMemory(). bool ROOT::Internal::DeleteChangesMemory ; (; ). Definition at line 127 of file TObject.cxx. ◆ DeleteChangesMemoryImpl(). bool ROOT::Internal::DeleteChangesMemoryImpl ; (; ). Definition at line 76 of file TObject.cxx. ◆ DisableParBranchProcessing(). void ROOT::Internal::DisableParBranchProcessing ; (; ). Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ; Definition at line 434 of file TROOT.cxx. ◆ EmptyCollection(). const TCollection & ROOT::Internal::EmptyCollection ; (; ). Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:31184,avoid,avoid,31184,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['avoid'],['avoid']
Safety,"finition at line 916 of file TBranchProxy.h. ◆ TUShortProxy. typedef TImpProxy<UShort_t> ROOT::Internal::TUShortProxy. Definition at line 918 of file TBranchProxy.h. Enumeration Type Documentation. ◆ ELocation. enum ROOT::Internal::ELocation. 0 for the general case, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. . EnumeratorkOut ; kClones ; kSTL . Definition at line 38 of file TTreeReaderGenerator.h. Function Documentation. ◆ CastToTG(). tbb::isolated_task_group * ROOT::Internal::CastToTG ; (; void * ; p). Definition at line 43 of file TTaskGroup.cxx. ◆ ContaineeInheritsFrom(). bool ROOT::Internal::ContaineeInheritsFrom ; (; TClass * ; cl, . TClass * ; base . ). Return true if 'cl' inherits from 'base'. ; Definition at line 831 of file TCollection.cxx. ◆ DefaultStreamer(). void ROOT::Internal::DefaultStreamer ; (; TBuffer & ; R__b, . const TClass * ; cl, . void * ; objpointer . ). Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ; Definition at line 30 of file TBuffer.cxx. ◆ DefineBehavior() [1/2]. const TQObjectInitBehavior * ROOT::Internal::DefineBehavior ; (; TQObject * ; , . TQObject * ;  . ). inline . Definition at line 74 of file TQClass.h. ◆ DefineBehavior() [2/2]. const TInitBehavior * ROOT::Internal::DefineBehavior ; (; void * ; , . void * ;  . ). Definition at line 45 of file TGenericClassInfo.cxx. ◆ DeleteChangesMemory(). bool ROOT::Internal::DeleteChangesMemory ; (; ). Definition at line 133 of file TObject.cxx. ◆ DeleteChangesMemoryImpl(). bool ROOT::Internal::DeleteChangesMemoryImpl ; (; ). Definition at line 76 of file TObject.cxx. ◆ DisableParBranchProcessing(). void ROOT::Internal::DisableParBranchProcessing ; (; ). Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ; Definition at line 434 of file TROOT.cxx. ◆ EmptyCollection(). const TCollection & ROOT::Internal::EmptyCollection ; (; ). Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:31526,avoid,avoid,31526,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['avoid'],['avoid']
Safety,"finition civetweb.c:486; parse_http_headersstatic int parse_http_headers(char **buf, struct mg_header hdr[(64)])Definition civetweb.c:10420; mg_get_option#define mg_get_optionDefinition civetweb.c:3149; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16230; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3166; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10317; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18031; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20559; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6184; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17979; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1851; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17216; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20496; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6468; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4350; mg_startstruct m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:659511,timeout,timeout,659511,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"finition civetweb.c:486; parse_http_headersstatic int parse_http_headers(char **buf, struct mg_header hdr[(64)])Definition civetweb.c:10421; mg_get_option#define mg_get_optionDefinition civetweb.c:3150; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16231; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3167; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10318; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18032; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20560; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6185; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17980; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1852; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17217; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20497; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6469; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4351; mg_startstruct m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:659544,timeout,timeout,659544,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillSty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4602,recover,recovery,4602,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"float>(myVecFunc), {""var1"", ""var2"", ""var3""});; 100/// \endcode; 101// clang-format on; 102template <std::size_t N, typename T, typename F>; 103auto PassAsVec(F &&f) -> RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>; 104{; 105 return RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 106}; 107 ; 108// clang-format off; 109/// Create a graphviz representation of the dataframe computation graph, return it as a string.; 110/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 111///; 112/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 113///; 114/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 115/// effectively optimized away from the computation graph.; 116///; 117/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 134/// effectively optimized away from the computation graph.; 135///; 136/// Note that SaveGraph is not t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:5237,safe,safe,5237,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"fmt, va_list va) const; voidTObject::MakeZombie(); voidsafeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCollection.html:9813,safe,safeDeleteList,9813,root/html530/RooAbsCollection.html,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html,2,['safe'],"['safe', 'safeDeleteList']"
Safety,"fo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_clock::now() - fLastPrintTime) < fPrintInterval) {; 409 return;; 410 }; 411 ; 412 // ***************************************************; 413 // Protected by lock from here:; 414 // ***************************************************; 415 if (!fPrintMutex.try_lock()); 416 return;; 417 std::lock_guard<std::mutex> lockGuard(fPrintMutex, std::adopt_lock);; 418 ; 419 std::size_t eventCount;; 420 seconds elapsedSeconds;; 421 std::tie(eventCount, elapsedSeconds) = RecordEvtCountAndTime();; 422 ; 423 if (fIsTTY); 424 std::cout << ""\r"";; 425 ; 426 PrintProgressBar(std::cout, eventCount);; 427 PrintStats(std::cout, eventCount, elapsedSeconds);; 428 ; 429 if (fIsTTY); 430 std::cout << std::flush;; 431 else; 432 std::cout << std::endl;; 433 }; 434 ; 435 std::size_t C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:19167,safe,safe,19167,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:146719,avoid,avoid,146719,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"fo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:175238,risk,risk,175238,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['risk'],['risk']
Safety,"fo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated class, or -2 if the; 4704 // user requested the emulated streamerInfo for an abstract; 4705 // base class, even though we have a dictionary for it.; 4706 ; 4707 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4708 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4709 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4710 version = fClassVersion;; 4711 }; 4712 ; 4713 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4714 ; 4715 if (!sinfo &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177989,risk,risk,177989,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['risk'],['risk']
Safety,"following statements into a source file that you then run in ROOT; // Put into the file trigParam.C; // which #includes do you need?; #include ...; void trigParam() {; // The location of the input data; TFile* infile = TFile::Open(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; TTree* tree = 0;; infile->GetObject(""MyTree"", tree);. // The output file, it will hold the results of TMVA's work.; TFile* outputFile = TFile::Open(""mutrig.root"", ""RECREATE"" );. // Create a TMVA analysis; TMVA::Factory *factory = new TMVA::Factory(""MuonTrigger"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=Classification"" );. // Add a few variables to study - let's see which one TMVA finds relevant:; factory->AddVariable( ""muons.fPt"", 'F' );; factory->AddVariable( ""muons.fE"", 'F' );; factory->AddVariable( ""muons.fVertex.fX"", 'F' );; factory->AddVariable( ""muons.fTriggered"", 'F' );. // Usually TMVA can predict whether an event belongs to ""signal"" or ""background"":; // it determines that based on the valued of the parameters we selected above.; // We don't really want to know that ""signal"" / ""background"" thing: we just ""mis""-use; // TMVA to analyze the parameter correlations. Nonetheless, let's just define signal; // and background as triggered / not triggered. Both are in the same tree.; // We distinguish them using TCut objects: selections as one would use in TTree::Draw(). ; TCut signalCut(""muons.fTriggered"");; TCut backgroundCut(""!muons.fTriggered"");; factory->SetInputTrees(tree, signalCut, backgroundCut);. // Now select which algorithm to run - it's not important here as long as it; // determines the parameter correlations.; factory->BookMethod( TMVA::Types::kFisher, ""Fisher"", ""H:!V"" );; // And start the correlation analysis:; factory->TestAllMethods();; }. Parameter correlations; We want to know what muons.fTriggered depends on. A simple check is to look for correlations: variables that it depends on might be linearly correlated. TMVA tel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/6-multivariate-analysis.html:4314,predict,predict,4314,d/6-multivariate-analysis.html,https://root.cern,https://root.cern/d/6-multivariate-analysis.html,1,['predict'],['predict']
Safety,"follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:10207,recover,recover,10207,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:39688,timeout,timeout,39688,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['timeout'],['timeout']
Safety,"for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMark Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class for TEvePlot3D.; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.; TEvePointSetArray Array of T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:60726,safe,safe,60726,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['safe'],['safe']
Safety,"fore and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a segmentation fault); 120#if defined(_MSC_VER) && defined(__SANITIZE_ADDRESS__); 121 // on Windows, even __declspec(no_sanitize_address) does not prevent catching; 122 // heap-use-after-free errorswhen using the /fsanitize=address compiler flag; 123 // so don't even try; 124 return true;; 125#endif; 126 if ( *o_fbits != 0x01000000 ) {; 127 // operator delete tainted the memory, we can not rely on TestBit(kNotDeleted); 128 return true;; 129 }; 130 return false;; 131}; 132 ; 133bool DeleteChangesMemory(); 134{; 135 static const bool value = DeleteChangesMemoryImpl();; 136 if (gDebug >= 9); 137 DeleteChangesMemoryImpl(); // To allow for printing the debug info; 138 return value;; 139}; 140 ; 141}} // ROOT::Detail; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Copy this to obj.; 145 ; 146void TObject::Copy(TObject &obj) const; 147{; 148 obj.fUniqueID = fUniqueID; // when really unique don't copy; 149 if (obj.IsOnHeap()) { // test uses fBits so don't move next line; 150 obj.fBits = fBits;; 151 obj.fBits |= kIsOnHeap;; 152 } else {; 153 obj.fBits = fBits;; 154 obj.fBits &= ~kIsOnHeap;; 155 }; 156 obj.fBits &= ~kIsReferenced;; 157 obj.fBits &= ~kCanDelete;; 158}; 159 ; 160////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:4385,detect,detect,4385,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['detect'],['detect']
Safety,"fore starting the build.; Quick Start; The following are the basic instructions for UNIX systems. We use here the command-line, non-interactive CMake interface. Download and unpack the ROOT's sources from the download area or using directly the Git repository. Follow the instructions for getting the ROOT sources; Open a shell. Your development tools must be reachable from this shell through the PATH environment variable.; Create a directory for containing the build. It is not supported to build ROOT on the source directory. cd to this directory:; $ mkdir <builddir>; $ cd <builddir> . Execute the cmake command on the shell replacing path/to/source with the path to the top of your ROOT source tree:; $ cmake path/to/source. CMake will detect your development environment, perform a series of test and generate the files required for building ROOT. CMake will use default values for all build parameters. See the Build Options and Variables sections for fine-tuning your build; This can fail if CMake can’t detect your toolset, or if it thinks that the environment is not sane enough. On this case make sure that the toolset that you intend to use is the only one reachable from the shell and that the shell itself is the correct one for you development environment. You can force CMake to use a given build tool, see the Usage section.; After CMake has finished running, proceed to use IDE project files or start the build from the build directory:; $ cmake --build . [-- <options to the native tool>]. The --build option tells cmake to invoke the underlying build tool (make, ninja, xcodebuild, msbuild, etc).; The underlying build tool can also be invoked directly of course, but thecmake --build command is more portable.; On unix systems (with make or ninja) you can speedup the build with cmake --build . -- -jN where N is the number of available cores.; Setup the environment to run; $ source /path/to/install-or-build/dir/bin/thisroot.sh. Start ROOT interactive application; $ root. Ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:3776,detect,detect,3776,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['detect'],['detect']
Safety,"form a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111078,detect,detector,111078,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"form3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725230,avoid,avoiding,725230,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoiding']
Safety,"format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package ;  robot.CDrawing a famous Korean robot, TaekwonV, using ROOT geometry class ;  rootgeom.CDefinition of a simple geometry (the 4 ROOT characters) ;  runplugin.CCreates and runs a simple iterator plugin connected to TGeoPainter iterator ;  shapes.CThe old geometry shapes (see script geodemo.C) ;  shapesAnim.CMacro illustrating how to animate a geometry picture using a Timer ;  south_gate.CDrawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class ;  station1.CDrawing a space station, using ROOT geometry class ;  station2.CDrawing a space station (version 2), using ROOT geometry class ;  tank.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111986,detect,detector,111986,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:3711,avoid,avoid,3711,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['avoid'],['avoid']
Safety,"from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:15621,safe,safe,15621,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['safe'],['safe']
Safety,"from the top of the ascent to the bottom of the descent.; Information about the actual height of the individual letter is not; available. A text layout that contains no characters is considered to contain a; single zero-width placeholder character. The return value is 0 if the index did not specify a character in the; text layout, or non-zero otherwise. In that case, *bbox is filled with; the bounding box of the character. layout -- Layout information, from a previous call to ComputeTextLayout().; index -- The index of the character whose bbox is desired.; x, y -- Filled with the upper-left hand corner, in pixels, of the; bounding box for the character specified by index, if non-NULL.; w, h -- Filled with the width and height of the bounding box for the; character specified by index, if non-NULL. Int_t DistanceToText(Int_t x, Int_t y) const; Computes the distance in pixels from the given point to the given; text layout. Non-displaying space characters that occur at the end of; individual lines in the text layout are ignored for hit detection; purposes. The return value is 0 if the point (x, y) is inside the text layout.; If the point isn't inside the text layout then the return value is the; distance in pixels from the point to the text item. x, y -- Coordinates of point to check, with respect to the upper-left; corner of the text layout (in pixels). Int_t IntersectText(Int_t x, Int_t y, Int_t w, Int_t h) const; Determines whether a text layout lies entirely inside, entirely outside,; or overlaps a given rectangle. Non-displaying space characters that occur; at the end of individual lines in the text layout are ignored for; intersection calculations. The return value is -1 if the text layout is entirely outside of the; rectangle, 0 if it overlaps, and 1 if it is entirely inside of the; rectangle. x, y -- Upper-left hand corner, in pixels, of rectangular area to compare; with text layout. Coordinates are with respect to the upper-left; hand corner of the text layout i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextLayout.html:10328,detect,detection,10328,root/html528/TGTextLayout.html,https://root.cern,https://root.cern/root/html528/TGTextLayout.html,6,['detect'],['detection']
Safety,"fset information of the chain. Bool_t Remove(Long64_t entry, TTree* tree = 0); Remove entry #entry from the list; When tree = 0, removes from the current list; When tree != 0, finds the list, corresponding to this tree; When tree is a chain, the entry is assumed to be global index and the local; entry is recomputed from the treeoffset information of the chain. Long64_t GetEntry(Int_t index); return the number of the entry #index of this TEntryList in the TTree or TChain; See also Next(). Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the index of ""index""-th non-zero entry in the TTree or TChain; and the # of the corresponding tree in the chain. TEntryList * GetEntryList(const char* treename, const char* filename, Option_t* opt = """"); return the entry list, correspoding to treename and filename; By default, the filename is first tried as is, and then, if the corresponding list; is not found, the filename is expanded to the absolute path, and compared again.; To avoid it, use option ""ne"". Int_t Merge(TCollection* list); Merge this list with the lists from the collection. Long64_t Next(); return the next non-zero entry index (next after fLastIndexQueried); this function is faster than GetEntry(). void OptimizeStorage(); Checks if the array representation is more economical and if so, switches to it. void Print(Option_t* option = """") const; Print this list; option = """" - default - print the name of the tree and file; option = ""all"" - print all the entry numbers. void Reset(); Reset this list. void SetDirectory(TDirectory* dir); Add reference to directory dir. dir can be 0. void SetTree(const char* treename, const char* filename); If a list for a tree with such name and filename exists, sets it as the current sublist; If not, creates this list and sets it as the current sublist. ! the filename is taken as provided, no extensions to full path or url !. void SetTree(const TTree* tree); If a list for a tree with such name and filename exists, sets it as the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryList.html:18429,avoid,avoid,18429,root/html528/TEntryList.html,https://root.cern,https://root.cern/root/html528/TEntryList.html,3,['avoid'],['avoid']
Safety,"fset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; 3683void TF1::RejectPoint(Bool_t reject); 3684{; 3685 fgRejectPoint = reject;; 3686}; 3687 ; 3688 ; 3689////////////////////////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:140015,safe,safe,140015,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['safe'],['safe']
Safety,"full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for ROOT::RBrowserTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RBrowserTimer(). ROOT::RBrowserTimer::RBrowserTimer ; (; Long_t ; milliSec, . Bool_t ; mode, . RBrowser & ; br . ). inline . !< browser processing postponed requests ; constructor ; Definition at line 52 of file RBrowser.cxx. Member Function Documentation. ◆ Timeout(). void ROOT::RBrowserTimer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process postponed requests in main ROOT thread ; Reimplemented from TTimer.; Definition at line 56 of file RBrowser.cxx. Member Data Documentation. ◆ fBrowser. RBrowser& ROOT::RBrowserTimer::fBrowser. Definition at line 49 of file RBrowser.cxx. gui/browserv7/src/RBrowser.cxx. ROOTRBrowserTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html:17685,timeout,timeout,17685,doc/master/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowserTimer.html,1,['timeout'],['timeout']
Safety,"function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the function GetWebHistogram. This script connects a file; with histograms: pippa.root on the ROOT Web site and returns the object h6; to TRef::GetObject.; Note that if the definition of the TRef fWebHistogram had been:; TRef fWebHistogram; //EXEC:GetWebHistogram(); then, the compiled or interpreted function GetWebHistogram() would have; been called instead of the CINT script GetWebHistogram.C. Special case of a TRef pointing to an object with a TUUID. If the referenced object has a TUUID, its bit kHasUUID has been set.; This case is detected by the TRef assignement operator.; (For example, TFile and TDirectory have a TUUID); The TRef fPID points directly to the single object TProcessUUID (deriving; from TProcessID) and managing the list of TUUIDs for a process.; The TRef kHasUUID bit is set and its fUniqueID is set to the fUniqueID; of the referenced object.; When the TRef is streamed to a buffer, the corresponding TUUID is also; streamed with the TRef. When a TRef is read from a buffer, the corresponding; TUUID is also read and entered into the global list of TUUIDs (if not; already there). The TRef fUniqueID is set to the UUIDNumber.; see TProcessUUID for more details. Array of TRef. The special class TRefArray should be used to store multiple references.; A TRefArray has one single pointer fPID for all objects in the array.; It has a dynamic compact table of fUniqueIDs. Use a TRefArray rather; then a collection of TRefs if all TRefs stem from the same process. Example:; Suppose a TObjArray *mytracks containing a list of Trac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:8265,detect,detected,8265,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['detect'],['detected']
Safety,"function should return a void*. To start the thread call Run(). TThread(VoidFunc_t fn, void *arg, EPriority pri); Create a detached thread. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; To start the thread call Run(). TThread(const char *thname, VoidRtnFunc_t fn, void *arg, EPriority pri); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char *thname, VoidFunc_t fn, void *arg, EPriority pri); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). TThread(Long_t id = 0); Create a TThread for a already running thread. void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThread.html:11002,safe,safe,11002,root/html602/TThread.html,https://root.cern,https://root.cern/root/html602/TThread.html,2,['safe'],['safe']
Safety,"function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:11298,abort,abort,11298,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['abort'],['abort']
Safety,"function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 30170 2009-09-15 13:35:35Z rdm $ » Last generated: 2010-10-08 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:22920,avoid,avoid,22920,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,1,['avoid'],['avoid']
Safety,"function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 30170 2009-09-15 13:35:35Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetSystem.html:23048,avoid,avoid,23048,root/html530/TXNetSystem.html,https://root.cern,https://root.cern/root/html530/TXNetSystem.html,1,['avoid'],['avoid']
Safety,"fy() so timers will keep working repeatedly. ; Implements TSysEvtHandler.; Reimplemented in TViewTimer, TViewUpdateTimer, and TTipDelayTimer.; Definition at line 145 of file TTimer.cxx. ◆ operator=(). TTimer & TTimer::operator= ; (; const TTimer & ; ). privatedelete . ◆ Remove(). void TTimer::Remove ; (; ). inlineoverridevirtual . Implements TSysEvtHandler.; Definition at line 86 of file TTimer.h. ◆ Reset(). void TTimer::Reset ; (; ). Reset the timer. ; Definition at line 159 of file TTimer.cxx. ◆ SetCommand(). void TTimer::SetCommand ; (; const char * ; command). Set the interpreter command to be executed at time out. ; Removes the object to be notified (if it was set). ; Definition at line 176 of file TTimer.cxx. ◆ SetInterruptSyscalls(). void TTimer::SetInterruptSyscalls ; (; Bool_t ; set = kTRUE). When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ; This is typically used in case one wants to put a timeout on an I/O operation. By default interrupted syscalls will be restarted. ; Definition at line 199 of file TTimer.cxx. ◆ SetObject(). void TTimer::SetObject ; (; TObject * ; object). Set the object to be notified at time out. ; Removes the command to be executed (if it was set). ; Definition at line 186 of file TTimer.cxx. ◆ SetTime(). void TTimer::SetTime ; (; Long_t ; milliSec). inline . Definition at line 91 of file TTimer.h. ◆ SetTimerID(). void TTimer::SetTimerID ; (; UInt_t ; id = 0). inline . Definition at line 92 of file TTimer.h. ◆ SingleShot(). void TTimer::SingleShot ; (; Int_t ; milliSec, . const char * ; receiver_class, . void * ; receiver, . const char * ; method . ). static . This static function calls a slot after a given time interval. ; Created internal timer will be deleted after that. ; Definition at line 258 of file TTimer.cxx. ◆ Start(). void TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:23929,timeout,timeout,23929,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"fy(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:8736,safe,safe,8736,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,1,['safe'],['safe']
Safety,"g ;  ; std::vector< Double_t > fHighBkgCut;  ; std::vector< Double_t > fHighSigCut;  ; Bool_t fHistoricBool;  ; Double_t fHuberQuantile;  the option string determining the quantile for the Huber Loss Function in BDT regression. ;  ; Bool_t fInverseBoostNegWeights;  boost ev. with neg. weights with 1/boostweight rather than boostweight ;  ; std::vector< Bool_t > fIsHighBkgCut;  ; std::vector< Bool_t > fIsHighSigCut;  ; std::vector< Bool_t > fIsLowBkgCut;  ; std::vector< Bool_t > fIsLowSigCut;  ; Int_t fITree;  ntuple var: ith tree ;  ; std::map< const TMVA::Event *, LossFunctionEventInfo > fLossFunctionEventInfo;  map event to true value, predicted value, and weight used by different loss functions for BDT regression ;  ; std::vector< Double_t > fLowBkgCut;  ; std::vector< Double_t > fLowSigCut;  ; UInt_t fMaxDepth;  max depth ;  ; Double_t fMinLinCorrForFisher;  the minimum linear correlation between two variables demanded for use in fisher criterium in node splitting ;  ; Int_t fMinNodeEvents;  min number of events in node ;  ; Float_t fMinNodeSize;  min percentage of training events in node ;  ; TString fMinNodeSizeS;  string containing min percentage of training events in node ;  ; TTree * fMonitorNtuple;  monitoring ntuple ;  ; Int_t fNCuts;  grid used in cut applied in node splitting ;  ; TString fNegWeightTreatment;  variable that holds the option of how to treat negative event weights in training ;  ; UInt_t fNNodesMax;  max # of nodes ;  ; Double_t fNodePurityLimit;  purity limit for sig/bkg nodes ;  ; Bool_t fNoNegWeightsInTraining;  ignore negative event weights in the training ;  ; Int_t fNTrees;  number of decision trees requested ;  ; Bool_t fPairNegWeightsGlobal;  pair ev. with neg. and pos. weights in training sample and ""annihilate"" them ;  ; DecisionTree::EPruneMethod fPruneMethod;  method used for pruning ;  ; TString fPruneMethodS;  prune method option String ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:35910,predict,predicted,35910,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['predict'],['predicted']
Safety,"g current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:16571,safe,safe,16571,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,3,['safe'],['safe']
Safety,"g current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.; Check if parallel world navigation is enabled. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:17264,safe,safe,17264,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,3,['safe'],['safe']
Safety,"g marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TEveProjected; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetDepthLocal (Float_t d) override;  This is not needed for functionality as SetDepth(Float_t d) is overriden – but SetDepthLocal() is abstract. ;  ;  Protected Member Functions inherited from TEveTrackList; void FindMomentumLimits (TEveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TEveProjected; void SetDepthCommon (Float_t d, TEveElement *el, Float_t *bbox);  Utility function to update the z-values of the bounding-box. ;  . Private Member Functions;  TEveTrackListProjected (const TEveTrackListProjected &);  ; TEveTrackListProjected & operator= (const TEveTrackListProjected &);  . Additional Inherited Members;  Public Types inherited from TEveElemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackListProjected.html:37045,detect,detected,37045,doc/master/classTEveTrackListProjected.html,https://root.cern,https://root.cern/doc/master/classTEveTrackListProjected.html,1,['detect'],['detected']
Safety,"g media.Definition TGeoManager.cxx:3708; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::Browsevoid Browse(TBrowser *b) overrideDescribe how to browse this object.Definition TGeoManager.cxx:1023; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t *option="""")Check time of finding ""Where am I"" for n points.Definition TGeoManager.cxx:1942; TGeoManager::GetSafeLevelInt_t GetSafeLevel() constGo upwards the tree until a non-overlapping node.Definition TGeoManager.cxx:2251; TGeoManager::fGVolumesTObjArray * fGVolumeslist of runtime shapesDefinition TGeoManager.h:98; TGeoManager::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)Set factors that will ""bomb"" all translations in cartesian and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:213706,safe,safety,213706,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety,"g nodes. ; Current node must be on top of all the nodes in cluster. Always nc>1. ; Definition at line 2159 of file TGeoNavigator.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoNavigator::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 624 of file TGeoNavigator.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoNavigator::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 1178 of file TGeoNavigator.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoNavigator::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool_t ; compmatrix = kFALSE . ). Computes as fStep the distance to next daughter of the current volume. ; The point and direction must be converted in the coordinate system of the current volume. The proposed step limit is fStep. ; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:27567,safe,safety,27567,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"g on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in his \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and he therefore has access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:11995,avoid,avoid,11995,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['avoid'],['avoid']
Safety,"g time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizer.html:10276,avoid,avoid,10276,root/html534/TPacketizer.html,https://root.cern,https://root.cern/root/html534/TPacketizer.html,1,['avoid'],['avoid']
Safety,"g your build. If you already have experience with CMake, this is the recommended starting point.; Preparation; Check the prerequisites and supported platforms for the list of packages needed for your setup before starting the build.; Quick Start; The following are the basic instructions for UNIX systems. We use here the command-line, non-interactive CMake interface. Download and unpack the ROOT's sources from the download area or using directly the Git repository. Follow the instructions for getting the ROOT sources; Open a shell. Your development tools must be reachable from this shell through the PATH environment variable.; Create a directory for containing the build. It is not supported to build ROOT on the source directory. cd to this directory:; $ mkdir <builddir>; $ cd <builddir> . Execute the cmake command on the shell replacing path/to/source with the path to the top of your ROOT source tree:; $ cmake path/to/source. CMake will detect your development environment, perform a series of test and generate the files required for building ROOT. CMake will use default values for all build parameters. See the Build Options and Variables sections for fine-tuning your build; This can fail if CMake can’t detect your toolset, or if it thinks that the environment is not sane enough. On this case make sure that the toolset that you intend to use is the only one reachable from the shell and that the shell itself is the correct one for you development environment. You can force CMake to use a given build tool, see the Usage section.; After CMake has finished running, proceed to use IDE project files or start the build from the build directory:; $ cmake --build . [-- <options to the native tool>]. The --build option tells cmake to invoke the underlying build tool (make, ninja, xcodebuild, msbuild, etc).; The underlying build tool can also be invoked directly of course, but thecmake --build command is more portable.; On unix systems (with make or ninja) you can speedup the bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:3505,detect,detect,3505,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['detect'],['detect']
Safety,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:3984,safe,safe,3984,doc/master/rf608__fitresultaspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html,1,['safe'],['safe']
Safety,"g& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:27960,abort,abort,27960,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,4,['abort'],"['abort', 'aborts']"
Safety,"g(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultTXSocket::ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTXSocket::Recv(TMessage*& mess); virtual Int_tTXSocket::Recv(Int_t& status, Int_t& kind); virtual Int_tTXSocket::Recv(char* mess, Int_t max); virtual Int_tTXSocket::Recv(char* mess, Int_t max, Int_t& kind); virtual Int_tTXSocket::RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidTXSocket::RemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tTXSocket::Send(const TMessage& mess); virtual Int_tTXSocket::Send(Int_t kind); virtual Int_tTXSocket::Send(Int_t status, Int_t kind); virtual Int_tTXSocket::Send(const char* mess, Int_t kind = kMESS_STRING); TObjString*TXSocket::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tTXSocket::SendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tTXSocket::SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidTXSocket::SendUrgent(Int_t type, Int_t int1, Int_t int2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t cid); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTXSocket::SetInterrupt(); virtual voidTNamed::SetName(const char* name)ME",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXUnixSocket.html:6448,timeout,timeout,6448,root/html528/TXUnixSocket.html,https://root.cern,https://root.cern/root/html528/TXUnixSocket.html,1,['timeout'],['timeout']
Safety,"g. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGrap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:877,abort,aborted,877,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,3,['abort'],['aborted']
Safety,"g...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; TGeoGtra Class Reference. . Definition at line 149 of file TGeoArb8.h. Public Member Functions;  TGeoGtra ();  ;  TGeoGtra (const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  TGeoGtra (Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  ~TGeoGtra () override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Double_t GetTwistAngle () const;  ; TClass * IsA () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:908,safe,safe,908,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,3,['safe'],['safe']
Safety,"g.replaceArg(asymCat,*asymNeg) ;; 2310 std::unique_ptr<RooAbsReal> funcPos{static_cast<RooAbsReal*>(custPos.build())};; 2311 std::unique_ptr<RooAbsReal> funcNeg{static_cast<RooAbsReal*>(custNeg.build())};; 2312 ; 2313 // Create projection integral; 2314 RooArgSet *posProjCompList;; 2315 RooArgSet *negProjCompList;; 2316 ; 2317 // Add projDataVars to normalized dependents of projection; 2318 // This is needed only for asymmetries (why?); 2319 RooArgSet depPos(*plotVar,*asymPos) ;; 2320 RooArgSet depNeg(*plotVar,*asymNeg) ;; 2321 depPos.add(projDataVars) ;; 2322 depNeg.add(projDataVars) ;; 2323 ; 2324 const RooAbsReal *posProj = funcPos->createPlotProjection(depPos, &projectedVars, posProjCompList, o.projectionRangeName) ;; 2325 const RooAbsReal *negProj = funcNeg->createPlotProjection(depNeg, &projectedVars, negProjCompList, o.projectionRangeName) ;; 2326 if (!posProj || !negProj) {; 2327 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") Unable to create projections, abort"" << std::endl ;; 2328 return frame ;; 2329 }; 2330 ; 2331 // Create a RooFormulaVar representing the asymmetry; 2332 TString asymName(GetName()) ;; 2333 asymName.Append(""_Asym["") ;; 2334 asymName.Append(asymCat.GetName()) ;; 2335 asymName.Append(""]"") ;; 2336 TString asymTitle(asymCat.GetName()) ;; 2337 asymTitle.Append("" Asymmetry of "") ;; 2338 asymTitle.Append(GetTitle()) ;; 2339 RooFormulaVar funcAsym{asymName,asymTitle,""(@0-@1)/(@0+@1)"",RooArgSet(*posProj,*negProj)};; 2340 ; 2341 if (o.projData) {; 2342 ; 2343 // If data set contains more rows than needed, make reduced copy first; 2344 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2345 std::unique_ptr<RooAbsData> projDataSelOwned;; 2346 if (projDataNeededVars && projDataNeededVars->size() < o.projData->get()->size()) {; 2347 ; 2348 // Determine if there are any slice variables in the projection set; 2349 RooArgSet sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:102331,abort,abort,102331,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety,"g64_t fst, TDSet *dset, const char *selec);  Create a TProofQueryResult instance for this query. ;  ; Int_t PollForNewWorkers () override;  Simulate dynamic addition, for test purposes. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t SetupWorkers (Int_t opt=0, TList *wrks=0);  Start up PROOF workers. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ;  ; Int_t Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; Int_t Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; TSlave * CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir);  Create a new TSlave of type TSlave::kSlave. ;  ; TSlave * CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1);  Create a new TSlave of type TSlave::kMaster. ;  ; TList * GetEnabledPackages () const;  ; TList * GetListOfActiveSlaves () const;  ; TVirtualProofPlayer * GetPlayer () const;  ; TPluginHandler * GetProgressDialog () const;  ; Int_t GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0);  Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ;  ; void HandleLibIncPath (const char *what, Bool_t add, const char *dirs);  Handle lib, inc search paths modification request. ;  ; Int_t HandleOutputOptions (TString &opt, TString &target, Int_t action);  Extract from opt information about output handling settings. ;  ; Int_t In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:36572,timeout,timeout,36572,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['timeout'],['timeout']
Safety,"g64_t jFirst=0) -> InvokeResult_t< F, std::reference_wrapper< TTreeReader > >;  ; TList * Process (TTree &tree, TSelector &selector, TEntryList &entries, ULong64_t nToProcess=0, ULong64_t jFirst=0);  TSelector-based tree processing: memory resident tree. ;  ; TList * Process (TTree &tree, TSelector &selector, ULong64_t nToProcess=0, ULong64_t jFirst=0);  ; void SetNWorkers (unsigned n);  . Private Types; enum class  ETask : unsigned char { kNoTask; , kProcByRange; , kProcByFile; };  A collection of the types of tasks that TTreeProcessorMP can execute. More...;  ; template<typename F , typename... Args> ; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  . Private Member Functions; template<class T > ; void Collect (std::vector< T > &reslist);  Listen for messages sent by the workers and call the appropriate handler function. ;  ; void FixLists (std::vector< TObject * > &lists);  Fix list of lists before merging (to avoid errors about duplicated objects) ;  ; template<class T > ; void HandlePoolCode (MPCodeBufPair &msg, TSocket *sender, std::vector< T > &reslist);  Handle message and reply to the worker. ;  ; void ReplyToIdle (TSocket *s);  Reply to a worker who is idle. ;  ; void Reset ();  Reset TTreeProcessorMP's state. ;  ;  Private Member Functions inherited from TMPClient;  TMPClient (const TMPClient &)=delete;  ;  TMPClient (unsigned nWorkers=0);  Class constructor. ;  ;  ~TMPClient ();  Class destructor. ;  ; template<class T > ; unsigned Broadcast (unsigned code, const std::vector< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, std::initializer_list< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, T obj, unsigned nMessages=0);  Send a message containing code and obj to each worker, up to a maximum number of nMessages workers. ;  ; unsigned Broadcast (unsigned code, unsigned nM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:8869,avoid,avoid,8869,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['avoid'],['avoid']
Safety,"g64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:8505,recover,recover,8505,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['recover'],['recover']
Safety,"g64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:6513,recover,recover,6513,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,3,['recover'],['recover']
Safety,"g; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t DrawSelect(const char* dsetname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Execute the specified drawing action on a data set which is stored on the; master with name 'dsetname'.; The syntax for dsetname is name[#[dir/]objname], e.g.; ""mydset"" analysis of the first tree in the top dir of the dataset; named ""mydset""; ""mydset#T"" analysis tree ""T"" in the top dir of the dataset; named ""mydset""; ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset; named ""mydset""; ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the; dataset named ""mydset""; The last argument 'enl' specifies an entry- or event-list to be used as; event selection.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void StopProcess(Bool_t abort, Int_t timeout = -1); Send STOPPROCESS message to master and workers. void DisableGoAsyn(); Signal to disable related switches. void GoAsynchronous(); Send GOASYNC message to the master. void RecvLogFile(TSocket* s, Int_t size); Receive the log file of the slave with socket s. void NotifyLogMsg(const char* msg, const char* sfx = ""\n""); Notify locally 'msg' to the appropriate units (file, stdout, window); If defined, 'sfx' is added after 'msg' (typically a line-feed);. void LogMessage(const char* msg, Bool_t all); Log a message into the appropriate window by emitting a signal. Int_t SendGroupView(); Send to all active slaves servers the current slave group size; and their unique id. Returns number of active slaves.; Returns -1 in case of error. Bool_t GetFileInCmd(const char* cmd, TString& fn); Static method to extract the filename (if any) form a CINT command.; Returns kTRUE and the filename in 'fn'; returns kFALSE if not found or not; appliable. Int_t Exec(const char* cmd, Bool_t plusMaster = kFALSE); S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:52524,abort,abort,52524,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,12,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"g; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else nt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:41350,safe,safer,41350,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['safe'],['safer']
Safety,"g; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromize; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occured while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:39205,safe,safer,39205,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['safe'],['safer']
Safety,"g; kSmall2WelcomeMsg; kOriginalWelcomeMsgColor; kOriginalWelcomeMsgBW; };; enum ECitation { kPlainText; kBibTeX; kLaTeX; kHtmlLink; };. public:. TMVA::MsgLogger*fLogger; const TStringfRegexp; TXMLEngine*fXMLEngine; static TMVA::Tools*fgTools. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(); { return fgTools?*(fgTools): *(fgTools = new Tools()); }. void DestroyInstance(). Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S^2(x) - B^2(x))/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x)2 - B(x)2)/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.0); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* ,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Tools.html:5744,sanity check,sanity check,5744,root/html528/TMVA__Tools.html,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html,3,['sanity check'],['sanity check']
Safety,"gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 3105 bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();; 3106 fInterpreter->enableDynamicLookup(false);; 3107 bool oldRawInput = fInterpreter->isRawInputEnabled();; 3108 fInterpreter->enableRawInput(true);; 3109 ; 3110 Bool_t ret = LoadText(code);; 3111 ; 3112 fInterpreter->enableRawInput(oldRawInput);; 3113 fInterpreter->enableDynamicLookup(oldDynLookup);; 3114 return ret;; 3115}; 3116 ; 3117////////////////////////////////////////////////////////////////////////////////; 3118/// It calls a ""fantom"" method to synchronize user keyboard input; 3119/// and ROOT prompt line.; 3120 ; 3121void TCling::EndOfLineAction(); 3122{; 3123 ProcessLineSynch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling; 3127// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which; 3128// was already taking a lock.; 3129static Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:120702,avoid,avoid,120702,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"gWriterDefinition TVirtualMonitoring.h:116; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPerfStats.h; gPerfStats#define gPerfStatsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:199239,safe,safe,199239,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['safe'],['safe']
Safety,"gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited Parameters; For variable parameters with limits, Minuit uses the following transformation:; Pint = arcsin(2((Pext-a)/(b-a))-1); Pext = a+((b-a)/(2))(sinPint+1); so that the internal value Pint can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:216634,avoid,avoided,216634,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoided']
Safety,"geDefinition TTimer.cxx:56; TSingleShotCleaner::TSingleShotCleanerTSingleShotCleaner()Definition TTimer.cxx:58; TString::LengthSsiz_t Length() constDefinition TString.h:417; TSystem::ResetTimervirtual void ResetTimer(TTimer *)Definition TSystem.h:396; TSystem::GetListOfTimersvirtual TList * GetListOfTimers() constDefinition TSystem.h:393; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::SetObjectvoid SetObject(TObject *object)Set the object to be notified at time out.Definition TTimer.cxx:186; TTimer::SingleShotstatic void SingleShot(Int_t milliSec, const char *receiver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:13166,timeout,timeout,13166,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety,"genDecay, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooTFnPdfBinding, RooUniform, RooVoigtian, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooCachedPdf, RooEfficiency, RooEffProd, RooExtendedTerm, RooExtendPdf, RooFFTConvPdf, RooGenericPdf, RooHistPdf, RooMultiVarGaussian, RooNumConvPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooResolutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare.; Definition at line 351 of file RooAbsPdf.h. ◆ isActiveNormSet(). bool RooAbsPdf::isActiveNormSet ; (; RooArgSet const * ; normSet); const. inlineprotected . Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ; Definition at line 299 of file RooAbsPdf.h. ◆ isDirectGenSafe(). bool RooAbsPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. virtual . Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ; Observables on which a PDF depends via more than route are not safe for use with internal generators because they introduce correlations not known to the internal generator ; Reimplemented in RooAbsAnaConvPdf, RooAddModel, RooBinSamplingPdf, and RooProdPdf.; Definition at line 1557 of file RooAbsPdf.cxx. ◆ logBatchComputationErrors(). void RooAbsPdf::logBatchComputationErrors ; (; std::span< const double > & ; outputs, . std::size_t ; begin . ); const. private . Scan through outputs and fix+log all nans and negative values. ; Parameters. [in,out]outputsArray to be scanned & fixed. ; [in]beginBegin of event range. Only needed to print the correct event number where the error occurred. . Definition at line 654 of file RooAbsPdf.cxx. ◆ mustBeExtended(). bool RooAbsPdf::mustBeExtended ; (; ); const. inline . If true PDF must provide extended likelihood term. ; Definition at line 222 of file RooAbsPdf.h. ◆ normalizeWithNaNPacking().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:132608,safe,safely,132608,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['safe'],['safely']
Safety,"ger highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013079,detect,detector,1013079,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,"ges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 143 ,Int_t nbinsy,const Float_t *ybins; 144 ,Int_t nbinsz,const Float_t *zbins); 145 :TH1(name,title,nbinsx,xbins); 146{; 147 fDimension = 3;; 148 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 149 if (nbinsz <= 0) nbinsz = 1;; 150 if (ybins) fYaxis.Set(nbinsy,ybins);; 151 else fYaxis.Set(nbinsy,0,1);; 152 if (zbins) fZaxis.Set(nbinsz,zbins);; 153 else fZaxis.Set(nbinsz,0,1);; 154 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 155 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 156 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 157}; 158 ; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 162/// arrays of type double.; 163///; 164/// \param[in] name name of histogram (avoid blanks); 165/// \param[in] title histogram title.; 166/// If title is of the form `stringt;stringx;stringy;stringz`; 167/// the histogram title is set to `stringt`,; 168/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 169/// \param[in] nbinsx number of bins; 170/// \param[in] xbins array of low-edges for each bin.; 171/// This is an array of type double and size nbinsx+1; 172/// \param[in] nbinsy number of bins; 173/// \param[in] ybins array of low-edges for each bin.; 174/// This is an array of type double and size nbinsy+1; 175/// \param[in] nbinsz number of bins; 176/// \param[in] zbins array of low-edges for each bin.; 177/// This is an array of type double and size nbinsz+1; 178 ; 179TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 180 ,Int_t nbinsy,const Double_t *ybins; 181 ,Int_t nbinsz,const Double_t *zbins); 182 :TH1(name,title,nbinsx,xbins); 183{; 184 fDimension = 3;; 185 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:7308,avoid,avoid,7308,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"get from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:25922,avoid,avoid,25922,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['avoid'],['avoid']
Safety,"gger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:32725,abort,abort,32725,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['abort'],['abort']
Safety,"gin(). Create e.g. histograms in this method.; 23 This method is called (with or without PROOF) before looping on the; 24 entries in the Tree. When using PROOF, this method is called on; 25 each worker node.; 26 ; 27- void TSelector::Begin(). Mostly for backward compatibility; use; 28 SlaveBegin() instead. Both methods are called before looping on the; 29 entries in the Tree. When using PROOF, Begin() is called on the; 30 client only.; 31 ; 32- bool TSelector::Notify(). This method is called at the first entry; 33 of a new file in a chain.; 34 ; 35- bool TSelector::Process(Long64_t entry). This method is called; 36 to process an entry. It is the user's responsibility to read; 37 the corresponding entry in memory (may be just a partial read).; 38 Once the entry is in memory one can apply a selection and if the; 39 entry is selected histograms can be filled. Processing stops; 40 when this function returns false. This function combines the; 41 next two functions in one, avoiding to have to maintain state; 42 in the class to communicate between these two functions.; 43 See WARNING below about entry.; 44 This method is used by PROOF.; 45 ; 46- bool TSelector::ProcessCut(Long64_t entry). This method is called; 47 before processing entry. It is the user's responsibility to read; 48 the corresponding entry in memory (may be just a partial read).; 49 The function returns true if the entry must be processed,; 50 false otherwise. This method is obsolete, use Process().; 51 See WARNING below about entry.; 52 ; 53- void TSelector::ProcessFill(Long64_t entry). This method is called; 54 for all selected entries. User fills histograms in this function.; 55 This method is obsolete, use Process().; 56 See WARNING below about entry.; 57 ; 58- void TSelector::SlaveTerminate(). This method is called at the end of; 59 the loop on all PROOF worker nodes. In local mode this method is; 60 called on the client too.; 61 ; 62- void TSelector::Terminate(). This method is called at the end of; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:1937,avoid,avoiding,1937,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['avoid'],['avoiding']
Safety,"gin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(5); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_s1f.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_s1f.Draw(""box""); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_a1.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_a1.Draw(""box""); c.cd(7); ROOT.gPad.SetLeftMargin(0.15); corrHist000.GetYaxis().SetTitleOffset(1.4); corrHist000.Draw(""colz""); c.cd(8); ROOT.gPad.SetLeftMargin(0.15); corrHist127.GetYaxis().SetTitleOffset(1.4); corrHist127.Draw(""colz""); c.cd(9); ROOT.gPad.SetLeftMargin(0.15); corrHist953.GetYaxis().SetTitleOffset(1.4); corrHist953.Draw(""colz""); ; c.SaveAs(""rf801_mcstudy.png""); ; # Make ROOT.RooMCStudy object available on command line after; # macro finishes; ROOT.gDirectory.Add(mcstudy); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 930; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-867.289) to force MIGRAD to back out of this region. Error log follows.; P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8py.html:5087,safe,safe,5087,doc/master/rf801__mcstudy_8py.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html,1,['safe'],['safe']
Safety,"gin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd1.html:12360,safe,safe,12360,root/html528/TGeoTrd1.html,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html,6,['safe'],['safe']
Safety,"given set of; observables. If frozen, fractions are automatically transformed; from the reference normalization set to the contextual normalization; set by ratios of integrals. void fixCoefRange(const char* rangeName); By default the interpretation of the fraction coefficients is; performed in the default range. This make the shape of a RooAddPdf; explicitly dependent on the range of the observables. To allow; a range independent definition of the fraction this function; instructs RooAddPdf to freeze its interpretation in the given; named range. If the current normalization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions using; ratios if integrals. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. RooAddModel will clone all the component models to create a composite convolution object. Int_t basisCode(const char* name) const; Return code for basis function representing by 'name' string.; The basis code of the first component model will be returned,; if the basis is supported by all components. Otherwise 0; is returned. void updateCoefficients(RooAddModel::CacheElem& cache, const RooArgSet* nset) const; Update the coefficient values in the given cache element: calculate new remainder; fraction, normalize fractions obtained from extended ML terms to unity and; multiply these the various range and dimensional corrections needed in the; current use context. Double_t evaluate() const; Calculate the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. Bool_t checkObservables(const RooArgSet* ns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:44576,avoid,avoid,44576,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,7,['avoid'],['avoid']
Safety,"gle; TStringTNamed::fTitleobject title; Double_tTGeoTrap::fTl1half length in x at low z and y high edge; Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. TGeoGtra(); constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtra.html:15001,safe,safe,15001,root/html530/TGeoGtra.html,https://root.cern,https://root.cern/root/html530/TGeoGtra.html,2,['safe'],['safe']
Safety,"gle; TStringTNamed::fTitleobject title; Double_tTGeoTrap::fTl1half length in x at low z and y high edge; Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Ren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:14823,safe,safe,14823,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,1,['safe'],['safe']
Safety,"gleKey; kOverwrite; kWriteDelete; };. protected:. map<TString,ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,ExtraHeader>_ehmapList of extra header files; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& ); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. CodeRepo(const RooWorkspace::CodeRepo& other, RooWorkspace* wspace = 0); {}. virtual ~CodeRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace__CodeRepo.html:7269,abort,abort,7269,root/html534/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html534/RooWorkspace__CodeRepo.html,1,['abort'],['abort']
Safety,"gn only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:71985,avoid,avoid,71985,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['avoid'],['avoid']
Safety,"gnal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Private Member Functions; Int_t Broadcast (const char *mess, Int_t kind=kMESS_STRING, Int_t type=kRRT_Undef);  Broadcast a character string buffer to the remote session. ;  ; Int_t Broadcast (const TMessage &mess);  Broadcast a message to the remote session. ;  ; Int_t Broadcast (Int_t kind, Int_t type=kRRT_Undef);  ; Int_t BroadcastObject (const TObject *obj, Int_t kind=kMESS_OBJECT);  Broadcast an object to the remote session. ;  ; Int_t BroadcastRaw (const void *buffer, Int_t length);  Broadcast a raw buffer of specified length to the remote session. ;  ; Bool_t CheckFile (const char *file, Long_t modtime);  Check if a file needs to be send to the server. ;  ; Int_t Collect (Long_t timeout=-1);  Collect responses from the remote server. ;  ; Int_t CollectInput ();  Collect and analyze available input from the socket. ;  ; void RecvLogFile (Int_t size);  Receive the log file from the server. ;  . Private Attributes; THashList * fFileList;  ; Bool_t fInterrupt;  ; TSignalHandler * fIntHandler;  ; TString fLogFilePath;  ; TMonitor * fMonitor;  ; TString fName;  ; Int_t fProtocol;  ; TObject * fReceivedObject;  ; TSeqCollection * fRootFiles;  ; TSocket * fSocket;  ; TUrl fUrl;  ; TRemoteObject * fWorkingDir;  . Static Private Attributes; static Int_t fgPortAttempts = 100;  ; static Int_t fgPortLower = 49152;  ; static Int_t fgPortUpper = 65535;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") subm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:19005,timeout,timeout,19005,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['timeout'],['timeout']
Safety,"gram axis.Definition TAxis.h:31; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37. Number of divisions optimisation; By default the number of divisions on axis is optimised to show a coherent labelling of the main tick marks. The number of division (ndiv) is a composite integer given by:; ndiv = N1 + 100*N2 + 10000*N3. N1 = number of 1st divisions.; N2 = number of 2nd divisions.; N3 = number of 3rd divisions. by default the value of N1, N2 and N3 are maximum values. After optimisation the real number of divisions will be smaller or equal to these value. If one wants to bypass the optimisation, the option ""N"" should be given when the TGaxis is created. The option ""I"" also act on the number of division as it will force an integer labelling of the axis.; On an histogram pointer h the number of divisions can be set in different ways:. Directly on the histogram. The following will set the number of division to 510 on the X axis of h. To avoid optimization the number of divisions should be negative (ie: -510); h->SetNdivisions(510, ""X"");. On the axis itself: h->GetXaxis()->SetNdivisions(510, kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93. The first parameter is the number of division. If it is negative of if the second parameter is kFALSE then the number of divisions is not optimised. And other signature is also allowed: h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; . Maximum Number of Digits for the axis labels; The static method TGaxis::SetMaxDigits sets the maximum number of digits permitted for the axis labels above which the notation with 10^N is used. For example, to accept 6 digits number like 900000 on an axis call TGaxis::SetMaxDigits(6). The default value is 5. fgMaxDigits must be greater than 0. Warning: even when called on a particular TGaxis* instance, this static function changes globally the number of digits for all axes (X, Y, ...) in the canvas. If you want to change the maximum number of digits N only of the current TGaxis*, and no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:16280,avoid,avoid,16280,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['avoid'],['avoid']
Safety,"gs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107479,avoid,avoid,1107479,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"gv, void *options=nullptr, Int_t numOptions=0);  Create an application environment. ;  ; virtual ~TApplication ();  TApplication dtor. ;  ; Int_t Argc () const;  ; char ** Argv () const;  ; char * Argv (Int_t index) const;  Return specified argument. ;  ; void ClearInputFiles ();  Clear list containing macro files passed as program arguments. ;  ; EExitOnException ExitOnException (EExitOnException opt=kExit);  Set the exit on exception option. ;  ; virtual TApplicationImp * GetApplicationImp ();  ; TApplication * GetAppRemote () const;  ; const char * GetIdleCommand () const;  ; virtual void GetOptions (Int_t *argc, char **argv);  Get and handle command line options. ;  ; TString GetSetup ();  It gets the ROOT installation setup as TString. ;  ; TSignalHandler * GetSignalHandler () const;  ; virtual void HandleException (Int_t sig);  Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ;  ; virtual void HandleIdleTimer ();  Handle idle timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:4107,timeout,timeout,4107,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['timeout'],['timeout']
Safety,"h a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:5938,predict,predicting,5938,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['predict'],['predicting']
Safety,"h data with Super smoother. ; Smooth the (x, y) values by Friedman's `‘super smoother’'.; Parameters. [in]gringraph for smoothing ; [in]optionspecific options ; [in]spanthe fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. ; [in]basscontrols the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. ; [in]isPeriodicif TRUE, the x values are assumed to be in [0, 1] and of period 1. ; [in]wcase weights. Details:; supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.; The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.; The FORTRAN code says: `‘For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.’'; References:; Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.; Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5. . Definition at line 479 of file TGraphSmooth.cxx. ◆ Streamer(). void TGraphSmooth::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphSmooth::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 76 of file TGraphSmooth.h. Member Data Documentation. ◆ fGin. TGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphSmooth.html:26461,predict,prediction,26461,doc/master/classTGraphSmooth.html,https://root.cern,https://root.cern/doc/master/classTGraphSmooth.html,1,['predict'],['prediction']
Safety,"h""; #include ""TFile.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayF.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TLegend.h""; #include ""TSystem.h""; ; #include ""TMatrixD.h""; #include ""TMatrixDSym.h""; #include ""TVectorD.h""; #include ""TQpProbDens.h""; #include ""TGondzioSolver.h""; ; const Int_t nrStocks = 10;; static const Char_t *stocks[] =; {""GE"",""SUNW"",""QCOM"",""BRCM"",""TYC"",""IBM"",""AMAT"",""C"",""PFE"",""HD""};; ; class TStockDaily {; public:; Int_t fDate;; Int_t fOpen; // 100*open_price; Int_t fHigh; // 100*high_price; Int_t fLow; // 100*low_price; Int_t fClose; // 100*close_price; Int_t fVol;; Int_t fCloseAdj; // 100*close_price adjusted for splits and dividend; ; TStockDaily() {; fDate = fVol = fOpen = fHigh = fLow = fClose = fCloseAdj = 0;; }; virtual ~TStockDaily() {}; ; ClassDef(TStockDaily,1); };; ; //---------------------------------------------------------------------------; Double_t RiskProfile(Double_t *x, Double_t *par) {; Double_t riskFactor = par[0];; return 1-TMath::Exp(-riskFactor*x[0]);; }; ; //---------------------------------------------------------------------------; TArrayF &StockReturn(TFile *f,const TString &name,Int_t sDay,Int_t eDay); {; TTree *tDaily = (TTree*)f->Get(name);; TStockDaily *data = 0;; tDaily->SetBranchAddress(""daily"",&data);; TBranch *b_closeAdj = tDaily->GetBranch(""fCloseAdj"");; TBranch *b_date = tDaily->GetBranch(""fDate"");; ; //read only the ""adjusted close"" branch for all entries; const Int_t nrEntries = (Int_t)tDaily->GetEntries();; TArrayF closeAdj(nrEntries);; for (Int_t i = 0; i < nrEntries; i++) {; b_date->GetEntry(i);; b_closeAdj->GetEntry(i);; if (data->fDate >= sDay && data->fDate <= eDay); closeAdj[i] = data->fCloseAdj/100.;; }; ; TArrayF *r = new TArrayF(nrEntries-1);; for (Int_t i = 1; i < nrEntries; i++); // (*r)[i-1] = closeAdj[i]-closeAdj[i-1];; (*r)[i-1] = closeAdj[i]/closeAdj[i-1];; ; return *r;; }; ; #ifndef __MAKECINT__; //---------------------------------------------------------------------------; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:6595,risk,riskFactor,6595,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,2,['risk'],['riskFactor']
Safety,"h""; 27#include <string>; 28 ; 29typedef void (*SigHandler_t)(ESignals);; 30 ; 31 ; 32class TUnixSystem : public TSystem {; 33 ; 34private:; 35 void FillWithCwd(char *cwd) const;; 36 ; 37protected:; 38 const char *GetLinkedLibraries() override;; 39 ; 40 // static functions providing semi-low level interface to raw Unix; 41 static int UnixMakedir(const char *name);; 42 static void *UnixOpendir(const char *name);; 43 static const char *UnixGetdirentry(void *dir);; 44 static const char *UnixHomedirectory(const char *user = nullptr);; 45 static const char *UnixHomedirectory(const char *user, char *path, char *mydir);; 46 static Long64_t UnixNow();; 47 static int UnixWaitchild();; 48 static int UnixSetitimer(Long_t ms);; 49 static int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 50 Long_t timeout);; 51 static void UnixSignal(ESignals sig, SigHandler_t h);; 52 static const char *UnixSigname(ESignals sig);; 53 static void UnixSigAlarm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8h_source.html:1855,timeout,timeout,1855,doc/master/TUnixSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"h""; 40#include ""TPaveStats.h""; 41#include ""TGroupButton.h""; 42#include ""TBrowser.h""; 43#include ""TVirtualGL.h""; 44#include ""TString.h""; 45#include ""TDataMember.h""; 46#include ""TMethod.h""; 47#include ""TDataType.h""; 48#include ""TFrame.h""; 49#include ""TExec.h""; 50#include ""TDatime.h""; 51#include ""TColor.h""; 52#include ""TCanvas.h""; 53#include ""TPluginManager.h""; 54#include ""TEnv.h""; 55#include ""TImage.h""; 56#include ""TViewer3DPad.h""; 57#include ""TCreatePrimitives.h""; 58#include ""TLegend.h""; 59#include ""TAtt3D.h""; 60#include ""TVirtualPadPainter.h""; 61#include ""strlcpy.h""; 62#include ""snprintf.h""; 63 ; 64#include ""TVirtualMutex.h""; 65 ; 66static Int_t gReadLevel = 0;; 67 ; 68Int_t TPad::fgMaxPickDistance = 5;; 69 ; 70ClassImpQ(TPad); 71 ; 72/** \class TPad; 73\ingroup gpad; 74 ; 75The most important graphics class in the ROOT system.; 76 ; 77A Pad is contained in a Canvas.; 78 ; 79A Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:2287,detect,detectors,2287,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['detect'],['detectors']
Safety,"h(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:2971,safe,safe,2971,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"h); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:10955,timeout,timeout,10955,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"h. When the buffer is full, it is compressed and written to disc.; 366 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 367 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 368 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 369 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:19361,avoid,avoid,19361,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['avoid'],['avoid']
Safety,"hDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:25225,recover,recover,25225,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['recover'],['recover']
Safety,"hDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:26164,recover,recover,26164,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['recover'],['recover']
Safety,"hHeight is the batchSize in case of first Dense layers (then we need to set to fNet batch size); 2314 //if (fXInput.size() > 0) fXInput.clear();; 2315 //fXInput.emplace_back(MatrixImpl_t(n1,n2));; 2316 fXInput = ArchitectureImpl_t::CreateTensor(fNet->GetBatchSize(), GetInputDepth(), GetInputHeight(), GetInputWidth() );; 2317 if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1); 2318 // make here a ColumnMajor tensor; 2319 fXInput = TensorImpl_t( fNet->GetBatchSize(), GetInputWidth(),TMVA::Experimental::MemoryLayout::ColumnMajor );; 2320 fXInputBuffer = HostBufferImpl_t( fXInput.GetSize());; 2321 ; 2322 // create pointer to output matrix used for the predictions; 2323 fYHat = std::unique_ptr<MatrixImpl_t>(new MatrixImpl_t(fNet->GetBatchSize(), fNet->GetOutputWidth() ) );; 2324 ; 2325 ; 2326}; 2327 ; 2328 ; 2329////////////////////////////////////////////////////////////////////////////////; 2330void MethodDL::ReadWeightsFromStream(std::istream & /*istr*/); 2331{; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335const Ranking *TMVA::MethodDL::CreateRanking(); 2336{; 2337 // TODO; 2338 return NULL;; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342void MethodDL::GetHelpMessage() const; 2343{; 2344 // TODO; 2345}; 2346 ; 2347} // namespace TMVA; Adadelta.h; Adagrad.h; Adam.h; ClassifierFactory.h; REGISTER_METHOD#define REGISTER_METHOD(CLASS)for exampleDefinition ClassifierFactory.h:124; Configurable.h; Cuda.h; DLMinimizers.h; IMethod.h; MethodDL.h; RMSProp.h; e#define e(i)Definition RSha256.hxx:103; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; SGD.h; TCudnn.h; R__ASSERT#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:92999,predict,predictions,92999,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['predictions']
Safety,"handler from the list of file handlers. ;  ; void RemoveOnExit (TObject *obj);  Objects that should be deleted on exit of the OS interface. ;  ; virtual TSignalHandler * RemoveSignalHandler (TSignalHandler *sh);  Remove a signal handler from list of signal handlers. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual TTimer * RemoveTimer (TTimer *t);  Remove timer from list of system timers. ;  ; virtual int Rename (const char *from, const char *to);  Rename a file. ;  ; virtual void ResetSignal (ESignals sig, Bool_t reset=kTRUE);  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; virtual void ResetSignals ();  Reset signals handlers to previous behaviour. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual Int_t Select (TFileHandler *fh, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual Int_t Select (TList *active, Long_t timeout);  Select on active file descriptors (called by TMonitor). ;  ; virtual int SendBuf (int sock, const void *buffer, int length);  Send a buffer headed by a length indicator. ;  ; virtual int SendRaw (int sock, const void *buffer, int length, int flag);  Send exactly length bytes from buffer. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; virtual void SetDynamicPath (const char *pathname);  Set the dynamic path to a new value. ;  ; virtual void Setenv (const char *name, const char *value);  Set environment variable. ;  ; void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:15233,timeout,timeout,15233,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['timeout'],['timeout']
Safety,"hape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:18363,safe,safe,18363,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"hape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoArb8.html:2638,safe,safe,2638,root/html530/TGeoArb8.html,https://root.cern,https://root.cern/root/html530/TGeoArb8.html,1,['safe'],['safe']
Safety,"hape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHype.html:3014,safe,safe,3014,root/html530/TGeoHype.html,https://root.cern,https://root.cern/root/html530/TGeoHype.html,1,['safe'],['safe']
Safety,"hape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoEltu.html:2034,safe,safe,2034,root/html530/TGeoEltu.html,https://root.cern,https://root.cern/root/html530/TGeoEltu.html,1,['safe'],['safe']
Safety,"har y1Definition TGWin32VirtualXProxy.cxx:70; TGWin32VirtualXProxy.h; GetPixelstatic void GetPixel(int y, int width, Byte_t *scline)Get pixels in line y and put in array scline.Definition TGWin32.cxx:4302; TGWin32.h; namechar name[80]Definition TGX11.cxx:110; TList.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TGWin32VirtualXProxyDefinition TGWin32VirtualXProxy.h:30; TGWin32VirtualXProxy::fgRealObjectstatic TVirtualX * fgRealObjectDefinition TGWin32VirtualXProxy.h:35; TGWin32VirtualXProxy::CheckEventBool_t CheckEvent(Window_t id, EGEventType type, Event_t &ev) overrideCheck if there is for window ""id"" an event of type ""type"".Definition TGWin32VirtualXProxy.cxx:312; TGWin32VirtualXProxy::LookupStringvoid LookupString(Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) overrideConvert the keycode from the event structure to a key symbol (according to the modifiers specified in...Definition TGWin32VirtualXProxy.cxx:285; TGWin32VirtualXProxy::GetParentWindow_t GetParent(Window_t id) const overridemight be thread unsafe (?)Definition TGWin32VirtualXProxy.cxx:274; TGWin32VirtualXProxy::SendEventvoid SendEvent(Window_t id, Event_t *ev) overrideSend event ev to window id.Definition TGWin32VirtualXProxy.cxx:320; TGWin32VirtualXProxy::GetCurrentWindowWindow_t GetCurrentWindow() const overrideReturn a pointer to the current window.Definition TGWin32VirtualXProxy.cxx:336; TGWin32VirtualXProxy::EventsPendingInt_t EventsPending() overrideReturn number of pending events.Definition TGWin32VirtualXProxy.cxx:296; TGWin32VirtualXProxy::IsCmdThreadBool_t IsCmdThread() const overrideReturn kTRUE if we are inside cmd/server thread.Definition TGWin32VirtualXProxy.cxx:328; TGWin32VirtualXProxy::RealObjectstatic TVirtualX * RealObject()Definition TGWin32VirtualXProxy.cxx:32; TGWin32VirtualXProxy::NextEventvoid NextEvent(Event_t &event) overrideProcess next event in the queue - if any.Definition TGWin32VirtualXProxy.cxx:304; TPointDefinition TPoint.h:31; TStringBasic string class.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:94158,unsafe,unsafe,94158,doc/master/TGWin32VirtualXProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"har* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterTree&operator=(const TEventIterTree&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t ent); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterTree(); TEventIterTree(const TEventIterTree&); TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterTree.html:4651,abort,abort,4651,root/html602/TEventIterTree.html,https://root.cern,https://root.cern/root/html602/TEventIterTree.html,2,['abort'],['abort']
Safety,"har* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterUnit&operator=(const TEventIterUnit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterUnit(); TEventIterUnit(const TEventIterUnit&); TEventIterUnit(TDSet* dset, TSelector* sel, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterUnit.html:4647,abort,abort,4647,root/html602/TEventIterUnit.html,https://root.cern,https://root.cern/root/html602/TEventIterUnit.html,2,['abort'],['abort']
Safety,"har* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:4109,abort,abort,4109,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['abort'],['abort']
Safety,"har* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*GetCacheLock(); const char*GetConfDir() const; const char*Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:4109,abort,abort,4109,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['abort'],['abort']
Safety,"hat the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t[4] rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t[17] rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t[17] rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen positio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPhysicalShape.html:6919,avoid,avoid,6919,root/html602/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html,2,['avoid'],['avoid']
Safety,"have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ;  ; static void SetLoopbackMode (bool on=true);  Set loopback mode for THttpServer used for web widgets By default is on. ;  ; static void SetUseConnectionKey (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ;  ; float GetLaunchTmout () const;  Returns timeout for launching new browser process. ;  ; std::string GetUrl (RWebWindow &win, bool remote=false, std::string *produced_key=nullptr);  Provide URL address to access specified window from inside or from remote. ;  ; bool InformListener (const std::string &msg);  If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ;  ; bool IsUseHttpThread () const;  Returns true if http server use special thread for requests processing (default off) ;  ; bool IsUseSenderThreads () const;  Returns true if extra threads to send data via websockets will be used (default off) ;  ; unsigned ShowWindow (RWebWindow &win, const RWebDisplayArgs &args);  Show window in specified location, see Show() method for more details. ;  ; void Unregister (RWebWindow &win);  Release all references to specified window Called from RWebWindow destructor. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:3481,timeout,timeout,3481,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['timeout'],['timeout']
Safety,"hcore:$Id$; 2// Authors: L. Moneta, A. Zsenei 08/2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2004 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14#ifndef ROOT_Math_WrappedFunction; 15#define ROOT_Math_WrappedFunction; 16 ; 17#include ""IFunction.h""; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23 ; 24 ; 25 ; 26struct NullTypeFunc1D {};; 27 ; 28typedef double(*FreeFunctionPtr)(double);; 29 ; 30typedef double(*FreeMultiFunctionPtr)(const double*);; 31 ; 32/**; 33 Template class to wrap any C++ callable object which takes one argument; 34 i.e. implementing operator() (double x) in a One-dimensional function interface.; 35 It provides a ROOT::Math::IGenFunction-like signature; 36 ; 37 Note: If you want to wrap just the reference (to avoid copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedFunction_8h_source.html:1235,avoid,avoid,1235,doc/master/WrappedFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html,1,['avoid'],['avoid']
Safety,"he caller. ; Definition at line 5692 of file TProofServ.cxx. ◆ HandleArchive(). void TProofServ::HandleArchive ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle archive request. ; Definition at line 3597 of file TProofServ.cxx. ◆ HandleCache(). Int_t TProofServ::HandleCache ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here all cache and package requests. ; Definition at line 5280 of file TProofServ.cxx. ◆ HandleCheckFile(). void TProofServ::HandleCheckFile ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle file checking request. ; Definition at line 5129 of file TProofServ.cxx. ◆ HandleDataSets(). Int_t TProofServ::HandleDataSets ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here requests about datasets. ; Definition at line 6087 of file TProofServ.cxx. ◆ HandleException(). void TProofServ::HandleException ; (; Int_t ; sig). overridevirtual . Exception handler: we do not try to recover here, just exit. ; Reimplemented from TApplication.; Definition at line 6070 of file TProofServ.cxx. ◆ HandleFork(). void TProofServ::HandleFork ; (; TMessage * ; mess). protectedvirtual . Cloning itself via fork. Not implemented. ; Reimplemented in TProofServLite.; Definition at line 6654 of file TProofServ.cxx. ◆ HandleLibIncPath(). Int_t TProofServ::HandleLibIncPath ; (; TMessage * ; mess). protectedvirtual . Handle lib, inc search paths modification request. ; Definition at line 4999 of file TProofServ.cxx. ◆ HandleProcess(). void TProofServ::HandleProcess ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle processing request. ; Definition at line 3756 of file TProofServ.cxx. ◆ HandleQueryList(). void TProofServ::HandleQueryList ; (; TMessage * ; mess). protectedvirtual . Handle request for list of queries. ; Definition at line 4795 of file TProofServ.cxx. ◆ HandleRemove(). void TProofServ::HandleRemove ; (; TMessage * ; mess, . TString * ; sl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:44703,recover,recover,44703,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['recover'],['recover']
Safety,"he class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:92259,detect,detection,92259,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['detect'],['detection']
Safety,"he contents of the argset in ASCII form from given stream. ; The stream is read to end-of-file and each line is assumed to be of the form <argName> = <argValue>; Lines starting with argNames not matching any element in the list will be ignored with a warning message. In addition limited C++ style preprocessing and flow control is provided. The following constructions are recognized: include ""include.file""; Include given file, recursive inclusion OK if (<boolean_expression>); <name> = <value>; ....; else if (<boolean_expression>); ....; else; ....; endif; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; All expressions are evaluated by RooFormula, and may involve any of the sets variables. echo <Message>; Print console message while reading from stream abort; Force termination of read sequence with error status; The value of each argument is read by the arguments readFromStream function. ; Definition at line 336 of file RooArgSet.cxx. ◆ selectByName(). RooArgSet * RooArgSet::selectByName ; (; const char * ; nameList, . bool ; verbose = false . ); const. inline . Use RooAbsCollection::selectByName(), but return as RooArgSet. ; Definition at line 144 of file RooArgSet.h. ◆ selectCommon() [1/3]. RooAbsCollection * RooAbsCollection::selectCommon ; (; const RooAbsCollection & ; refColl); const. Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ; The caller is responsible for deleting the returned collection ; Definition at line 230 of file RooAbsCollection.cxx. ◆ selectCommon() [2/3]. RooArgSet * RooArgSet::selectCommon ; (; const RooAbsCollection & ; refColl); const. inline . Use RooAbsCollection::selecCommon(), but return as RooArgSet. ; Definition at line 149 of file RooArgSet.h. ◆ s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:41528,abort,abort,41528,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['abort'],['abort']
Safety,"he corresponding space in the file by looking in the; 1880/// TFree list of free blocks of the file.; 1881/// - The buffer is written to the file.; 1882///; 1883/// By default, the buffersize will be taken from the average buffer size; 1884/// of all objects written to the current file so far.; 1885/// Use TDirectoryFile::SetBufferSize to force a given buffer size.; 1886///; 1887/// If a name is specified, it will be the name of the key.; 1888/// If name is not given, the name of the key will be the name as returned; 1889/// by obj->GetName().; 1890///; 1891/// The option can be a combination of:; 1892/// - ""SingleKey""; 1893/// - ""Overwrite""; 1894/// - ""WriteDelete""; 1895/// Using the ""Overwrite"" option a previous key with the same name is; 1896/// overwritten. The previous key is deleted before writing the new object.; 1897/// Using the ""WriteDelete"" option a previous key with the same name is; 1898/// deleted only after the new object has been written. This option; 1899/// is safer than kOverwrite but it is slower.; 1900/// The ""SingleKey"" option is only used by TCollection::Write() to write; 1901/// a container with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:65098,safe,safer,65098,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['safe'],['safer']
Safety,"he current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:49198,abort,abort,49198,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['abort'],['abort']
Safety,"he current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 1e-3, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. Needed here because a RooSimultaneous; works like a RooAddPdf when plotted. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:44452,abort,abort,44452,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,4,['abort'],['abort']
Safety,"he deletion ot update the list itself.; 1107 ; 1108 static TObject harmless;; 1109 TObjLink *cursor = files->FirstLink();; 1110 while (cursor) {; 1111 Content *dir = static_cast<Content*>( cursor->GetObject() );; 1112 if (dir) {; 1113 // In order for the iterator to stay valid, we must; 1114 // prevent the removal of the object (dir) from the list; 1115 // (which is done in TFile::Close). We can also can not; 1116 // just move to the next iterator since the Close might; 1117 // also (indirectly) remove that file.; 1118 // So we SetObject to a harmless value, so that 'dir'; 1119 // is not seen as part of the list.; 1120 // We will later, remove all the object (see files->Clear(); 1121 cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.; 1122 // See related comment at the files->Clear(""nodelete"");; 1123 dir->Close(""nodelete"");; 1124 // Put it back; 1125 cursor->SetObject(dir);; 1126 }; 1127 cursor = cursor->Next();; 1128 };; 1129 // Now were done, clear the list but do not delete the objects as; 1130 // they have been moved to the list of closed objects and must be; 1131 // deleted from there in order to avoid a double delete from a; 1132 // use objects (on the interpreter stack).; 1133 files->Clear(""nodelete"");; 1134 }; 1135 ; 1136 static void R__ListSlowDeleteContent(TList *files); 1137 {; 1138 // Routine to delete the content of list of files using the 'slow' techniques; 1139 ; 1140 static TObject harmless;; 1141 TObjLink *cursor = files->FirstLink();; 1142 while (cursor) {; 1143 TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );; 1144 if (dir) {; 1145 // In order for the iterator to stay valid, we must; 1146 // prevent the removal of the object (dir) from the list; 1147 // (which is done in TFile::Close). We can also can not; 1148 // just move to the next iterator since the Close might; 1149 // also (indirectly) remove that file.; 1150 // So we SetObject to a harmless value, so that 'dir'; 1151 // is not seen as part o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:44186,avoid,avoid,44186,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avoid'],['avoid']
Safety,"he entry is assumed to be global index and the local entry is recomputed from the treeoffset information of the chain . Reimplemented in TEntryListArray, and TEntryListFromFile.; Definition at line 631 of file TEntryList.cxx. ◆ Enter() [2/2]. bool TEntryList::Enter ; (; Long64_t ; localentry, . const char * ; treename, . const char * ; filename . ). virtual . Reimplemented in TEntryListArray, and TEntryListFromFile.; Definition at line 679 of file TEntryList.cxx. ◆ EnterRange(). void TEntryList::EnterRange ; (; Long64_t ; start, . Long64_t ; end, . TTree * ; tree = nullptr, . UInt_t ; step = 1U . ). Enter all entries in a range in the TEntryList. ; Parameters. [in]startstarting entry to enter. ; [in]endending entry to enter. ; [in]treepassed as is to TEntryList::Enter. ; [in]stepstep increase of the loop entering the entries. This is a helper function that enters all entries between start (inclusive) and end (exclusive) to the TEntryList in a loop. It is useful also in PyROOT to avoid having to do the same in a Python loop. ; Definition at line 703 of file TEntryList.cxx. ◆ GetCurrentList(). virtual TEntryList * TEntryList::GetCurrentList ; (; ); const. inlinevirtual . Reimplemented in TEntryListFromFile.; Definition at line 71 of file TEntryList.h. ◆ GetDirectory(). virtual TDirectory * TEntryList::GetDirectory ; (; ); const. inlinevirtual . Definition at line 77 of file TEntryList.h. ◆ GetEntriesToProcess(). virtual Long64_t TEntryList::GetEntriesToProcess ; (; ); const. inlinevirtual . Definition at line 75 of file TEntryList.h. ◆ GetEntry(). Long64_t TEntryList::GetEntry ; (; Long64_t ; index). virtual . Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next(). ; Reimplemented in TEntryListFromFile.; Definition at line 759 of file TEntryList.cxx. ◆ GetEntryAndTree(). Long64_t TEntryList::GetEntryAndTree ; (; Long64_t ; index, . Int_t & ; treenum . ). virtual . Return the index of ""index""-th non-zero entry in the TTree or TCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:31651,avoid,avoid,31651,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['avoid'],['avoid']
Safety,"he error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. eps",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:2755,detect,detector,2755,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,['detect'],['detector']
Safety,"he geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:4929,safe,safely,4929,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safely']
Safety,"he interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimer.html:13704,timeout,timeout,13704,root/html534/TTimer.html,https://root.cern,https://root.cern/root/html534/TTimer.html,3,['timeout'],['timeout']
Safety,"he list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:21620,timeout,timeout,21620,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"he lower edge of the PDF ;  ; Float_t fSigma;  Width of the Kernel function. ;  ; TH1F * fSigmaHist;  contains the Sigmas Widths for adaptive KDE ;  ; Float_t fUpperEdge;  the upper edge of the PDF ;  . #include <TMVA/KDEKernel.h>; Member Enumeration Documentation. ◆ EKernelBorder. enum TMVA::KDEKernel::EKernelBorder. EnumeratorkNoTreatment ; kKernelRenorm ; kSampleMirror . Definition at line 56 of file KDEKernel.h. ◆ EKernelIter. enum TMVA::KDEKernel::EKernelIter. EnumeratorkNonadaptiveKDE ; kAdaptiveKDE . Definition at line 55 of file KDEKernel.h. ◆ EKernelType. enum TMVA::KDEKernel::EKernelType. EnumeratorkNone ; kGauss . Definition at line 54 of file KDEKernel.h. Constructor & Destructor Documentation. ◆ KDEKernel(). TMVA::KDEKernel::KDEKernel ; (; EKernelIter ; kiter = kNonadaptiveKDE, . const TH1 * ; hist = nullptr, . Float_t ; lower_edge = 0., . Float_t ; upper_edge = 1., . EKernelBorder ; kborder = kNoTreatment, . Float_t ; FineFactor = 1. . ). constructor sanity check ; Definition at line 49 of file KDEKernel.cxx. ◆ ~KDEKernel(). TMVA::KDEKernel::~KDEKernel ; (; void ; ). virtual . destructor ; Definition at line 76 of file KDEKernel.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::KDEKernel::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::KDEKernel::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::KDEKernel::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 91 of file KDEKernel.h. ◆ DeclFileName(). static const char * TMVA::KDEKernel::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file KDEKernel.h. ◆ GetBinKernelIntegral(). Float_t TMVA::KDEKernel::GetBinKernelIntegral ; (; Float_t ; lowr, . Float_t ; highr, . Float_t ; mean, . Int_t ; binnum . ). calculates the integral of the Kernel ; Definition at line 21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:3130,sanity check,sanity check,3130,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"he neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241472,recover,recovered,241472,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovered']
Safety,"he new compression settings will only apply to branches created or attached after the setting is changed and other objects written after the setting is changed. In case the file does not exist or is not a valid ROOT file, it is made a Zombie. One can detect this situation with a code like: TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the environment variable ""TFile.Recover: 0"" in the system.rootrc file.; A bit TFile::kReproducible can be enabled specifying the ""reproducible"" url option when creating the file: TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; Unlike regular TFiles, the content of such file has reproducible binary content when writing exactly same data. This achieved by writing pre-defined values for creation and modification date of TKey/TDirectory objects and null value for TUUID objects inside TFile. As drawback, TRef objects stored in such file cannot be read correctly.; In case the name of the file is not reproducible either (in case of creating temporary filenames) a value can be passed to the reproducible ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:52169,detect,detected,52169,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['detect'],['detected']
Safety,"he object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:131206,safe,safe,131206,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safe']
Safety,"he object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning “step approved”. The default value for stepmax is TGeoShape::Bigwith the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary. According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big() ; The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was req",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1027055,safe,safe,1027055,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"he original function value to compute the integral However, TF1::Moment, CentralMoment require to compute the integral using the absolute value of the function. ; Definition at line 984 of file TF1.cxx. ◆ AddParameter(). virtual void TF1::AddParameter ; (; const TString & ; name, . Double_t ; value . ). inlinevirtual . Definition at line 435 of file TF1.h. ◆ AddToGlobalList(). Bool_t TF1::AddToGlobalList ; (; Bool_t ; on = kTRUE). virtual . Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the function was already in the list false if not) ; Definition at line 847 of file TF1.cxx. ◆ Browse(). void TF1::Browse ; (; TBrowser * ; b). overridevirtual . Browse. ; Reimplemented from TObject.; Definition at line 993 of file TF1.cxx. ◆ CalcGaussLegendreSamplingPoints(). void TF1::CalcGaussLegendreSamplingPoints ; (; Int_t ; num, . Double_t * ; x, . Double_t * ; w, . Double_t ; eps = 3.0e-11 . ). static . Type safe interface (static method) The number of sampling points are taken from the TGraph. ; Type: unsafe but fast interface filling the arrays x and w (static method); Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: ; \[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \]. num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 3826 of file TF1.cxx. ◆ CentralMoment(). Double_t TF1::CentralMoment ; (; Double_t ; n, . Double_t ; a, . Double_t ; b, . const Double_t * ; params = nullptr, . Double_t ; epsilon = 0.000001 . ). virtual . Return nth central moment of function between a and b (i.e the n-th moment around the mean value) ; See TF1::Integral() for parameter definitions; AuthorGene Van Buren gene@.nosp@m.bnl..nosp@m.gov ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:58391,safe,safe,58391,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['safe'],['safe']
Safety,"he outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf801_mcstudyDefinition rf801_mcstudy.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:10286,safe,safe,10286,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,1,['safe'],['safe']
Safety,"he predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFit3D_8C.html:1383,predict,predictor,1383,doc/master/exampleFit3D_8C.html,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html,1,['predict'],['predictor']
Safety,"he quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:15805,safe,safe,15805,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safe']
Safety,"he recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferred and asynchronous.; 23.2.4.5 Deferred; Set by TThread::SetCancelDeferred() (default): When the user knows safe places in their code where a thread can be canceled without risk for the rest of the system, they can define these points by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1111995,safe,safely,1111995,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safely']
Safety,"he reduction operation. An optional parameter allows initialization of the result object to non-default values. . Report() Obtain statistics on how many entries have been accepted and rejected by the filters. See the section on named filters for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. . Stats() Return a TStatistic object filled with the input columns. . StdDev() Return the unbiased standard deviation of the processed column values. . Sum() Return the sum of the values in the column. If the type of the column is inferred, the return type is double, the type of the column otherwise. . Take() Extract a column from the dataset as a collection of values, e.g. a std::vector<float> for a column of type float. . Instant action Description . Foreach() Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. . ForeachSlot() Same as Foreach(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case slot will always be 0. . Snapshot() Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:8020,safe,safety,8020,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safety']
Safety,"he title of the RooPlot to 'title'.Definition RooPlot.cxx:1243; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:5698,safe,safe,5698,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,1,['safe'],['safe']
Safety,"he use of smart pointers. For instance tree->Branch(""px"", &Category, ""px/F"");; becomes auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>; The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on most modern architectures. Combined with a clear separation of offset/index data and payload data for collections, uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; RNTuple shall investigate improvements of the TTree I/O in the following ways. More speed; Improve mapping to vectorized and parallel hardware; For types known at compile / JIT time: generate optimized code; Optimized for simple types (float, int, and vectors of them); Better memory control: work with a fixed budget of pre-defined I/O buffers; Naturally thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the deserialization and serialization.; The (de-)serialization is a mapping from the C++ type to the more simple column type system. A column contains an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of dif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:1336,safe,safety,1336,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['safe'],['safety']
Safety,"he, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TFile(); TFile(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:14171,timeout,timeout,14171,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['timeout'],['timeout']
Safety,"he, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:14328,timeout,timeout,14328,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['timeout'],['timeout']
Safety,"hed parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual IBaseFunctionOneDim * Clone () const =0;  Clone a function. ;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual unsigned int NPar () const =0;  Return the number of Parameters. ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; virtual const double * Parameters () const =0;  Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; virtual double DoParameterDerivative (double x, const double *p, unsigned int ipar) const =0;  Evaluate the gradient, to be implemented by the derived classes. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricGradFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IParametricFunctionOneDim::BaseFunc ROOT::Math::IParametricGradFunctionOneDim::BaseFunc. Definition at line 336 of file IParamFunction.h. ◆ BaseGradFunc. typedef IGradientFunctionOneDim ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Definition at line 335 of file IParamFunction.h. ◆ Bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:3667,avoid,avoid,3667,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['avoid'],['avoid']
Safety,"heir objective. ;  ;  Graphs tutorials;  Examples showing the ""graphs classes"" usage. ;  ;  Graphics tutorials;  Various examples showing the basic ROOT graphics. ;  ;  OpenGL tutorials;  Various examples showing the OpenGL graphics in ROOT. ;  ;  Tutorials specific to Mac/Cocoa;  Various examples showing graphics done with the Mac graphics system Cocoa. ;  ;  GUI tutorials;  Example code which illustrates how to use the ROOT GUI. ;  ;  HistFactory Tutorials;  These tutorials illustrate the usage of the histfactory. ;  ;  HTTP tutorials;  Examples showing the HTTP interface. ;  ;  Image tutorials;  Examples showing the TImage class usage. ;  ;  IO tutorials;  These tutorials illustrate some of the capabilities of the ROOT IO subsystem. ;  ;  Math tutorials;  Examples showing the Math classes. ;  ;  Matrix tutorials;  Examples showing how to use TMatrix. ;  ;  Monte Carlo tutorials;  Monte Carlo examples. ;  ;  Multicore tutorials;  These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. ;  ;  Net tutorials;  Examples showing the net classes. ;  ;  Physics tutorials;  Physics examples. ;  ;  PyRoot tutorials;  Selected examples illustrating how to use ROOT's Python interface: PyROOT. ;  ;  Pythia tutorials;  Examples showing the pythia usage. ;  ;  Quadratic programming package.;  Example showing the usage of the quadratic programming package quadp. ;  ;  R tutorials;  Examples showing the R interface. ;  ;  RooStats Tutorials;  These tutorials illustrate the main features of RooStats. ;  ;  Spectrum tutorials;  Examples showing the TSpectrum and TSpectrumPainter usage. ;  ;  TSPlot tutorials;  This tutorial illustrates the use of class TSPlot. ;  ;  SQL tutorials;  Examples showing the SQL classes. ;  ;  TMVA tutorials;  Example code which illustrates how to use the TMVA toolkit. ;  ;  TUnfold tutorials;  Test programs for the classes TUnfold and related. ;  ;  Unuran tutorials;  Examp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Tutorials.html:3132,safe,safety,3132,doc/master/group__Tutorials.html,https://root.cern,https://root.cern/doc/master/group__Tutorials.html,1,['safe'],['safety']
Safety,"hen building tmva/pymva; [ROOT-7896] - CMake: visibility inconsistency; [ROOT-7901] - Double-free in TROOT::EndOfProcessCleanups redux; [ROOT-7912] - Failure with -Dbuiltin_davix=ON on 64bit Ubuntu; [ROOT-7916] - pyroot problem with std::vector of enum; [ROOT-7927] - TPluginHandler::CheckForExecPlugin is not thread safe; [ROOT-7935] - Need a better way stop PyROOT from reading .rootlogon.(py|C); [ROOT-7940] - Incorrect handling of LLVM Threading; [ROOT-8003] - Root 6.06 slow to; [ROOT-8015] - cmake not honoring -Dbuiltin_lzma=OFF; [ROOT-8019] - Warning with spaces in the binary name; [ROOT-8031] - TTree auto (read) cache setup during Fill; [ROOT-7776] - Integrate GSL 2.0 in ROOT. Release 6.06/04; Released on May 4, 2016; General. Significant update of the valgrind suppression file to hide intentional lack of delete of some entities at the end of the process.; Resolved several memory leaks. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. Interpreter Library. Resolve memory hoarding in some case of looking up functions ROOT-8145. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file ROOT-8055.; Repaired the automatic conversion on read back into an STL collection of a on file object of a class that was inheriting from the STL collection. Meta. Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name ROOT-7972.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048; Fix a problem reading ROOT pcm files using gcc 6 optimized build ROOT-8097; Fix the detection of inheritance from an STL collection of an emulated class. Core. Reduce memory consumption (autopa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:28974,avoid,avoid,28974,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avoid'],['avoid']
Safety,"hen successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1632 of file TUnixSystem.cxx. ◆ ResetSignal(). void TUnixSystem::ResetSignal ; (; ESignals ; sig, . Bool_t ; reset = kTRUE . ). overridevirtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 875 of file TUnixSystem.cxx. ◆ ResetSignals(). void TUnixSystem::ResetSignals ; (; ). overridevirtual . Reset signals handlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 886 of file TUnixSystem.cxx. ◆ ResetTimer(). void TUnixSystem::ResetTimer ; (; TTimer * ; ti). overridevirtual . Reset a-sync timer. ; Reimplemented from TSystem.; Definition at line 3033 of file TUnixSystem.cxx. ◆ Select() [1/2]. Int_t TUnixSystem::Select ; (; TFileHandler * ; h, . Long_t ; to . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the file handler is 0 or does not have a file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1250 of file TUnixSystem.cxx. ◆ Select() [2/2]. Int_t TUnixSystem::Select ; (; TList * ; act, . Long_t ; to . ). overridevirtual . Select on file descriptors. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the list did not contain any file handlers or file handlers with file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1202 of file TUnixSystem.cxx. ◆ SendBuf(). int TUnixSystem::SendBuf ; (; int ; sock, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:65125,timeout,timeout,65125,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"here; 2424 if (el_set.insert(tmp).second && !tmp.empty()) {; 2425 el_list.push_back(tmp);; 2426 added = true;; 2427 }; 2428 }; 2429 ; 2430 return added;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434 ; 2435int ExtractClassesListAndDeclLines(RScanner &scan,; 2436 std::list<std::string> &classesList,; 2437 std::list<std::string> &classesListForRootmap,; 2438 std::list<std::string> &fwdDeclarationsList,; 2439 const cling::Interpreter &interpreter); 2440{; 2441 // Loop on selected classes. If they don't have the attribute ""rootmap""; 2442 // set to ""false"", store them in the list of classes for the rootmap; 2443 // Returns 0 in case of success and 1 in case of issues.; 2444 ; 2445 // An unordered_set to keep track of the existing classes.; 2446 // We want to avoid duplicates there as they may hint to a serious corruption; 2447 std::unordered_set<std::string> classesSet;; 2448 std::unordered_set<std::string> outerMostClassesSet;; 2449 ; 2450 std::string attrName, attrValue;; 2451 bool isClassSelected;; 2452 std::unordered_set<std::string> availableFwdDecls;; 2453 std::string fwdDeclaration;; 2454 for (auto const & selVar : scan.fSelectedVariables) {; 2455 fwdDeclaration = """";; 2456 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selVar, fwdDeclaration);; 2457 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2458 }; 2459 ; 2460 for (auto const & selEnum : scan.fSelectedEnums) {; 2461 fwdDeclaration = """";; 2462 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selEnum, fwdDeclaration);; 2463 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2464 }; 2465 ; 2466 // Loop on selected classes and put them in a list; 2467 for (auto const & selClass : scan.fSelectedClasses) {; 2468 isClassSelected = true;; 2469 const clang::RecordDecl *rDecl = selClass.GetRecordDecl();; 2470 st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:96498,avoid,avoid,96498,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"hers for parallel navigation:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; Int_t inav = gGeoManager->AddNavigator(navig);; gGeoManager->SetCurrentNavigator(inav);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; int; .... and then switch back to the default navigator:; gGeoManager->SetCurrentNavigator(0);. Definition at line 32 of file TGeoNavigator.h. Public Member Functions;  TGeoNavigator ();  global mode is caching enabled for parallel world safety calls ;  ;  TGeoNavigator (TGeoManager *geom);  Constructor. ;  ;  ~TGeoNavigator () override;  Destructor. ;  ; void BuildCache (Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE);  Builds the cache for physical nodes and global matrices. ;  ; Bool_t cd (const char *path="""");  Browse the tree of nodes starting from top node according to pathname. ;  ; void CdDown (Int_t index);  Make a daughter of current node current. ;  ; void CdDown (TGeoNode *node);  Make a daughter of current node current. ;  ; void CdNext ();  Do a cd to the node found next by FindNextBoundary. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  Make top level node the current node. ;  ; void CdUp ();  Go one level up in geometry. ;  ; Bool_t CheckPath (const char *path) const;  Check if a geometry path is valid without changing the state of the navigator. ;  ; TGeoNode * CrossBoundaryAndLocate (Bool_t downwards, TGeoNode *skipnode);  Cross",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:1576,safe,safety,1576,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"hes className. ; See alsoTTree::Branch() for other details. ; Reimplemented in TTreeSQL.; Definition at line 1554 of file TTree.cxx. ◆ BranchImp() [2/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:91890,detect,detection,91890,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['detect'],['detection']
Safety,"hin that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plottin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8C.html:6256,safe,safe,6256,doc/master/rf202__extendedmlfit_8C.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html,1,['safe'],['safe']
Safety,"hing...; No Matches. Files ; PyRoot tutorialsTutorials. ; Selected examples illustrating how to use ROOT's Python interface: PyROOT. . Files; file  demo.py;  To run, do ""python <path-to>/demo.py"". ;  ; file  demoshelp.py;   Display demo help. ;  ; file  DynamicSlice.py;   Example of function called when a mouse event occurs in a pad. ;  ; file  fit1.py;   Fit example. ;  ; file  formula1.py;   TF1 example. ;  ; file  geometry.py;   Geometry ;  ; file  gerrors.py;   A Simple Graph with error bars ;  ; file  graph.py;   A Simple Graph Example ;  ; file  gui_ex.py;  A Simple GUI Example. ;  ; file  h1ReadAndDraw.py;   A Simple histogram drawing example ;  ; file  hsimple.py;   This program creates : ;  ; file  hsum.py;   Simple example illustrating how to use the C++ interpreter ;  ; file  mrt.py;   Build ROOT Ntuple from other source. ;  ; file  na49geomfile.py;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.py;  This macro generates two views of the NA49 detector. ;  ; file  na49visible.py;  Set visibility attributes for the NA49 geometry Set Shape attributes. ;  ; file  ntuple1.py;   Ntuple drawing example. ;  ; file  numberEntry.py;  Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ;  ; file  parse_CSV_file_with_TTree_ReadStream.py;  This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ;  ; file  pyroot001_arrayInterface.py;   This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ;  ; file  pyroot002_pythonizationDecorator.py;   This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ;  ; file  pyroot003_prettyPrinting.py;   This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__pyroot.html:1106,detect,detector,1106,doc/master/group__tutorial__pyroot.html,https://root.cern,https://root.cern/doc/master/group__tutorial__pyroot.html,1,['detect'],['detector']
Safety,"his != htmp->String()) continue;; 1605 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1606 if (oldcl && oldcl != this) {; 1607 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1608 ForceReload (oldcl);; 1609 }; 1610 }; 1611 }; 1612 if (fClassInfo) {; 1613 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1614 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1615 fDeclFileName = kUndeterminedClassInfoName;; 1616 // Missing interface:; 1617 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1618 ; 1619 // But really do not want to set ImplFileLine as it is currently the; 1620 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1621 }; 1622 }; 1623 ; 1624 if (persistentRef) {; 1625 fPersistentRef = persistentRef;; 1626 } else {; 1627 fPersistentRef = new TClass*;; 1628 }; 1629 *fPersistentRef = this;; 1630 ; 1631 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1632 if (fState != kHasTClassInit) {; 1633 // If we have a TClass compiled initialization, we can safely assume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642 } else if (!silent) {; 1643 Warning(""Init"",""Collection proxy for %s was not properly initialized!"",GetName());; 1644 }; 1645 if (fStreamer==nullptr) {; 1646 fStreamer = TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );; 1647 }; 1648 }; 1649 } else if (TClassEdit::IsStdPair(GetName())) {; 1650 // std::pairs have implicit conversions; 1651 GetSchemaRules(kTRUE);; 1652 }; 1653 ; 1654 ResetBit(kLoading);; 1655}; 1656 ; 1657/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:63047,safe,safely,63047,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safely']
Safety,"his != htmp->String()) continue;; 1672 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1673 if (oldcl && oldcl != this) {; 1674 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1675 ForceReload (oldcl);; 1676 }; 1677 }; 1678 }; 1679 if (fClassInfo) {; 1680 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1681 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1682 fDeclFileName = kUndeterminedClassInfoName;; 1683 // Missing interface:; 1684 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1685 ; 1686 // But really do not want to set ImplFileLine as it is currently the; 1687 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1688 }; 1689 }; 1690 ; 1691 if (persistentRef) {; 1692 fPersistentRef = persistentRef;; 1693 } else {; 1694 fPersistentRef = new TClass*;; 1695 }; 1696 *fPersistentRef = this;; 1697 ; 1698 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1699 if (fState != kHasTClassInit) {; 1700 // If we have a TClass compiled initialization, we can safely assume that; 1701 // there will also be a collection proxy.; 1702 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1703 if (fCollectionProxy) {; 1704 fSizeof = fCollectionProxy->Sizeof();; 1705 ; 1706 // Numeric Collections have implicit conversions:; 1707 GetSchemaRules(kTRUE);; 1708 ; 1709 } else if (!silent) {; 1710 Warning(""Init"",""Collection proxy for %s was not properly initialized!"",GetName());; 1711 }; 1712 if (fStreamer==nullptr) {; 1713 fStreamer = TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );; 1714 }; 1715 }; 1716 } else if (TClassEdit::IsStdPair(GetName())) {; 1717 // std::pairs have implicit conversions; 1718 GetSchemaRules(kTRUE);; 1719 }; 1720 ; 1721 ResetBit(kLoading);; 1722}; 1723 ; 1724/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:65798,safe,safely,65798,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safely']
Safety,"his file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifiers of data members (to be used mainly by subclasses). { fS3Request.SetAccessKey(accessKey); }. void SetSecretKey(const TString& secretKey); { fS3Request.SetSecretKey(secretKey); }. TS3WebFile(const char* url, Option_t* options = """"); Constructors & Destructor. virtual ~TS3WebFile(); {}. const TString& GetAccessKey() const; Selectors. { return fS3Request.GetAccessKe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:32064,detect,detect,32064,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['detect'],['detect']
Safety,"his file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifiers of data members (to be used mainly by subclasses). { fS3Request.SetAccessKey(accessKey); }. void SetSecretKey(const TString& secretKey); { fS3Request.SetSecretKey(secretKey); }. virtual ~TS3WebFile(); {}. const TString& GetAccessKey() const; Selectors. { return fS3Request.GetAccessKey(); }. const TString& GetSecretKey() const; { return fS3Request.GetSecretKey();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:31020,detect,detect,31020,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['detect'],['detect']
Safety,"his->destroy_range(RHS.begin() + NumShared, RHS.end());; 990 RHS.set_size(NumShared);; 991 }; 992}; 993 ; 994template <typename T>; 995RVecImpl<T> &RVecImpl<T>::operator=(const RVecImpl<T> &RHS); 996{; 997 // Avoid self-assignment.; 998 if (this == &RHS); 999 return *this;; 1000 ; 1001 // If we already have sufficient space, assign the common elements, then; 1002 // destroy any excess.; 1003 size_t RHSSize = RHS.size();; 1004 size_t CurSize = this->size();; 1005 if (CurSize >= RHSSize) {; 1006 // Assign common elements.; 1007 iterator NewEnd;; 1008 if (RHSSize); 1009 NewEnd = std::copy(RHS.begin(), RHS.begin() + RHSSize, this->begin());; 1010 else; 1011 NewEnd = this->begin();; 1012 ; 1013 // Destroy excess elements.; 1014 if (this->Owns()); 1015 this->destroy_range(NewEnd, this->end());; 1016 ; 1017 // Trim.; 1018 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't sma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:35731,avoid,avoid,35731,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Constructor for variable bin size histograms using an input array of type double.; 731///; 732/// \param[in] name name of histogram (avoid blanks); 733/// \param[in] tit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:29418,avoid,avoid,29418,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); Creates histogram basic data structure. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:41446,avoid,avoid,41446,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['avoid'],['avoid']
Safety,"histogram of the same type and with the same name already exists in current Directory,; 2395/// the histogram is reset and filled again with the projected contents of the TH3.; 2396///; 2397/// NOTE 3: The number of entries in the projected histogram is estimated from the number of; 2398/// effective entries for all the cells included in the projection.; 2399///; 2400/// NOTE 4: underflow/overflow are included by default in the projection; 2401/// To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF""; 2402/// With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as; 2403/// following after having called SetRange: axis->SetRange(1, axis->GetNbins());; 2404///; 2405/// NOTE 5: If TH1::AddDirectory is set to false, a new histogram is always created and the ownership of the; 2406/// returned pointer is delegated to the user. Be sure in this case to call `delete` on it after it's no longer needed,; 2407/// to avoid memory leaks.; 2408 ; 2409TH1 *TH3::Project3D(Option_t *option) const; 2410{; 2411 TString opt = option;; 2412 TString extra_name = option;; 2413 Int_t underscore = extra_name.Last('_');; 2414 if (underscore > 0) {; 2415 extra_name.Remove(underscore,extra_name.Length()-underscore);; 2416 opt.Remove(0,underscore+1);; 2417 }; 2418 opt.ToLower();; 2419 ; 2420 Int_t pcase = 0;; 2421 TString ptype;; 2422 if (opt.Contains(""x"")) { pcase = 1; ptype = ""x""; }; 2423 if (opt.Contains(""y"")) { pcase = 2; ptype = ""y""; }; 2424 if (opt.Contains(""z"")) { pcase = 3; ptype = ""z""; }; 2425 if (opt.Contains(""xy"")) { pcase = 4; ptype = ""xy""; }; 2426 if (opt.Contains(""yx"")) { pcase = 5; ptype = ""yx""; }; 2427 if (opt.Contains(""xz"")) { pcase = 6; ptype = ""xz""; }; 2428 if (opt.Contains(""zx"")) { pcase = 7; ptype = ""zx""; }; 2429 if (opt.Contains(""yz"")) { pcase = 8; ptype = ""yz""; }; 2430 if (opt.Contains(""zy"")) { pcase = 9; ptype = ""zy""; }; 2431 ; 2432 if (pcase == 0) {; 2433 Er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:95845,avoid,avoid,95845,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"hod name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for ROOT::RTreeDrawInvokeTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RTreeDrawInvokeTimer(). ROOT::RTreeDrawInvokeTimer::RTreeDrawInvokeTimer ; (; Long_t ; milliSec, . bool ; mode, . RTreeViewer & ; viewer . ). inline . constructor ; Definition at line 91 of file RTreeViewer.cxx. Member Function Documentation. ◆ Timeout(). void ROOT::RTreeDrawInvokeTimer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process postponed requests in main ROOT thread ; Reimplemented from TTimer.; Definition at line 95 of file RTreeViewer.cxx. Member Data Documentation. ◆ fViewer. RTreeViewer& ROOT::RTreeDrawInvokeTimer::fViewer. Definition at line 88 of file RTreeViewer.cxx. tree/webviewer/src/RTreeViewer.cxx. ROOTRTreeDrawInvokeTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:59 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html:17687,timeout,timeout,17687,doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RTreeDrawInvokeTimer.html,1,['timeout'],['timeout']
Safety,"hort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBufferFile.h; TBufferText.h; TClassEdit.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:206499,abort,abort,206499,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['abort'],['abort']
Safety,"hoton momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol volume name of the starting node; number copy number of topvol (relevant for gsposp); nlevel number of levels in the tree structure; to be written out, starting from topvol; (Geant3 only); Deprecated; Set geometry from Root (built via TGeo). void SetUserParameters(Bool_t isUserParameters); Activate the parameters defined in tracking media; (DEEMAX, STMIN, STEMAX), which are, be default, ignored.; In Geant4 case, only STEMAX is taken into account.; In FLUKA, all tracking media parameters are ignored. Int_t VolId(const char* volName) const. get methods. Return the unique numeric identifier for volume name volName. const char* VolName(Int_t id) const; Return the volume name for a given volume identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMC.html:24821,detect,detector,24821,root/html534/TVirtualMC.html,https://root.cern,https://root.cern/root/html534/TVirtualMC.html,3,['detect'],['detector']
Safety,"hout std:: in Math/GenVector/PxPyPzE4D.h; [#8196] - TUnuranContDist ctor clones the dpdf but does not use the clone causing a segfault later on; [#8011] - Bug in RooAbsPdf::extendedTerm when expected events is negative; [#8499] - Dict type alias fwd decl: underlying type not fwd declared; [#6454] - ROOT fails to parse <boost/shared_ptr.hpp> at runtime on macOS. Release 6.24/04; Published on August 26, 2021; Bugs and Issues fixed in this release. [#8503] - ranluxpp code is using left shift of negative value -1 which is undefined per the C standard; [#8641] - RooStats::HypoTestInverterResult::FindIndex fails if xvalue == 1; [#8767] - [netxng] Crash in on-exit destruction of an TNetXNGFile object; [#8739] - [DF] Cannot read files that don’t have a .root extension with IMT on; [#8713] - [tree] TTreeCache is turned off when fAutoFlush == 0. Release 6.24/06; Published on September 1, 2021; Bugs and Issues fixed in this release. [#8931] - TDirectory::RegisterGDirectory is MT unsafe; [#8011] - Bug in RooAbsPdf::extendedTerm when expected events is negative. Release 6.24/08; Published on September 29, 2022; Bugs and Issues fixed in this release. [ROOT-10829] - pure virtual method called error; [#8933] - CMAKE_INSTALL_PYTHONDIR on macOS creates broken symlinks; [#9017] - Access of deleted object during hadd tear down.; [#8072] - Failures with root 6.24.00 on Fedora 33 ppc64le; [#9297] - ROOT 6.24 debug build failed on ppc64le; [#9424] - ROOT 6.24 failed to build with GCC10 or 11 on ppc64le arch; [#9547] - [RF] RooFit crashes when ROOT is built with Clang 13; [#9543] - roottest-root-treeformula-stl-make crashes during process termination; [#8987] - Missing operator= in code generated by MakeProject; [#7754] - Segfault when using schema evolution; [#8428] - I/O customization rule not run on split sub-object of a non-collection object.; [#9899] - TTree incorrectly run I/O customization rules on “new” data members.; [#9939] - Hadd super slow since TFileMerger modification; [#1017",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:49908,unsafe,unsafe,49908,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['unsafe'],['unsafe']
Safety,"howLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALSE);  List contents of package directory. ;  ; void ShowParameters (const char *wildcard=""PROOF_*"") const;  Show the input list parameters specified by the wildcard. ;  ; void ShowQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; virtual void ShowStagingStatusDataSet (const char *dataset, const char *optStr=""filter:SsCc"");  Like GetStagingStatusDataSet, but displays results immediately. ;  ; void StartupMessage (const char *msg, Bool_t status, Int_t done, Int_t total);  Send startup message. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1);  Send STOPPROCESS message to master and workers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Touch ();  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; Int_t UploadDataSet (const char *, const char *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadDataSet (const char *, TList *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadDataSetFromFile (const char *, const char *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadPackage (const char *par, EUploadPackageOpt opt=kUntar, TList *workers=0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:21070,abort,abort,21070,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"howLog (const char *queryref);  Display on screen the content of the temporary log file for query in reference. ;  ; void ShowLog (Int_t qry=-1);  Display on screen the content of the temporary log file. ;  ; void ShowMissingFiles (TQueryResult *qr=0);  Show information about missing files during query described by 'qr' or the last query if qr is null (default). ;  ; void ShowPackages (Bool_t all=kFALSE, Bool_t redirlog=kFALSE);  List contents of package directory. ;  ; void ShowParameters (const char *wildcard=""PROOF_*"") const;  Show the input list parameters specified by the wildcard. ;  ; void ShowQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; virtual void ShowStagingStatusDataSet (const char *dataset, const char *optStr=""filter:SsCc"");  Like GetStagingStatusDataSet, but displays results immediately. ;  ; void StartupMessage (const char *msg, Bool_t status, Int_t done, Int_t total);  Send startup message. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1);  Send STOPPROCESS message to master and workers. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Touch ();  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; Int_t UploadDataSet (const char *, const char *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadDataSet (const char *, TList *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadDataSetFromFile (const char *, const char *, const char *=0, Int_t=0, TList *=0);  *** This function is deprecated and will disappear in future versions *** *** It is just a wrapper around TFile::Cp. ;  ; Int_t UploadPackage (const char *par, EUploadPackageOpt opt=kUntar, TList *workers=0);  Upload a PROOF archive (PAR file). ;  ; Bool_t UseDynamicStartup () const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:19522,abort,abort,19522,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"hrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ MarkovChain() [1/3]. MarkovChain::MarkovChain ; (; ). Definition at line 43 of file MarkovChain.cxx. ◆ MarkovChain() [2/3]. MarkovChain::MarkovChain ; (; RooArgSet & ; parameters). Definition at line 45 of file MarkovChain.cxx. ◆ MarkovChain() [3/3]. MarkovChain::MarkovChain ; (; const char * ; name, . const char * ; title, . RooArgSet & ; parameters . ). Definition at line 50 of file MarkovChain.cxx. ◆ ~MarkovChain(). RooStats::MarkovChain::~MarkovChain ; (; ). inlineoverride . Definition at line 114 of file MarkovChain.h. Member Function Documentation. ◆ Add() [1/2]. void MarkovChain::Add ; (; MarkovChain & ; otherChain, . double ; discardEntries = 0.0 . ). virtual . add another markov chain ; Definition at line 102 of file MarkovChain.cxx. ◆ Add() [2/2]. void MarkovChain::Add ; (; RooArgSet & ; entry, . double ; nllValue, . double ; weight = 1.0 . ). virtual . safely add an entry to the chain ; Definition at line 77 of file MarkovChain.cxx. ◆ AddFast(). void MarkovChain::AddFast ; (; RooArgSet & ; entry, . double ; nllValue, . double ; weight = 1.0 . ). virtual . add an entry to the chain ONLY IF you have constructed with parameters or called SetParameters ; Definition at line 119 of file MarkovChain.cxx. ◆ AddWithBurnIn(). void MarkovChain::AddWithBurnIn ; (; MarkovChain & ; otherChain, . Int_t ; burnIn = 0 . ). virtual . add another markov chain ; Definition at line 88 of file MarkovChain.cxx. ◆ Class(). static TClass * RooStats::MarkovChain::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooStats::MarkovChain::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooStats::MarkovChain::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 127 of file MarkovChain.h. ◆ DeclFileName(). static const char * RooStats::MarkovChain::DeclFileName ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html:15389,safe,safely,15389,doc/master/classRooStats_1_1MarkovChain.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html,1,['safe'],['safely']
Safety,"hs) :; 144 rhs_(rhs) {}; 145 ; 146 ///; 147 ~Expr() {}; 148 ; 149 ///; 150 inline T apply(unsigned int i) const {; 151 return rhs_.apply(i);; 152 }; 153 inline T operator() (unsigned int i, unsigned j) const {; 154 return rhs_(i,j);; 155 }; 156 ; 157 /**; 158 function to determine if any use operand; 159 is being used (has same memory address); 160 */; 161 inline bool IsInUse (const T * p) const {; 162 return rhs_.IsInUse(p);; 163 }; 164 ; 165 ; 166 ; 167#ifdef OLD_IMPL; 168 ///; 169 static const unsigned int rows = D;; 170 ///; 171 static const unsigned int cols = D2;; 172#else; 173 // use enumerations; 174 enum {; 175 ///; 176 kRows = D,; 177 ///; 178 kCols = D2; 179 };; 180#endif; 181 ; 182 /// used by operator<<(); 183 /// simplify to use apply(i,j); 184 std::ostream& print(std::ostream& os) const {; 185 os.setf(std::ios::right,std::ios::adjustfield);; 186 os << ""[ "";; 187 for (unsigned int i=0; i < D; ++i) {; 188 unsigned int d2 = D2; // to avoid some annoying warnings in case of vectors (D2 = 0); 189 for (unsigned int j=0; j < D2; ++j) {; 190 os << std::setw(12) << this->operator() (i,j);; 191 if ((!((j+1)%12)) && (j < d2-1)); 192 os << std::endl << "" ..."";; 193 }; 194 if (i != D - 1); 195 os << std::endl << "" "";; 196 }; 197 os << "" ]"";; 198 ; 199 return os;; 200 }; 201 ; 202private:; 203 ExprType rhs_; // cannot be a reference!; 204};; 205 ; 206//==============================================================================; 207// operator<<; 208//==============================================================================; 209template <class A, class T, unsigned int D>; 210inline std::ostream& operator<<(std::ostream& os, const VecExpr<A,T,D>& rhs) {; 211 return rhs.print(os);; 212}; 213 ; 214template <class A, class T, unsigned int D1, unsigned int D2, class R1>; 215inline std::ostream& operator<<(std::ostream& os, const Expr<A,T,D1,D2,R1>& rhs) {; 216 return rhs.print(os);; 217}; 218 ; 219/**; 220 BinaryOperation class; 221 A class representing binary op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Expression_8h_source.html:4563,avoid,avoid,4563,doc/master/Expression_8h_source.html,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html,1,['avoid'],['avoid']
Safety,"hysical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; 385#include ""TBrowser.h""; 386#include ""TStyle.h""; 387#include ""TH2F.h""; 388#include ""TROOT.h""; 389#include ""TEnv.h""; 390#include ""TMap.h""; 391#include ""TFile.h""; 392#include ""TKey.h""; 393 ; 394#include ""TGeoManager.h""; 395#include ""TGeoNode.h""; 396#include ""TGeoMatrix.h""; 397#include ""TVirtualGeoPainter.h""; 398#include ""TGeoVolume.h""; 399#include ""TGeoShapeAssembly.h""; 400#include ""TGeoScaledShape.h""; 401#include ""TGeoCompositeShape.h""; 402#include ""TGeoVoxelFinder.h""; 403#include ""TGeoExtension.h""; 404 ; 405ClassImp(TGeoVolume);; 406 ; 407TGeoMedium *TGeoVolume::fgDummyMedium = nullptr;; 408 ; 409/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:19393,avoid,avoid,19393,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['avoid'],['avoid']
Safety,"iDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:106; TGeoTrap::fAlpha2Double_t fAlpha2Definition TGeoArb8.h:108; TGeoTrap::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTrap::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTrap::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTrap::fBl1Double_t fBl1Definition TGeoArb8.h:102; TGeoTrap::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::fH1Double_t fH1Definition TGeoArb8.h:101; TGeoTrap::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTrap::fPhiDouble_t fPhiDefinition TGeoArb8.h:100; TGeoTrap::GetAlpha2Double_t GetAlpha2() constDefinition TGeoArb8.h:139; TGeoTrap::GetThetaDouble_t GetTheta() constDefinition TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:18633,safe,safe,18633,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"iability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002361,avoid,avoid,1002361,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"ialize(nPoints,1, type);; 594 ; 595#ifdef DEBUG; 596 std::cout << ""DoFillData: graph npoints = "" << nPoints << "" type "" << type << std::endl;; 597 if (func) {; 598 double a1,a2; func->GetRange(a1,a2); std::cout << ""func range "" << a1 << "" "" << a2 << std::endl;; 599 }; 600#endif; 601 ; 602 double x[1];; 603 for ( int i = 0; i < nPoints; ++i) {; 604 ; 605 x[0] = gx[i];; 606 ; 607 ; 608 if (useRange && ( x[0] < xmin || x[0] > xmax) ) continue;; 609 ; 610 // need to evaluate function to know about rejected points; 611 // hugly but no other solutions; 612 if (func) {; 613 TF1::RejectPoint(false);; 614 (*func)( x ); // evaluate using stored function parameters; 615 if (TF1::RejectedPoint() ) continue;; 616 }; 617 ; 618 ; 619 if (fitOpt.fErrors1); 620 dv.Add( gx[i], gy[i] );; 621 ; 622 // for the errors use the getters by index to avoid cases when the arrays are zero; 623 // (like in a case of a graph); 624 else if (type == BinData::kValueError) {; 625 double errorY = gr->GetErrorY(i);; 626 // should consider error = 0 as 1 ? Decide to skip points with zero errors; 627 // in case want to keep points with error = 0 as errrors=1 need to set the option UseEmpty; 628 if (!HFitInterface::AdjustError(fitOpt,errorY) ) continue;; 629 dv.Add( gx[i], gy[i], errorY );; 630 ; 631#ifdef DEBUG; 632 std::cout << ""Point "" << i << "" "" << gx[i] << "" "" << gy[i] << "" "" << errorY << std::endl;; 633#endif; 634 ; 635 ; 636 }; 637 else { // case use error in x or asym errors; 638 double errorX = 0;; 639 if (fitOpt.fCoordErrors); 640 // shoulkd take combined average (sqrt(0.5(e1^2+e2^2)) or math average ?; 641 // gr->GetErrorX(i) returns combined average; 642 // use math average for same behaviour as before; 643 errorX = std::max( 0.5 * ( gr->GetErrorXlow(i) + gr->GetErrorXhigh(i) ) , 0. ) ;; 644 ; 645 ; 646 // adjust error in y according to option; 647 double errorY = std::max(gr->GetErrorY(i), 0.);; 648 // we do not check the return value since we check later if error in X and Y is zero for skip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:19808,avoid,avoid,19808,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Double_t GetMaximumStored() const; {return fMaximum;}. Double_t GetMinimumStored() const; {return fMinimum;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF1.html:64070,safe,safe,64070,root/html534/TF1.html,https://root.cern,https://root.cern/root/html534/TF1.html,1,['safe'],['safe']
Safety,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return fXmax;}. void SetChisquare(Double_t chi2); {fChisquare = chi2;}. void SetNumberFitPoints(Int_t npfits); {fNpfit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:63525,safe,safe,63525,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,3,['safe'],['safe']
Safety,"ible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441510,recover,recovery,441510,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovery']
Safety,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoUnion.html:8850,safe,safe,8850,root/html528/TGeoUnion.html,https://root.cern,https://root.cern/root/html528/TGeoUnion.html,2,['safe'],"['safe', 'safety']"
Safety,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoUnion.html:8950,safe,safe,8950,root/html530/TGeoUnion.html,https://root.cern,https://root.cern/root/html530/TGeoUnion.html,2,['safe'],"['safe', 'safety']"
Safety,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:3065,safe,safe,3065,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,2,['safe'],['safe']
Safety,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:3044,safe,safe,3044,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,2,['safe'],['safe']
Safety,"ic TMVA::Tools::ECitationkPlainText; static TMVA::Tools::EWelcomeMessagekSmall1WelcomeMsg; static TMVA::Tools::EWelcomeMessagekSmall2WelcomeMsg; static TMVA::Tools::EWelcomeMessagekStandardWelcomeMsg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(). void DestroyInstance(); NOTE: there is no thread safe way to do this so; one must only call this method ones in an executable. Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Tools.html:6610,sanity check,sanity check,6610,root/html602/TMVA__Tools.html,https://root.cern,https://root.cern/root/html602/TMVA__Tools.html,2,['sanity check'],['sanity check']
Safety,"ic TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_AsIs; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Fill; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Line; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Int_tfBoxSkipNumber of boxes to skip for each drawn box during scene rotation.; TEveBoxSet::EBoxType_efBoxTypeType of rendered box.; UChar_tTEveElement::fCSCBits; TEveDigitSet::Callback_fooTEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefDepthBreadth assigned to third coordinate (C).; Float_tfDefHeightBreadth assigned to second coordinate (B).; Float_tfDefWid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBoxSet.html:25477,avoid,avoid,25477,root/html602/TEveBoxSet.html,https://root.cern,https://root.cern/root/html602/TEveBoxSet.html,2,['avoid'],['avoid']
Safety,"ic TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. atomic<TApplication*>fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; TROOT::AListOfEnums_tfEnumsList of enum types; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TListOfFunctionTemplates*fFuncTemplateList of global function templates; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TStringfGitBranchGit branch; TStringfGitCommitGit commit SHA1 of built; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:18061,detect,detected,18061,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['detect'],['detected']
Safety,"ic const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19131,timeout,timeout,19131,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3417,avoid,avoid,3417,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['avoid'],['avoid']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3417,avoid,avoid,3417,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['avoid'],['avoid']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3417,avoid,avoid,3417,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['avoid'],['avoid']
Safety,"ic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ;  . Private Attributes; std::string fAddr;  ! HTTP address of the server ;  ; std::unique_ptr< TExec > fAssgnExec;  ! special exec to assign thread id via ProcessEvents ;  ; WebWindowDeleteCallback_t fDeleteCallback;  ! function called when RWebWindow is destroyed ;  ; bool fExternalProcessEvents {false};  ! indicate that there are external process events engine ;  ; unsigned fIdCnt {0};  ! counter for identifiers ;  ; float fLaunchTmout {30.};  ! timeout in seconds to start browser process, default 30s ;  ; std::recursive_mutex fMutex;  ! main mutex, used for window creations ;  ; std::unique_ptr< THttpServer > fServer;  ! central communication with the all used displays ;  ; std::string fSessionKey;  ! secret session key used on client to code connections keys ;  ; WebWindowShowCallback_t fShowCallback;  ! function called for each RWebWindow::Show call ;  ; bool fUseHttpThrd {false};  ! use special thread for THttpServer ;  ; bool fUseSenderThreads {false};  ! use extra threads for sending data from RWebWindow to clients ;  ; bool fUseSessionKey {false};  ! is session key has to be used for data signing ;  . Friends; class RWebWindow;  . #include <ROOT/RWebWindowsManager.hxx>; Constructor & Destructor Documentation. ◆ RWebWindowsManager(). RWebWindowsManager::RWebWindowsManager ; (; ). window manager constructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 273 of file RWebWindowsManager.cxx. ◆ ~RWebWindowsManager(). RWebWindowsManager::~RWebWindowsManager ; (; ). window manager destructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 287 of file RWebWindowsManager.cxx. Member Function Documentation. ◆ AddServerLocation(). void RWebWindowsManager::AddServerLocation ; (; const std::string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:6418,timeout,timeout,6418,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety,"ic voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:5845,timeout,timeout,5845,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['timeout'],['timeout']
Safety,"ically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid problems; using AsString multiple times in a single statement. void Copy(TTimeStamp& ts) const; Copy this to ts. UInt_t GetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Return date in form of 19971224 (i.e. 24/12/1997),; if non-zero pointers supplied for year, month, day fill those as well. UInt_t GetTime(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* hour = 0, UInt_t* min = 0, UInt_t* sec = 0) const; Return time in form of 123623 (i.e. 12:36:23),; if non-zero pointers supplied for hour, min, sec fill those as well. Int_t GetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Get the day of the year represented by this time stamp value.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetMonth(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:5904,avoid,avoid,5904,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,6,['avoid'],['avoid']
Safety,"ices; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Tra; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Trap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:18016,safe,safe,18016,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety,"ich threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46574,safe,safe,46574,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"iciency is then the combined efficiency. The weights to be used in the combination should be the probability that an electron comes from the corresponding process. \[; p_{1} = \frac{\sigma_{1}}{\sigma_{1} + \sigma_{2}} = \frac{N_{1}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\; p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}; \]. VI. Further operations. VI.1 Information about the internal histograms; The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram return a constant pointer to the internal histograms. They can be used to obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...). One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto. The returned histograms are completely independent from the current TEfficiency object. By default, they are not attached to a directory to avoid the duplication of data and the user is responsible for deleting them.; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; ; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; ; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; ; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directory and write the file; //clone->SetDirectory(gDirectory);; //pFile->Write();; ; //delete histogram object; delete clone;; clone = 0;; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TEfficiency::GetCopyTotalHistoTH1 * GetCopyTotalHisto() constReturns a cloned version of fTotalHistogram.Definition TEfficiency.cxx:2647; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; It is also possible to set the internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:24350,avoid,avoid,24350,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['avoid'],['avoid']
Safety,"ict(var=y, Binning=50)); hh_model_1.SetLineColor(ROOT.kBlue); hh_model_2.SetLineColor(ROOT.kBlue); hh_model_3.SetLineColor(ROOT.kBlue); hh_model_4.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; Author",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3577,safe,safe,3577,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBuffer.html:18325,avoid,avoid,18325,root/html534/TBuffer.html,https://root.cern,https://root.cern/root/html534/TBuffer.html,3,['avoid'],['avoid']
Safety,"id * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TThread.h 41086 2011-09-30 21:27:53Z pcanal $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TThread.html:14972,avoid,avoid,14972,root/html532/TThread.html,https://root.cern,https://root.cern/root/html532/TThread.html,1,['avoid'],['avoid']
Safety,"id 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:1990,detect,detects,1990,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,6,['detect'],['detects']
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:19184,safe,safe,19184,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,2,['safe'],['safe']
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTorus.html:20938,safe,safe,20938,root/html604/TGeoTorus.html,https://root.cern,https://root.cern/root/html604/TGeoTorus.html,2,['safe'],['safe']
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:20938,safe,safe,20938,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['safe'],['safe']
Safety,"id DefineColors() constDefine 100 colors with increasing light intensities for each basic color (1-7) Register these colors ...Definition TGeoPainter.cxx:279; TGeoPainter::SetExplodedViewvoid SetExplodedView(Int_t iopt=0) overrideSet type of exploding view.Definition TGeoPainter.cxx:1962; TGeoPainter::ExecuteManagerEventvoid ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1074; TGeoPainter::SetTopVolumevoid SetTopVolume(TGeoVolume *vol) overrideDefinition TGeoPainter.h:173; TGeoPainter::SetRaytracingvoid SetRaytracing(Bool_t flag=kTRUE) overrideDefinition TGeoPainter.h:171; TGeoPainter::fLastVolumeTGeoVolume * fLastVolumeDefinition TGeoPainter.h:67; TGeoPainter::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints) overrideSet number of points to be generated on the shape outline when checking for overlaps.Definition TGeoPainter.cxx:2007; TGeoPainter::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideCheck current point in the geometry.Definition TGeoPainter.cxx:242; TGeoPainter::DistanceToPrimitiveVolInt_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) overrideCompute the closest distance of approach from point px,py to a volume.Definition TGeoPainter.cxx:348; TGeoPainter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:17403,safe,safety,17403,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['safe'],['safety']
Safety,"id Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSubtraction.html:9580,safe,safe,9580,root/html534/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html,2,['safe'],"['safe', 'safety']"
Safety,"id TGeoBoolNode::CreateThreadData ; (; Int_t ; nthreads). Create thread data for n threads max. ; Definition at line 100 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoBoolNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). virtual Int_t TGeoBoolNode::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromInside(). virtual Double_t TGeoBoolNode::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromOutside(). virtual Double_t TGeoBoolNode::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetBooleanOperator(). virtual EGeoBoolType TGeoBoolNode::GetBooleanOperator ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetLeftMatrix(). TGeoMatrix * TGeoBoolNode::GetLeftMatrix ; (; ); const. inline . Definition at line 76 of file TGeoBoolNode.h. ◆ GetLeftShape(). TGeoShape * TGeoBoolNode::GetLeftShape ; (; ); const. inline . Definition at line 78 of file TGeoBoolNode.h. ◆ GetNpoints(). virtual Int_t TGeoBoolNode::GetNpoints ; (; ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetRightMatrix(). TGeoMatrix * TGeoBoolNode::GetRightMatrix ; (; ); const. inline . Definition at line 77 of file TGeoBoolNode.h. ◆ GetRightShape(). TGeoShape * TGeoBoolNode::GetRightShape ; (; ); const. inline . Definition at line 79 of file TGeoBoolNode.h. ◆ GetThreadData(). TGeoBoolNode::ThreadData_t & TGeoBoolNode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:17437,safe,safe,17437,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['safe'],['safe']
Safety,"id);  only for use by root streamer or derived classes ;  ;  ~TUnfold (void) override;  ; virtual Double_t DoUnfold (Double_t tau);  perform the unfolding for a given regularisation parameter tau ;  ; Double_t DoUnfold (Double_t tau, const TH1 *hist_y, Double_t scaleBias=0.0);  perform the unfolding for a given input and regularisation ;  ; void GetBias (TH1 *bias, const Int_t *binMap=nullptr) const;  get bias vector including bias scale ;  ; Double_t GetChi2A (void) const;  get χ2A contribution determined in recent unfolding ;  ; Double_t GetChi2L (void) const;  get χ2L contribution determined in recent unfolding ;  ; double GetDF (void) const;  return the effecive number of degrees of freedom See e.g. ;  ; void GetDXDY (TH2 *dxdy) const;  get matrix connecting input and output changes ;  ; void GetEmatrix (TH2 *ematrix, const Int_t *binMap=nullptr) const;  get output covariance matrix, possibly cumulated over several bins ;  ; Double_t GetEpsMatrix (void) const;  get numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ;  ; void GetFoldedOutput (TH1 *folded, const Int_t *binMap=nullptr) const;  get unfolding result on detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:5039,detect,detector,5039,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,3,['detect'],['detector']
Safety,"id* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPSocket.html:5979,timeout,timeout,5979,root/html528/TPSocket.html,https://root.cern,https://root.cern/root/html528/TPSocket.html,1,['timeout'],['timeout']
Safety,"id; TReffLastTrackreference pointer to last track; Double32_tfMatrix[4][4]; Int_tfMeasures[10]; TRefArray*fMuonsarray of Muon tracks only; Int_tfNsegNumber of track segments; Int_tfNtrackNumber of tracks; Int_tfNvertex; Double32_tfTemperature; TClonesArray*fTracks->array with all tracks; TBitsfTriggerBitsBits triggered by this event.; charfType[20]event type; TReffWebHistogramEXEC:GetWebHistogram reference to an histogram in a TWebFile; static TH1F*fgHist; static TClonesArray*fgTracks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). void Build(Int_t ev, Int_t arg5 = 600, Float_t ptmin = 1). Track * AddTrack(Float_t random, Float_t ptmin = 1); Add a new track to the list of tracks for this event.; To avoid calling the very time consuming operator new for each track,; the standard but not well know C++ operator ""new with placement""; is called. If tracks[i] is 0, a new Track object will be created; otherwise the previous Track[i] will be overwritten. void Clear(Option_t* option = """"). void Reset(Option_t* option = """"); Static function to reset all static objects for this event; fgTracks->Delete(option);. void SetHeader(Int_t i, Int_t run, Int_t date, Float_t random). void SetMeasure(UChar_t which, Int_t what). void SetRandomVertex(); This delete is to test the relocation of variable length array. TBits& GetTriggerBits(); { return fTriggerBits; }. Event(). Bool_t IsValid() const; { return fIsValid; }. void ResetHistogramPointer(); {fH=0;}. void SetNseg(Int_t n); { fNseg = n; }. void SetNtrack(Int_t n); { fNtrack = n; }. void SetNvertex(Int_t n); { fNvertex = n; SetRandomVertex(); }. void SetFlag(UInt_t f); { fFlag = f; }. void SetTemperature(Double32_t t); { fTemperature = t; }. void SetType(char* type); {strcpy(fType,type);}. void SetMatrix(UChar_t x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Event.html:9934,avoid,avoid,9934,root/html528/Event.html,https://root.cern,https://root.cern/root/html528/Event.html,1,['avoid'],['avoid']
Safety,"idIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line 916 of file TGeoParallelWorld.cxx. ◆ IsA(). TClass * TGeoParallelWorld::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 184 of file TGeoParallelWorld.h. ◆ IsClosed(). Bool_t TGeoParallelWorld::IsClosed ; (; ); const. inline . Definition at line 143 of file TGeoParallelWorld.h. ◆ IsUsingOverlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. ◆ operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld & ; ). protecteddelete . ◆ PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. ◆ RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25179,detect,detected,25179,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['detect'],['detected']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:2454,safe,safe,2454,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:2240,safe,safe,2240,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,1,['safe'],['safe']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:7932,safe,safe,7932,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"idTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:8463,safe,safe,8463,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,1,['safe'],['safe']
Safety,"idTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:10465,timeout,timeout,10465,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,1,['timeout'],['timeout']
Safety,"idTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonitor&operator=(const TMonitor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:7320,timeout,timeout,7320,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['timeout'],['timeout']
Safety,"ide EACH volume and calling FindNextBoundary() + Safety() for each call. The timing is normalized by the number of crossings computed at stage 2 and presented as percentage. One can get a picture on which are the most ""burned"" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced. ; Definition at line 3811 of file TGeoManager.cxx. ◆ CheckOverlaps(). void TGeoManager::CheckOverlaps ; (; Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ). Check all geometry for illegal overlaps within a limit OVLP. ; Definition at line 3869 of file TGeoManager.cxx. ◆ CheckPath(). Bool_t TGeoManager::CheckPath ; (; const char * ; path); const. Check if a geometry path is valid without changing the state of the current navigator. ; Definition at line 1715 of file TGeoManager.cxx. ◆ CheckPoint(). void TGeoManager::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Classify a given point. See TGeoChecker::CheckPoint(). ; Definition at line 3770 of file TGeoManager.cxx. ◆ CheckShape(). void TGeoManager::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2) . Definition at line 3783 of file TGeoManager.cxx. ◆ Class(). static TClass * TGeoManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 605 of file TGeoManager.h. ◆ CleanGarb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:76425,safe,safety,76425,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"ide alternative; scan methods or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ProduceXml(const char* path, const char* options, TString& res); produce XML data for specified item; For object conversion TBufferXML is used. TString DecodeUrlOptionValue(const char* value, Bool_t remove_quotes = kTRUE); method replaces all kind of special symbols, which could appear in URL options. Bool_t ProduceExe(const char* path, const char* options, TString& res, Bool_t astxt = kFALSE); execute co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSniffer.html:10480,detect,detect,10480,root/html602/TRootSniffer.html,https://root.cern,https://root.cern/root/html602/TRootSniffer.html,1,['detect'],['detect']
Safety,"ide(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside); compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.; Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside); returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a different array. Dividing shapes; Shapes can generally be divided along a given axis. Supported axis are X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:5780,safe,safe,5780,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"ide(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 18.3.5 Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923271,safe,safe,923271,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"idth; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. private:. static intfgCoinFlagno coin viewer;; static intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. Int_t InitWindow(ULong_t window); -; *-* if window == 0 InitWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:22767,safe,safely,22767,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,3,['safe'],['safely']
Safety,"id DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; ROOT::R::TRFunctionImport asfactor;  ; ROOT::R::TRFunctionImport asmatrix;  ; Double_t fEta;  ; std::vector< UInt_t > fFactorNumeric;  ; UInt_t fMaxDepth;  ; ROOT::R::TRObject * fModel;  ; UInt_t fNRounds;  ; ROOT::R::TRFunctionImport predict;  ; ROOT::R::TRFunctionImport xgbdmatrix;  ; ROOT::R::TRFunctionImport xgbload;  ; ROOT::R::TRFunctionImport xgbsave;  ; ROOT::R::TRFunctionImport xgbtrain;  ;  Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrame fDfSpectators;  ; ROOT::R::TRDataFrame fDfTest;  ; ROOT::R::TRDataFrame fDfTrain;  ; std::vector< std::string > fFactorTest;  ; std::vector< std::string > fFactorTrain;  ; TVectorD fWeightTest;  ; TVectorD fWeightTrain;  ; ROOT::R::TRInterface & r;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Bool_t IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""xgboost"");  . Private Attributes; DataSetMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html:24391,predict,predict,24391,doc/master/classTMVA_1_1MethodRXGB.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html,1,['predict'],['predict']
Safety,"ied, ""A"" is ignored. ""F"" show all details available about queries ""H"" print help menu Default """" ; Definition at line 2165 of file TProof.cxx. ◆ ShowStagingStatusDataSet(). void TProof::ShowStagingStatusDataSet ; (; const char * ; dataset, . const char * ; optStr = ""filter:SsCc"" . ). virtual . Like GetStagingStatusDataSet, but displays results immediately. ; Definition at line 11116 of file TProof.cxx. ◆ SlaveStartupThread(). static void * TProof::SlaveStartupThread ; (; void * ; arg). staticprotected . ◆ StartSlaves(). Bool_t TProof::StartSlaves ; (; Bool_t ; attach = kFALSE). protectedvirtual . Start up PROOF slaves. ; Reimplemented in TProofCondor, and TProofSuperMaster.; Definition at line 1660 of file TProof.cxx. ◆ StartupMessage(). void TProof::StartupMessage ; (; const char * ; msg, . Bool_t ; status, . Int_t ; done, . Int_t ; total . ). Send startup message. ; Definition at line 9312 of file TProof.cxx. ◆ StopProcess(). void TProof::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). Send STOPPROCESS message to master and workers. ; Definition at line 6224 of file TProof.cxx. ◆ Streamer(). void TProof::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed.; Reimplemented in TProofCondor, TProofLite, and TProofSuperMaster. ◆ StreamerNVirtual(). void TProof::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 1073 of file TProof.h. ◆ SystemCmd(). void TProof::SystemCmd ; (; const char * ; cmd, . Int_t ; fdout . ). staticprotected . Exec system command 'cmd'. If fdout > -1, append the output to fdout. ; Definition at line 7735 of file TProof.cxx. ◆ TerminateWorker() [1/2]. void TProof::TerminateWorker ; (; const char * ; ord). private . Ask an active worker 'ord' to terminate, i.e. to shutdown. ; Definition at line 4720 of file TProof.cxx. ◆ TerminateWorker() [2/2]. void TProof::TerminateWorker ; (; TSlave * ; wrk). private . Ask an active worker 'wrk' to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:152754,timeout,timeout,152754,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset = 0, const char* rangeName = 0) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:47042,unsafe,unsafe,47042,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,3,['unsafe'],['unsafe']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:50430,unsafe,unsafe,50430,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,3,['unsafe'],['unsafe']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const char* rangeName); Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:46566,unsafe,unsafe,46566,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['unsafe'],['unsafe']
Safety,"iew name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:7068,safe,safe,7068,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,1,['safe'],['safe']
Safety,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:175055,timeout,timeout,175055,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:175087,timeout,timeout,175087,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"if (mom); 545 result = mom->GetDirectory(slash+1,printError,funcname);; 546 delete [] path; return result;; 547 }; 548 GetObject(subdir,obj);; 549 if (!obj) {; 550 if (printError) Error(funcname,""Unknown directory %s"", subdir.Data());; 551 delete [] path; return nullptr;; 552 }; 553 ; 554 result = ((TDirectory*)obj)->GetDirectory(slash+1,printError,funcname);; 555 delete [] path; return result;; 556}; 557 ; 558////////////////////////////////////////////////////////////////////////////////; 559/// Delete all objects from memory and directory structure itself.; 560 ; 561void TDirectoryFile::Close(Option_t *option); 562{; 563 if (!fList || !fSeekDir) {; 564 return;; 565 }; 566 ; 567 // Save the directory key list and header; 568 Save();; 569 ; 570 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 571 ; 572 if (!nodelete) {; 573 Bool_t fast = kTRUE;; 574 TObjLink *lnk = fList->FirstLink();; 575 while (lnk) {; 576 if (lnk->GetObject()->IsA() == TDirectoryFile::Class()) {fast = kFALSE;break;}; 577 lnk = lnk->Next();; 578 }; 579 // Delete objects from directory list, this in turn, recursively closes all; 580 // sub-directories (that were allocated on the heap); 581 // if this dir contains subdirs, we must use the slow option for Delete!; 582 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 583 // with a large number of objects (eg >10^5) would take for ever.; 584 {; 585 if (fast) fList->Delete();; 586 else fList->Delete(""slow"");; 587 }; 588 }; 589 ; 590 // Delete keys from key list (but don't delete the list header); 591 if (fKeys) {; 592 fKeys->Delete(""slow"");; 593 }; 594 ; 595 TDirectoryFile::CleanTargets();; 596}; 597 ; 598////////////////////////////////////////////////////////////////////////////////; 599/// Delete Objects or/and keys in a directory; 600///; 601/// Properties of the namecycle string:; 602/// - namecycle has the format name;cycle; 603/// - namecycle = """" is same as namecycle =""T*""; 604/// - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:19065,avoid,avoid,19065,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:34084,avoid,avoid,34084,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"if the vertices are defined; clockwise or anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoArb8.html:14372,safe,safe,14372,root/html528/TGeoArb8.html,https://root.cern,https://root.cern/root/html528/TGeoArb8.html,3,['safe'],['safe']
Safety,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:7437,avoid,avoid,7437,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['avoid'],['avoid']
Safety,"ific readv config params. ;  ; virtual Bool_t IsUseable () const;  Check the file is open and isn't a zombie. ;  ; TNetXNGFile & operator= (const TNetXNGFile &other);  ; virtual void SetEnv ();  Map ROOT and xrootd environment variables. ;  . Private Attributes; XrdCl::File * fFile;  ; XrdSysCondVar * fInitCondVar;  ; int fMode;  ; TString fNewUrl;  ; Int_t fQueryReadVParams;  ; Int_t fReadvIorMax;  ; Int_t fReadvIovMax;  ; XrdCl::URL * fUrl;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:30287,timeout,timeout,30287,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['timeout'],['timeout']
Safety,"ified by index, if non-NULL. w, h – Filled with the width and height of the bounding box for the character specified by index, if non-NULL. ; Definition at line 1109 of file TGFont.cxx. ◆ Class(). static TClass * TGTextLayout::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGTextLayout::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGTextLayout::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 134 of file TGFont.h. ◆ DeclFileName(). static const char * TGTextLayout::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 134 of file TGFont.h. ◆ DistanceToText(). Int_t TGTextLayout::DistanceToText ; (; Int_t ; x, . Int_t ; y . ); const. Computes the distance in pixels from the given point to the given text layout. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for hit detection purposes.; The return value is 0 if the point (x, y) is inside the text layout. If the point isn't inside the text layout then the return value is the distance in pixels from the point to the text item.; x, y – Coordinates of point to check, with respect to the upper-left corner of the text layout (in pixels). ; Definition at line 1191 of file TGFont.cxx. ◆ DrawText(). void TGTextLayout::DrawText ; (; Drawable_t ; dst, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . Int_t ; firstChar, . Int_t ; lastChar . ); const. Use the information in the TGTextLayout object to display a multi-line, justified string of text. ; This procedure is useful for simple widgets that need to display single-font, multi-line text and want TGFont to handle the details.; dst – Window or pixmap in which to draw. gc – Graphics context to use for drawing text. x, y – Upper-left hand corner of rectangle in which to draw (pixels). firstChar – The index of the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextLayout.html:14684,detect,detection,14684,doc/master/classTGTextLayout.html,https://root.cern,https://root.cern/doc/master/classTGTextLayout.html,1,['detect'],['detection']
Safety,"ig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCompositeShape.html:7916,safe,safe,7916,root/html532/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html,1,['safe'],['safe']
Safety,"ight use more memory.; 283/// (For the currently supported algorithms, the maximum level is 9); 284/// If compress is negative it indicates the compression level is not set yet.; 285/// The enumeration ROOT::RCompressionSetting::EAlgorithm associates each; 286/// algorithm with a number. There is a utility function to help; 287/// to set the value of compress. For example,; 288/// ROOT::CompressionSettings(ROOT::kLZMA, 1); 289/// will build an integer which will set the compression to use; 290/// the LZMA algorithm and compression level 1. These are defined; 291/// in the header file <em>Compression.h</em>.; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:12468,detect,detect,12468,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['detect'],['detect']
Safety,"ight, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoUnion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoUnion.html:2339,safe,safe,2339,root/html528/TGeoUnion.html,https://root.cern,https://root.cern/root/html528/TGeoUnion.html,2,['safe'],['safe']
Safety,"ignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStylePreview. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad). » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStylePreview.html:23386,avoid,avoid,23386,root/html602/TStylePreview.html,https://root.cern,https://root.cern/root/html602/TStylePreview.html,2,['avoid'],['avoid']
Safety,"ihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:3943,avoid,avoided,3943,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['avoid'],['avoided']
Safety,"ij, . const Int_t * ; binMap = nullptr . ); const. get correlation coefficiencts, possibly cumulated over several bins ; Parameters. [out]rhoijhistogram to store the correlation coefficiencts. The bin contents are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 3461 of file TUnfold.cxx. ◆ GetRhoMax(). Double_t TUnfold::GetRhoMax ; (; void ; ); const. inline . get maximum global correlation determined in recent unfolding ; Definition at line 325 of file TUnfold.h. ◆ GetRowFromBin(). Int_t TUnfold::GetRowFromBin ; (; int ; ix); const. inlineprotected . converts truth histogram bin number to matrix row ; Definition at line 234 of file TUnfold.h. ◆ GetSqrtEvEmatrix(). TVectorD TUnfold::GetSqrtEvEmatrix ; (; void ; ); const. Definition at line 2509 of file TUnfold.cxx. ◆ GetSURE(). double TUnfold::GetSURE ; (; void ; ); const. return Stein's unbiased risk estimator See e.g. ; arXiv:1612.09415; A minimum in the SURE variable is a good choice of regularisation strength; NOTE: the calculation of SURE depends on the calculation of DF. See the method GetDF() for caveats with Poisson-distributed data. ; Definition at line 3732 of file TUnfold.cxx. ◆ GetTau(). Double_t TUnfold::GetTau ; (; void ; ); const. return regularisation parameter ; Definition at line 3223 of file TUnfold.cxx. ◆ GetTUnfoldVersion(). const char * TUnfold::GetTUnfoldVersion ; (; void ; ). static . return a string describing the TUnfold version ; The version is reported in the form Vmajor.minor Changes of the minor version number typically correspond to bug-fixes. Changes of the major version may result in adding or removing data attributes, such that the streamer methods are not compatible between different major versions. ; Definition at line 3717 of file TUnfold.cxx. ◆ GetVxx(). const TMatrixDSparse * TUnfold::GetVxx ; (; void ; ); const. inlineprotected . covari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:45011,risk,risk,45011,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['risk'],['risk']
Safety,"il(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:182605,timeout,timeout,182605,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"il(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:182637,timeout,timeout,182637,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ile TFractionFitter.h. ◆ fIntegralData. Double_t TFractionFitter::fIntegralData. protected . ""data"" histogram content integral over allowed fit range ; Definition at line 103 of file TFractionFitter.h. ◆ fIntegralMCs. Double_t* TFractionFitter::fIntegralMCs. protected . Same for template histograms (weights not taken into account) ; Definition at line 104 of file TFractionFitter.h. ◆ fLowLimitX. Int_t TFractionFitter::fLowLimitX. protected . First bin in X dimension. ; Definition at line 84 of file TFractionFitter.h. ◆ fLowLimitY. Int_t TFractionFitter::fLowLimitY. protected . First bin in Y dimension. ; Definition at line 86 of file TFractionFitter.h. ◆ fLowLimitZ. Int_t TFractionFitter::fLowLimitZ. protected . First bin in Z dimension. ; Definition at line 88 of file TFractionFitter.h. ◆ fMCs. TObjArray TFractionFitter::fMCs. protected . Array of pointers to template histograms. ; Definition at line 101 of file TFractionFitter.h. ◆ fNDF. Int_t TFractionFitter::fNDF. protected . Number of degrees of freedom in the fit. ; Definition at line 93 of file TFractionFitter.h. ◆ fNpar. Int_t TFractionFitter::fNpar. protected . number of fit parameters ; Definition at line 110 of file TFractionFitter.h. ◆ fNpfits. Int_t TFractionFitter::fNpfits. protected . Number of points used in the fit. ; Definition at line 92 of file TFractionFitter.h. ◆ fPlot. TH1* TFractionFitter::fPlot. protected . Pointer to histogram containing summed template predictions. ; Definition at line 106 of file TFractionFitter.h. ◆ fWeights. TObjArray TFractionFitter::fWeights. protected . Array of pointers to corresponding weight factors (may be null) ; Definition at line 102 of file TFractionFitter.h. Libraries for TFractionFitter:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TFractionFitter.h; hist/hist/src/TFractionFitter.cxx. TFractionFitter. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:53 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:36494,predict,predictions,36494,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['predictions']
Safety,"ile and libraries); [#6509] - [ROOT I/O] Warning: writing 1 byte into a region of size 0; [#6597] - pytest shipped in roottest is not compatible with py3.9; [#6677] - [bug] Clang builds ROOT libraries that emit FPEs; [#6784] - external nlohmann/json.hpp is not forwarded as dependency or should be linked PRIVATE?; [#6523] - TBufferMerger cannot handle TTree spanning over multiple files; [#6743] - ROOT crashes with no helpful error messages if a TApplication is not present and tree->StartViewer() is called; [#6840] - TClass for pair sometimes have the wrong offset/size; [#6839] - Compilation fails on macosx 11.0 with arm processor; [#6838] - build/unix/compiledata.sh assumes macOS will always have major version 10; [#6817] - macOS packaging broken in master; [#6856] - error when creating a python class inheriting from a ROOT class, 6.22/02; [#6797] - TCling::UpdateListOfLoadedSharedLibraries() Linux thread safety; [#6483] - [GUI] Crashes when creating TGClient in a standalone application; [#6563] - Test failures on MacOS with Xcode 12; [#6624] - TRandom: signature mismatch between getter and setter; [#6815] - PowerShell version of thisroot.bat; [#6853] - [DF] SaveGraph can be confused by shared upstream Defines; [#6731] - Compilation error on CentOS 7 of root V6.22.02 c++17; [#6974] - pyROOT doesn’t work with ipyparallel; [#6964] - [TTree] GetLeaf ignores the branchname arg if friend trees are present; [#6944] - RDataFrame misidentifies vector<XYZTVector> type of a friend tree with identical branch name to another friend tree; [#6345] - 6.22.00 pyroot regression: Can’t derive from TProfile.; [#6903] - Builtin TBB is broken on MacOS M1; [#7016] - Memory leak during schema evolution of some classes; [#6993] - [TTreeReader] Segfault when reading branch of “automatically loaded” friend; [#6741] - [DF] When dataset is specified as treename/filename, the TTree is read without its friends; [#6470] - PyROOT: virtual C++ method overriden in python ignored with further inherita",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:42083,safe,safety,42083,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['safe'],['safety']
Safety,"ile.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In particular, if 'output' is nullptr or empty, reset the internal list. On return, the content of 'output' is cleared to avoid double deletion issues. (The caller is responsible of 'output' as container: its content is transferred under the selector ownership). ; Definition at line 270 of file TSelector.cxx. ◆ Init(). virtual void TSelector::Init ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelVerifyDataSet, TSelHandleDataSet, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, h1analysisTreeReader, TSelEvent, TSelEventGen, TProofDrawGraph, TProofDrawPolyMarker3D, RooProofDriverSelector, TSelectorEntries, and h1analysis.; Definition at line 53 of file TSelector.h. ◆ IsA(). TClass * TSelector::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSelVerifyDataSet, TSelEvent, TSelEventGen, TSelHandleDataSet, TSelHist, TSelectorDraw, and TSelectorEntries.; Definition at line 79 of file TSelector.h. ◆ IsStandardDraw(). bool TSelector::IsStandardDraw ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:19067,avoid,avoid,19067,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['avoid'],['avoid']
Safety,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:25503,avoid,avoid,25503,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['avoid'],['avoid']
Safety,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:25843,avoid,avoid,25843,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['avoid'],['avoid']
Safety,"iled; 2973 /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; 2974 ///; 2975 /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; 2976 ///; 2977 /// ### Examples; 2978 /// See [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html) for an example implementation of an action helper.; 2979 ///; 2980 /// It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx.; 2981 ///; 2982 // clang-format on; 2983 template <typename FirstColumn = RDFDetail::RInferredType, typename... OtherColumns, typename Helper>; 2984 RResultPtr<typename std::decay_t<Helper>::Result_t> Book(Helper &&helper, const ColumnNames_t &columns = {}); 2985 {; 2986 using HelperT = std::decay_t<Helper>;; 2987 // TODO add more static sanity checks on Helper; 2988 using AH = RDFDetail::RActionImpl<HelperT>;; 2989 static_assert(std::is_base_of<AH, HelperT>::value && std::is_convertible<HelperT *, AH *>::value,; 2990 ""Action helper of type T must publicly inherit from ROOT::Detail::RDF::RActionImpl<T>"");; 2991 ; 2992 auto hPtr = std::make_shared<HelperT>(std::forward<Helper>(helper));; 2993 auto resPtr = hPtr->GetResultPtr();; 2994 ; 2995 if (std::is_same<FirstColumn, RDFDetail::RInferredType>::value && columns.empty()) {; 2996 return CallCreateActionWithoutColsIfPossible<HelperT>(resPtr, hPtr, TTraits::TypeList<FirstColumn>{});; 2997 } else {; 2998 return CreateAction<RDFInternal::ActionTags::Book, FirstColumn, OtherColumns...>(columns, resPtr, hPtr,; 2999 fProxiedPtr, columns.size());; 3000 }; 3001 }; 3002 ; 3003 ////////////////////////////////////////////////////////////////////////////; 3004 /// \brief Provides a representation of the columns in the dataset.; 3005 /// \tparam ColumnTypes variadic list of branch/column types.; 3006 /// \param[in] columnList Names of the columns to be displayed.; 3007 /// \param[in] nRows Number of events f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:169762,sanity check,sanity checks,169762,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['sanity check'],['sanity checks']
Safety,"ilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:12695,safe,safely,12695,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,4,['safe'],['safely']
Safety,"ill provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMarker(TGCompositeFrame* f); Add the 'Marker' group frame to the 'General' tab. void CreateTabCanvas(TGCompositeFrame* tab); Add the tab 'Canvas' to the editor. void AddCanvasFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'Canvas' tab. void AddCanvasGeome",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:50929,avoid,avoid,50929,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['avoid'],['avoid']
Safety,"illed from the buffer. When the histogram is filled from the; 1406/// buffer the value fBuffer[0] is set to a negative number (= - number of entries); 1407/// When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0; 1408/// While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if; 1409/// the histogram was filled before. This is needed when drawing the histogram; 1410/// - action = 1 histogram is filled and buffer is deleted; 1411/// The buffer is automatically deleted when filling the histogram and the entries is; 1412/// larger than the buffer size; 1413 ; 1414Int_t TH1::BufferEmpty(Int_t action); 1415{; 1416 // do we need to compute the bin size?; 1417 if (!fBuffer) return 0;; 1418 Int_t nbentries = (Int_t)fBuffer[0];; 1419 ; 1420 // nbentries correspond to the number of entries of histogram; 1421 ; 1422 if (nbentries == 0) {; 1423 // if action is 1 we delete the buffer; 1424 // this will avoid infinite recursion; 1425 if (action > 0) {; 1426 delete [] fBuffer;; 1427 fBuffer = nullptr;; 1428 fBufferSize = 0;; 1429 }; 1430 return 0;; 1431 }; 1432 if (nbentries < 0 && action == 0) return 0; // case histogram has been already filled from the buffer; 1433 ; 1434 Double_t *buffer = fBuffer;; 1435 if (nbentries < 0) {; 1436 nbentries = -nbentries;; 1437 // a reset might call BufferEmpty() giving an infinite recursion; 1438 // Protect it by setting fBuffer = nullptr; 1439 fBuffer = nullptr;; 1440 //do not reset the list of functions; 1441 Reset(""ICES"");; 1442 fBuffer = buffer;; 1443 }; 1444 if (CanExtendAllAxes() || (fXaxis.GetXmax() <= fXaxis.GetXmin())) {; 1445 //find min, max of entries in buffer; 1446 Double_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:55964,avoid,avoid,55964,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11475,avoid,avoid,11475,root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,6,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:11475,avoid,avoid,11475,root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,9,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11258,avoid,avoid,11258,root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,5,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:11151,avoid,avoid,11151,root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,10,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11475,avoid,avoid,11475,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,8,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:11475,avoid,avoid,11475,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,7,['avoid'],['avoid']
Safety,"ilure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:243518,avoid,avoid,243518,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"imental::EIOUnsupportedFeatures ; input_bits). Clear a specific IO feature from this set. ; Parameters. [in]input_bitsThe specific feature to disable. Removes a feature from the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT. ; Definition at line 69 of file TIOFeatures.cxx. ◆ GetFeatures(). UChar_t TIOFeatures::GetFeatures ; (; ); const. private . Definition at line 250 of file TIOFeatures.cxx. ◆ Print(). void TIOFeatures::Print ; (; ); const. Print a human-readable representation of the TIOFeatures to stdout. ; Prints a string with the names of all enabled IO features. ; Definition at line 197 of file TIOFeatures.cxx. ◆ Set() [1/4]. bool TIOFeatures::Set ; (; const std::string & ; value). Given a IO feature string, set the corresponding feature. ; Parameters. [in]valueFeature name to test. This allows one to set a feature given a specific string from the TBasket::EIOBits enum.; NOTE this function is quite slow and users are strongly encouraged to use the type-safe Set version instead. This has been added for better CLI interfaces.; Returns true only if a new feature was set; otherwise emits an error message and returns false. ; Definition at line 172 of file TIOFeatures.cxx. ◆ Set() [2/4]. bool TIOFeatures::Set ; (; EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 139 of file TIOFeatures.cxx. ◆ Set() [3/4]. bool TIOFeatures::Set ; (; Experimental::EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html:4980,safe,safe,4980,doc/v632/classROOT_1_1TIOFeatures.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html,2,['safe'],['safe']
Safety,"imental::NTupleSize_t ROOT::Experimental::Internal::RPageSource::GetNElements ; (; ColumnHandle_t ; columnHandle). Definition at line 219 of file RPageStorage.cxx. ◆ GetNEntries(). ROOT::Experimental::NTupleSize_t ROOT::Experimental::Internal::RPageSource::GetNEntries ; (; ). Definition at line 214 of file RPageStorage.cxx. ◆ GetReadOptions(). const RNTupleReadOptions & ROOT::Experimental::Internal::RPageSource::GetReadOptions ; (; ); const. inline . Definition at line 714 of file RPageStorage.hxx. ◆ GetSharedDescriptorGuard(). const RSharedDescriptorGuard ROOT::Experimental::Internal::RPageSource::GetSharedDescriptorGuard ; (; ); const. inline . Takes the read lock for the descriptor. ; Multiple threads can take the lock concurrently. The underlying std::shared_mutex, however, is neither read nor write recursive: within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special care in sections protected by GetSharedDescriptorGuard() and GetExclDescriptorGuard() especially to avoid that the locks are acquired indirectly (e.g. by a call to GetNEntries()). As a general guideline, no other method of the page source should be called (directly or indirectly) in a guarded section. ; Definition at line 722 of file RPageStorage.hxx. ◆ GetType(). EPageStorageType ROOT::Experimental::Internal::RPageSource::GetType ; (; ). inlinefinalvirtual . Whether the concrete implementation is a sink or a source. ; Implements ROOT::Experimental::Internal::RPageStorage.; Definition at line 713 of file RPageStorage.hxx. ◆ LoadClusters(). virtual std::vector< std::unique_ptr< RCluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:13372,avoid,avoid,13372,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['avoid'],['avoid']
Safety,"imit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441337,abort,aborted,441337,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['abort'],['aborted']
Safety,"implified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  fit1.C Simple fitting example (1-d histogram with an interpreted function) ;  fit2.C Fitting a 2-D histogram This tutorial illustrates : ;  fit2a.C Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  fit2d.C Example illustrating how to fit a 2-d histogram of type y=f(x) ;  fit2dHist.C ;  fitCircle.C Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  fitcont.C Example illustrating how to draw the n-sigma contour of a Minuit fit ;  fitConvolution.C Tutorial for convolution of two functions ;  fitEllipseTGraphDLSF.cxx;  fitEllipseTGraphRMM.cxx;  fitExclude.C Illustrates how to fit excluding points in a given range ;  fithist.C Example of fit where the model is histogram + function ;  fitLinear.C Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:104354,predict,predictor,104354,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['predict'],['predictor']
Safety,"in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:6351,detect,detector,6351,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['detect'],['detector']
Safety,"in edge. . kBinCenter Get the bin center. . kBinTo Get the bin high edge. . Definition at line 252 of file RHistImpl.hxx. ◆ EColumnCppType. enum class ROOT::Experimental::Internal::EColumnCppType. strong . EnumeratorkChar ; kBool ; kByte ; kUint8 ; kUint16 ; kUint32 ; kUint64 ; kInt8 ; kInt16 ; kInt32 ; kInt64 ; kFloat ; kDouble ; kClusterSize ; kColumnSwitch ; kMax . Definition at line 119 of file RColumnElementBase.hxx. ◆ EDaosLocatorFlags. enum ROOT::Experimental::Internal::EDaosLocatorFlags. EnumeratorkCagedPage . Definition at line 43 of file RPageStorageDaos.hxx. ◆ EFindStatus. enum class ROOT::Experimental::Internal::EFindStatus. strong . Status of FindBin(x) and FindAdjustedBin(x) . EnumeratorkCanGrow The coordinate could fit after growing the axis. . kValid The returned bin index is valid. . Definition at line 259 of file RHistImpl.hxx. ◆ ENTupleMergeErrBehavior. enum class ROOT::Experimental::Internal::ENTupleMergeErrBehavior. strong . EnumeratorkAbort The merger will abort merging as soon as an error is encountered. . kSkip Upon errors, the merger will skip the current source and continue. . Definition at line 45 of file RNTupleMerger.hxx. ◆ ENTupleMergingMode. enum class ROOT::Experimental::Internal::ENTupleMergingMode. strong . EnumeratorkFilter The merger will discard all columns that aren't present in the prototype model (i.e. ; the model of the first source) . kStrict The merger will refuse to merge any 2 RNTuples whose schema doesn't match exactly. . kUnion The merger will update the output model to include all columns from all sources. ; Entries corresponding to columns that are not present in a source will be set to the default value of the type. . Definition at line 34 of file RNTupleMerger.hxx. ◆ EPageStorageType. enum class ROOT::Experimental::Internal::EPageStorageType. strong . EnumeratorkSink ; kSource . Definition at line 56 of file RPageStorage.hxx. Function Documentation. ◆ CallCommitClusterOnField(). void ROOT::Experimental::Internal::Cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:16524,abort,abort,16524,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['abort'],['abort']
Safety,"in loss: 0.679; [3, 12] train loss: 0.679; [3] val loss: 0.692; [4, 4] train loss: 0.663; [4, 8] train loss: 0.668; [4, 12] train loss: 0.650; [4] val loss: 0.708; [5, 4] train loss: 0.642; [5, 8] train loss: 0.635; [5, 12] train loss: 0.633; [5] val loss: 0.707; [6, 4] train loss: 0.607; [6, 8] train loss: 0.588; [6, 12] train loss: 0.585; [6] val loss: 0.700; [7, 4] train loss: 0.553; [7, 8] train loss: 0.564; [7, 12] train loss: 0.542; [7] val loss: 0.637; [8, 4] train loss: 0.474; [8, 8] train loss: 0.446; [8, 12] train loss: 0.436; [8] val loss: 0.758; [9, 4] train loss: 0.381; [9, 8] train loss: 0.435; [9, 12] train loss: 0.456; [9] val loss: 1.218; [10, 4] train loss: 0.438; [10, 8] train loss: 0.436; [10, 12] train loss: 0.444; [10] val loss: 0.632; Finished Training on 10 Epochs!; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchTrainedModelCNN.pt; PyTorch : [dataset] : Evaluation of PyTorch on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.12 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: BDT; : ; BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN_CPU; : ; TMVA_DNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_CNN_CPU; : ; TMVA_CNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:41276,predict,predict,41276,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predict']
Safety,"in of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17689 server_domain_len = strlen(server_domain);; 17690 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17691 return 0;; 17692 }; 17693 if ((request_domain_len == server_domain_len); 17694 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17695 /* Request is directed to this server - full name match. */; 17696 } else {; 17697 if (request_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699 * is longer than the request name.; 17700 * Drop this case here to avoid overflows in the; 17701 * following checks. */; 17702 return 0;; 17703 }; 17704 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:526244,avoid,avoid,526244,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"in of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17690 server_domain_len = strlen(server_domain);; 17691 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17692 return 0;; 17693 }; 17694 if ((request_domain_len == server_domain_len); 17695 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17696 /* Request is directed to this server - full name match. */; 17697 } else {; 17698 if (request_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700 * is longer than the request name.; 17701 * Drop this case here to avoid overflows in the; 17702 * following checks. */; 17703 return 0;; 17704 }; 17705 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:526277,avoid,avoid,526277,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf305_condcorrprodDefinition rf305_condcorrprod.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf305_condcorrprod.C. tutorialsroofitrf305_condcorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8C.html:5327,safe,safe,5327,doc/master/rf305__condcorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html,1,['safe'],['safe']
Safety,"in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; PairNegWeightsInNode Randomly pair miscl. ev. with neg. and pos. weights in node and don't boost them; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:27589,avoid,avoided,27589,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,2,['avoid'],['avoided']
Safety,"in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterium; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); IgnoreNegWeightsInTraining Ignore negative weight events in the training.; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:26184,avoid,avoided,26184,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['avoid'],['avoided']
Safety,"in volume corresponding to the variables in sumSet; inverseBinCor: divide counts in each bin by the bin volume corresponding to the variables not in sumSet. New fully parametrised Crystal Ball shape class; So far, the Crystal Ball distribution has been represented in RooFit only by the RooCBShape class, which has a Gaussian core and a single power-law tail on one side. This release introduces RooCrystalBall, which implements some common generalizations of the Crystal Ball shape:. symmetric or asymmetric power-law tails on both sides; different width parameters for the left and right sides of the Gaussian core. The new RooCrystalBall class can substitute the RooDSCBShape and RooSDSCBShape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channel. This significantly increase a performance, especially when several clients are connected.; Better security for THttpServer with webgui; If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will provide access to the widgets via websocket connection - any other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:26278,avoid,avoids,26278,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['avoid'],['avoids']
Safety,"in(Double_t x, Double_t y = 0, Double_t z = 0) const; returns the global bin number containing the given values. Note: - values which belong to dimensions higher than the current dimension; of the TEfficiency object are ignored (i.e. for 1-dimensional; efficiencies only the x-value is considered). Int_t Fit(TF1* f1, Option_t* opt = """"); fits the efficiency using the TBinomialEfficiencyFitter class. The resulting fit function is added to the list of associated functions. Options: - ""+"": previous fitted functions in the list are kept, by default; all functions in the list are deleted; - for more fitting options see TBinomialEfficiencyFitter::Fit. TH1* GetCopyPassedHisto() const; returns a cloned version of fPassedHistogram. Notes: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""passed.root"",""update"");; TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; TH1* copy = pEff->GetCopyPassedHisto();; copy->SetDirectory(gDirectory);; pFile->Write();. TH1* GetCopyTotalHisto() const; returns a cloned version of fTotalHistogram. Notes: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""total.root"",""update"");; TEfficiency* pEff = (TEfficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:54005,avoid,avoid,54005,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,6,['avoid'],['avoid']
Safety,"in) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:52103,risk,risks,52103,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['risk'],['risks']
Safety,"in) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53743,risk,risks,53743,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['risk'],['risks']
Safety,"in, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:16486,safe,safe,16486,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['safe'],['safe']
Safety,"in, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4381,safe,safe,4381,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,3,['safe'],['safe']
Safety,"inDeepNet<DNN::TCuda<ScalarImpl_t>>();; 1674#endif; 1675#else; 1676 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 1677 ""you have CUDA installed and it was successfully ""; 1678 ""detected by CMAKE.""; 1679 << Endl;; 1680 return;; 1681#endif; 1682 } else if (this->GetArchitectureString() == ""CPU"") {; 1683#ifdef R__HAS_TMVACPU; 1684 // note that number of threads used for BLAS might be different; 1685 // e.g use openblas_set_num_threads(num_threads) for OPENBLAS backend; 1686 Log() << kINFO << ""Start of deep neural network training on CPU using MT, nthreads = ""; 1687 << gConfig().GetNCpu() << Endl << Endl;; 1688#else; 1689 Log() << kINFO << ""Start of deep neural network training on single thread CPU (without ROOT-MT support) "" << Endl; 1690 << Endl;; 1691#endif; 1692 TrainDeepNet<DNN::TCpu<ScalarImpl_t> >();; 1693 return;; 1694 }; 1695 else {; 1696 Log() << kFATAL << this->GetArchitectureString() <<; 1697 "" is not a supported architecture for TMVA::MethodDL""; 1698 << Endl;; 1699 }; 1700 ; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704void TMVA::MethodDL::FillInputTensor(); 1705{; 1706 // fill the input tensor fXInput from the current Event data; 1707 // with the correct shape depending on the model used; 1708 // The input tensor is used for network prediction after training ; 1709 // using a single event. The network batch size must be equal to 1. ; 1710 // The architecture specified at compile time in ArchitectureImpl_t; 1711 // is used. This should be the CPU architecture; 1712 ; 1713 if (!fNet || fNet->GetDepth() == 0) {; 1714 Log() << kFATAL << ""The network has not been trained and fNet is not built"" << Endl;; 1715 }; 1716 if (fNet->GetBatchSize() != 1) {; 1717 Log() << kFATAL << ""FillINputTensor::Network batch size must be equal to 1 when doing single event predicition"" << Endl;; 1718 }; 1719 ; 1720 // get current event; 1721 const std::vector<Float_t> &inputValues = GetEvent()->GetValues()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:67599,predict,prediction,67599,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17656,avoid,avoids,17656,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,3,['avoid'],['avoids']
Safety,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16297,avoid,avoids,16297,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,3,['avoid'],['avoids']
Safety,"inate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:18656,timeout,timeout,18656,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,2,['timeout'],['timeout']
Safety,"ind and return logical shape identified by unique 'ID' in refresh-cache. ;  ; virtual TGLPhysicalShape * FindPhysical (UInt_t phid) const;  Find and return physical shape identified by unique 'ID'. ;  ; TGLContextIdentity * GetGLCtxIdentity () const;  ; virtual UInt_t GetMaxPhysicalID ();  Returns the maximum used physical id. ;  ; void LodifySceneInfo (TGLRnrCtx &rnrCtx) override;  Setup LOD-dependant values in scene-info. ;  ; void PostDraw (TGLRnrCtx &rnrCtx) override;  Called after the rendering is finished. ;  ; void PreDraw (TGLRnrCtx &rnrCtx) override;  Initialize rendering. ;  ; void RebuildSceneInfo (TGLRnrCtx &rnrCtx) override;  Major change in scene, need to rebuild all-element draw-vector and sort it. ;  ; LogicalShapeMap_t & RefLogicalShapes ();  ; virtual void RenderAllPasses (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeout);  Do full rendering of scene. ;  ; virtual void RenderElements (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeout, const TGLPlaneSet_t *clipPlanes=nullptr);  Render DrawElements in elementVec with given timeout. ;  ; virtual void RenderHighlight (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec);  ; void RenderOpaque (TGLRnrCtx &rnrCtx) override;  Render opaque elements. ;  ; void RenderSelOpaque (TGLRnrCtx &rnrCtx) override;  Render selected opaque elements. ;  ; void RenderSelOpaqueForHighlight (TGLRnrCtx &rnrCtx) override;  Render selected opaque elements for highlight. ;  ; void RenderSelTransp (TGLRnrCtx &rnrCtx) override;  Render selected transparent elements. ;  ; void RenderSelTranspForHighlight (TGLRnrCtx &rnrCtx) override;  Render selected transparent elements for highlight. ;  ; void RenderTransp (TGLRnrCtx &rnrCtx) override;  Render transparent elements. ;  ; Bool_t ResolveSelectRecord (TGLSelectRecord &rec, Int_t curIdx) override;  Process selection record rec. ;  ; UInt_t SizeOfScene () const;  Return memory cost of scene. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:13748,timeout,timeout,13748,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['timeout'],['timeout']
Safety,"ine 132 of file TGLSAViewer.h. ◆ MenuHidingTimeout(). void TGLSAViewer::MenuHidingTimeout ; (; ). Action for menu-hiding timeout. ; Definition at line 638 of file TGLSAViewer.cxx. ◆ operator=(). TGLSAViewer & TGLSAViewer::operator= ; (; const TGLSAViewer & ; ). private . ◆ ProcessFrameMessage(). Bool_t TGLSAViewer::ProcessFrameMessage ; (; Long_t ; msg, . Long_t ; parm1, . Long_t ;  . ). Process GUI message capture by the main GUI frame (TGLSAFrame). ; Definition at line 663 of file TGLSAViewer.cxx. ◆ ResetMenuHidingTimer(). void TGLSAViewer::ResetMenuHidingTimer ; (; Bool_t ; show_menu). private . Reset the timer for menu-bar hiding. ; Definition at line 620 of file TGLSAViewer.cxx. ◆ SelectionChanged(). void TGLSAViewer::SelectionChanged ; (; ). overridevirtual . Update GUI components for embedded viewer selection change. ; Override from TGLViewer. ; Reimplemented from TGLViewer.; Definition at line 481 of file TGLSAViewer.cxx. ◆ SetMenuHidingTimeout(). void TGLSAViewer::SetMenuHidingTimeout ; (; Long_t ; timeout). static . Set global timeout for menu-hiding in mili-seconds. ; Static function. ; Definition at line 655 of file TGLSAViewer.cxx. ◆ Show(). void TGLSAViewer::Show ; (; ). Show the viewer. ; Definition at line 500 of file TGLSAViewer.cxx. ◆ Streamer(). void TGLSAViewer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLSAViewer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 132 of file TGLSAViewer.h. ◆ ToggleEditObject(). void TGLSAViewer::ToggleEditObject ; (; ). Toggle state of the 'Edit Object' menu entry. ; Definition at line 820 of file TGLSAViewer.cxx. ◆ ToggleOrthoDolly(). void TGLSAViewer::ToggleOrthoDolly ; (; ). Toggle state of the 'Ortho allow dolly' menu entry. ; Definition at line 850 of file TGLSAViewer.cxx. ◆ ToggleOrthoRotate(). void TGLSAViewer::ToggleOrthoRotate ; (; ). Toggle state of the 'Ortho a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:46367,timeout,timeout,46367,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['timeout'],['timeout']
Safety,"ine 528 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:454; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:209; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 454 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when a very large number of files and workers is used. ; Definition at line 541 of file TTreeProcessorMT.cxx. Member Data Documentation. ◆ fEntryList. TEntryList ROOT::TTreeProcessorMT::fEntryList. private . User-defined selection of entry numbers to be processed, empty if none was provided. ; Definition at line 84 of file TTreeProcessorMT.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html:6615,safe,safe,6615,doc/v632/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html,1,['safe'],['safe']
Safety,"ine 53 of file TGeoShapeAssembly.h. ◆ IsCylType(). Bool_t TGeoShapeAssembly::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoShapeAssembly.h. ◆ NeedsBBoxRecompute(). void TGeoShapeAssembly::NeedsBBoxRecompute ; (; ). inline . Definition at line 55 of file TGeoShapeAssembly.h. ◆ RecomputeBoxLast(). void TGeoShapeAssembly::RecomputeBoxLast ; (; ). Recompute bounding box of the assembly after adding a node. ; Definition at line 114 of file TGeoShapeAssembly.cxx. ◆ Safety(). Double_t TGeoShapeAssembly::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 476 of file TGeoShapeAssembly.cxx. ◆ Safety_v(). void TGeoShapeAssembly::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoShapeAssembly.cxx. ◆ SavePrimitive(). void TGeoShapeAssembly::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 542 of file TGeoShapeAssembly.cxx. ◆ SetPoints() [1/2]. void TGeoShapeAssembly::SetPoints ; (; Double_t * ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 547 of file TGeoShapeAssembly.cxx. ◆ SetPoints() [2/2]. void TGeoShapeAssembly::SetPoints ; (; Float_t * ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:30649,safe,safe,30649,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"ine 535 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:460; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:216; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 460 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when a very large number of files and workers is used. ; Definition at line 548 of file TTreeProcessorMT.cxx. Member Data Documentation. ◆ fEntryList. TEntryList ROOT::TTreeProcessorMT::fEntryList. private . User-defined selection of entry numbers to be processed, empty if none was provided. ; Definition at line 85 of file TTreeProcessorMT.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html:6982,safe,safe,6982,doc/master/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html,1,['safe'],['safe']
Safety,"ine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. private:. static intfgCoinFlagno coin viewer;; static intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:22702,safe,safely,22702,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,3,['safe'],['safely']
Safety,"ineSlot(""x"", function, {""column1"", ""column2""}); See Define() for more information. ; Definition at line 470 of file RInterface.hxx. ◆ DefineSlotEntry(). template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefineSlotEntry ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column with a value dependent on the processing slot and the current entry. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding slot and entry). . Returnsthe first node of the computation graph for which the new quantity is defined.; This alternative implementation of Define is meant as a helper in writing entry-specific, thread-safe custom columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where T1, T2... are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter is reserved for a ULong64_t representing the current entry being processed by the current thread.; The following two Defines are equivalent, although DefineSlotEntry is slightly more performant: int function(unsigned int, ULong64_t, double, double);; Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); DefineSlotEntry(""x"", function, {""column1"", ""column2""}); ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterface::DefineRInterface< Proxied, DS_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:60244,safe,safe,60244,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"ing class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:2122,avoid,avoid,2122,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ing example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THistPainter.html:69949,avoid,avoid,69949,root/html532/THistPainter.html,https://root.cern,https://root.cern/root/html532/THistPainter.html,4,['avoid'],['avoid']
Safety,"ing key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361395,timeout,timeout,361395,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ing key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361428,timeout,timeout,361428,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ing mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:66027,detect,detector,66027,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"ing terminator) should be specified in; 1295/// namesize.; 1296/// @note Edge cases:; 1297/// - If the number after the `;` is larger than `SHORT_MAX`, cycle is set to `0`.; 1298/// - If name ends with `;*`, cycle is set to 10000`.; 1299/// - In all other cases, i.e. when number is not a digit or buffer is a nullptr, cycle is set to `9999`.; 1300 ; 1301void TDirectory::DecodeNameCycle(const char *buffer, char *name, Short_t &cycle,; 1302 const size_t namesize); 1303{; 1304 if (!buffer) {; 1305 cycle = 9999;; 1306 return;; 1307 }; 1308 ; 1309 size_t len = 0;; 1310 const char *ni = strchr(buffer, ';');; 1311 ; 1312 if (ni) {; 1313 // Found ';'; 1314 len = ni - buffer;; 1315 ++ni;; 1316 } else {; 1317 // No ';' found; 1318 len = strlen(buffer);; 1319 ni = &buffer[len];; 1320 }; 1321 ; 1322 if (namesize) {; 1323 if (len > namesize-1ul) len = namesize-1; // accommodate string terminator; 1324 } else {; 1325 ::Warning(""TDirectory::DecodeNameCycle"",; 1326 ""Using unsafe version: invoke this method by specifying the buffer size"");; 1327 }; 1328 ; 1329 strncpy(name, buffer, len);; 1330 name[len] = '\0';; 1331 ; 1332 if (*ni == '*'); 1333 cycle = 10000;; 1334 else if (isdigit(*ni)) {; 1335 long parsed = strtol(ni,nullptr,10);; 1336 if (parsed >= (long) std::numeric_limits<Short_t>::max()); 1337 cycle = 0;; 1338 else; 1339 cycle = (Short_t)parsed;; 1340 } else; 1341 cycle = 9999;; 1342}; 1343 ; 1344void TDirectory::TContext::RegisterCurrentDirectory(); 1345{; 1346 // peg the current directory; 1347 TDirectory *current;; 1348 {; 1349 ROOT::Internal::TSpinLockGuard slg(*GetCurrentDirectoryLock());; 1350 current = TDirectory::CurrentDirectory().load();; 1351 // Don't peg if there is no current directory or if the current; 1352 // directory's destruction has already started (in another thread); 1353 // and is waiting for this thread to leave the critical section.; 1354 if (!current || !current->IsBuilt()); 1355 return;; 1356 ++(current->fContextPeg);; 1357 }; 1358 current->Register",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:46117,unsafe,unsafe,46117,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"ing the remote master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 493 of file TSlave.cxx. ◆ Print(). void TSlave::Print ; (; Option_t * ; option = """"); const. overridevirtual . Printf info about slave. ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 340 of file TSlave.cxx. ◆ SendCoordinator(). TObjString * TSlave::SendCoordinator ; (; Int_t ; kind, . const char * ; msg = 0, . Int_t ; int2 = 0 . ). protectedvirtual . Send message to intermediate coordinator. ; Only meaningful when there is one, i.e. in XPD framework ; Definition at line 643 of file TSlave.cxx. ◆ SendGroupPriority(). virtual Int_t TSlave::SendGroupPriority ; (; const char * ; , . Int_t ;  . ). inlineprotectedvirtual . Definition at line 110 of file TSlave.h. ◆ SetAlias(). void TSlave::SetAlias ; (; const char * ; alias). protectedvirtual . Set an alias for this session. ; If reconnection is supported, the alias will be communicated to the remote coordinator so that it can be recovered when reconnecting ; Definition at line 655 of file TSlave.cxx. ◆ SetArchCompiler(). void TSlave::SetArchCompiler ; (; const char * ; ac). inline . Definition at line 158 of file TSlave.h. ◆ SetInputHandler(). void TSlave::SetInputHandler ; (; TFileHandler * ; ih). Adopt and register input handler for this slave. ; Handler will be deleted by the slave. ; Definition at line 393 of file TSlave.cxx. ◆ SetInterruptHandler(). virtual void TSlave::SetInterruptHandler ; (; Bool_t ; ). inlinevirtual . Definition at line 156 of file TSlave.h. ◆ SetROOTVersion(). void TSlave::SetROOTVersion ; (; const char * ; rv). inline . Definition at line 159 of file TSlave.h. ◆ SetSessionTag(). void TSlave::SetSessionTag ; (; const char * ; st). inline . Definition at line 161 of file TSlave.h. ◆ SetSocket(). void TSlave::SetSocket ; (; TSocket * ; s). inlineprotected . Definition at line 112 of file TSlave.h. ◆ SetStatus(). virtual void TSlave::SetStatus ; (; Int_t ; st). inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:22072,recover,recovered,22072,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['recover'],['recovered']
Safety,"ingle integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:14769,safe,safe,14769,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['safe'],['safe']
Safety,ings.py ;  tdf013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  tdf014_CSVDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf014_CSVDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a TDataFrame ;  ► eve;  alice_esd.CComplex example showing ALICE ESD track visualization ;  alice_esd_html_summary.CHtml table and event summary for alice_esd.C ;  alice_esd_split.CComplex example showing ALICE ESD visualization in several views ;  alice_vsd.CComplex example showing ALICE VSD visualization ;  annotation.CDemonstrates usage of TGLAnnotation class ;  arrow.CDemonstrates usage of TEveArrow class ;  arrow_standalone.CHow to use EVE without the standard window ;  assembly.CGeometry detector assembly example ;  box.CDemonstrates usage of TEveBox class ;  boxset.CDemonstrates usage of TEveBoxSet class ;  boxset_cones.CDemonstrates usage of 'cone' mode in TEveBoxSet class ;  calo_detail.CCalorimeter detailed view by using TEveCaloDataVec as data-source ;  calorimeters.CDemonstrates usage of EVE calorimetry classes ;  camera_restore.C;  compound.CDemonstrates usage of EVE compound objects - class TEveCompound ;  csgdemo.CCombinatorial Solid Geometry example ;  geom_alias.CDemonstates usage of geometry aliases - merge ALICE ITS with ATLAS MUON ;  geom_alice_its.CShows geometry of ALICE ITS ;  geom_alice_tpc.CShows geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usag,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:99528,detect,detector,99528,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['detect'],['detector']
Safety,"ingz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) ; [in]nbinsznumber of bins along the Z axis ; [in]zlowlow edge of the Z axis first bin ; [in]zupupper edge of the Z axis last bin (not included in last bin) . Definition at line 101 of file TH3.cxx. ◆ TH3() [3/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Float_t * ; xbins, . Int_t ; nbinsy, . const Float_t * ; ybins, . Int_t ; nbinsz, . const Float_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type float. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type float and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type float and size nbinsz+1 . Definition at line 142 of file TH3.cxx. ◆ TH3() [4/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins, . Int_t ; nbinsz, . const Double_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:60561,avoid,avoid,60561,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety,"inition TSystem.cxx:653; f1TF1 * f1Definition legend1.C:11. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with ""("", the file remains opened (it is not closed). If the Postscript file name finishes with "")"" and the file has been opened with ""("", the file is closed.; Example: {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; h1TH1F * h1Definition legend1.C:5; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop one needs to detect the special cases of first and last page and then munge the argument to Print() accordingly. The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below.; Example: c1.Print(""file.ps[""); // No actual print, just open file.ps; ; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.ps""); // Actually print canvas to the file; }; ; c1.Print(""file.ps]""); // No actual print, just close the file. Color Model; TPostScript support two color model RGB and CMYK. CMY and CMYK models are subtractive color models unlike RGB which is an additive. They are mainly used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more component K (black). The conversion from RGB to CMYK is:; Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);; double; TMath::MinSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:8903,detect,detect,8903,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['detect'],['detect']
Safety,"inition at line 3975 of file TGeoManager.cxx. ◆ FindDuplicateMaterial(). TGeoMaterial * TGeoManager::FindDuplicateMaterial ; (; const TGeoMaterial * ; mat); const. Find if a given material duplicates an existing one. ; Definition at line 2992 of file TGeoManager.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoManager::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 2755 of file TGeoManager.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoManager::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 2736 of file TGeoManager.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoManager::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool_t ; compmatrix = kFALSE . ). Computes as fStep the distance to next daughter of the current volume. ; The point and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:85799,safe,safety,85799,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"ink ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a symlink from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 2826 of file TWinNTSystem.cxx. ◆ TempDirectory(). const char * TWinNTSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 2257 of file TWinNTSystem.cxx. ◆ TempFileName(). FILE * TWinNTSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 2281 of file TWinNTSystem.cxx. ◆ ThreadStub(). static void TWinNTSystem::ThreadStub ; (; void * ; Parameter). inlinestaticprivate . Definition at line 88 of file TWinNTSystem.h. ◆ TimerThread(). void TWinNTSystem::TimerThread ; (; ). private . Special Thread to check asynchronous timers. ; Definition at line 4442 of file TWinNTSystem.cxx. ◆ Umask(). int TWinNTSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 3081 of file TWinNTSystem.cxx. ◆ UnixPathName(). const char * TWinNTSystem::UnixPathName ; (; const char * ; name). overridevirtual . Convert a pathname to a unix pathname. ; E.g. from \user\root to /user/root. General rules for applications creating names for directories and files or processing names supplied by the user include the following:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:73472,safe,safely,73472,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<std::string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<std::string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:42033,avoid,avoid,42033,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,4,['avoid'],['avoid']
Safety,"input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:46789,avoid,avoid,46789,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['avoid'],['avoid']
Safety,"input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:150918,timeout,timeout,150918,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:5815,avoid,avoid,5815,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ins_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DeclFileName(). static const char * TGeoCtub::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGeoTube.h. ◆ DistFromInside(). Double_t TGeoCtub::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoCtub::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoCtub::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoCtub::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoCtub::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoCtub::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoCtub::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoCtub::GetByteCount ; (; ); const. inlineover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:31113,safe,safe,31113,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety,"inst the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103346,safe,safety,103346,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"int length); virtual intTSystem::RecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheSystem.html:11432,timeout,timeout,11432,root/html530/TDCacheSystem.html,https://root.cern,https://root.cern/root/html530/TDCacheSystem.html,10,['timeout'],['timeout']
Safety,"int[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:19736,safe,safety,19736,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,inted; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with indirect file; [#14902] - compilation error; [#14863] - [hist] TH1::SaveAs missing default option argument causes compilation errors; [#14855] - TRatioPlot crashes if loaded from the file; [#14842] - TRatioplot gives “different” results with Web Graphics; [#14838] - Problems with Confidence Band of TRatioPlot; [#14801] - TEfficiency drawing to .C is broken; [#14793] - 6.26 cannot read file written with 6.30.4; [#14772] - [cling] Undocumented behaviour of root macro_C.so; [#14767] - rootn.exe instant crash on startup; [#14765] - TGenPhaseSpace weight normalization; [#14748] - [ntuple] Show and PrintInfo does not work for friend RNTuples; [#14601] - std::source_location not found when running with c++20 enabled; [#14599] ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26399,detect,detect,26399,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['detect'],['detect']
Safety,"interName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. TGeoShape(); constructors. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:22752,safe,safe,22752,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,2,['safe'],['safe']
Safety,"interactions. It is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame). A menu bar contains one or more popup menus and usually is placed along the top of the application window. Any popup menu is invisible until the user invokes it by using the mouse pointer or the keyboard.; Popup menus implemented by TGPopupMenu class are unique in that, by convention, they are not placed with the other GUI components in the user interfaces. Instead, a popup menu usually appears either in a menu bar or as a context menu on the TOP of the GUI. For that reason it needs gClient->GetDefaultRoot() as a parent to get the pointer to the root (i.e. desktop) window. This way a popup menu will never be embedded. NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not avoid the possibility of embedding the corresponding popup menu because the current window hierarchy can be changed by using gClient->SetRoot() method.; As a context menus TGPopupMenu shows up after pressing the right mouse button, over a popup-enabled component. The popup menu then appears under the mouse pointer.; Selecting a menu item will generate the event: kC_COMMAND, kCM_MENU, menu id, user data. ; Definition at line 282 of file TGMenu.h. Public Member Functions;  TGMenuBar (const TGWindow *p=nullptr, UInt_t w=60, UInt_t h=20, UInt_t options=kHorizontalFrame|kRaisedFrame);  Create a menu bar object. ;  ;  ~TGMenuBar () override;  Delete menu bar object. ;  ; virtual void AddPopup (const char *s, TGPopupMenu *menu, TGLayoutHints *l, TGPopupMenu *before=nullptr);  Add popup menu to menu bar. ;  ; virtual TGPopupMenu * AddPopup (const TString &s, Int_t padleft=4, Int_t padright=0, Int_t padtop=0, Int_t padbottom=0);  Add popup menu to menu bar. ;  ; virtual void AddPopup (TGHotString *s, TGPopupMenu *menu, TGLayoutHints *l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMenuBar.html:1669,avoid,avoid,1669,doc/master/classTGMenuBar.html,https://root.cern,https://root.cern/doc/master/classTGMenuBar.html,1,['avoid'],['avoid']
Safety,"interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));. Deprecation of legacy iterators; The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34. They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. RooAbsArg::clientIterator(): use clients() and begin(), end() or range-based loops instead; RooAbsArg::valueClientIterator(): use valueClients(); RooAbsArg::shapeClientIterator(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11661,safe,safe,11661,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:39073,avoid,avoids,39073,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['avoid'],['avoids']
Safety,"ints by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up functions use:; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; Note: CleanUpPush and CleanUpPop should be used as corresponding pairs like brackets; unlike pthreads cleanup stack (which is not implemented here), TThread does not force this usage.; 23.2.4.7 Finishing thread; When a thread returns from a user function the thread is finished. It also can be finished by TThread::Exit(). Then, in case of thread-detached mode, the thread vanishes completely. By default, on finishing TThread executes the most recent cleanup function (CleanUpPop(1) is called automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1112811,safe,safe,1112811,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11642,avoid,avoid,11642,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11708,avoid,avoid,11708,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11710,avoid,avoid,11710,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11710,avoid,avoid,11710,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"ion = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCtub.html:2775,safe,safe,2775,root/html530/TGeoCtub.html,https://root.cern,https://root.cern/root/html530/TGeoCtub.html,1,['safe'],['safe']
Safety,"ion TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:42593,timeout,timeout,42593,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,2,['timeout'],['timeout']
Safety,"ion about TGListTree and TGListTreeItem that represents given TEveElement ;  CTEveElementEditorEditor for TEveElement class ;  CTEveElementListA list of TEveElements ;  CTEveElementListProjectedA projected element list – required for proper propagation of render state to projected views ;  CTEveEventManagerBase class for event management and navigation ;  CTEveExceptionException class thrown by TEve classes and macros ;  CTEveFrameBoxDescription of a 2D or 3D frame that can be used to visually group a set of objects ;  CTEveFrameBoxGLA class encapsulating GL rendering of TEveFrameBox via a static member function ;  CTEveGDoubleValuatorComposite GUI element for selection of range (label, two number-entries and double-slider) ;  CTEveGedEditorSpecialization of TGedEditor for proper update propagation to TEveManager ;  CTEveGedNameFrameSpecialization of TGedNameFrame used in EVE ;  CTEveGedNameTextButtonSpecialization of TGTextButton for EVE name frame ;  CTEveGeoManagerHolderException safe wrapper for setting gGeoManager ;  CTEveGeoNodeWrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement ;  CTEveGeoNodeEditorEditor for TEveGeoNode class ;  ►CTEveGeoPolyShapeDescription of TEveGeoPolyShape ;  CEdge_t;  CTEveGeoShapeWrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections) ;  CTEveGeoShapeExtractGlobally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts ;  CTEveGeoShapeProjectedA 3D projected TEveGeoShape ;  CTEveGeoTopNodeA wrapper over a TGeoNode, possibly displaced with a global trasformation stored in TEveElement ;  CTEveGeoTopNodeEditorEditor for TEveGeoTopNode class ;  CTEveGListTreeEditorFrameComposite GUI frame for parallel display of a TGListTree and TEveGedEditor ;  CTEveGridStepperProvide discrete position coordinates for placement of obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:147827,safe,safe,147827,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['safe'],['safe']
Safety,"ion from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:174368,safe,safe,174368,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"ion from the currently loaded class library.; 4658/// - -1: Assume no class library loaded (emulated class).; 4659///; 4660/// Warning: If we create a new streamer info, whether or not the build; 4661/// optimizes is controlled externally to us by a global variable!; 4662/// Don't call us unless you have set that variable properly; 4663/// with TStreamer::Optimize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177119,safe,safe,177119,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"ion histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<PDF*>*fPDFBgdlist of PDFs (background); vector<PDF*>*fPDFSiglist of PDFs (signal) ; Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLikelihood.html:18851,avoid,avoid,18851,root/html530/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLikelihood.html,3,['avoid'],['avoid']
Safety,"ion in POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Implements TGeoBoolNode.; Definition at line 965 of file TGeoBoolNode.cxx. ◆ Contains(). Bool_t TGeoSubtraction::Contains ; (; const Double_t * ; point); const. overridevirtual . Find if a subtraction of two shapes contains a given point. ; Implements TGeoBoolNode.; Definition at line 1016 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoSubtraction::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 203 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoSubtraction::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1031 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoSubtraction::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1039 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoSubtraction::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1072 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoSubtraction::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 193 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoSubtractio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:16719,safe,safe,16719,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safe']
Safety,"ion is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; averWindow-averaging window of searched peaks, for details we refer to manual (applies only for Markov method). Peaks searching; Goal: to identify automatically the peaks in spectrum with the presence of the continuous background, one-fold coincidences (ridges) and statistical fluctuations - noise.; The common problems connected with correct peak identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; non-sensitivity of the algorithm to continuous background; non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; ability to identify peaks with different sigma. References:; [1] M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451. Examples of peak searching method; SearchHighRes function provides users with the possibility to vary the input parameters and with the access to the output deconvolved data in the destination spectrum. Based on the output data one can tune the parameters. Example 8 - Src.C; ; #include <TSpectrum2.h>; ; void Src(); {; const Int_t nbinsx = 64;; const Int_t nbinsy = 64;; std::vector<Double_t *> source(nbinsx)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2.html:36217,detect,detect,36217,doc/master/classTSpectrum2.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2.html,1,['detect'],['detect']
Safety,"ion specifier. Case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). See TBufferFile::WriteFloat16 for more information.; see example of use of the Double32_t data type in tutorial double32.C . Implements TBuffer.; Definition at line 678 of file TBufferFile.cxx. ◆ WriteFastArray() [1/15]. void TBufferFile::WriteFastArray ; (; const Bool_t * ; b, . Long64_t ; n . ). overridevirtual . Write array of n bools into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 1982 of file TBufferFile.cxx. ◆ WriteFastArray() [2/15]. void TBufferFile::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2010 of file TBufferFile.cxx. ◆ WriteFastArray() [3/15]. void TBufferFile::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). overridevirtual . Write array of n doubles into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2236 of file TBufferFile.cxx. ◆ WriteFastArray() [4/15]. void TBufferFile::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). overridevirtual . Write array of n floats into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:81423,abort,aborts,81423,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"ion with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1028028,safe,safety,1028028,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"ion), inputColumns, variationTags, variationName);; 954 }; 955 ; 956 /// \brief Register systematic variations for multiple existing columns using custom variation tags.; 957 /// \param[in] colNames set of names of the columns for which varied values are provided.; 958 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 959 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 960 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 961 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 962 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 963 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 964 /// colName is used if none is provided.; 965 ///; 966 /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; 967 /// is avoided.; 968 ///; 969 /// \sa This Vary() overload for more information.; 970 template <typename F>; 971 RInterface<Proxied, DS_t>; 972 Vary(std::initializer_list<std::string> colNames, F &&expression, const ColumnNames_t &inputColumns,; 973 const std::vector<std::string> &variationTags, std::string_view variationName); 974 {; 975 return Vary(std::vector<std::string>(colNames), std::forward<F>(expression), inputColumns, variationTags, variationName);; 976 }; 977 ; 978 /// \brief Register systematic variations for multiple existing columns using auto-generated tags.; 979 /// \param[in] colNames set of names of the columns for which varied values are provided.; 980 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 981 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 982 /// return an RVec of varied valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:52608,avoid,avoided,52608,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['avoid'],['avoided']
Safety,"ion, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:2023,predict,predictions,2023,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['predict'],['predictions']
Safety,"ion. Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,.... Note that the passed dataSize is not the size of the array but is the number of points (N); The size of the array must be at least dataDim*dataSize. ~TKDTreeBinning(); Class's destructor. void SetNBins(UInt_t bins); Sets binning inner structure. void SortBinsByDensity(Bool_t sortAsc = kTRUE); Sorts bins by their density. void SetData(Double_t* data); Sets the data and finds minimum and maximum by dimensional coordinate. void SetTreeData(); Sets the data for constructing the kD-tree. void SetBinsContent(); Sets the bins' content. void SetBinsEdges(); Sets the bins' edges; Double_t* rawBinEdges = fDataBins->GetBoundaryExact(fDataBins->GetNNodes());. void SetBinMinMaxEdges(Double_t* binEdges); Sets the bins' minimum and maximum edges. void SetCommonBinEdges(Double_t* binEdges); Sets indexing on the bin edges which have common boundaries. void ReadjustMinBinEdges(Double_t* binEdges); Readjusts the bins' minimum edge by shifting it slightly lower; to avoid overlapping with the data. void ReadjustMaxBinEdges(Double_t* binEdges); Readjusts the bins' maximum edge; and shift it sligtly higher. const Double_t* GetBinsMinEdges() const; Returns the bins' minimum edges. const Double_t* GetBinsMaxEdges() const; Returns the bins' maximum edges. std::pair<const Double_t*, const Double_t*> GetBinsEdges() const; Returns the bins' edges. const Double_t* GetBinMinEdges(UInt_t bin) const; Returns the bin's minimum edges. 'bin' is between 0 and fNBins - 1. const Double_t* GetBinMaxEdges(UInt_t bin) const; Returns the bin's maximum edges. 'bin' is between 0 and fNBins - 1. std::pair<const Double_t*, const Double_t*> GetBinEdges(UInt_t bin) const; Returns the bin's edges. 'bin' is between 0 and fNBins - 1. UInt_t GetNBins() const; Returns the number of bins. UInt_t GetDim() const; Returns the number of dimensions. UInt_t GetBinContent(UInt_t bin) const; Returns the number of points in bin. 'bin' is between 0 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TKDTreeBinning.html:9990,avoid,avoid,9990,root/html530/TKDTreeBinning.html,https://root.cern,https://root.cern/root/html530/TKDTreeBinning.html,5,['avoid'],['avoid']
Safety,"ionOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; - The first argument is the base of the name of all the output; weight files in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TMVA session.; For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; option string; ; - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; input variables; ***/; ; TMVA::Factory factory(; ""TMVA_CNN_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification:Transformations=None:!Correlations"");; ; /***; ; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; **/; ; TMVA::DataLoader loader(""dataset"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:50035,avoid,avoid,50035,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['avoid'],['avoid']
Safety,"ion_t TGeoGtra::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 177 of file TGeoArb8.h. ◆ DeclFileName(). static const char * TGeoGtra::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 177 of file TGeoArb8.h. ◆ DistFromInside(). Double_t TGeoGtra::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromInside_v(). void TGeoGtra::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside(). Double_t TGeoGtra::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoGtra::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoGtra::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetTwistAngle(). Double_t TGeoGtra::GetTwistAngle ; (; ); const. inline . Definition at line 171 of file TGeoArb8.h. ◆ IsA(). TClass * TGeoGtra::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 177 of file TGeoArb8.h. ◆ Safety(). Double_t TGeoGtra::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Safety_v(). void TGeoGtra::Safety_v ; (; const Double_t * ; p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:29149,safe,safe,29149,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety,"ion_t TGeoTrap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TGeoArb8.h. ◆ DeclFileName(). static const char * TGeoTrap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TGeoArb8.h. ◆ DistFromInside(). Double_t TGeoTrap::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromInside_v(). void TGeoTrap::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside(). Double_t TGeoTrap::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoTrap::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Divide(). TGeoVolume * TGeoTrap::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoArb8. ◆ GetAlpha1(). Double_t TGeoTrap::GetAlpha1 ; (; ); const. inline . Definition at line 135 of file TGeoArb8.h. ◆ GetAlpha2(). Double_t TGeoTrap::GetAlpha2 ; (; ); const. inline . Definition at line 139 of file TGeoArb8.h. ◆ GetBl1(). Double_t TGeoTrap::GetBl1 ; (; ); const. inline . Definition at line 133 of file TGeoArb8.h. ◆ GetBl2(). Double_t TGeoTrap::GetBl2 ; (; ); const. inline . Definition at line 137 of file TGeoArb8.h. ◆ GetH1(). Double_t TGeoTrap::GetH1 ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:27166,safe,safe,27166,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['safe'],['safe']
Safety,"ion_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCtubDefinition TGeoTube.h:173; TGeoCtub::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:208; TGeoCtub::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoCtub::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoCtub::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoCtub::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoCtub::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoCtub::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoCtub::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoCtub::GetNlowconst Double_t * GetNlow() constDefinition TGeoTube.h:213; TGeoCtub::TGeoCtubTGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoCtub::TGeoCtubTGeoCtub(); TGeoCtub::SetPointsvoid SetPoints(Float_t *points) const override; TGeoCtub::CapacityDouble_t Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:13830,safe,safe,13830,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:125653,detect,detector,125653,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['detect'],['detector']
Safety,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:16178,safe,safety,16178,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,2,['safe'],['safety']
Safety,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoChecker.html:16297,safe,safety,16297,root/html534/TGeoChecker.html,https://root.cern,https://root.cern/root/html534/TGeoChecker.html,3,['safe'],['safety']
Safety,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:5164,risk,risk,5164,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['risk'],['risk']
Safety,"ions the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:4943,risk,risk,4943,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['risk'],['risk']
Safety,"ions the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:4943,risk,risk,4943,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['risk'],['risk']
Safety,"ions:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IBaseParam.html:1764,avoid,avoid,1764,root/html602/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"ions:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IBaseParam.html:1764,avoid,avoid,1764,root/html604/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,ions;  IntegratorMultiDimOptions (const IntegratorMultiDimOptions &rhs);  copy constructor ;  ;  IntegratorMultiDimOptions (IOptions *extraOpts=nullptr);  constructor using the default options can pass a pointer to extra options (N.B. ;  ;  ~IntegratorMultiDimOptions () override;  ; std::string Integrator () const override;  name of multi-dim integrator ;  ; IntegrationMultiDim::Type IntegratorType () const;  type of the integrator (return the enumeration type) ;  ; unsigned int NCalls () const;  maximum number of function calls ;  ; IntegratorMultiDimOptions & operator= (const IntegratorMultiDimOptions &rhs);  assignment operator ;  ; void Print (std::ostream &os=std::cout) const;  print all the options ;  ; void SetIntegrator (const char *name);  set multi-dim integrator name ;  ; void SetNCalls (unsigned int calls);  set maximum number of function calls ;  ;  Public Member Functions inherited from ROOT::Math::BaseIntegratorOptions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Static Public Member Functions; static ROOT::Math::IOptions & Default (const char *name);  retrieve specific options ;  ; static double DefaultAbsTolerance ();  ; static std::string DefaultIntegrator ();  ; static IntegrationMultiDim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html:1581,avoid,avoid,1581,doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,1,['avoid'],['avoid']
Safety,"ir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:23122,safe,safe,23122,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,6,['safe'],['safe']
Safety,"irectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:10288,avoid,avoid,10288,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,4,['avoid'],['avoid']
Safety,"irtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerMulti.html:5761,abort,abort,5761,root/html528/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"irtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSphere.html:8695,safe,safe,8695,root/html602/TGeoSphere.html,https://root.cern,https://root.cern/root/html602/TGeoSphere.html,2,['safe'],['safe']
Safety,"irtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:17622,timeout,timeout,17622,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['timeout'],['timeout']
Safety,"irtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:7684,safe,safe,7684,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,1,['safe'],['safe']
Safety,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:94028,avoid,avoid,94028,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"is not given, the name of the key will be the name as returned; 1889/// by obj->GetName().; 1890///; 1891/// The option can be a combination of:; 1892/// - ""SingleKey""; 1893/// - ""Overwrite""; 1894/// - ""WriteDelete""; 1895/// Using the ""Overwrite"" option a previous key with the same name is; 1896/// overwritten. The previous key is deleted before writing the new object.; 1897/// Using the ""WriteDelete"" option a previous key with the same name is; 1898/// deleted only after the new object has been written. This option; 1899/// is safer than kOverwrite but it is slower.; 1900/// The ""SingleKey"" option is only used by TCollection::Write() to write; 1901/// a container with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1919 return 0;; 1920 }; 1921 ; 1922 if (!fFile->IsWritable()) {; 1923 if (!fFile->TestBit(TFile::kWriteError)) {; 1924 // Do not print the error if the file already had a SysError.; 1925 Error(""WriteTObject"",""Directory %s is not writable"", fFile->GetName());; 1926 }; 1927 return 0;; 1928 }; 1929 ; 1930 if (!obj) return 0;; 1931 ; 1932 TString opt = option;; 1933 opt.ToLower();; 1934 ; 1935 TKey *key=0, *oldke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:65558,avoid,avoid,65558,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"is painted; 49 - then the sum of the first and second histograms is painted, and so on; 50 ; 51The axis ranges are computed automatically along the X and Y axes to display the complete; 52histogram collection.; 53 ; 54Warning: Histogram bins with negative content may produce wrong plots.; 55 ; 56### Stack's drawing options; 57 ; 58The specific stack's drawing options are:; 59 ; 60 - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; 61 as if the option ""same"" had been specified.; 62 ; 63 - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THStack_8cxx_source.html:2660,avoid,avoids,2660,doc/master/THStack_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html,1,['avoid'],['avoids']
Safety,"is robj is read by TObject::Streamer, the pidf is read. At this point, robj is entered into the table of objects of the TProcessID corresponding to pidf. WARNING1:; If MyClass is the class of the referenced object, The TObject part of MyClass must be Streamed. One should not call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2:; A TRef cannot point to another TRef. ObjectNumber; When an object is referenced (see TRef assignment operator or TRefArray::Add) a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. fUniqueID is some sort of serial object number in the current session. One can retrieve at any time the current value of fgNumber by calling the static function TProcessID::GetObjectCount or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the ObjectNumber at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be saved at the beginning of one event and reset to this original value at the end of the event via TProcessID::SetObjectCount(saveNumber). These actions may be stacked. Action on Demand; The normal behaviour of a TRef has been described above. In addition, TRef supports also ""Actions on Demand"". It may happen that the object referenced is not yet in memory, on a separate file or not yet computed. In this case TRef is able to automatically execute an action:. call to a compiled function (static function of member function); call to an interpreted function; execution of a C++ script. How to select this option? In the definition of the TRef data member in the original class, do: TRef fRef; //EXEC:execName. points to something; When the special key",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:4469,avoid,avoid,4469,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['avoid'],['avoid']
Safety,"is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9857,safe,safety,9857,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safety']
Safety,"is.GetXmin())/fCellX;; 528 fStepY = (fYaxis.GetXmax() - fYaxis.GetXmin())/fCellY;; 529 ; 530 delete [] fIsEmpty;; 531 delete [] fCompletelyInside;; 532 fIsEmpty = new Bool_t [fNCells];; 533 fCompletelyInside = new Bool_t [fNCells];; 534 ; 535 // Initializes the flags; 536 for (int i = 0; i<fNCells; i++) {; 537 fIsEmpty[i] = kTRUE;; 538 fCompletelyInside[i] = kFALSE;; 539 }; 540 ; 541 // TList iterator; 542 TIter next(fBins);; 543 TObject *obj;; 544 ; 545 while((obj = next())){ // Loop over bins and add them to the partition; 546 AddBinToPartition((TH2PolyBin*) obj);; 547 }; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Make a complete copy of the underlying object. If 'newname' is set,; 552/// the copy's name will be set to that name.; 553 ; 554TObject* TH2Poly::Clone(const char* newname) const; 555{; 556 // TH1::Clone relies on ::Copy to implemented by the derived class.; 557 // Until this is implemented, revert to the much slower default version; 558 // (and possibly non-thread safe).; 559 ; 560 return TNamed::Clone(newname);; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Clears the contents of all bins in the histogram.; 565 ; 566void TH2Poly::ClearBinContents(); 567{; 568 TIter next(fBins);; 569 TObject *obj;; 570 TH2PolyBin *bin;; 571 ; 572 // Clears the bin contents; 573 while ((obj = next())) {; 574 bin = (TH2PolyBin*) obj;; 575 bin->ClearContent();; 576 }; 577 ; 578 // Clears the statistics; 579 fTsumw = 0;; 580 fTsumw2 = 0;; 581 fTsumwx = 0;; 582 fTsumwx2 = 0;; 583 fTsumwy = 0;; 584 fTsumwy2 = 0;; 585 fEntries = 0;; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Reset this histogram: contents, errors, etc.; 590 ; 591void TH2Poly::Reset(Option_t *opt); 592{; 593 TIter next(fBins);; 594 TObject *obj;; 595 TH2PolyBin *bin;; 596 ; 597 // Clears the bin contents; 598 while ((obj = next())) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:21210,safe,safe,21210,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['safe'],['safe']
Safety,"isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 // sanity check.; 2210 newType = -1;; 2211 }; 2212 }; 2213 }; 2214 }; 2215 }; 2216 ; 2217 if (newType > 0) {; 2218 // Case of a numerical type; 2219 if (element->GetType() >= TStreamerInfo::kObject) {; 2220 // Old type was not a numerical type.; 2221 element->SetNewType(TVirtualStreamerInfo::kUnsupportedConversion);; 2222 } else if (element->GetType() != newType) {; 2223 element->SetNewType(newType);; 2224 if (gDebug > 0) {; 2225 // coverity[mixed_enums] - All the values of EDataType have the same semantic in EReadWrite; 2226 Info(""BuildOld"", ""element: %s %s::%s has new type: %s/%d"", element->GetTypeName(), GetName(), element->GetName(), dm ? dm->GetFullTypeName() : TDataType::GetTypeName((EDataType)newType), newType);; 2227 }; 2228 }; 2229 } else if (newClass.GetClass()) {; 2230 // Sometime BuildOld is called again.; 2231 // In that case we might already have fix up the streamer element.; 2232 // So we need to go back to the original information!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:86116,sanity check,sanity check,86116,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"ison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:91662,avoid,avoid,91662,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"issing;; 2465 element->SetOffset(kMissing);; 2466 }; 2467 ; 2468 if (offset != kMissing && fClass->GetState() <= TClass::kEmulated && !fClass->fIsSyntheticPair) {; 2469 // Note the initialization in this case are; 2470 // delayed until __after__ the schema evolution; 2471 // section, just in case the info has changed.; 2472 ; 2473 // The class is NOT known to Cling, i.e. is emulated,; 2474 // and we need to use the calculated offset.; 2475 ; 2476 Int_t asize;; 2477 if (element->GetType() == TStreamerInfo::kSTL &&; 2478 strcmp(element->GetName(),""This"") == 0 &&; 2479 strcmp(element->GetTypeName(),GetName()) == 0 &&; 2480 !fClass->GetCollectionProxy()) {; 2481 // Humm .. we are missing the collection Proxy; 2482 // for a proxied (custom) collection ... avoid; 2483 // an infinite recursion and take a wild guess; 2484 asize = sizeof(std::vector<int>);; 2485 } else {; 2486 // Regular case; 2487 asize = element->GetSize();; 2488 }; 2489 // align the non-basic data types (required on alpha and IRIX!!); 2490 if ((offset % kSizeOfPtr) != 0) {; 2491 offset = offset - (offset % kSizeOfPtr) + kSizeOfPtr;; 2492 }; 2493 element->SetOffset(offset);; 2494 offset += asize;; 2495 }; 2496 ; 2497 if (!wasCompiled && rules) {; 2498 if (rules.HasRuleWithSource( element->GetName(), kTRUE ) ) {; 2499 ; 2500 if (allocClass == 0) {; 2501 infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()));; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.Has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:99050,avoid,avoid,99050,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ; file  statsEditing.C;   Edit statistics box. ;  ; file  testSmooth.C;   Histogram smoothing. ;  ; file  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ; file  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ; file  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ; file  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ; file  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ; file  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ; file  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  tprofile2polyRealistic.C;   Different charges depending on region ;  ; file  tprofile2polyRealisticModuleError.C;   Simulate faulty detector panel w.r.t. ;  ; file  transpad.C;   Example of a canvas showing two histograms with different scales. ;  ; file  twoscales.C;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  twoscales.py;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  xyplot.C;   Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ;  ; file  ZoomHistogram.C;   Changing the Range on the X-Axis of a Histogram ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__hist.html:6611,detect,detector,6611,doc/master/group__tutorial__hist.html,https://root.cern,https://root.cern/doc/master/group__tutorial__hist.html,1,['detect'],['detector']
Safety,"istFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0;  ; virtual void DistFromInside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const;  ; virtual Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0;  ; virtual void DistFromOutside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const;  ; virtual TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; virtual const char * GetAxisName (Int_t iaxis) const =0;  ; virtual Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0;  ; virtual void GetBoundingCylinder (Double_t *param) const =0;  ; virtual const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const;  Stub implementation to avoid forcing implementation at this stage. ;  ; virtual Int_t GetByteCount () const =0;  ; virtual Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const =0;  ; Int_t GetId () const;  ; virtual TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const =0;  ; virtual void GetMeshNumbers (Int_t &, Int_t &, Int_t &) const;  ; const char * GetName () const override;  Get the shape name. ;  ; virtual Int_t GetNmeshVertices () const;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; virtual Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const =0;  ; virtual void InspectShape () const =0;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:11247,avoid,avoid,11247,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['avoid'],['avoid']
Safety,"istance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:15969,safe,safe,15969,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,"istancetoPrimitive(Int_t px, Int_t py); virtual voidSetConnection(TShape* connection); Int_tTShape::ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TShape*fConnectionshape to represent the each ""end"" of the polyline; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tfHasDrawnflag to avoid multiply plots; Color_tTAttLine::fLineColorline color; Bool_tfLineFlagFlag whether we should connect the points with ""line"" (option ""L""); Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; Bool_tfPointFlagFlag whether we should paint ""points"" (option ""P""); TPoints3DABC*fPointsPolyLine itself; TShape*fShapeshape for draw each segment of the polylins; EShapeTypesfShapeTypeshape of the segment connections; _x3d_sizeof_*fSizeX3D! the X3D buffer sizes; Bool_tfSmoothMake smooth connections; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_tfWidthFactorfactor to calculate the the tube diameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPolyLineShape(); to be documented. TPolyLineShape(TPoints3DABC* points, Option_t* option = ""P""); fShape = new TTUBE(""tube"",""tube"",""void"",0.5,0.5);. ~TPolyLineShape(); to be documented. void Create(); to be documented. Size3D * CreateX3DSize(Bool_t marker = kFALSE); to be documented. Int_t SetConnection(EShapeTypes connection = kBrik); to be documented. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPolyLineShape.html:9836,avoid,avoid,9836,root/html528/TPolyLineShape.html,https://root.cern,https://root.cern/root/html528/TPolyLineShape.html,4,['avoid'],['avoid']
Safety,"istograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<TMVA::PDF*>*fPDFBgdlist of PDFs (background); vector<TMVA::PDF*>*fPDFSiglist of PDFs (signal); Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodLikelihood.html:20114,avoid,avoid,20114,root/html602/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodLikelihood.html,2,['avoid'],['avoid']
Safety,"ists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 211 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 212 Int_t GetNmeshVertices() const override;; 213 const Double_t *GetNlow() const { return &fNlow[0]; }; 214 const Double_t *GetNhigh() const { return &fNhigh[0]; }; 215 Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const;; 216 void InspectShape() const override;; 217 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 218 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 219 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 220 void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx,; 221 Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 222 void SetDimensions(Double_t *param) override;; 223 void SetPoints(Double_t *points) const override;; 224 void SetPoints(Float_t *points) const override;; 225 ; 226 ClassDefOverride(TGeoCtub, 1) // cut tube segment class; 227};; 228 ; 229#endif; b#define b(i)Definition RSha256.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:12245,safe,safe,12245,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:28807,safe,safely,28807,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,12,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"it(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10483,abort,abort,10483,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,1,['abort'],['abort']
Safety,"it(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:10584,abort,abort,10584,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,1,['abort'],['abort']
Safety,"it(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:11713,abort,abort,11713,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,"ite ; (; Option_t * ; option = """"); const. virtual . Paint this composite shape into the current 3D viewer Returns bool flag indicating if the caller should continue to paint child objects. ; Definition at line 429 of file TGeoCompositeShape.cxx. ◆ RegisterYourself(). void TGeoCompositeShape::RegisterYourself ; (; ). Register the shape and all components to TGeoManager class. ; Definition at line 475 of file TGeoCompositeShape.cxx. ◆ Safety(). Double_t TGeoCompositeShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 521 of file TGeoCompositeShape.cxx. ◆ Safety_v(). void TGeoCompositeShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 629 of file TGeoCompositeShape.cxx. ◆ SavePrimitive(). void TGeoCompositeShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 531 of file TGeoCompositeShape.cxx. ◆ SetDimensions(). void TGeoCompositeShape::SetDimensions ; (; Double_t * ; ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoCompositeShape.h. ◆ SetPoints() [1/2]. void TGeoCompositeShape::SetPoints ; (; Double_t * ; points); const. overridevirtual . create points for a composite shape ; Reimplemented from TGeoBBox.; Definition at line 548 of file TGeoCompositeShape.cxx. ◆ SetPoints() [2/2]. void TGeoCompositeShape::SetPoints ; (; Flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:43177,safe,safe,43177,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"iteBasket) {; 1202 // Nothing to do.; 1203 } else {; 1204 basket->DropBuffers();; 1205 if (basket == fCurrentBasket) {; 1206 fCurrentBasket = nullptr;; 1207 fFirstBasketEntry = -1;; 1208 fNextBasketEntry = -1;; 1209 }; 1210 delete basket;; 1211 --fNBaskets;; 1212 fBaskets[ibasket] = nullptr;; 1213 }; 1214 }; 1215 }; 1216 }; 1217 return nbytes;; 1218}; 1219 ; 1220////////////////////////////////////////////////////////////////////////////////; 1221/// Return pointer to basket basketnumber in this Branch; 1222///; 1223/// If a new buffer must be created and the user_buffer argument is non-null,; 1224/// then the memory in the user_buffer will be shared with the returned TBasket.; 1225 ; 1226TBasket* TBranch::GetBasketImpl(Int_t basketnumber, TBuffer *user_buffer); 1227{; 1228 // This counter in the sequential case collects errors coming also from; 1229 // different files (suppose to have a program reading f1.root, f2.root ...); 1230 // In the mt case, it is made atomic: it safely collects errors from; 1231 // different files processed simultaneously.; 1232 static std::atomic<Int_t> nerrors(0);; 1233 ; 1234 // reference to an existing basket in memory ?; 1235 if (basketnumber <0 || basketnumber > fWriteBasket) return nullptr;; 1236 TBasket *basket = (TBasket*)fBaskets.UncheckedAt(basketnumber);; 1237 if (basket) return basket;; 1238 if (basketnumber == fWriteBasket) return nullptr;; 1239 ; 1240 // create/decode basket parameters from buffer; 1241 TFile *file = GetFile(0);; 1242 if (file == nullptr) {; 1243 return nullptr;; 1244 }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:42958,safe,safely,42958,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['safe'],['safely']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:16574,avoid,avoid,16574,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,2,['avoid'],['avoid']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(const TF1* f1) const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effective variance"" m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph.html:15578,avoid,avoid,15578,root/html532/TGraph.html,https://root.cern,https://root.cern/root/html532/TGraph.html,1,['avoid'],['avoid']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(const TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:16081,avoid,avoid,16081,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,1,['avoid'],['avoid']
Safety,"ithin; Project2(). - TreatEmptyCells - if this option is set false (default),; it is not checked, wether the cell or its neighbors are empty; or not. If this option is set true, than only non-empty; neighbor cells are taken into account for weighting. If the; cell, which contains txvec is empty, than its value is; replaced by the average value of the non-empty neighbor cells. Float_t WeightGaus(TMVA::PDEFoamCell* , vector<Float_t>& , UInt_t dim = 0); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). - dim - number of dimensions for the calculation of the euclidean distance.; If dim=0, all dimensions of the foam are taken. Else only the first 'dim'; coordinates of 'txvec' are used for the calculation of the euclidean distance. Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. TMVA::PDEFoamCell* FindCell(vector<Float_t>& ); Find cell that contains 'xvec' (in foam coordinates [0,1]). Loop to find cell that contains 'xvec' starting at root cell,; and traversing binary tree to find the cell quickly. Note, that; if 'xvec' lies outside the foam, the cell which is nearest to; 'xvec' is returned. (The returned pointer should never be; NULL.). void FindCellsRecursive(vector<Float_t>& , TMVA::PDEFoamCell* , vector<TMVA::PDEFoamCell*,allocator<TMVA::PDEFoamCell*> >& ); This is a helper function for FindCells(). It saves in 'cells'; all cells, which contain txvec. It works analogous to; FindCell(). Parameters:. - txvec - vector of variables (no targets!) (transformed into; foam). - cell - cell to start searching with (usually root cell; fCells[0]). - cells - list of cells found. std::vector<TMVA::PDEFoamCell*> FindCells(vector<Float_t>& ); Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:23178,avoid,avoid,23178,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['avoid'],['avoid']
Safety,"ithout affecting the cache stack. ; Definition at line 2657 of file TGeoNavigator.cxx. ◆ FindInCluster(). TGeoNode * TGeoNavigator::FindInCluster ; (; Int_t * ; cluster, . Int_t ; nc . ). protected . Find a node inside a cluster of overlapping nodes. ; Current node must be on top of all the nodes in cluster. Always nc>1. ; Definition at line 2159 of file TGeoNavigator.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoNavigator::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 624 of file TGeoNavigator.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoNavigator::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 1178 of file TGeoNavigator.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoNavigator::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:27427,safe,safe,27427,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"itialize GD path search. ;  ; Double_t LossFunction (const Event &e) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; Double_t LossFunction (UInt_t evtidx) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; Double_t LossFunction (UInt_t evtidx, UInt_t itau) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; void MakeGDPath ();  The following finds the gradient directed path in parameter space. ;  ; Double_t Penalty () const;  This is the ""lasso"" penalty To be used for regression. ;  ; Double_t Risk (UInt_t ind1, UInt_t ind2, Double_t neff) const;  risk assessment ;  ; Double_t Risk (UInt_t ind1, UInt_t ind2, Double_t neff, UInt_t itau) const;  risk assessment for tau model <itau> ;  ; Double_t RiskPath () const;  ; Double_t RiskPerf () const;  ; Double_t RiskPerf (UInt_t itau) const;  ; UInt_t RiskPerfTst ();  Estimates the error rate with the current set of parameters. ;  ; void SetGDErrScale (Double_t s);  ; void SetGDNPathSteps (Int_t np);  ; void SetGDPathStep (Double_t s);  ; void SetGDTau (Double_t t);  ; void SetGDTauPrec (Double_t p);  ; void SetGDTauRange (Double_t t0, Double_t t1);  ; void SetGDTauScan (UInt_t n);  ; void SetMsgType (EMsgType t);  ; void SetRuleFit (RuleFit *rf);  ; Int_t Type (const Event *e) const;  . Protected Types; typedef std::vector< constTMVA::Event * >::const_iterator EventItr;  . Protected Member Functions; Double_t CalcAverageResponse ();  calculate the average response - TODO : rewrite bad dependancy on EvaluateAverage() ! ;  ; Double_t CalcAverageResponseOLD ();  ; Double_t CalcAverageTruth ();  calculate the average truth ;  ; void CalcFStar ();  Estimates F* (optimum scoring function) for all events for the given ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:1811,risk,risk,1811,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,2,['risk'],['risk']
Safety,ition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TRO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:160878,detect,detected,160878,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['detect'],['detected']
Safety,ition TROOT.cxx:2895; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TRO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:161054,detect,detected,161054,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['detect'],['detected']
Safety,"ition at line 2630 of file TWinNTSystem.cxx. ◆ ResetSignal(). void TWinNTSystem::ResetSignal ; (; ESignals ; sig, . Bool_t ; reset = kTRUE . ). overridevirtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 1425 of file TWinNTSystem.cxx. ◆ ResetSignals(). void TWinNTSystem::ResetSignals ; (; ). overridevirtual . Reset signals handlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 1433 of file TWinNTSystem.cxx. ◆ Select() [1/2]. Int_t TWinNTSystem::Select ; (; TFileHandler * ; h, . Long_t ; to . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4628 of file TWinNTSystem.cxx. ◆ Select() [2/2]. Int_t TWinNTSystem::Select ; (; TList * ; active, . Long_t ; timeout . ). overridevirtual . Select on file descriptors. The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4591 of file TWinNTSystem.cxx. ◆ SendBuf(). int TWinNTSystem::SendBuf ; (; int ; sock, . const void * ; buf, . int ; length . ). overridevirtual . Send a buffer headed by a length indicator. ; Returns length of sent buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 4945 of file TWinNTSystem.cxx. ◆ SendRaw(). int TWinNTSystem::SendRaw ; (; int ; sock, . const void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 5010 of file TWinNTSystem.cxx. ◆ SetDynamicPath(). void TWinNTSystem::SetDynamicPath ; (; const char * ; path). overridevirtual . Set the dynamic path to a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:68711,timeout,timeout,68711,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"ition at line 379 of file TPad.cxx. Member Function Documentation. ◆ AbsCoordinates(). void TPad::AbsCoordinates ; (; Bool_t ; set). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 167 of file TPad.h. ◆ AbsPixeltoX(). Double_t TPad::AbsPixeltoX ; (; Int_t ; px). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 168 of file TPad.h. ◆ AbsPixeltoXY(). void TPad::AbsPixeltoXY ; (; Int_t ; xpixel, . Int_t ; ypixel, . Double_t & ; x, . Double_t & ; y . ). virtual . Convert absolute pixel into X/Y coordinates. ; Definition at line 7378 of file TPad.cxx. ◆ AbsPixeltoY(). Double_t TPad::AbsPixeltoY ; (; Int_t ; py). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 169 of file TPad.h. ◆ Add(). void TPad::Add ; (; TObject * ; obj, . Option_t * ; opt = """", . Bool_t ; modified = kTRUE . ). overridevirtual . Add an object to list of primitives with speicified draw option When. ; modified set to kTRUE (default) pad will be marked as modifiedLet avoid usage of gPad when drawing object(s) in canvas or in subpads.; auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; c1->Divide(2,2);; ; for (Int_t n = 1; n <= 4; ++n) {; auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; h1->FillRandom(""gaus"", 2000 + n*1000);; c1->GetPad(n)->Add(h1);; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; int; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5. Implements TVirtualPad.; Definition at line 418 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:54839,avoid,avoid,54839,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety,"ition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:22115,safe,safe,22115,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:22076,safe,safe,22076,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:25315,safe,safe,25315,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 57 of file TGeoVGShape.h. ◆ Draw(). void TGeoVGShape::Draw ; (; Option_t * ; option = """"). inlineoverridevirtual . Draw this shape. ; Reimplemented from TGeoShape.; Definition at line 58 of file TGeoVGShape.h. ◆ GetAxisName(). const char * TGeoVGShape::GetAxisName ; (; Int_t ; iaxis); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoVGShape.h. ◆ GetAxisRange(). Double_t TGeoVGShape::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 60 of file TGeoVGShape.h. ◆ GetBoundingCylinder(). void TGeoVGShape::GetBoundingCylinder ; (; Double_t * ; param); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 64 of file TGeoVGShape.h. ◆ GetBuffer3D(). const TBuffer3D & TGeoVGShape::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. inlineoverridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoVGShape.h. ◆ GetByteCount(). Int_t TGeoVGShape::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 69 of file TGeoVGShape.h. ◆ GetFittingBox(). Int_t TGeoVGShape::GetFittingBox ; (; const TGeoBBox * ; parambox, . TGeoMatrix * ; mat, . Double_t & ; dx, . Double_t & ; dy, . Double_t & ; dz . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 76 of file TGeoVGShape.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoVGShape::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 80 of file TGeoVGShape.h. ◆ GetMeshNumbers(). void TGeoVGShape::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 84 of file TGeoVGShape.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:27289,avoid,avoid,27289,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['avoid'],['avoid']
Safety,"ition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21386,safe,safe,21386,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21478,safe,safe,21478,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition of ECellValue . Definition at line 119 of file PDEFoamKernelGauss.cxx. ◆ IsA(). virtual TClass * TMVA::PDEFoamKernelGauss::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::PDEFoamKernelBase.; Definition at line 61 of file PDEFoamKernelGauss.h. ◆ Sqr(). template<typename T > . T TMVA::PDEFoamKernelGauss::Sqr ; (; T ; x); const. inlineprotected . Definition at line 45 of file PDEFoamKernelGauss.h. ◆ Streamer(). virtual void TMVA::PDEFoamKernelGauss::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::PDEFoamKernelBase. ◆ StreamerNVirtual(). void TMVA::PDEFoamKernelGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file PDEFoamKernelGauss.h. ◆ WeightGaus(). Float_t TMVA::PDEFoamKernelGauss::WeightGaus ; (; PDEFoam * ; foam, . PDEFoamCell * ; cell, . std::vector< Float_t > & ; txvec . ). protected . Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. ; Parameters:; cell - the cell; txvec - the transformed event variables (in [0,1]) (coordinates <0 are set to 0, >1 are set to 1). Returns:. \[; e^(\frac{-(\frac{d}{\sigma})^2}{2}); \]. where:; d - is the euclidean distance between 'txvec' and the point of the 'cell' which is most close to 'txvec' (in order to avoid artefacts because of the form of the cells).; \( sigma = \frac{1}{VolFrac} \) . Definition at line 182 of file PDEFoamKernelGauss.cxx. Member Data Documentation. ◆ fSigma. Float_t TMVA::PDEFoamKernelGauss::fSigma. protected . width of gauss curve ; Definition at line 42 of file PDEFoamKernelGauss.h. Libraries for TMVA::PDEFoamKernelGauss:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/PDEFoamKernelGauss.h; tmva/tmva/src/PDEFoamKernelGauss.cxx. TMVAPDEFoamKernelGauss. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelGauss.html:15239,avoid,avoid,15239,doc/master/classTMVA_1_1PDEFoamKernelGauss.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"ition of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:15294,safe,safe,15294,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,2,['safe'],['safe']
Safety,"itional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987617,safe,safety,987617,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolume(); TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:16771,avoid,avoided,16771,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeAssembly(); TGeoVolumeAssembly(const char* name); TGeoVolumeAssembly(const TGeoVolumeAssembly&); virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:16734,avoid,avoided,16734,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeMulti(); TGeoVolumeMulti(const char* name, TGeoMedium* med = 0); virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:16725,avoid,avoided,16725,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:16771,avoid,avoided,16771,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:16734,avoid,avoided,16734,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeMulti.html:16725,avoid,avoided,16725,root/html602/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html,2,['avoid'],['avoided']
Safety,"itor::ResetInterrupt ; (; ). inline . Definition at line 72 of file TMonitor.h. ◆ Select() [1/3]. TSocket * TMonitor::Select ; (; ). Return pointer to socket for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. ◆ Select() [2/3]. TSocket * TMonitor::Select ; (; Long_t ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. ◆ Select() [3/3]. Int_t TMonitor::Select ; (; TList * ; rdready, . TList * ; wrready, . Long_t ; timeout . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. ◆ SetInterest(). void TMonitor::SetInterest ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Set interest mask for socket sock to interest. ; If the socket is not in the active list move it or add it there. If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 180 of file TMonitor.cxx. ◆ SetReady(). void TMonitor::SetReady ; (; TSocket * ; sock). private . Called by TSocketHandler::Notify() to signal which socket is ready to be read or written. ; User should not call t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:22375,timeout,timeout,22375,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"its : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:50630,abort,abort,50630,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Fri Dec 2 14:26:41 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:22744,abort,abort,22744,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Mon Jul 4 15:21:38 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgSet.html:22230,abort,abort,22230,root/html530/RooArgSet.html,https://root.cern,https://root.cern/root/html530/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Sat Oct 9 22:38:34 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgSet.html:22019,abort,abort,22019,root/html528/RooArgSet.html,https://root.cern,https://root.cern/root/html528/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Tue Jun 2 15:27:50 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooArgSet.html:24015,abort,abort,24015,root/html604/RooArgSet.html,https://root.cern,https://root.cern/root/html604/RooArgSet.html,1,['abort'],['abort']
Safety,"itten; automatically to a file during the next TFile::Write command.; ; Example:; create a twodimensional TEfficiency object with; - name = ""eff""; - title = ""my efficiency""; - axistitles: x, y and LaTeX formated epsilon as label for Z axis; - 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; from first bin) upto 10 (upper edge of last bin); - 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; edge from first bin) upto 5 (upper edge of last bin); TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; to fullfill the conditions mentioned in CheckConsistency, otherwise the construction will fail.; As the histograms already exist, the new TEfficiency is by default not attached; to the current directory to avoid duplication of data. If you want to store the; new object anyway, you can either write it directly by calling Write or attach it to a directory using SetDirectory.; This also applies for TEfficiency objects created by the copy constructor TEfficiency(const TEfficiency& rEff). Example 1:; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");; //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; // this will write the TEfficiency object to ""myfile.root""; // AND pEff will be attached to the current directory; pEff->Write();; }; Example 2:; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");; //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; //this will attach the TEfficiency object to the current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEfficiency.html:3512,avoid,avoid,3512,root/html602/TEfficiency.html,https://root.cern,https://root.cern/root/html602/TEfficiency.html,2,['avoid'],['avoid']
Safety,"ity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 378 of file THashList.cxx. ◆ Remove() [2/2]. TObject * THashList::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 391 of file THashList.cxx. ◆ Streamer(). void THashList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates. ◆ StreamerNVirtual(). void THashList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 72 of file THashList.h. ◆ UseRWLock(). bool THashList::UseRWLock ; (; Bool_t ; enable = true). overridevirtual . Set this collection to use a RW lock upon access, making it thread safe. ; Return the previous state.; Note: To test whether the usage is enabled do: collection->TestBit(TCollection::kUseRWLock); ; Reimplemented from TCollection.; Definition at line 409 of file THashList.cxx. Member Data Documentation. ◆ fTable. THashTable* THashList::fTable. protected . Definition at line 37 of file THashList.h. Libraries for THashList:. [legend]; The documentation for this class was generated from the following files:; core/cont/inc/THashList.h; core/cont/src/THashList.cxx. THashList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:48 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:33621,safe,safe,33621,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['safe'],['safe']
Safety,"ity"");; f1->GetHistogram()->SetMinimum(0.0);; f1->GetHistogram()->SetMaximum(1.0);; TF1 *f2 = new TF1(""f2"",RiskProfile,0,2.5,1);; f2->SetParameter(0,10.);; f2->SetLineColor(50);; f2->Draw(""CSAME"");; ; TLegend *legend1 = new TLegend(0.50,0.65,0.70,0.82);; legend1->AddEntry(f1,""1-exp(-2.0*x)"",""l"");; legend1->AddEntry(f2,""1-exp(-10.*x)"",""l"");; legend1->Draw();; ; // vertical bar chart of portfolio distribution; ; c1->cd(2);; TH1F *h1 = new TH1F(""h1"",""Portfolio Distribution"",nrStocks,0,0);; TH1F *h2 = new TH1F(""h2"",""Portfolio Distribution"",nrStocks,0,0);; h1->SetStats(0);; h1->SetFillColor(49);; h2->SetFillColor(50);; h1->SetBarWidth(0.45);; h1->SetBarOffset(0.1);; h2->SetBarWidth(0.4);; h2->SetBarOffset(0.55);; for (Int_t i = 0; i < nrStocks; i++) {; h1->Fill(stocks[i],weight1[i]);; h2->Fill(stocks[i],weight2[i]);; }; ; h1->Draw(""BAR2 HIST"");; h2->Draw(""BAR2SAME HIST"");; ; TLegend *legend2 = new TLegend(0.50,0.65,0.70,0.82);; legend2->AddEntry(h1,""high risk"",""f"");; legend2->AddEntry(h2,""low risk"",""f"");; legend2->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TArrayF.h; TCanvas.h; TF1.h; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TGondzioSolver.h; TH1.h; TLegend.h; TMath.h; TMatrixDSym.h; TMatrixD.h; TQpProbDens.h; Form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:13416,risk,risk,13416,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,2,['risk'],['risk']
Safety,"iven variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] IN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8C.html:6423,safe,safe,6423,doc/master/rf202__extendedmlfit_8C.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html,1,['safe'],['safe']
Safety,"ize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:3387,safe,safe,3387,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['safe'],['safe']
Safety,"ize(EAddToList addToGlobalList); 803{; 804 // add to global list of functions if default adding is on OR if bit is set; 805 bool doAdd = ((addToGlobalList == EAddToList::kDefault && fgAddToGlobList); 806 || addToGlobalList == EAddToList::kAdd);; 807 if (doAdd && gROOT) {; 808 SetBit(kNotGlobal, kFALSE);; 809 R__LOCKGUARD(gROOTMutex);; 810 // Store formula in linked list of formula in ROOT; 811 TF1 *f1old = (TF1 *)gROOT->GetListOfFunctions()->FindObject(fName);; 812 if (f1old) {; 813 gROOT->GetListOfFunctions()->Remove(f1old);; 814 // We removed f1old from the list, it is not longer global.; 815 // (See TF1::AddToGlobalList which requires this flag to be correct).; 816 f1old->SetBit(kNotGlobal, kTRUE);; 817 }; 818 gROOT->GetListOfFunctions()->Add(this);; 819 } else; 820 SetBit(kNotGlobal, kTRUE);; 821 ; 822 if (gStyle) {; 823 SetLineColor(gStyle->GetFuncColor());; 824 SetLineWidth(gStyle->GetFuncWidth());; 825 SetLineStyle(gStyle->GetFuncStyle());; 826 }; 827 SetFillStyle(0);; 828}; 829 ; 830////////////////////////////////////////////////////////////////////////////////; 831/// Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ); 832/// After having called this static method, all the functions created afterwards will follow the; 833/// desired behaviour.; 834///; 835/// By default the functions are added automatically; 836/// It returns the previous status (true if the functions are added automatically); 837 ; 838Bool_t TF1::DefaultAddToGlobalList(Bool_t on); 839{; 840 return fgAddToGlobList.exchange(on);; 841}; 842 ; 843////////////////////////////////////////////////////////////////////////////////; 844/// Add to global list of functions (gROOT->GetListOfFunctions() ); 845/// return previous status (true if the function was already in the list false if not); 846 ; 847Bool_t TF1::AddToGlobalList(Bool_t on); 848{; 849 if (!gROOT) return false;; 850 ; 851 bool prevStatus = !TestBit(kNotGlobal);; 852 if (on) {; 85",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:29442,avoid,avoid,29442,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ize);  ; int CompressionSettings (RCompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:7812,safe,safe,7812,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,2,['safe'],['safe']
Safety,"ize;; 1907 // case of batch prediction for; 1908 if (ievt_end <= lastEvt) {; 1909 ; 1910 if (ievt == firstEvt) {; 1911 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1917 << "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:77133,predict,prediction,77133,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"izerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at time t,; based on the numbers already processed and the latests worker measured speeds.; If t <= 0 the current time is used.; Only the estimation for the entries is currently implemented.; This is needed to smooth the instantaneous rate plot. void MarkBad(TSlave* s, TProofProgressStatus* status, TList** missingFiles); This method c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:12959,predict,predict,12959,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,6,['predict'],['predict']
Safety,"jan95 == -1) {; 3862 ::SysError(""TUnixSystem::UnixNow"", ""error converting 950001 0:00 to time_t"");; 3863 return 0;; 3864 }; 3865 }; 3866 ; 3867 struct timeval t;; 3868 gettimeofday(&t, nullptr);; 3869 return Long64_t(t.tv_sec-(Long_t)jan95)*1000 + t.tv_usec/1000;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124778,timeout,timeout,124778,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:2215,safe,safe,2215,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,3,['safe'],['safe']
Safety,"ject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShapeAssembly.html:1852,safe,safe,1852,root/html532/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html532/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:2510,safe,safe,2510,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,1,['safe'],['safe']
Safety,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBufferJSON.html:20198,recover,recovered,20198,root/html604/TBufferJSON.html,https://root.cern,https://root.cern/root/html604/TBufferJSON.html,1,['recover'],['recovered']
Safety,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualPacketizer.html:5780,abort,abort,5780,root/html530/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html530/TVirtualPacketizer.html,2,['abort'],['abort']
Safety,"ject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:11792,abort,abort,11792,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLocal.html:11559,abort,abort,11559,root/html604/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLocal.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualMCGeometry&operator=(const TVirtualMCGeometry&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCGeometry(). Destructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:9127,detect,detector,9127,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,4,['detect'],['detector']
Safety,"ject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. TGLAutoRotator(const TGLAutoRotator& ). TGLAutoRota",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLAutoRotator.html:7173,timeout,timeout,7173,root/html530/TGLAutoRotator.html,https://root.cern,https://root.cern/root/html530/TGLAutoRotator.html,2,['timeout'],['timeout']
Safety,"jets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; //fill some histograms; hdmd->Fill(*fDm_d);; h2->Fill(*fDm_d,*fRpd0_t/0.029979*1.8646/ *fPtd0_d);; ; return kTRUE;; }; ; void h1analysisTreeReader::Begin(TTree* /*myTree*/) {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Reset();; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""Begin"", ""starting h1analysis with process option: %s"", option.Data());; ; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is processed in SlaveBegin and we do not need; // to do anything here; } else {; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; void h1analysisTreeReader::SlaveBegin(TTree *myTree){; ; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Init(myTree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:3233,avoid,avoid,3233,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,2,['avoid'],['avoid']
Safety,"jority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32250,risk,risk,32250,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['risk'],['risk']
Safety,"k;}; 4143 case 17: {b.ReadFastArray((ULong64_t*)fAddress, n); break;}; 4144 case 18: {b.ReadFastArray((bool*) fAddress, n); break;}; 4145 case 9: {; 4146 TVirtualStreamerInfo* si = GetInfoImp();; 4147 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4148 Double_t *xx = (Double_t*) fAddress;; 4149 for (Int_t ii=0;ii<n;ii++) {; 4150 b.ReadDouble32(&(xx[ii]),se);; 4151 }; 4152 break;; 4153 }; 4154 case 19: {; 4155 TVirtualStreamerInfo* si = GetInfoImp();; 4156 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4157 Float_t *xx = (Float_t*) fAddress;; 4158 for (Int_t ii=0;ii<n;ii++) {; 4159 b.ReadFloat16(&(xx[ii]),se);; 4160 }; 4161 break;; 4162 }; 4163 }; 4164 return;; 4165 } else if (fType <= 2) { // branch in split mode; 4166 // FIXME: This should probably be < 60 instead.; 4167 if (fStreamerType > 40 && fStreamerType < 55) {; 4168 Int_t atype = fStreamerType - 40;; 4169 Int_t n;; 4170 if (fBranchCount==nullptr) {; 4171 // Missing fBranchCount. let's attempts to recover.; 4172 ; 4173 TString countname( GetName() );; 4174 Ssiz_t dot = countname.Last('.');; 4175 if (dot>=0) {; 4176 countname.Remove(dot+1);; 4177 } else {; 4178 countname = """";; 4179 }; 4180 TString counter( GetTitle() );; 4181 Ssiz_t loc = counter.Last('[');; 4182 if (loc>=0) {; 4183 counter.Remove(0,loc+1);; 4184 }; 4185 loc = counter.Last(']');; 4186 if (loc>=0) {; 4187 counter.Remove(loc);; 4188 }; 4189 countname += counter;; 4190 SetBranchCount((TBranchElement *)fTree->GetBranch(countname));; 4191 }; 4192 if (fBranchCount) {; 4193 n = (Int_t)fBranchCount->GetValue(0,0);; 4194 } else {; 4195 Warning(""ReadLeaves"",""Missing fBranchCount for %s. Data will not be read correctly by the MakeClass mode."",GetName());; 4196 n = 0;; 4197 }; 4198 fNdata = n;; 4199 Char_t isArray;; 4200 b >> isArray;; 4201 switch (atype) {; 4202 case 1: {b.ReadFastArray((Char_t*) fAddress, n); break;}; 4203 case 2: {b.ReadFastArray((Short_t*) fAddress, n); break;}; 4204 case 3: {b.ReadFastArray((Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:154555,recover,recover,154555,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['recover'],['recover']
Safety,"kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(tree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:2238,predict,prediction,2238,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['predict'],['prediction']
Safety,"kBFGS.; This implementation, written by C. Delaere, is inspired from the mlpfit package from J.Schwindling et al. with some extensions:. the algorithms are globally the same; in TMultilayerPerceptron, there is no limitation on the number of layers/neurons, while MLPFIT was limited to 2 hidden layers; TMultilayerPerceptron allows you to save the network in a root file, and provides more export functionalities; TMultilayerPerceptron gives more flexibility regarding the normalization of inputs/outputs; TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to use cross-entropy errors, which allows to train a network for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2033,predict,predictions,2033,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['predict'],['predictions']
Safety,"kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:57661,safe,safe,57661,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['safe'],['safe']
Safety,"kFALSE, Bool_t wait_process=kFALSE);  Execute WS request. ;  ; std::shared_ptr< THttpWSHandler > FindWS (const char *name);  Find web-socket handler with given name. ;  ; const char * GetCors () const;  Returns specified CORS domain. ;  ; const char * GetCorsCredentials () const;  Returns specified CORS credentials value - if any. ;  ; const char * GetItemField (const char *fullname, const char *name);  Get item field from sniffer. ;  ; TRootSniffer * GetSniffer () const;  returns pointer on objects sniffer ;  ; const char * GetTopName () const;  returns name of top item in objects hierarchy ;  ; Bool_t Hide (const char *fullname, Bool_t hide=kTRUE);  Hides folder or element from web gui. ;  ; TClass * IsA () const override;  ; Bool_t IsAnyEngine () const;  ; Bool_t IsCors () const;  Returns kTRUE if CORS was configured. ;  ; Bool_t IsCorsCredentials () const;  Returns kTRUE if Access-Control-Allow-Credentials header should be used. ;  ; Bool_t IsFileRequested (const char *uri, TString &res) const;  Check if file is requested, thread safe. ;  ; Bool_t IsReadOnly () const;  returns read-only mode ;  ; Bool_t IsTerminated () const;  returns kTRUE, if server was terminated ;  ; Bool_t IsWSOnly () const;  returns true if only websockets are handled by the server ;  ; Int_t ProcessRequests ();  Process submitted requests, must be called from appropriate thread. ;  ; Bool_t Register (const char *subfolder, TObject *obj);  Register object in subfolder. ;  ; Bool_t RegisterCommand (const char *cmdname, const char *method, const char *icon=nullptr);  Register command which can be executed from web interface. ;  ; void RegisterWS (std::shared_ptr< THttpWSHandler > ws);  Register WS handler. ;  ; void Restrict (const char *path, const char *options);  Restrict access to specified object. ;  ; void SetCors (const std::string &domain=""*"");  Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header. ;  ; void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:3447,safe,safe,3447,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['safe'],['safe']
Safety,"kLoadTree ; kPrint ; kRemoveFriend ; kSetBranchStatus . Definition at line 211 of file TTree.h. ◆ ESetBranchAddressStatus. enum TTree::ESetBranchAddressStatus. EnumeratorkMissingBranch ; kInternalError ; kMissingCompiledCollectionProxy ; kMismatch ; kClassMismatch ; kMatch ; kMatchConversion ; kMatchConversionCollection ; kMakeClass ; kVoidPtr ; kNoCheck ; kNeedEnableDecomposedObj ; kNeedDisableDecomposedObj ; kDecomposedObjMask . Definition at line 232 of file TTree.h. ◆ EStatusBits. enum TTree::EStatusBits. EnumeratorkForceRead ; kCircular ; kOnlyFlushAtCluster If set, the branch's buffers will grow until an event cluster boundary is hit, guaranteeing a basket per cluster. ; This mode does not provide any guarantee on the memory bounds in the case of extremely large events. . kEntriesReshuffled If set, signals that this TTree is the output of the processing of another TTree, and the entries are reshuffled w.r.t. ; to the original TTree. As a safety measure, a TTree with this bit set cannot add friends nor can be added as a friend. If you know what you are doing, you can manually unset this bit with ResetBit(EStatusBits::kEntriesReshuffled). . Definition at line 250 of file TTree.h. Constructor & Destructor Documentation. ◆ TTree() [1/3]. TTree::TTree ; (; ). Default constructor and I/O constructor. ; Note: We do not insert ourself into the current directory. ; Definition at line 737 of file TTree.cxx. ◆ TTree() [2/3]. TTree::TTree ; (; const char * ; name, . const char * ; title, . Int_t ; splitlevel = 99, . TDirectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:67667,safe,safety,67667,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['safe'],['safety']
Safety,"kQT_HexagonXY; kQT_HexagonYX; kQT_Hexagon_End; };; enum TEveDigitSet::ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; void*TEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefCoordDefault value for third coordinate (C); Float_tfDefHeightBreadth assigned to second coordinate (B); Float_tfDefWidthBreadth assigned to first coordinate (A); Int_tTEveDigitSet::fDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveQuadSet.html:24382,avoid,avoid,24382,root/html528/TEveQuadSet.html,https://root.cern,https://root.cern/root/html528/TEveQuadSet.html,1,['avoid'],['avoid']
Safety,"k_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:370587,timeout,timeout,370587,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"k_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:370620,timeout,timeout,370620,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be cross",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2951,safe,safe,2951,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:18708,avoid,avoid,18708,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['avoid'],['avoid']
