quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability," if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14801,synchroniz,synchronized,14801,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['synchroniz'],['synchronized']
Integrability," if(BLAS_FOUND); target_link_libraries(TMVA PRIVATE ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}); elseif(GSL_FOUND); target_compile_definitions(TMVA PRIVATE -DDNN_USE_CBLAS); target_include_directories(TMVA SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(TMVA PRIVATE ${GSL_CBLAS_LIBRARY}); if(builtin_gsl); add_dependencies(TMVA GSL); endif(); else(); message(FATAL_ERROR ""tmva-cpu enabled but neither BLAS nor GSL BLAS were found""); endif(); endif(). if(tmva-gpu); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cuda.cu; src/DNN/Architectures/Cuda/CudaBuffers.cxx; src/DNN/Architectures/Cuda/CudaMatrix.cu; src/DNN/Architectures/Cuda/CudaTensor.cu ); target_link_libraries(TMVA PRIVATE CUDA::cuda_driver CUDA::cublas); if(tmva-cudnn); message(STATUS ""Using Cuda+cuDNN for TMVA Deep Learning on GPU""); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cudnn/TensorDataLoader.cxx; src/DNN/Architectures/Cudnn.cu); target_link_libraries(TMVA PRIVATE ROOT::cuDNN); else(); message(STATUS ""cuDNN not found or disabled - use only Cuda+Cublas for TMVA Deep Learning on GPU""); endif(); endif(tmva-gpu). if(dataframe); ROOT_STANDARD_LIBRARY_PACKAGE(TMVAUtils; NO_INSTALL_HEADERS; HEADERS; TMVA/RTensorUtils.hxx; TMVA/RStandardScaler.hxx; TMVA/RReader.hxx; TMVA/RInferenceUtils.hxx; TMVA/RBDT.hxx; TMVA/RSofieReader.hxx; TMVA/RBatchGenerator.hxx; TMVA/RBatchLoader.hxx; TMVA/RChunkLoader.hxx. SOURCES. src/RBDT.cxx. DEPENDENCIES; TMVA ROOTDataFrame ROOTVecOps; ${TMVA_EXTRA_DEPENDENCIES}. LINKDEF LinkDefUtils.h; DICTIONARY_OPTIONS; -writeEmptyRootPCM. ${EXTRA_DICT_OPTS}; ); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/crossvalidation); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN); ROOT_ADD_TEST_SUBDIRECTORY(test/Method); ROOT_ADD_TEST_SUBDIRECTORY(test/ROC); ROOT_ADD_TEST_SUBDIRECTORY(test/envelope); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/CNN); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/RNN); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/LSTM); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/GRU); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:10759,message,message,10759,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['message'],['message']
Integrability," imports the enclosing module. Each imported module that matches the *wildcard-module-id* up to, but not including, the first ``*`` will be re-exported. **Example:** In the following example, importing ``MyLib.Derived`` also provides the API for ``MyLib.Base``:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the module that the current; module will be re-exported through. Only top-level modules; can be re-exported, and any given module may only be re-exported; through a single module. **Example:** In the following example, the module ``MyFrameworkCore``; will be re-exported via the module ``MyFramework``:. .. parsed-literal::. module MyFrameworkCore {; export_as MyFramework; }. Use declaration; ~~~~~~~~~~~~~~~; A *use-declaration* specifies another module that the current top-level module; intends to use. When the option *-fmodu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43661,depend,depends,43661,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['depends']
Integrability," in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimizatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:37559,wrap,wrapper,37559,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability," in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52944,interface,interfaces,52944,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interfaces']
Integrability," in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: ob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88489,protocol,protocol,88489,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability," in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization examples are still incorrect; Yes. 337; CD1; Attempt to create array of abtract type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:22242,depend,dependent,22242,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability," in the example above:. - *ExecutionSession* represents the JIT'd program and provides context for the; JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the; materializers. - *JITDylibs* provide the symbol tables. - *Layers* (ObjLinkingLayer and CXXLayer) are wrappers around compilers and; allow clients to add uncompiled program representations supported by those; compilers to JITDylibs. - *ResourceTrackers* allow you to remove code. Several other important APIs are used explicitly. JIT clients need not be aware; of them, but Layer authors will use them:. - *MaterializationUnit* - When XXXLayer::add is invoked it wraps the given; program representation (in this example, C++ source) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the layer it comes with an associated; MaterializationResponsibility object. This object tracks the definitions; that must be materialized and provides a way to notify the JITDylib once they; are either successfully materialized or a failure occurs. Absolute Symbols, Aliases, and Reexports; ========================================. ORC makes it easy to define symbols with absolute addresses, or symbols that; are simply aliases of other symbols:. Absolute Symbols; ----------------. Absolute symbols are symbols that map directly to addresses without requiring; further materialization, for example: ""foo"" = 0x1234. One use case for; absolute symbols is allowing resolution ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:12517,synchroniz,synchronization,12517,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['synchroniz'],['synchronization']
Integrability," in the matrix operations test. Minuit. Implement in the TMinuitMinimizer class the method SetPrecision() using the ""SET EPS"" Minuit command; Fix a problem when using the user provided gradient in TMinuitMinimizer. The gradient calculation is always forced, i.e. Minuit will always use the derivatives calculations provided by the user. This is now the same behavior as in Minuit2Minimizer.; Implement in TMinuitMinimizer a method to retrieve the variable name given the index.; Fix a printout in TMinuit::mnscan and a problem observed with valgrind. Minuit2. Fix a bug in MnFunctionCross. ; Add a protection against very small step sizes which can cause; nan values in InitialGradientCalculator.; Implement a new function in the MnUserTransformation class, FindIndex(name), which returns -1 when the parameter name does not exist.; Implement new methods in Minuit2Minimizer as requested by the Minimizer interface:; SetPrecision(double eps) to change the precision value used internally in Minuit2 (in MnPrecision), VariableName(index) to return the name of a variable (parameter) given an index, and VariableIndex(name) to return the index of a variable given a name.; Set a status code in Minuit2Minimizer according to the following convention:; status = minimizeStatus + 10 * minosStatus + 100 * hesseStatus.; See the Minuit2Minimizer reference documentation for the possible values of minimizeStatus , minosStatus and hesseStatus.; In MnHesse. when the inversion of the hessian matrix failed, return MnInvertFailed instead of MnHesseFailed. Mathcore Fitting classes. Fix the fitting with the integral option in multi-dimensions.; Force the gradient calculation when requested in the minimizer; classes and avoid to perform the check when using TMinuit. This was; already the case in Minuit2.; Add new class ROOT::Fit::SparseData for dealing with binned sparse data. This class automatically merges the empty region, so they can be considered, whenever possible as a larger single bin. This impro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:2008,interface,interface,2008,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,1,['interface'],['interface']
Integrability," in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47208,interface,interface,47208,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['interface', 'wrap']","['interface', 'wrap']"
Integrability," installed under ROOTSYS/include.; set(CLING_ROOT_BUILD ON); add_subdirectory(cling EXCLUDE_FROM_ALL); add_dependencies(CLING ${CLING_LIBRARIES}). set(CLING_INCLUDE_DIRS ${CMAKE_SOURCE_DIR}/interpreter/cling/include CACHE STRING """"). #---These are the libraries that we link ROOT with CLING---------------------------; if (builtin_llvm); add_dependencies(CLING intrinsics_gen); endif(); if (builtin_clang); add_dependencies(CLING clang-headers clang-resource-headers); # Windows (and some other LLVM setups) do not have that target available.; if (TARGET clang-cmake-exports); add_dependencies(CLING clang-cmake-exports); endif(); endif(); else(); set(Cling_DIR ${LLVM_BINARY_DIR}/lib/cmake/cling/); find_package(Cling REQUIRED CONFIG PATHS ${Cling_DIR} ""${Cling_DIR}/lib/cmake/cling"" ""${Cling_DIR}/cmake"" NO_DEFAULT_PATH); find_package(Clang REQUIRED CONFIG PATHS ${Cling_DIR} ""${Cling_DIR}/lib/cmake/clang"" ""${Cling_DIR}/cmake"" NO_DEFAULT_PATH). # We need to consider not just the direct link dependencies, but also the; # transitive link dependencies. Do this by starting with the set of direct; # dependencies, then the dependencies of those dependencies, and so on.; set(new_libs ""clingMetaProcessor""); set(link_libs ${new_libs}); while(NOT ""${new_libs}"" STREQUAL """"); foreach(lib ${new_libs}); if(TARGET ${lib}); get_target_property(lib_type ${lib} TYPE); if(""${lib_type}"" STREQUAL ""STATIC_LIBRARY""); list(APPEND static_libs ${lib}); else(); list(APPEND other_libs ${lib}); endif(); get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES); if (NOT transitive_libs); continue(); endif(); foreach(transitive_lib ${transitive_libs}); list(FIND link_libs ${transitive_lib} idx); #if(TARGET ${transitive_lib} AND idx EQUAL -1); if(idx EQUAL -1); list(APPEND newer_libs ${transitive_lib}); list(APPEND link_libs ${transitive_lib}); endif(); endforeach(transitive_lib); endif(); endforeach(lib); set(new_libs ${newer_libs}); set(newer_libs """"); endwhile(); set(CLING_DEPEND_LIBS ${link_lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:23145,depend,dependencies,23145,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,2,['depend'],['dependencies']
Integrability," instances. In basic-block enumeration loop we associate *i*-th; BasicBlock from the left function with *i*-th BasicBlock from the right; function.; * Instructions.; * Instruction operands. Note, we can meet *Value* here we have never seen; before. In this case it is not a function argument, nor *BasicBlock*, nor; *Instruction*. It is a global value. It is a constant, since it's the only; supposed global here. The method also compares: Constants that are of the; same type and if right constant can be losslessly bit-casted to the left; one, then we also compare them. How to implement cmpValues?; ^^^^^^^^^^^^^^^^^^^^^^^^^^^; *Association* is a case of equality for us. We just treat such values as equal,; but, in general, we need to implement antisymmetric relation. As mentioned; above, to understand what is *less*, we can use order in which we; meet values. If both values have the same order in a function (met at the same; time), we then treat values as *associated*. Otherwise – it depends on who was; first. Every time we run the top-level compare method, we initialize two identical; maps (one for the left side, another one for the right side):. ``map<Value, int> sn_mapL, sn_mapR;``. The key of the map is the *Value* itself, the *value* – is its order (call it; *serial number*). To add value *V* we need to perform the next procedure:. ``sn_map.insert(std::make_pair(V, sn_map.size()));``. For the first *Value*, map will return *0*, for the second *Value* map will; return *1*, and so on. We can then check whether left and right values met at the same time with; a simple comparison:. ``cmpNumbers(sn_mapL[Left], sn_mapR[Right]);``. Of course, we can combine insertion and comparison:. .. code-block:: c++. std::pair<iterator, bool>; LeftRes = sn_mapL.insert(std::make_pair(Left, sn_mapL.size())), RightRes; = sn_mapR.insert(std::make_pair(Right, sn_mapR.size()));; return cmpNumbers(LeftRes.first->second, RightRes.first->second);. Let's look, how whole method could be implemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:18697,depend,depends,18697,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['depend'],['depends']
Integrability," instead be aggregated via bitwise; or, and can be accessed using; ``dfsan_label dfsan_get_labels_in_signal_conditional();``. * ``-dfsan-track-origins`` -- Controls how to track origins. When its value is; 0, the runtime does not track origins. When its value is 1, the runtime tracks; origins at memory store operations. When its value is 2, the runtime tracks; origins at memory load and store operations. Its default value is 0. * ``-dfsan-instrument-with-call-threshold`` -- If a function being instrumented; requires more than this number of origin stores, use callbacks instead of; inline checks (-1 means never use callbacks). Its default value is 3500. Environment Variables; ---------------------. * ``warn_unimplemented`` -- Whether to warn on unimplemented functions. Its; default value is false.; * ``strict_data_dependencies`` -- Whether to propagate labels only when there is; explicit obvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:9914,depend,dependent,9914,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['depend'],['dependent']
Integrability," integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55269,integrat,integration,55269,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability," interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1582,interface,interface,1582,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,1,['interface'],['interface']
Integrability," interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheritance for implementation differences, it; just adds complexity. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:5795,interface,interfaces,5795,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interfaces']
Integrability," into the; initialization of the parameter. The implicit ``self`` parameter of a method may be marked as consumed by adding; ``__attribute__((ns_consumes_self))`` to the method declaration. Methods in; the ``init`` :ref:`family <arc.method-families>` are treated as if they were; implicitly marked with this attribute. It is undefined behavior if an Objective-C message send to a method with; ``ns_consumed`` parameters (other than self) is made with a null receiver. It; is undefined behavior if the method to which an Objective-C message send; statically resolves to has a different set of ``ns_consumed`` parameters than; the method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with a different set of; ``ns_consumed`` parameters than the implementation of the called block or; function. .. admonition:: Rationale. Consumed parameters with null receiver are a guaranteed leak. Mismatches; with consumed parameters will cause over-retains or over-releases, depending; on the direction. The rule about function calls is really just an; application of the existing C/C++ rule about calling functions through an; incompatible function type, but it's useful to state it explicitly. .. _arc.object.operands.retained-return-values:. Retained return values; ^^^^^^^^^^^^^^^^^^^^^^. A function or method which returns a retainable object pointer type may be; marked as returning a retained value, signifying that the caller expects to take; ownership of a +1 retain count. This is done by adding the; ``ns_returns_retained`` attribute to the function or method declaration, like; so:. .. code-block:: objc. id foo(void) __attribute((ns_returns_retained));; - (id) foo __attribute((ns_returns_retained));. This attribute is part of the type of the function or method. When returning from such a function or method, ARC retains the value at the; point of evaluation of the return statement, before leaving all local scopes. When receiving a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:18793,depend,depending,18793,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['depending']
Integrability," invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP_ENABLE_LIBOMPTARGET); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); if(""libc"" IN_LIST LLVM_ENABLE_PROJECTS AND; (LLVM_LIBC_FULL_BUILD OR LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES)); if(LIBC_HDRGEN_EXE); set(hdrgen_exe ${LIBC_HDRGEN_EXE}); else(); if(TARGET ${LIBC_TABLEGEN_EXE}); set(hdrgen_exe $<TARGET_FILE:${LIBC_TABLEGEN_EXE}>); else(); set(hdrgen_exe ${LIBC_TABLEGEN_EXE}); endif(); set(hdrgen_deps ${LIBC_TABLEGEN_TARGET}); endif(); if(NOT hdrgen_exe); message(FATAL_ERROR ""libc-hdrgen executable missing""); endif(); set(libc_cmake_args ""-DLIBC_HDRGEN_EXE=${hdrgen_exe}""; ""-DLLVM_LIBC_FULL_BUILD=ON""); list(APPEND extra_deps ${hdrgen_deps}); if(LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES); foreach(dep clang-offload-packager nvptx-arch amdgpu-arch); if(TARGET ${dep}); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); endif(); if(NOT LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); set(test_targets check-runtimes); else(); if(""default"" IN_LIST LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); list(REMOVE_ITEM LLVM_RUNTIME_TARGETS ""default""); else(); add_custom_target(runtimes); add_custom_target(runtimes-configure); add_custom_target(install-runtimes); add_custom_target(install-runtimes-stripped); if(LLVM_INCLUDE_TESTS); add_custom_target(check-runtimes); add_custom_target(runtimes-test-depends); set(test_targets """"); endif(); if(LLVM_RUNTIME_DISTRIBUTION_COMPONENTS); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_custom_target(${component}); add_custom_target(install-${component}); add_custom_target(install-${component}-stripped); endforeach(); endif(); endif(). foreach(nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:16026,message,message,16026,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,"['depend', 'message']","['depends', 'message']"
Integrability," is Ok.; * When there is an explicit cast from nonnull to nullable I will trust the cast (it is probable there for a reason, because this cast does not suppress any warnings or errors).; * But what should we do about null checks?:. .. code-block:: cpp. __nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to keep in mind/take care of:. * Messaging:. * Sending a message to a nullable pointer. * Even though the method might return a nonnull pointer, when it was sent to a nullable pointer the return type will be nullable.; 	* The result is nullable unless the receiver is known to be non null. * Sending a message to an unspecified or nonnull pointer. * If the pointer is not assumed to be nil, we should be optimistic and use the nullability implied by the method. * This will not happen automatically, since the AST will have null unspecified in this case. Inlining; --------. A symbol may need to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:2848,message,message,2848,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,1,['message'],['message']
Integrability, is expected. Having multiple metadata blocks is an error. This block can contain the following records:. .. _bitstreamremarksrecordmetacontainerinfo:. ``RECORD_META_CONTAINER_INFO``. The container version and type. Version: u32. Type: u2. .. _bitstreamremarksrecordmetaremarkversion:. ``RECORD_META_REMARK_VERSION``. The version of the remark entries. This can change independently from the; container version. Version: u32. .. _bitstreamremarksrecordmetastrtab:. ``RECORD_META_STRTAB``. The string table used by the remark entries. The format of the string table; is a sequence of strings separated by ``\0``. .. _bitstreamremarksrecordmetaexternalfile:. ``RECORD_META_EXTERNAL_FILE``. The external remark file path that contains the remark blocks associated; with this metadata. This is an absolute path. .. _bitstreamremarksremarkblock:. REMARK_BLOCK; ------------. The block describing a remark entry. 0 or more blocks per file are allowed. Each block will depend on the; :ref:`META_BLOCK <bitstreamremarksmetablock>` in order to be parsed correctly. This block can contain the following records:. ``RECORD_REMARK_HEADER``. The header of the remark. This contains all the mandatory information about; a remark. +---------------+---------------------------+; | Type | u3 |; +---------------+---------------------------+; | Remark name | VBR6 (string table index) |; +---------------+---------------------------+; | Pass name | VBR6 (string table index) |; +---------------+---------------------------+; | Function name | VBR6 (string table index) |; +---------------+---------------------------+. ``RECORD_REMARK_DEBUG_LOC``. The source location for the corresponding remark. This record is optional. +--------+---------------------------+; | File | VBR7 (string table index) |; +--------+---------------------------+; | Line | u32 |; +--------+---------------------------+; | Column | u32 |; +--------+---------------------------+. ``RECORD_REMARK_HOTNESS``. The hotness of the remark. This reco,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:8279,depend,depend,8279,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['depend'],['depend']
Integrability," is no longer redrawn. When the external viewer is closed,; clicking in the pad will refresh. ### The GL Viewer. The GL Viewer uses <OpenGL®> (or compliant libraries such as <Mesa3D>); to generate high quality, high-performance 3D renderings, with; sophisticated lighting, materials and rendering styles for 3D scenes.; Many users will be able to take advantage of hardware acceleration of; the underlying OpenGL commands by their computer's video card, resulting; is considerable performance gains - up to interactive manipulation of; 1000's of complex shapes in real-time. The GL Viewer is supported on all official ROOT platforms (assuming you; have suitable <OpenGL®> libraries), and is the main 3D viewer, which; development effort is concentrated upon. As OpenGL® is a trademark we; refer to our viewer built on this technology as the ‘GL Viewer'. The; code for it can be found under `$ROOTSYS/gl`. ![The GL 3D Viewer](pictures/020000DA.jpg). You can manipulate the viewer via the GUI or via the base; **`TGLViewer`** object behind the interface. These are detailed below -; see also `$ROOTSYS/tutorials/gl/glViewerExercise.C`. #### Projections Modes (Cameras). The GL Viewer supports two basic types of camera, which affect how the; 3D world is projected onto the 2D render area:. - Perspective: Objects are drawn with characteristic ‘foreshortening'; effect, where distant objects appear smaller than near ones. This is; useful for obtaining a ‘real world' views. The degree of; foreshortening is affected by the current camera field of view; (focal length of its ‘lens') - see ""Adjusting Cameras"". - Orthographic: Distance from camera does not affect object size.; These projections are useful for measurement or checking alignments,; as the sizes and angles between objects are preserved. You can select the active camera from the viewer's Camera menu on the; top menu bar. There are three perspective camera choices:. - Perspective (Floor XOZ) Default. - Perspective (Floor YOZ). - Perspec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:108091,interface,interface,108091,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability," is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked together with differing values.; ``vscale_range(<min>[, <max>])``; This function attribute indicates `vscale` is a power-of-two within a; specified range. `min` must be a power-of-two that is greater than 0. When; specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0; to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be; used to set both `min` and `max` to the same value. Functions that don't; in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:110424,contract,contract,110424,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['contract'],['contract']
Integrability," is used as well by the ROOT::Math functions. This implementation has been found to be more accurate and in some cases more efficient in term of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms like TMath::LocMin, TMath::LocMax or TMath::Permute the original implementation is faster than STL and has been maintained.; ; Add a generic iterator interface, similar to the STL algorithm interface, to the following TMath functions:; MinElement, MaxElement, LocMin, LocMax, Mean, GeomMean, RMS,; BinarySearch. The iterator interface for sort is called; TMath::SortItr to avoid a compilation ambiguity. For example,; for finding the mean of a std::vector<double> v, one simply needs to call TMath::Mean(v.begin(), v.end() ) .; ; Various changes have been applied to the mathematical functions to remove duplications in the implementation with the special and statistical functions defined in ROOT::Math. The functions which have been changed and thus they can return a sightly different result than before are:; ; TMath::Erf and TMath::Erfc call ROOT::Math::erf and ROOT::math::erfc which are implemented using the Cephes algorithms, which is accurate at the required double precision level.; TMath::Gamma(z) is implemented with ROOT::Math::tgamma, which again uses Cephes.; The incomplete gamma function, TMath::Gamma(a,x) it is implemented using ROOT::Math::inc_gamma based on a corresponding Cephes function.; TMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:2150,interface,interface,2150,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interface']
Integrability," is. It could be a pointer to an object or struct which your various; traits use to shared context sensitive information. Output; ======. The llvm::yaml::Output class is used to generate a YAML document from your; in-memory data structures, using traits defined on your data types.; To instantiate an Output object you need an llvm::raw_ostream, an optional; context pointer and an optional wrapping column:. .. code-block:: c++. class Output : public IO {; public:; Output(llvm::raw_ostream &, void *context = NULL, int WrapColumn = 70);. Once you have an Output object, you can use the C++ stream operator on it; to write your native data as YAML. One thing to recall is that a YAML file; can contain multiple ""documents"". If the top level data structure you are; streaming as YAML is a mapping, scalar, or sequence, then Output assumes you; are generating one document and wraps the mapping output; with ""``---``"" and trailing ""``...``"". The WrapColumn parameter will cause the flow mappings and sequences to; line-wrap when they go over the supplied column. Pass 0 to completely; suppress the wrapping. .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyMapType &info) {; Output yout(llvm::outs());; yout << info;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ... On the other hand, if the top level data structure you are streaming as YAML; has a DocumentListTraits specialization, then Output walks through each element; of your DocumentList and generates a ""---"" before the start of each element; and ends with a ""..."". .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyDocListType &docList) {; Output yout(llvm::outs());; yout << docList;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ---; name: Tom; shoe-size: 11; ... Input; =====. The llvm::yaml::Input class is used to parse YAML document(s) into your native; data structures. To instantiate an Inp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:29850,wrap,wrap,29850,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wrap']
Integrability," issues are addressed by the CMake support. This is a blend of Python; packaging and CMake where CMake provides:. * Platform-independent scripting of the creation of a Python 'wheel' package; for the bindings.; * An facility for CMake-based projects to automate the entire bindings; generation process, including basic automated tests. .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. Python packaging; ----------------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminated in due course.; * FindCppyy.cmake provides the interface described further here. Details of the usage of these modules is within the modules themselves, but; here is a summary of the usage. ``FindLibClang.cmake`` sets the following; variables:. ::. LibClang_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:1849,depend,dependent,1849,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['depend'],['dependent']
Integrability," it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. It does however retain the best value after each; scan, so it does some sort of highly primitive minimization. ### $\mbox{SIMPLEX}$ ###. This genuine multidimensional minimization routine is usually much; slower than $\mbox{MIGRAD}$, but it does not use first derivatives,; so it should not be so sensitive to the precision of the; $\mbox{FCN}$ calculations, and is even rather robust with respect to; gross fluctuations in the function value. However, it gives no reliable; information about parameter errors, no information whatsoever about; parameter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:epsmac] describes what to do if this is; not the case. ## Parameter limits ##. Putting limits (absolute bounds) on the allowed values for a given; parameter, causes M t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:62241,rout,routine,62241,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['rout'],['routine']
Integrability," it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25075,depend,depend,25075,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['depend']
Integrability," least one of the following:. * **ll.addressof**: Takes a cppyy bound C++ object and returns its address as; an integer value.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_capsule**: Takes a cppyy bound C++ object and returns its address as; a PyCapsule object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_cobject**: Takes a cppyy bound C++ object and returns its address as; a PyCObject object for Python2 and a PyCapsule object for Python3.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. * **ll.as_ctypes**: Takes a cppyy bound C++ object and returns its address as; a ``ctypes.c_void_p`` object.; Takes an optional ``byref`` parameter and if set to true, returns a pointer; to the address instead. `ctypes`; --------. The `ctypes module`_ has been part of Python since version 2.5 and provides a; Python-side foreign function interface.; It is clunky to use and has very bad performance, but it is guaranteed to be; available.; It does not have a public C interface, only the Python one, but its internals; have been stable since its introduction, making it safe to use for tight and; efficient integration at the C level (with a few Python helpers to assure; lazy lookup). Objects from ``ctypes`` can be passed through arguments of functions that; take a pointer to a single C++ builtin, and ``ctypes`` pointers can be passed ; when a pointer-to-pointer is expected, e.g. for array out-parameters.; This leads to the following set of possible mappings:. ======================================== ========================================; C++ ctypes; ======================================== ========================================; by value (ex.: ``int``) ``.value`` (ex.: ``c_int(0).value``); by const reference (ex.: ``const int&``) ``.value`` (ex.: ``c_int(0).value``); by reference (ex.: ``int&``) direc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:7306,interface,interface,7306,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability," length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14722,synchroniz,synchronized,14722,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['synchroniz'],['synchronized']
Integrability," level:""),; cl::values(; clEnumVal(g , ""No optimizations, enable debugging""),; clEnumVal(O1, ""Enable trivial optimizations""),; clEnumVal(O2, ""Enable default optimizations""),; clEnumVal(O3, ""Enable expensive optimizations"")));. ...; if (OptimizationLevel >= O2) doPartialRedundancyElimination(...);; ... This declaration defines a variable ""``OptimizationLevel``"" of the; ""``OptLevel``"" enum type. This variable can be assigned any of the values that; are listed in the declaration. The CommandLine library enforces that; the user can only specify one of the options, and it ensure that only valid enum; values can be specified. The ""``clEnumVal``"" macros ensure that the command; line arguments matched the enum values. With this option added, our help output; now is:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. In this case, it is sort of awkward that flag names correspond directly to enum; names, because we probably don't want an enum definition named ""``g``"" in our; program. Because of this, we can alternatively write this example like this:. .. code-block:: c++. enum OptLevel {; Debug, O1, O2, O3; };. cl::opt<OptLevel> OptimizationLevel(cl::desc(""Choose optimization level:""),; cl::values(; clEnumValN(Debug, ""g"", ""No optimizations, enable debugging""),; clEnumVal(O1 , ""Enable trivial optimizations""),; clEnumVal(O2 , ""Enable default optimizations""),; clEnumVal(O3 , ""Enable expensive optimizations"")));. ...; if (OptimizationLevel == Debug) outputDebugInfo(...);; ... By using the ""``clEnumValN``"" macro instead of ""``clEnumVal``"", we can directly; specify the name that the flag should get. In general a direct m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:15918,message,messages,15918,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['messages']
Integrability," libraries and; `data-structures <https://llvm.org/docs/ProgrammersManual.html>`_, including; command line option processing, various containers and a system abstraction; layer, which is used for file system access. The Clang ""Basic"" Library; =========================. This library certainly needs a better name. The ""basic"" library contains a; number of low-level utilities for tracking and manipulating source buffers,; locations within the source buffers, diagnostics, tokens, target abstraction,; and information about the subset of the language being compiled for. Part of this infrastructure is specific to C (such as the ``TargetInfo``; class), other parts could be reused for other non-C-based languages; (``SourceLocation``, ``SourceManager``, ``Diagnostics``, ``FileManager``).; When and if there is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:1715,depend,dependencies,1715,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependencies']
Integrability," limits or the; FUMILI algorithm, which is an optimized method for least square and log likelihood; minimizations. The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html));; 2. F. James and M. Winkler, _C++ MINUIT User's Guide_ ([html](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html) and [pdf](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.pdf));; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1397,interface,interface,1397,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,1,['interface'],['interface']
Integrability," line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3962,depend,depend,3962,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['depend']
Integrability," linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:193088,depend,dependence,193088,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependence']
Integrability," list with components x and y,; //containing n coordinates which interpolate the given data points according to the method (and rule) desired.; r<<""points(approx(x, y), col = 2, pch = '*')"";; r<<""points(approx(x, y, method = 'constant'), col = 4, pch = '*')"";. //The function ""approxfun"" returns a function performing (linear or constant); //interpolation of the given data.; //For a given set of x values, this function will return the corresponding interpolated values.; r<<""f <- approxfun(x, y)"";. r<<""curve(f(x), 0, 11, col = 'green2')"";; r<<""points(x, y)"";. //using approxfun with const method; r<<""fc <- approxfun(x, y, method = 'const')"";; r<<""curve(fc(x), 0, 10, col = 'darkblue', add = TRUE)"";; // different interpolation on left and right side :; r<<""plot(approxfun(x, y, rule = 2:1), 0, 11,col = 'tomato', add = TRUE, lty = 3, lwd = 2)"";; }; ~~~; The image shows the interpolated function plotted within R:; \image html R_image3.png. ## Integration (Passing vectorized function to R); Numerical integration using R passing the function from ROOT. ~~~{.cxx}; #include<TMath.h>; #include<TRInterface.h>; #include<Math/Integrator.h>; #include<TF1.h>. //To integrate using R the function must be vectorized; //The idea is just to receive a vector like an argument,to evaluate; //every element saving the result in another vector; //and return the resultant vector.; std::vector<Double_t> BreitWignerVectorized(std::vector<Double_t> xx); {; std::vector<Double_t> result(xx.size());; for(Int_t i=0;i<xx.size();i++); {; result[i]=TMath::BreitWigner(xx[i]);; }; return result;; }. double BreitWignerWrap( double x){; return TMath::BreitWigner(x);; }. void Integration(); {. ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();. r[""BreitWigner""]=BreitWignerVectorized;. Double_t value=r.Eval(""integrate(BreitWigner, lower = -2, upper = 2)$value"");. std::cout.precision(18);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] R = ""<<value<<std::endl;. ROOT::Math::WrappedF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:22254,integrat,integration,22254,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['integrat'],['integration']
Integrability," listing below) and has only been tested on; Linux on x86_64. Numba `is a JIT compiler`_ for Python functions that can be statically typed; based on their input arguments.; Since C++ objects are always statically typed and already implemented at the; machine level, they can be dynamically integrated into the Numba type tracing; and lowering by exposing type details through C++ reflection at runtime. JIT-compiling traces of mixed Python/bound C++ code reduces, and in some; cases removes, the overhead of boxing/unboxing native data into their Python; proxies and vice versa.; It can also reduce or remove temporaries, especially for template; expressions.; Thus, there can be significant speedups for mixed code, beyond the Numba; compilation of Python code itself.; The current implementation integrates compiled C++ through function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:1137,integrat,integrate,1137,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['integrat'],['integrate']
Integrability," loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it didn't break due to an error.; if (Err); return Err;. To enable this idiom, iterators over fallible containers are written in a; natural style, with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_ite",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38325,interface,interface,38325,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,3,"['interface', 'wrap']","['interface', 'wrapped', 'wrapper']"
Integrability," lowering function, using; templated functions. For example:. // lib/Target/Mips/MipsISelLowering.cpp; SDValue MipsTargetLowering::; lowerJumpTable(SDValue Op, SelectionDAG &DAG) const. calls. template <class NodeTy> // lib/Target/Mips/MipsISelLowering.h; SDValue getAddrLocal(NodeTy *N, const SDLoc &DL, EVT Ty,; SelectionDAG &DAG, bool IsN32OrN64) const. which calls the overloaded function:. // lib/Target/Mips/MipsISelLowering.h; SDValue getTargetNode(JumpTableSDNode *N, EVT Ty, SelectionDAG &DAG,; unsigned Flag) const;. 2. Generic address nodes are lowered to some combination of target; independent and machine specific SDNodes (for example:; MipsISD::{Highest, Higher, Hi, Lo}) depending upon relocation model,; ABI, and compilation options. The choice of specific instructions that are to be used is delegated; to ISel which in turn relies on TableGen patterns to choose subtarget; specific instructions. For example, in getAddrLocal, the pseudo-code; generated is:. (add (load (wrapper $gp, %got(sym)), %lo(sym)). where ""%lo"" represents an instance of an SDNode with opcode; ""MipsISD::Lo"", ""wrapper"" indicates one with opcode ""MipsISD::Wrapper"",; and ""%got"" the global table pointer ""getGlobalReg(...)"". The ""add"" is; ""ISD::ADD"", not a target dependent one. 3. A TableGen multiclass pattern ""MipsHiLoRelocs"" is used to define a; template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td; multiclass MipsHiLoRelocs<Instruction Lui, Instruction Addiu,; Register ZeroReg, RegisterOperand GPROpnd> {; def : MipsPat<(MipsHi tglobaladdr:$in), (Lui tglobaladdr:$in)>;; ...; def : MipsPat<(MipsLo tglobaladdr:$in), (Addiu ZeroReg, tglobaladdr:$in)>;; ...; def : MipsPat<(add GPROpnd:$hi, (MipsLo tglobaladdr:$lo)),; (Addiu GPROpnd:$hi, tglobaladdr:$lo)>;;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:1536,wrap,wrapper,1536,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['wrap'],['wrapper']
Integrability," maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:24315,interface,interface,24315,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability," major new extension, it is a good; idea to get consensus with the development community before you start working on; it. Once the design of the new feature is finalized, the work itself should be done; as a series of `incremental changes`_, not as a long-term development branch. .. _incremental changes:. Incremental Development; -----------------------. In the LLVM project, we do all significant changes as a series of incremental; patches. We have a strong dislike for huge changes or long-term development; branches. Long-term development branches have a number of drawbacks:. #. Branches must have mainline merged into them periodically. If the branch; development and mainline development occur in the same pieces of code,; resolving merge conflicts can take a lot of time. #. Other people in the community tend to ignore work on branches. #. Huge changes (produced when a branch is merged back onto mainline) are; extremely difficult to `code review`_. #. Branches are not routinely tested by our nightly tester infrastructure. #. Changes developed as monolithic large changes often don't work until the; entire set of changes is done. Breaking it down into a set of smaller; changes increases the odds that any of the work will be committed to the main; repository. To address these problems, LLVM uses an incremental development style and we; require contributors to follow this practice when making a large/invasive; change. Some tips:. * Large/invasive changes usually have a number of secondary changes that are; required before the big change can be made (e.g. API cleanup, etc). These; sorts of changes can often be done before the major change is done,; independently of that work. * The remaining inter-related work should be decomposed into unrelated sets of; changes if possible. Once this is done, define the first increment and get; consensus on what the end goal of the change is. * Each change in the set can be stand alone (e.g. to fix a bug), or part of a; planned series of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:27655,rout,routinely,27655,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['rout'],['routinely']
Integrability," member expressions. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; int a; static int b;; };; memberExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel``,; ``omp parallel default(none)`` and ``omp taskyield``. Matcher<Stmt>opaqueValueExprMatcher<OpaqueValueExpr>...; Matches opaque va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38458,message,message,38458,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['message'],['message']
Integrability," metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.trunc``' intrinsic returns the first; operand rounded to the nearest integer not larger in magnitude than the; operand. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``trunc`` functions; would and handles error conditions in the same way. .. _int_experimental_noalias_scope_decl:. '``llvm.experimental.noalias.scope.decl``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.experimental.noalias.scope.decl(metadata !id.scope.list). Overview:; """""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. Arguments:; """""""""""""""""""". The ``!id.scope.list`` argument is metadata that is a list of ``noalias``; metadata references. The format is identical to that required for ``noalias``; metadata. This list must have exactly one element. Semantics:; """""""""""""""""""". The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a; noalias scope is declared. When the intrinsic is duplicated, a decision must; also be made about the scope: depending on the reason of the duplication,; the scope might need to be duplicated as well. For example, when the intrinsic is used inside a loop body, and that loop is; unrolled, the associated noalias scope must also be duplicated. Otherwise, the; noalias property it signifies would spill across loop iterations, whereas it; was only valid within a single iteration. .. code-block:: llvm. ; This examples shows two possible positions for noalias.decl and how they impact the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:913476,depend,depending,913476,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability," module units. This is incorrect. Since both definitions of `fun()` has the same; spelling and `T` refers to the same type entity finally. So the program should be; fine. This is tracked in https://github.com/llvm/llvm-project/issues/78850. Using TU-local entity in other units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Module units are translation units. So the entities which should only be local to the; module unit itself shouldn't be used by other units in any means. In the language side, to address the idea formally, the language specification defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:26833,message,messages,26833,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['message'],['messages']
Integrability," must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_EARLY_PRIM_DEALLOC 8 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst:1792,message,message,1792,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,3,['message'],['message']
Integrability," must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_GET_DDID 11 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:1793,message,message,1793,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,2,['message'],['message']
Integrability," must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_HOST_TRAP_ACK 3 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst:1790,message,message,1790,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,1,['message'],['message']
Integrability," must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_HOST_TRAP_ACK 3 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the correspondi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst:1790,message,message,1790,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,1,['message'],['message']
Integrability," must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_HS_TESSFACTOR 2 \- \- \-; MSG_DEALLOC_VGPRS 3 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:1800,message,message,1800,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,1,['message'],['message']
Integrability," must define it as nothing or include a header; that has the define. .. code-block:: c. #if defined(__has_feature) && __has_feature(bounds_safety); #define __counted_by(T) __attribute__((__counted_by__(T))); // ... other bounds annotations; #else #define __counted_by(T) // defined as nothing; // ... other bounds annotations; #endif. // expands to `void foo(int * ptr, size_t count);`; // when extension is not enabled or not available; void foo(int *__counted_by(count) ptr, size_t count);. Other potential applications of bounds annotations; ==================================================. The bounds annotations provided by the ``-fbounds-safety`` programming model; have potential use cases beyond the language extension itself. For example,; static and dynamic analysis tools could use the bounds information to improve; diagnostics for out-of-bounds accesses, even if ``-fbounds-safety`` is not used.; The bounds annotations could be used to improve C interoperability with; bounds-safe languages, providing a better mapping to bounds-safe types in the; safe language interface. The bounds annotations can also serve as documentation; specifying the relationship between declarations. Limitations; ===========. ``-fbounds-safety`` aims to bring the bounds safety guarantee to the C language,; and it does not guarantee other types of memory safety properties. Consequently,; it may not prevent some of the secondary bounds safety violations caused by; other types of safety violations such as type confusion. For instance,; ``-fbounds-safety`` does not perform type-safety checks on conversions between; `__single`` pointers of different pointee types (e.g., ``char *__single`` →; ``void *__single`` → ``int *__single``) beyond what the foundation languages; (C/C++) already offer. ``-fbounds-safety`` heavily relies on run-time checks to keep the bounds safety; and the soundness of the type system. This may incur significant code size; overhead in unoptimized builds and leaving some of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:46910,interoperab,interoperability,46910,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,"['interface', 'interoperab']","['interface', 'interoperability']"
Integrability," mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:8167,synchroniz,synchronization,8167,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['synchroniz'],['synchronization']
Integrability," my-monorepo/submodule-map.txt; echo ""tools/lldb lldb"" >> my-monorepo/submodule-map.txt; echo ""projects/openmp openmp"" >> my-monorepo/submodule-map.txt; echo ""tools/polly polly"" >> my-monorepo/submodule-map.txt; echo ""projects/myproj local/myproj"" >> my-monorepo/submodule-map.txt. # Rewrite history; (; cd my-monorepo; zip-downstream-fork.py \; refs/remotes/umbrella \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --old-repo-prefix=refs/remotes/upstream/split \; --revmap-in=monorepo-map.txt \; --revmap-out=zip-map.txt \; --subdir=llvm \; --submodule-map=submodule-map.txt \; --update-tags; ). # Create the zip branch (assuming umbrella main is wanted).; git -C my-monorepo branch --no-track local/zip/main refs/remotes/umbrella/main. Comments at the top of ``zip-downstream-fork.py`` describe in more; detail how the tool works and various implications of its operation. Importing local repositories; ----------------------------. You may have additional repositories that integrate with the LLVM; ecosystem, essentially extending it with new tools. If such; repositories are tightly coupled with LLVM, it may make sense to; import them into your local mirror of the monorepo. If such repositories participated in the umbrella repository used; during the zipping process above, they will automatically be added to; the monorepo. For downstream repositories that don't participate in; an umbrella setup, the ``import-downstream-repo.py`` tool at; https://github.com/greened/llvm-git-migration/tree/import can help with; getting them into the monorepo. A recipe follows::. # Import downstream repo history into the monorepo.; git -C my-monorepo remote add myrepo https://my.local.mirror.org/myrepo.git; git fetch myrepo. my_local_tags=( refs/tags/release; refs/tags/hotfix ). (; cd my-monorepo; import-downstream-repo.py \; refs/remotes/myrepo \; ${my_local_tags[@]} \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --subdir=myrepo \; --tag-prefix=""myrepo-""; ). # Preserve release branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:34476,integrat,integrate,34476,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['integrat'],['integrate']
Integrability," name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:173423,interface,interface,173423,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability," needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards or; reverse) is O(1) worst case. Testing and setting bits within 128 bits (depends; on size) of the current bit is also O(1). As a general statement,; testing/setting bits in a SparseBitVector is O(distance away from last set bit). .. _dss_coalescingbitvector:. CoalescingBitVector; ^^^^^^^^^^^^^^^^^^^. The CoalescingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:98603,depend,depends,98603,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['depend'],['depends']
Integrability," new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag operation entering the widget. The typelist parameter is; the list of types the data contains. If the list contains one type the; widget understands, it should return this type to notify the manager; that the drop would be accepted, i.e. :. ``` {.cpp}; for (int i = 0; typelist[i] != kNone; ++i) {; if (typelist[i] == gVirtualX->InternAtom(""application/root"")); // accept ""application/root"" DND type; return typelist[i];; }; // other type not accepted; return kNone;; ```. `Atom_t HandleDNDposition(Int_t x,Int_t y,Atom_t action,Int_t xroot,; Int_t yroot)` - this; method should be used to handle the drag position in widget coordinates; (`x,y`) or in root coordinates (`xroot,yroot`). ``` {.cpp}; // get the pad over which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110775,message,messages,110775,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['messages']
Integrability," new object-oriented implementation, written in C++,; of the popular MINUIT minimization package. These new version provides basically; all the functionality present in the old Fortran version, with almost equivalent; numerical accuracy and computational performances. Furthermore, it contains new; functionality, like the possibility to set single side parameter limits or the; FUMILI algorithm, which is an optimized method for least square and log likelihood; minimizations. The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1067,integrat,integrate,1067,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,1,['integrat'],['integrate']
Integrability," no attribute 'GetLength'; >>>. The deletion of ``GetLength`` method with ``del`` can be omitted; if both ``MyClass.GetLength`` and ``MyClass.__len__`` should be valid. C++ callbacks; -------------. If you are familiar with the Python C-API, it may sometimes be beneficial to; add unique optimizations to your C++ classes to be picked up by the; pythonization layer.; There are two conventional function that cppyy will look for (no registration; of callbacks needed):. .. code-block:: C++. static void __cppyy_explicit_pythonize__(PyObject* klass, const std::string&);. which is called *only* for the class that declares it.; And:. .. code-block:: C++. static void __cppyy_pythonize__(PyObject* klass, const std::string&);. which is also called for all derived classes. Just as with the Python callbacks, the first argument will be the Python; class proxy, the second the C++ name, for easy filtering.; When called, cppyy will be completely finished with the class proxy, so any; and all changes are fair game, including the low-level ones such as the replacement of; iteration or buffer protocols. An example pythonization replacing ``MyClass.GetLength`` method with Python's ``__len__``; done with the C++ callbacks:. .. code-block:: python. >>> import cppyy; >>> ; >>> cppyy.cppdef(""""""; ... #include <Python.h>; ...; ... namespace MyNamespace {; ... class MyClass {; ... public:; ... MyClass(int i) : fInt(i) {}; ... int GetLength() { return fInt; }; ... ; ... private:; ... int fInt;; ... ; ... // pythonizations; ... public:; ... static void __cppyy_pythonize__(PyObject* klass, const std::string&){; ... auto cppName = ""GetLength"";; ... auto pythonizationName = ""__len__"";; ... auto* methodObject = PyObject_GetAttrString(klass, cppName);; ... PyObject_SetAttrString(klass, pythonizationName, methodObject);; ... Py_DECREF(methodObject);; ... PyObject_DelAttrString(klass, cppName);; ... }; ... };; ... }""""""); True ; >>> m = cppyy.gbl.MyNamespace.MyClass(42); >>> len(m); 42; >>> m.GetLength();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/pythonizations.rst:4016,protocol,protocols,4016,bindings/pyroot/cppyy/cppyy/doc/source/pythonizations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/pythonizations.rst,1,['protocol'],['protocols']
Integrability," not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15962,interface,interface,15962,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability," not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130760,interface,interfaces,130760,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interfaces']
Integrability," note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interfa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7307,interface,interface,7307,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['interface'],['interface']
Integrability," object. This; is useful in particular in roottest. Use this in hadd; and TFileMerger. TROOT. New routine CloseFiles used automatically shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:1466,rout,routines,1466,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['rout'],['routines']
Integrability," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10558,interface,interface,10558,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability," of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-block:: c++. bool run(Module &M) {; InitializeAliasAnalysis(this);; // Perform analysis here...; return false;; }. Required methods to override; ----------------------------. You must override the ``getAdjustedAnalysisPointer`` method on all subclasses; of ``AliasAnalysis``. An example implementation of this method would look like:. .. code-block:: c++. void *getAdjustedAnalysisPointer(const void* ID) override {; if (ID == &AliasAnalys",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:11064,depend,dependencies,11064,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependencies']
Integrability," of base units from 2019, where the Planck constant, the Boltzmann constant, the elementary electric charge and the Avogadro constant are exact numerical values. See <https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units>. Note that with this new definition the functions `TMath::HUncertainty()`, `TMath::KUncertainty()`, `TMath::QeUncertainty()` and `TMath::NaUncertainty()` all return a `0.0` value.; - Due to some planned major improvements to `RVec`, the layout of `RVec` objects will change in a backward-incompatible way between v6.24 and v6.26.; Because of this, we now print a warning if an application is reading or writing a `ROOT::RVec` object from/to a ROOT file. We assume this is an; exceedingly rare case, as the ROOT interface typically used to manipulate `RVec`s is `RDataFrame`, and `RDataFrame` performs an on-the-fly; `RVec <-> std::vector` conversion rather than writing `RVec`s to disk. Note that, currently, `RVecs` written e.g. in a `TTree` cannot be read back; using certain ROOT interfaces (e.g. `TTreeReaderArray`, `RDataFrame` and the experimental `RNTuple`). All these limitations will be lifted in v6.26.; - Portable implementation of the RANLUX++ generator, see [RanluxppEngine](https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html) and [our blog post](https://root.cern/blog/ranluxpp/). ## TMVA. - Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power. ## RooFit Libraries. - Extension / updates of the doxygen reference guide.; - Allow for removing RooPlot from global directory management, see [RooPlot::AddDirectory](https://root.cern/doc/v624/classRooPlot.html#a47f7ba71dcaca30ad9ee295dee89c9b8); and [RooPlot::SetDirectory](https://root.cern/doc/v624/classRooPlot.html#a5938bc6d5c47d94c2f04fdcc10c1c026); - Hash-assisted finding of elements in RooWorkspace. Large RooWorksp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:13286,interface,interfaces,13286,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['interface'],['interfaces']
Integrability," of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]. ### Primitive Shapes. #### Boxes - TGeoBBox Class. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to; compute and store the parameters of their minimal bounding box. The; bounding boxes are essential to optimize navigation algorithms.; Therefore all other primitives derive from **`TGeoBBox`**. Since the; minimal bounding box is not necessary centered in the origin, any box; allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive; constructors automatically compute the bounding box parameters. Users; shoul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:25657,interface,interface,25657,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability, of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142965,depend,dependence,142965,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependence']
Integrability," of programs that translates target; description (``.td``) files into C++ code and other output formats. Most; users of LLVM will not need to use this program. It is used only for; writing parts of the compiler, debugger, and LLVM target backends. The details of the input and output of the :program:`*-tblgen` programs is; beyond the scope of this short introduction; please see the :doc:`TableGen; Overview <../TableGen/index>` for an introduction and for references to; additional TableGen documents. The *filename* argument specifies the name of the Target Description (``.td``); file that TableGen processes. OPTIONS; -------. General Options; ~~~~~~~~~~~~~~~. .. option:: -help. Print a description of the command line options. .. option:: -help-list. Print a description of the command line options in a simple list format. .. option:: -D=macroname. Specify the name of a macro to be defined. The name is defined, but it; has no particular value. .. option:: -d=filename. Specify the name of the dependency filename. .. option:: -debug. Enable debug output. .. option:: -dump-json. Print a JSON representation of all records, suitable for further; automated processing. .. option:: -I directory. Specify where to find other target description files for inclusion. The; ``directory`` value should be a full or partial path to a directory that; contains target description files. .. option:: -null-backend. Parse the source files and build the records, but do not run any; backend. This is useful for timing the frontend. .. option:: -o filename. Specify the output file name. If ``filename`` is ``-``, then; :program:`*-tblgen` sends its output to standard output. .. option:: -print-records. Print all classes and records to standard output (default backend option). .. option:: -print-detailed-records. Print a detailed report of all global variables, classes, and records; to standard output. .. option:: -stats. Print a report with any statistics collected by the backend. .. option:: -time-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:1366,depend,dependency,1366,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['depend'],['dependency']
Integrability," of the Hist library (i.e. TH1::Fit, TGraph::Fit/; ; The Fitter class has been changed to retain a pointer to the Minimizer and Objective function of the last fit. The objective function depends on a reference to the data and the model function, therefore the objective function pointer is valid as far the data and the model function are maintained alive.; ; The library provides the implementation of standard objective function like the Chi2 function, the Poisson likelihood function (for binned likelihood fits) and the loh likelihood function (for unbinned fits). These standard objective functions can be created with or without gradient functionality. In the first case the minimization will be performed using the gradient provided by the function. These functions can also be used in specialized fitting methods like Fumili or the GSL non-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUser",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:2750,interface,interface,2750,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['interface'],['interface']
Integrability," of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15913,depend,dependent,15913,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability," of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7339,interface,interface,7339,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability," of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31342,protocol,protocol,31342,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['protocol'],['protocol']
Integrability," of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:24050,adapter,adapter,24050,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['adapter'],['adapter']
Integrability," on different platforms, hinting to a PyROOT; # issue. We disable the rf617 tutorial for now. as the covered RooFit; # functionality is also covered by rf617 (the multidimensional case).; list(APPEND roofit_veto roofit/rf615_simulation_based_inference.py). if (NOT dataframe); # RDataFrame; list(APPEND dataframe_veto dataframe/*.C dataframe/*.py); # RDataFrame tutorial in graphs; list(APPEND dataframe_veto graphs/timeSeriesFromCSV_TDF.C); # TMVA tutorials dependent on RDataFrame; list(APPEND dataframe_veto tmva/tmva*.C); list(APPEND dataframe_veto tmva/TMVA_SOFIE_RDataFrame*.C); list(APPEND dataframe_veto tmva/TMVA_SOFIE_RDataFrame*.py); list(APPEND dataframe_veto tmva/TMVA_SOFIE_Inference.py); list(APPEND dataframe_veto tmva/RBatchGenerator_NumPy.py); list(APPEND dataframe_veto tmva/RBatchGenerator_TensorFlow.py); list(APPEND dataframe_veto tmva/RBatchGenerator_PyTorch.py); list(APPEND dataframe_veto tmva/RBatchGenerator_filters_vectors.py); # RooFit tutorial depending on RDataFrame; list(APPEND dataframe_veto roofit/rf408*); endif(). if(NOT sqlite); # RDF+SQlite tutorials; list(APPEND dataframe_veto dataframe/*SQlite*); endif(); if(NOT davix); list(APPEND dataframe_veto dataframe/df027_SQliteDependencyOverVersion.C); list(APPEND dataframe_veto dataframe/df028_SQliteIPLocation.C); list(APPEND dataframe_veto dataframe/df029_SQlitePlatformDistribution.C); list(APPEND dataframe_veto dataframe/df030_SQliteVersionsOfROOT.C); endif(). if(MACOSX_VERSION VERSION_EQUAL 10.13); list(APPEND dataframe_veto dataframe/df103_NanoAODHiggsAnalysis.*); endif(). if(NOT geom); set(geom_veto geom/*.C); endif(). if(NOT ROOT_proof_FOUND); set(proof_veto roostats/StandardFrequentistDiscovery.C); endif(). if(NOT ROOT_spectrum_FOUND); set(spectrum_veto spectrum/*.C); endif(). if(NOT ROOT_roofit_FOUND); set(roofit_veto roofit/*.C roofit/*.py; roostats/*.C roostats/*.py; histfactory/*.C histfactory/*.py); else(); if(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 4 AND NOT llvm13_broken_tests); # The follow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:5011,depend,depending,5011,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depending']
Integrability, on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57184,depend,dependent,57184,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability," on the final SelectionDAG, with nodes that must be scheduled together; bundled into a single scheduling-unit node, and with immediate operands and; other nodes that aren't relevant for scheduling omitted. The option ``-filter-view-dags`` allows to select the name of the basic block; that you are interested to visualize and filters all the previous; ``view-*-dags`` options. .. _Build initial DAG:. Initial SelectionDAG Construction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The initial SelectionDAG is na\ :raw-html:`&iuml;`\ vely peephole expanded from; the LLVM input by the ``SelectionDAGBuilder`` class. The intent of this pass; is to expose as much low-level, target-specific details to the SelectionDAG as; possible. This pass is mostly hard-coded (e.g. an LLVM ``add`` turns into an; ``SDNode add`` while a ``getelementptr`` is expanded into the obvious; arithmetic). This pass requires target-specific hooks to lower calls, returns,; varargs, etc. For these features, the :raw-html:`<tt>` `TargetLowering`_; :raw-html:`</tt>` interface is used. .. _legalize types:; .. _Legalize SelectionDAG Types:; .. _Legalize SelectionDAG Ops:. SelectionDAG LegalizeTypes Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Legalize phase is in charge of converting a DAG to only use the types that; are natively supported by the target. There are two main ways of converting values of unsupported scalar types to; values of supported types: converting small types to larger types (""promoting""),; and breaking up large integer types into smaller ones (""expanding""). For; example, a target might require that all f32 values are promoted to f64 and that; all i1/i8/i16 values are promoted to i32. The same target might require that; all i64 values be expanded into pairs of i32 values. These changes can insert; sign and zero extensions as needed to make sure that the final code has the same; behavior as the input. There are two main ways of converting values of unsupported vector types to; value of supported types",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:40773,interface,interface,40773,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interface']
Integrability," on; occasion if the C++ side takes ownership (otherwise, prefer either; ``array`` from the builtin module ``array`` or ``ndarray`` from Numpy). The low-level module adds the following functions:. * **ll.malloc**: an interface on top of C's malloc.; Use it as a template with the number of elements (not the number types) to; be allocated.; The result is a ``cppyy.LowLevelView`` with the proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.malloc[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. The actual C malloc can also be used directly, through ``cppyy.gbl.malloc``,; taking the number of *bytes* to be allocated and returning a ``void*``. * **ll.free**: an interface to C's free, to deallocate memory allocated by; C's malloc.; To continue to example above:. .. code-block:: python. >>> cppyy.ll.free(arr); >>>. The actual C free can also be used directly, through ``cppyy.gbl.free``. * **ll.array_new**: an interface on top of C++'s ``new[]``.; Use it as a template; the result is a ``cppyy.LowLevelView`` with the; proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.array_new[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. * **ll.array_delete**: an interface on top of C++'s ``delete[]``.; To continue to example above:. .. code-block:: python. >>> cppyy.ll.array_delete(arr); >>>. `argc/argv`; -----------. C/C++'s ``main`` function can take the number of command line arguments; (``argc``) and their values (``argv``) as function arguments.; A common idiom has these values subsequently passed on to the entry point of; e.g. a framework or library.; Since the type of ``argv`` in particular (``char*[]``) is clunky to work with; in Python, the low level module contains two convenient helper functions,; ``ll.argc()`` and ``ll.argv()``, that convert the command line arguments as; provided by Python's ``sys`` module, into typed values t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:10553,interface,interface,10553,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability," once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. - *ExecutionSession* represents the JIT'd program and provides context for the; JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the; materializers. - *JITDylibs* provide the symbol tables. - *Layers* (ObjLinkingLayer and CXXLayer) are wrappers around compilers and; allow clients to add uncompiled program representations supported by those; compilers to JITDylibs. - *ResourceTrackers* allow you to remove code. Several other important APIs are used explicitly. JIT clients need not be aware; of them, but Layer authors will use them:. - *MaterializationUnit* - When XXXLayer::add is invoked it wraps the given; program representation (in this example, C++ source) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:11601,wrap,wrappers,11601,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrappers']
Integrability," only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89372,message,message,89372,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability," only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named constructor idiom and return an ``Expected<T>``:. .. code-block:: c++. class Foo {; public:. static Expected<Foo> Create(Resource R1, Resource R2) {; Error Err = Error::success();; Foo F(R1, R2, Err);; if (Err); return std::move(Err);; return std::move(F);; }. private:. Foo(Resource R1, Resource R2, Error &Err) {; ErrorAsOutParamet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:33150,wrap,wrapped,33150,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapped']
Integrability," opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instanti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58366,depend,dependent,58366,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependent']
Integrability," operands are already available, and pipeline JFPU1 is ready to; serve another instruction. So the instruction can be immediately issued on the; JFPU1 pipeline. That is demonstrated by the fact that the instruction only; spent 1cy in the scheduler's queue. There is a gap of 5 cycles between the write-back stage and the retire event.; That is because instructions must retire in program order, so [1,0] has to wait; for [0,2] to be retired first (i.e., it has to wait until cycle 10). In the example, all instructions are in a RAW (Read After Write) dependency; chain. Register %xmm2 written by vmulps is immediately used by the first; vhaddps, and register %xmm3 written by the first vhaddps is used by the second; vhaddps. Long data dependencies negatively impact the ILP (Instruction Level; Parallelism). In the dot-product example, there are anti-dependencies introduced by; instructions from different iterations. However, those dependencies can be; removed at register renaming stage (at the cost of allocating register aliases,; and therefore consuming physical registers). Table *Average Wait times* helps diagnose performance issues that are caused by; the presence of long latency instructions and potentially long data dependencies; which may limit the ILP. Last row, ``<total>``, shows a global average over all; instructions measured. Note that :program:`llvm-mca`, by default, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. When performance is mostly limited by the lack of hardware; resources, the delta between the two counters is small. However, the number of;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:25293,depend,dependencies,25293,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability," operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_GET_DDID 11 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC); s_sendmsg sendmsg(MSG_GET_DOORBELL). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:2730,depend,depending,2730,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,8,"['depend', 'message']","['depending', 'message']"
Integrability," operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1400,interface,interfaces,1400,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['interface'],['interfaces']
Integrability," or goose.; 3. C-language family front-end toolkit. The world needs better compiler tools, tools which are built as libraries. This; design point allows reuse of the tools in new and novel ways. However, building; the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and avoiding tying the libraries to a; specific use. Oh yeah, did I mention that we want the resultant libraries to; be as fast as possible? :). This front-end is built as a component of the LLVM toolkit that can be used; with the LLVM backend or independently of it. In this spirit, the API has been; carefully designed as the following components:; ; libsupport - Basic support library, reused from LLVM. libsystem - System abstraction library, reused from LLVM.; ; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-level declaration; at a time, allowing clients to use decl-at-a-time processing,; build up entire translation units, or even build 'whole; program' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntacti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:1298,depend,depends,1298,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability," or pointer, instead of the direct; object, and ``ctypes.c_void_p`` can pass through all pointer types.; The addresses will be adjusted internally by cppyy. Note that ``ctypes.c_char_p`` is expected to be a NULL-terminated C string,; not a character array (see the `ctypes module`_ documentation), and that; ``ctypes.c_bool`` is a C ``_Bool`` type, not C++ ``bool``. `Memory`; --------. C++ has three ways of allocating heap memory (``malloc``, ``new``, and; ``new[]``) and three corresponding ways of deallocation (``free``,; ``delete``, and ``delete[]``).; Direct use of ``malloc`` and ``new`` should be avoided for C++ classes, as; these may override ``operator new`` to control their own allocation.; However these low-level allocators can be necessary for builtin types on; occasion if the C++ side takes ownership (otherwise, prefer either; ``array`` from the builtin module ``array`` or ``ndarray`` from Numpy). The low-level module adds the following functions:. * **ll.malloc**: an interface on top of C's malloc.; Use it as a template with the number of elements (not the number types) to; be allocated.; The result is a ``cppyy.LowLevelView`` with the proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.malloc[int](4) # allocates memory for 4 C ints; >>> print(len(arr)); 4; >>> print(type(arr[0])); <type 'int'>; >>>. The actual C malloc can also be used directly, through ``cppyy.gbl.malloc``,; taking the number of *bytes* to be allocated and returning a ``void*``. * **ll.free**: an interface to C's free, to deallocate memory allocated by; C's malloc.; To continue to example above:. .. code-block:: python. >>> cppyy.ll.free(arr); >>>. The actual C free can also be used directly, through ``cppyy.gbl.free``. * **ll.array_new**: an interface on top of C++'s ``new[]``.; Use it as a template; the result is a ``cppyy.LowLevelView`` with the; proper type and size:. .. code-block:: python. >>> arr = cppyy.ll.array_new[int](4) # allocates memory for 4 C ints; >>> print(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:9780,interface,interface,9780,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability," or return their; inverse:. ``` {.cpp}; Rotation3D r1(...);; r1.Invert(); //invert the rotation modifying its content; Rotation3D r2 =r1.Inverse(); //return the inverse in a new; //rotation class; ```. We have used rotation as examples, but all these operations can be; applied to all the transformation classes. #### Set/GetComponents Methods. Common methods to all transformations are `Get` and `SetComponents`.; They can be used to retrieve all the scalar values on which the; transformation is based. ``` {.cpp}; RotationX rx;; rx.SetComponents(1.); //set agle of the X rotation; double d[9] = {........};; Rotation3D r;; r.SetComponents(d,d+9); //set 9 components of 3D rotation; double d[16];; LorentzRotation lr;; lr.GetComponents(d,d+16); //get 16 components of a LorentzRotation; TMatrixD(3,4) m;; Transform3D t;; t.GetComponens(m); //fill 3x4 matrix with components of t; ```. The` GetComponents` and `SetComponents` methods can be used with a; signature based iterators or by using any foreign matrix which; implements the `operator(i,j)` or a different signatures depending on; the transformation type. For more details on all methods see the; reference documentation of any specific transformation class. ### Example with External Packages. #### Connection to Linear Algebra Classes. It is possible to use the vector and rotation classes together with the; linear algebra classes and to set and get the contents of any 3D or 4D; vector from a linear algebra vector class which implements an iterator; or something which behaves like an iterator. For example a pointer to a; C array (double`*`) behaves like an iterator. It is then assumed that; the coordinates, like (`x,y,z`) will be stored contiguously. ``` {.cpp}; TVectorD r2(N); //ROOT Linear Algebra Vector containing; //many vectors; XYZVector v2;; //construct vector from x=r[INDEX], y=r[INDEX+1], z=r[INDEX+2]; v2.SetCoordinates(&r2[INDEX],&r2[index]+3);; ```. To fill a linear algebra vector from a 3D or 4D vector, with; `GetC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:96783,depend,depending,96783,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['depend'],['depending']
Integrability," other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you used this class in your own; implementations, just multiply the underlying RooAbsReal function with the; scale factor and create a RooRealBinding, e.g.:; ```c++; RooProduct scaledFunc{""scaled_func"", """", func, scaleFactor};; RooRealBinding scaleBind(scaledFunc, x) ;; ```; instead of:; ```c++; RooRealBinding binding(func, x) ;; RooScaledFunc scaledBinding(binding, scaleFactor);; ```; 3. The `RooAbsRootFinder`, which was the base class of `RooBrentRootFinder`.; The `RooAbsRootFinder` was only used as the base class of; `RooBrentRootFinder`, which is an implementation detail of several; RooFit/RooStats functions. However, polymorphism never not relevant for root; finding, so the `RooAbsRootFinder` is removed. In the rare case where you; might have used it, p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14959,interface,interface,14959,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interface']
Integrability," owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phabricator; -------------------------------. Phabricator allows you to add inline comments as well as overall comments; to a revision. To add an inline comment, select the lines of code you want; to comment on by clicking and dragging the line numbers in the diff pane.; When you have added all your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10112,interface,interface,10112,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,2,['interface'],['interface']
Integrability," pad that is a cleanup.; %res = landingpad { ptr, i32 }; cleanup; ;; A landing pad which can catch an integer and can only throw a double.; %res = landingpad { ptr, i32 }; catch ptr @_ZTIi; filter [1 x ptr] [ptr @_ZTId]. .. _i_catchpad:. '``catchpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchpad within <catchswitch> [<args>*]. Overview:; """""""""""""""""". The '``catchpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; begins a catch handler --- one where a personality routine attempts to transfer; control to catch an exception. Arguments:; """""""""""""""""""". The ``catchswitch`` operand must always be a token produced by a; :ref:`catchswitch <i_catchswitch>` instruction in a predecessor block. This; ensures that each ``catchpad`` has exactly one predecessor block, and it always; terminates in a ``catchswitch``. The ``args`` correspond to whatever information the personality routine; requires to know if this is an appropriate handler for the exception. Control; will transfer to the ``catchpad`` if this is the first appropriate handler for; the exception. The ``resultval`` has the type :ref:`token <t_token>` and is used to match the; ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other nested EH; pads. Semantics:; """""""""""""""""""". When the call stack is being unwound due to an exception being thrown, the; exception is compared against the ``args``. If it doesn't match, control will; not reach the ``catchpad`` instruction. The representation of ``args`` is; entirely target and personality function-specific. Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad``; instruction must be the first non-phi of its parent basic block. The meaning of the tokens produced and consumed by ``catchpad`` and other ""pad""; instructions is described in the; `Windows exception handling documentation\ <ExceptionHandling.html#wineh>`_. When a ``catchpad`` ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:484153,rout,routine,484153,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routine']
Integrability," passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34.; They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. - `RooAbsArg::clientIterator()`: use `clients()` and `begin()`, `end()` or range-based loops instead; - `RooAbsArg::valueClientIterator()`: use `valueClients()`; - `RooAbsArg::shapeClientIterator()`: use `shapeClients()`; - `RooAbsArg::serverIterator()`: use `servers()`; - `RooAbsArg::valueClientMIterator()`: use `valueClients()`; - `RooAbsArg::shapeClientMIterator()`: use `shapeClients()`; - `RooAbsArg::serverMIterator()`: use `servers()`. - `RooAbsCollection::createIterator()`: use `begin()`, `end()` and range-based for loops; - `RooAbsCollection::iterator()`: same; - `RooAbsCollection::fwdIterator()`: same. - `RooWorkspace::componentIterator()`: use `RooWorkspace::components()` with range-based loop. ### Deprecation of legacy test statistics classes in public interface. Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. * RooAbsTestStatistic; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:11926,interface,interfaces,11926,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability," path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:341172,depend,depend,341172,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability," pointer that outlives the call.; To be precise, a pointer is captured if one or more of the following conditions; hold:. 1. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be read from the place by the caller after this call; exits. .. code-block:: llvm. @glb = global ptr null; @glb2 = global ptr null; @glb3 = global ptr null; @glbi = global i32 0. define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {; store ptr %a, ptr @glb ; %a is captured by this call. store ptr %b, ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below; store ptr null, ptr @glb2. store ptr %c, ptr @glb3; call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured; store ptr null, ptr @glb3. %i = ptrtoint ptr %d to i64; %j = trunc i64 %i to i32; store i32 %j, ptr @glbi ; %d is captured. ret ptr %e ; %e is captured; }. 2. The call stores any bit of the pointer carrying information into a place,; and the stored bits can be safely read from the place by another thread via; synchronization. .. code-block:: llvm. @lock = global i1 true. define void @f(ptr %a) {; store ptr %a, ptr* @glb; store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb; store ptr null, ptr @glb; ret void; }. 3. The call's behavior depends on any bit of the pointer carrying information. .. code-block:: llvm. @glb = global i8 0. define void @f(ptr %a) {; %c = icmp eq ptr %a, @glb; br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a; BB_EXIT:; call void @exit(); unreachable; BB_CONTINUE:; ret void; }. 4. The pointer is used in a volatile access as its address. .. _volatile:. Volatile Memory Accesses; ------------------------. Certain memory accesses, such as :ref:`load <i_load>`'s,; :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be; marked ``volatile``. The optimizers must not change the number of; volatile operations or change their order of execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:145145,synchroniz,synchronization,145145,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronization']
Integrability," pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531810,rout,routine,531810,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routine']
Integrability," potential future concurrency. The second reason is to keep in mind potential future pass concurrency, for; example parallelizing function passes over different functions in a CGSCC or; module. Since passes can ask for a cached analysis result, allowing passes to; trigger outer level analysis computation could result in non-determinism if; concurrency was supported. A related limitation is that outer level IR analyses; that are used must be immutable, or else they could be invalidated by changes to; inner level IR. Outer analyses unused by inner passes can and often will be; invalidated by changes to inner level IR. These invalidations happen after the; inner pass manager finishes, so accessing mutable analyses would give invalid; results. The exception to not being able to access outer level analyses is accessing; function analyses in loop passes. Loop passes often use function analyses such; as the dominator tree. Loop passes inherently require modifying the function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate as few analysis results as possible to keep; compile times as low as possible. There are two ways to deal with potentially invalid analysis results. One is; to simply force clear the results. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:10841,depend,depend,10841,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['depend'],['depend']
Integrability," preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library (e.g.; libxml) it needs to be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] import Foo.*;; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:15384,depend,depends,15384,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['depends']
Integrability," problem with [Cross-Origin Request](https://developer.mozilla.org/en/http_access_control) can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself. ### Binary file-based monitoring (not recommended). Theoretically, one could use binary ROOT files to implement monitoring.; With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats. First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate. The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol.; There is no http file locking mechanism (at least not for standard web servers),; therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add ""+"" sign at the end of the file name. Of course, it only could work for small files. If somebody still wants to use monitoring of data from ROOT files, could try link like:. - <https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000>. In this particular case, the histogram is not changing. ## JSROOT API. JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications. Many differen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:33002,protocol,protocol,33002,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['protocol'],['protocol']
Integrability," program. Motivating Examples of Convergence Control; ==========================================. (This section is informative.). Unstructured control flow; -------------------------. Consider an example of how jump threading removes structure in a way that can; make semantics non-obvious without the convergence intrinsics described in this; document:. .. code-block:: llvm. void example_original() {; entry:; ...; br i1 %cond1, label %then1, label %mid. then1:; ...; %cond2 = ...; br label %mid. mid:; %flag = phi i1 [ true, %entry ], [ %cond2, %then1 ]; br i1 %flag, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier(); ...; br label %end. end:; }. void example_jumpthreaded() {; entry:; ...; br i1 %cond1, label %then1, label %then2. then1:; ...; %cond2 = ...; br i1 %cond2, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier(); ...; br label %end. end:; }. Is the control barrier guaranteed to synchronize among the same set of threads; in both cases? Different implementations in the literature may give different; answers to this question:. * In an implementation that reconverges at post-dominators, threads reconverge; at ``mid`` in the first version, so that all threads (within a subgroup/wave); that execute the control barrier do so together. In the second version,; threads that reach the control barrier via different paths synchronize; separately: the first (and only) post-dominator is ``end``, so threads do not; reconverge before then. * An implementation that sorts basic blocks topologically and ensures maximal; reconvergence for each basic block would behave the same way in both; versions. We generally take the stance that reconvergence in acyclic control flow must; be maximal. The compiler frontend could augment the original code as follows:. .. code-block:: llvm. define void @example_original() convergent {; entry:; %entry = call token @llvm.experimental.convergence.entry(); ...; br i1 %cond1, label %then1, label %mid. th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:9689,synchroniz,synchronize,9689,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['synchroniz'],['synchronize']
Integrability," properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description interfaces`_ for; particular targets. These machine descriptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; target-specific issues. The code for the target-independent JIT lives in; ``lib/ExecutionEngine/JIT``. Depending on which part of the code generator you are interested in working on,; different pieces of this will be useful to you. In any case, you should be; familiar with the `target description`_ and `machine code representation`_; classes. If you want to add a backend for a new target, you will need to; `implement the target description`_ classes for your new target and understand; the :doc:`LLVM code representation <LangRef>`. If you are interested in; implemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:2104,interface,interfaces,2104,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability," pull request title and description as the commit message.; You can do this manually with an interactive git rebase or with GitHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4853,interface,interface,4853,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['interface'],['interface']
Integrability," purpose of this section, ``bitcast`` as well as the following operations; are not ""floating-point math operations"": ``fneg``, ``llvm.fabs``, and; ``llvm.copysign``. These operations act directly on the underlying bit; representation and never change anything except possibly for the sign bit. For floating-point math operations, unless specified otherwise, the following; rules apply when a NaN value is returned: the result has a non-deterministic; sign; the quiet bit and payload are non-deterministically chosen from the; following set of options:. - The quiet bit is set and the payload is all-zero. (""Preferred NaN"" case); - The quiet bit is set and the payload is copied from any input operand that is; a NaN. (""Quieting NaN propagation"" case); - The quiet bit and payload are copied from any input operand that is a NaN.; (""Unchanged NaN propagation"" case); - The quiet bit is set and the payload is picked from a target-specific set of; ""extra"" possible NaN payloads. The set can depend on the input operand values.; This set is empty on x86 and ARM, but can be non-empty on other architectures.; (For instance, on wasm, if any input NaN does not have the preferred all-zero; payload or any input NaN is an SNaN, then this set contains all possible; payloads; otherwise, it is empty. On SPARC, this set consists of the all-one; payload.). In particular, if all input NaNs are quiet (or if there are no input NaNs), then; the output NaN is definitely quiet. Signaling NaN outputs can only occur if they; are provided as an input value. For example, ""fmul SNaN, 1.0"" may be simplified; to SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this shou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:159277,depend,depend,159277,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62278,interface,interface,62278,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability," recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30792,wrap,wrapped,30792,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapped']
Integrability, requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unkno,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128941,depend,dependent,128941,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability," requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22494,interface,interface,22494,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['interface'],['interface']
Integrability," results during tracking. A) If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an `extrusion`.; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131433,depend,depends,131433,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depends']
Integrability," return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6924,depend,depends,6924,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['depends']
Integrability," revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to define; variable bin sizes of a ROOT histogram. All we need to know is the interface; of the relevant ROOT class and its methods (from the ROOT documentation):. ``` {.cpp}; TH1F(const char* name , const char* title , Int_t nbinsx , const Double_t* xbins); ```. Here is the Python code:. ``` {.python}; import ROOT; from array import array; arrBins = array('d' ,(1 ,4 ,9 ,16) ) # array of bin edges; histo = ROOT.TH1F(""hist"", ""hist"", len(arrBins)-1, arrBins); # fill it with equally spaced numbers; for i in range (1 ,16) :; histo.Fill(i); histo.Draw (); ```. ## Custom code: from C++ to Python ##; The ROOT interpreter and type sytem offer interesting possibilities when it comes; to JITting of C++ code.; Take for example this header file, containing a class and a function. ```{.cpp}; // file cpp2pythonExample.h; #include ""stdio.h"". class A{; public:; A(int i):m_i(i){}; int getI() const {return m_i;}; private:; int m_i=0;; };. void printA(const A& a ){; printf (""The value of A instance is %i.\n"",a.getI());; }; ```. ```{ .python }; >>> import ROOT; >>> ROOT.gInterpreter.ProcessLine('#include ""cpp2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:2932,interface,interface,2932,documentation/primer/root_in_python.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md,1,['interface'],['interface']
Integrability," sample2[n2] containing the data; ; ROOT::Math::GoFTest goftest(n1, sample1, n2, sample2);; double pValueAD = goftest.AndersonDarling2SamplesTest();; double pValueKS = goftest.KolmogorovSmirnov2SamplesTest();; ; The class can return optionally also the test statistics instead of; the p value.; Example 2: perform a 1 sample test with a pre-defined; distribution starting from a data set sample[n]. ROOT::Math::GoFTest goftest(n, sample, ROOT::Math::GoFTest::kGaussian);; double pValueAD = goftest.AndersonDarlingTest();; double pValueKS = goftest.KolmogorovSmirnovTest();; . Example 3: perform a 1 sample test with a user-defined; distribution provided as cdf; ; ROOT::Math::Functor1D cdf_func(&ROOT::Math::landau_cdf);; ROOT::Math::GofTest goftest(n, sample, cdf_func, ROOT::Math::GoFTest::kCDF);; double pValueAD = goftest.AndersonDarlingTest();; . Example 4: perform a 1 sample test with a user-defined; distribution provided as pdf. Note that in this case to avoid; integration problems is sometimes recommended to give some; reasonable xmin and xmax values. xmin (and xmax) should however be; smaller (larger) than the minimum (maximum) data value.; ; ROOT::Math::Functor1D pdf_func(&ROOT::Math::landau_pdf);; double xmin = 5*TMath::Min_Element(n,sample);; double xmax = 5*TMath::Max_Element(n,sample);; ROOT::Math::GofTest goftest(n, sample, pdf_func, ROOT::Math::GoFTest::kPDF,xmin,xmax);; double pValueAD = goftest.AndersonDarlingTest();; . The tutorial math/goftest.C is an example on; how to use the ROOT::Math::GofTest class. New class TKDTreeBinning for binning multidimensional data.; ; The class implements multidimensional binning by constructing a; TKDTree inner structure form the data which is used as the bins.; The bins are retrieved as two double*, one for the minimum bin edges,; the other as the maximum bin edges. For one dimension one of these is enough; to correctly define the bins. The bin edges of d-dimensional data is a d-tet; of the bin's thresholds. For example if d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:2183,integrat,integration,2183,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['integrat'],['integration']
Integrability," saved as `int` with `nbits` bits precision. For; more details see the io tutorials `double32.C`. ![Compression and precision of Double32\_t](pictures/030000EA.png). ### Prevent Splitting (//|| ). If you want to prevent a data member from being split when writing it to; a tree, append the characters || right after the comment string. This; only makes sense for object data members. For example:. ``` {.cpp}; EventHeader fEvtHdr; //|| do not split the header; ```. ### Streamers with Special Additions. Most of the time you can let `rootcling` generate a `Streamer` for you.; However if you want to write your own `Streamer `you can do so. For some; classes, it may be necessary to execute some code before or after the; read or write block in the automatic `Streamer`. For example after the; execution of the read block, one can initialize some non persistent; members. There are two reasons why you would need to write your own; Streamer: 1) if you have a non-persistent data member that you want to; initialize to a value depending on the read data members; 2) if you want; or need to handle the schema evolution on your own. Note that an alternative; for those cases is to consider write a schema evolution rule. First, you need to tell `rootcling` not to build a `Streamer `for you.; The input to the `rootcling` command (in the `makefile`) is a list of; classes in a `LinkDef.h` file. For example, the list of classes for; `Event` is listed in `$ROOTSYS/test/EventLinkDef.h`. The ""`-`"" at the; end of the class name tells `rootcling` not to generate a `Streamer`. In; the example, you can see the `Event` class is the only one for which; `rootcling` is instructed not to generate a `Streamer`. ``` {.cpp}; #ifdef __ROOTCLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:49560,depend,depending,49560,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['depend'],['depending']
Integrability," scoping rules; * Same enum in transparent scope refers to same type; * More detailed enum ``repr()`` printing, where possible; * Fix for (extern) explicit template instantiations in namespaces; * Throw objects from an std::tuple a life line; * Global pythonizors now always run on all classes; * Simplified iteraton over STL-like containers defining ``begin()``/``end()``. 2020-09-08: 1.8.2; -----------------. * Add ``cppyy.set_debug()`` to enable debug output for fixing template errors; * Cover more partial template instantiation use cases; * Force template instantiation if necessary for type deduction (i.e. ``auto``). 2020-09-01: 1.8.1; -----------------. * Setup build dependencies with pyproject.toml; * Simplified flow of pointer types for callbacks and cross-derivation; * Pointer-comparing objects performs auto-cast as needed; * Add main dimension for ptr-ptr to builtin returns; * Transparant handling of ptr-ptr to instance returns; * Stricter handling of bool type in overload with int types; * Fix uint64_t template instantiation regression; * Do not filter out enum data for ``__dir__``; * Fix lookup of interpreter-only explicit instantiations; * Fix inconsistent naming of std types with char_traits; * Further hiding of upstream code/dependencies; * Extended documentation. 2020-07-12: 1.8.0; -----------------. * Support mixing of Python and C++ types in global operators; * Capture Cling error messages from cppdef and include in the Python exception; * Add a cppexec method to evalutate statements in Cling's global scope; * Support initialization of ``std::array<>`` from sequences; * Support C++17 style initialization of common STL containers; * Allow base classes with no virtual destructor (with warning); * Support const by-value returns in Python-side method overrides; * Support for cross-language multiple inheritance of C++ bases; * Allow for pass-by-value of ``std::unique_ptr`` through move; * Reduced dependencies on upstream code; * Put remaining upstream code i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:11725,depend,dependencies,11725,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['depend'],['dependencies']
Integrability," section of the class documentation](https://root.cern/doc/master/group__Tutorials.html). ## Build, Configuration and Testing Infrastructure; - `root-config` does not suppress deprecation warnings (-Wno-deprecated-declarations) anymore. This means compilers will now diagnose the use of deprecated interfaces in user code.; - Added new 'builtin_vc' option to bundle a version of Vc within ROOT.; The default is OFF, however if the Vc package is not found in the system the option is switched to; ON if the option 'vc' option is ON.; - Many improvements (provided by Mattias Ellert):; - Build RFIO using dpm libraries if castor libraries are not available; - Add missing glib header path in GFAL module for version > 2; - Search also for globus libraries wouthout the flavour in the name; - Add missing io/hdfs/CMakeLists.txt; - net/globusauth has no installed headers - remove ROOT_INSTALL_HEADERS(); - Add missing pieces to the cmake config that are built by configure: bin/pq2, bin/rootd, bin/xpdtest, initd and xinitd start-up scripts; - Only link to libgfortranbegin.a when it is provided by the compiler; - Don't remove -Wall without also removing -Werror=*; - Don't overwrite the initial value of CMAKE_Fortran_FLAGS. Inconsistent case variant of CMAKE_Fortran_FLAGS; - Use the same sonames in cmake as in configure; - Allow building for ppc64 as well as ppc64le; - Add build instructions for 32 bit ARM; - Add build instructions for System Z (s390 and s390x); - Make sure that the roots wrapper can be executed; - Move gl2ps.h to its own subdir; - Added new 'builtin-unuran' option (provided by Mattias Ellert); - Added new 'builtin-gl2ps' option (provided by Mattias Ellert); - Added new 'macos_native' option (only for MacOS) to disable looking for binaries, libraires and headers for dependent; packages at locations other than native MacOS installations. Needed when wanting to ignore packages from Fink, Brew or Ports.; - Added new 'cuda' option to enable looking for CUDA in the system. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:29571,wrap,wrapper,29571,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,2,"['depend', 'wrap']","['dependent', 'wrapper']"
Integrability," select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request is not mergeable, then that is likely because upstream has been; modified since your pull request was authored in a way that now results in a; merge conflict. You must first resolve this merge conflict in order to merge; your pull request. In order to do that:. ::. git fetch upstream; git rebase upstream/main. Then fix the source files causing merge conflicts and make sure to rebuild and; retest the result. Then:. ::. git add <files with resolved merge conflicts>; git rebase --continue. Finally, you'll need to force push to your branch one more time before you can; merge:. ::. git push -f; gh pr merge --squash --delete-branch. This force push may ask if you intend to push hundreds, or potentially; thousands of patches (depending on how long it's been since your pull request; was initially authored vs. when you intended to merge it). Since you're pushing; to a branch in your fork, this is ok and expected. Github's UI for the pull; request will understand that you're rebasing just your patches, and display; this result correctly with a note that a force push did occur. Checking out another PR locally; -------------------------------; Sometimes you want to review another person's PR on your local machine to run; tests or inspect code in your preferred editor. This is easily done with the; CLI:. ::. gh pr checkout <PR Number>. This is also possible with the web interface and the normal git command line; tools, but the process is a bit more complicated. See GitHub's; `documentation <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/checking-out-pull-requests-locally?platform=linux&tool=webui#modifying-an-inactive-pull-request-locally>`_; on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:6549,depend,depending,6549,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['depend'],['depending']
Integrability," selected elements are written into adjacent memory addresses starting at address '`ptr`', from lower to higher. The mask holds a bit for each vector lane, and is used to select elements to be stored. The number of elements to be stored is equal to the number of active bits in the mask. Arguments:; """""""""""""""""""". The first operand is the input vector, from which elements are collected and written to memory. The second operand is the base pointer for the store, it has the same underlying type as the element of the input vector operand. The third operand is the mask, a vector of boolean values. The mask and the input vector must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.compressstore``' intrinsic is designed for compressing data in memory. It allows to collect elements from possibly non-adjacent lanes of a vector and store them contiguously in memory in one IR operation. It is useful for targets that support compressing store operations and allows vectorizing loops with cross-iteration dependences like in the following example:. .. code-block:: c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:859872,depend,dependences,859872,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependences']
Integrability," sequence of table defining instructions that are described in; :ref:`amdgpu-dwarf-call-frame-instructions`. 6. ``padding`` (array of ubyte). Enough ``DW_CFA_nop`` instructions to make the size of this entry match the; length value above. .. _amdgpu-dwarf-call-frame-instructions:. A.6.4.2 Call Frame Instructions; +++++++++++++++++++++++++++++++. Each call frame instruction is defined to take 0 or more operands. Some of the; operands may be encoded as part of the opcode (see; :ref:`amdgpu-dwarf-call-frame-information-encoding`). The instructions are; defined in the following sections. Some call frame instructions have operands that are encoded as DWARF operation; expressions E (see :ref:`amdgpu-dwarf-operation-expressions`). The DWARF; operations that can be used in E have the following restrictions:. * ``DW_OP_addrx``, ``DW_OP_call2``, ``DW_OP_call4``, ``DW_OP_call_ref``,; ``DW_OP_const_type``, ``DW_OP_constx``, ``DW_OP_convert``,; ``DW_OP_deref_type``, ``DW_OP_fbreg``, ``DW_OP_implicit_pointer``,; ``DW_OP_regval_type``, ``DW_OP_reinterpret``, and ``DW_OP_xderef_type``; operations are not allowed because the call frame information must not depend; on other debug sections. * ``DW_OP_push_object_address`` is not allowed because there is no object; context to provide a value to push. * ``DW_OP_LLVM_push_lane`` and ``DW_OP_LLVM_push_iteration`` are not allowed; because the call frame instructions describe the actions for the whole target; architecture thread, not the lanes or iterations independently. * ``DW_OP_call_frame_cfa`` and ``DW_OP_entry_value`` are not allowed because; their use would be circular. * ``DW_OP_LLVM_call_frame_entry_reg`` is not allowed if evaluating E causes a; circular dependency between ``DW_OP_LLVM_call_frame_entry_reg`` operations. *For example, if a register R1 has a* ``DW_CFA_def_cfa_expression``; *instruction that evaluates a* ``DW_OP_LLVM_call_frame_entry_reg`` *operation; that specifies register R2, and register R2 has a*; ``DW_CFA_def_cfa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:203338,depend,depend,203338,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['depend'],['depend']
Integrability," set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62684,contract,contractions,62684,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contractions']
Integrability," set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting; # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point; # we should deprecate allowing users to set these variables by turning them; # into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:9677,message,message,9677,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,['message'],['message']
Integrability," shared context sensitive information. Output; ======. The llvm::yaml::Output class is used to generate a YAML document from your; in-memory data structures, using traits defined on your data types.; To instantiate an Output object you need an llvm::raw_ostream, an optional; context pointer and an optional wrapping column:. .. code-block:: c++. class Output : public IO {; public:; Output(llvm::raw_ostream &, void *context = NULL, int WrapColumn = 70);. Once you have an Output object, you can use the C++ stream operator on it; to write your native data as YAML. One thing to recall is that a YAML file; can contain multiple ""documents"". If the top level data structure you are; streaming as YAML is a mapping, scalar, or sequence, then Output assumes you; are generating one document and wraps the mapping output; with ""``---``"" and trailing ""``...``"". The WrapColumn parameter will cause the flow mappings and sequences to; line-wrap when they go over the supplied column. Pass 0 to completely; suppress the wrapping. .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyMapType &info) {; Output yout(llvm::outs());; yout << info;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ... On the other hand, if the top level data structure you are streaming as YAML; has a DocumentListTraits specialization, then Output walks through each element; of your DocumentList and generates a ""---"" before the start of each element; and ends with a ""..."". .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyDocListType &docList) {; Output yout(llvm::outs());; yout << docList;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ---; name: Tom; shoe-size: 11; ... Input; =====. The llvm::yaml::Input class is used to parse YAML document(s) into your native; data structures. To instantiate an Input; object you need a StringRef to the entire YAML file, and optionally a context; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:29929,wrap,wrapping,29929,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wrapping']
Integrability," should compile cleanly on all supported platforms. * The changes should not cause any correctness regressions in the ``llvm-test``; suite and must not cause any major performance regressions. * The change set should not cause performance or correctness regressions for the; LLVM tools. * The changes should not cause performance or correctness regressions in code; compiled by LLVM on all applicable targets. * You are expected to address any `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:14465,message,messages,14465,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['messages']
Integrability," should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``importable module unit`` ends with ``.cpp`` instead of ``.cppm``,; then we can't generate a BMI for the ``importable module unit`` by ``--precompile`` option; since ``--precompile`` option now would only run preprocessor, which is equal to `-E` now.; If we want the filename of an ``importable module unit`` ends with other suffixes instead of ``.cppm``,; we could put ``-x c++-module`` in front of the file. For example,. .. code-block:: c++. // Hello.cpp; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Now the filename of the ``module interface`` ends with ``.cpp`` instead of ``.cppm``,; we can't compile them by the original command lines. But we are still able to do it by:. .. code-block:: console. $ clang++ -std=c++20 -x c++-module Hello.cpp --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fprebuilt-module-path=. Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. Module name requirement; ~~~~~~~~~~~~~~~~~~~~~~~. [module.unit]p1 says:. .. code-block:: text. All module-names either beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:9561,interface,interface,9561,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability," should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT_CXX_STDLIB STREQUAL """" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libstdc++"" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libc++"")); message(WARNING ""Resetting default C++ stdlib to use platform default""); set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default"" FORCE); endif(). set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)""); if (NOT(CLANG_DEFAULT_RTLIB STREQUAL """" OR; CLANG_DEFAULT_RTLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_RTLIB STREQUAL ""compiler-rt"")); message(WARNING ""Resetting default rtlib to use platform default""); set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)"" FORCE); endif(). set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)""); if (CLANG_DEFAULT_UNWINDLIB STREQUAL """"); if (CLANG_DEFAULT_RTLIB STREQUAL ""libgcc""); set (CLANG_DEFAULT_UNWINDLIB ""libgcc"" CACHE STRING """" FORCE); endif(); endif(). if (NOT(CLANG_DEFAULT_UNWINDLIB STREQUAL """" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""none"" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""libunwind"")); message(WARNING ""Resetting default unwindlib to use platform default""); set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)"" FORCE); endif(). set(CLANG_DEFAU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:8563,message,message,8563,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability," shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. For example, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so it's equivalent as the local variable is; declared as ``int *l``, so it eventually becomes implicitly; ``__bidi_indexable``. .. code-block:: c. void foo(void) {; typeof(int *) l; // `int *__bidi_indexable` (same as `int *l`); }. The programmers can still explicitly add a bounds annotation on the types named; inside ``typeof``, e.g., ``typeof(int *__bidi_indexable)``, which evaluates to; ``int *__bidi_indexable``. Default pointer types in ``sizeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``sizeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. This means if a bounds annotation; is not specified, the evaluated pointer type is treated identically to a plain C; pointer type. Therefore, ``sizeof(int*)`` remains the same with or without; ``-fbounds-safety``. That said, programmers can explicitly add attribute to the; type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:27435,depend,depending,27435,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['depending']
Integrability," so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; sup",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:3849,synchroniz,synchronization,3849,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['synchroniz'],['synchronization']
Integrability," someone new to LLVM. This label feeds into `the landing page; for new contributors <https://github.com/llvm/llvm-project/contribute>`_. * If you are unsure of what a label is intended to be used for, please see the; `documentation for our labels <https://github.com/llvm/llvm-project/labels>`_. .. _Actively working on fixing:. Actively working on fixing bugs; ===============================. Please remember to assign the bug to yourself if you're actively working on; fixing it and to unassign it when you're no longer actively working on it. You; unassign a bug by removing the person from the ``Assignees`` field. .. _Closing:. Resolving/Closing bugs; ======================. Resolving bugs is good! Make sure to properly record the reason for resolving.; Examples of reasons for resolving are:. * If the issue has been resolved by a particular commit, close the issue with; a brief comment mentioning which commit(s) fixed it. If you are authoring; the fix yourself, your git commit message may include the phrase; ``Fixes #<issue number>`` on a line by itself. GitHub recognizes such commit; messages and will automatically close the specified issue with a reference; to your commit. * If the reported behavior is not a bug, it is appropriate to close the issue; with a comment explaining why you believe it is not a bug, and adding the; ``invalid`` tag. * If the bug duplicates another issue, close it as a duplicate by adding the; ``duplicate`` label with a comment pointing to the issue it duplicates. * If there is a sound reason for not fixing the issue (difficulty, ABI, open; research questions, etc), add the ``wontfix`` label and a comment explaining; why no changes are expected. * If there is a specific and plausible reason to think that a given bug is; otherwise inapplicable or obsolete. One example is an open bug that doesn't; contain enough information to clearly understand the problem being reported; (e.g. not reproducible). It is fine to close such a bug, adding with the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:3991,message,message,3991,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['message'],['message']
Integrability," standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that receives two iterators to it. ```{.cpp}; // Size of the array; const int n = 100;. // Vector v with random values; vector<double> v(n);; std::generate(v.begin(), v.end(), rand);. // Weight vector w; vector<double> w(n);; std::fill(w.begin(), w.end, 1);. double mean;. // Calculate the mean of the vector; // with iterators; mean = TMath::Mean(v.begin(), v.end());. // old-style; mean = TMath::Mean(n, &v[0]);. // Calculate the mean with a weight vector; // with iterators; mean = TMath::Mean(v.begin(), v.end(), w.begin());. // old-style; mean = TMath::Mean(n, &v[0], &w[0]);; ```. ### Special and Statistical Functions. `TMath` also provides special functions like Bessel, Error functions, Gamma or similar plus statistical mathematical functions, including probability density functions, cumulative distrib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:8664,interface,interfaces,8664,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability," statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1579,wrap,wrapping,1579,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['wrap'],"['wrapped', 'wrapping']"
Integrability," string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:161902,wrap,wrapped,161902,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrapped']
Integrability," such backend-specific `RDataFrame`s. For example:. ```python; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; ```. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all RDataFrame operations currently work with this package. The subset that is currently available is:. - AsNumpy; - Count; - Define; - Fill; - Filter; - Graph; - Histo[1,2,3]D; - Max; - Mean; - Min; - Profile[1,2,3]D; - Snapshot; - Sum. with support for more operations coming in the future. Any distributed RDataFrame backend inherits the dependencies of the underlying software needed to distribute the applications. The Spark backend for example has the following runtime dependencies (ROOT will build just fine without, but the feature will be unavailable without these packages):. - [pyspark](https://spark.apache.org/docs/latest/api/python/index.html), that in turn has its own set of dependencies:; - [Java](https://www.java.com/en/); - [py4j](https://www.py4j.org/). Tests for the Spark backend can be turned ON/OFF with the new build option `test_distrdf_pyspark` (OFF by default). ## Histogram Libraries. ## Math Libraries. - Update the definitions of the physical constants using the recommended 2018 values from NIST.; - Use also the new SI definition of base units from 2019, where the Planck constant, the Boltzmann constant, the elementary electric charge and the Avogadro constant are exact numerical values. See <https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units>. Note that with this new definition the functions `TMath::HUncertainty()`, `TMath::KUncertainty()`, `TMath::QeUncertainty()` and `TMath::NaUncertainty()` all return a `0.0` value.; - Due to some planned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:11678,depend,dependencies,11678,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['depend'],['dependencies']
Integrability," suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9577,interface,interface,9577,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['interface'],['interface']
Integrability," support all of the C++ features used in LLVM. We track certain versions of software that are *known* to fail when used as; part of the host toolchain. These even include linkers at times. **GNU ld 2.16.X**. Some 2.16.X versions of the ld linker will produce very long; warning messages complaining that some ""``.gnu.linkonce.t.*``"" symbol was; defined in a discarded section. You can safely ignore these messages as they are; erroneous and the linkage is correct. These messages disappear using ld 2.17. **GNU binutils 2.17**: Binutils 2.17 contains `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=3111>`__ which causes huge link; times (minutes instead of seconds) when building LLVM. We recommend upgrading; to a newer version (2.17.50.0.4 or later). **GNU Binutils 2.19.1 Gold**: This version of Gold contained `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=9836>`__ which causes; intermittent failures when building LLVM with position independent code. The; symptom is an error about cyclic dependencies. We recommend upgrading to a; newer version of Gold. Getting a Modern Host C++ Toolchain; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a recent version of mingw64. FreeBSD 10.0 and newer; have a modern Clang as the system compiler. However, some Linux distributions and some other or older BSDs sometimes have; extremely old versions of GCC. These steps attempt to help you upgrade you; compiler even on such a system. However, if at all possible, we encourage you; to use a recent version of a distribution with a modern system compiler that; meets these requirements. Note that it is tempting to install a prior; version of Clang and libc++ to be the host compiler, however libc++ was not; well tested or set up to b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:14785,depend,dependencies,14785,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['depend'],['dependencies']
Integrability," supports selection xml files and not only LinkDef files. ## I/O Libraries. ## TTree Libraries. ## RDataFrame. * The `GetColumnNames` function to retrieve the number of available column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4249,interface,interfaces,4249,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['interface'],['interfaces']
Integrability," synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirror",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10837,bridg,bridge,10837,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['bridg'],['bridge']
Integrability," target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:2048,depend,depends,2048,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['depend'],['depends']
Integrability," than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a shift to the right; compared to the 1E2, 1E1 and 1 labels.; ; {; c1 = new TCanvas(""c1"",""Examples of Log TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; TGaxis *axis1 = new TGaxis(-7,-0.8,-7,0.8,0.01,100,50510,""RG-"");; axis1->SetTitle(""RG-""); axis1->Draw();; TGaxis *axis2 = new TGaxis(-2,-0.8,-2,0.8,0.01,100,50510,""RG+"");; axis2->SetLabelOffset(-0.04); axis2->SetTitleOffset(-1.5);; axis2->SetTitle(""RG+""); axis2->Draw();; TGaxis *axis3 = new TGaxis(2,-0.8,2,0.8,0.01,100,50510,""LG-"");; axis3->SetLabelOffset(-0.04);; axis3->SetTitle(""LG-""); axis3->Draw();; TGaxis *axis4 = new TGaxis(7,-0.8,7,0.8,0.01,100,50510,""LG+"");; axis4->SetTitleOffset(-1);; axis4->SetTitle(""LG+""); axis4->Draw();; }; ; gStyle.SetStripDecimals(kFALSE) did not work in cases like the; following one:; ; {; gStyle.SetStripDecimals(kFALSE);; gStyle.SetPadLeftMargin(.15);; TGraph graph_freq;; graph_freq.SetPoint(0, 933., 40078879.);; graph_freq.SetPoint(1, 934., 40078966.);; graph_freq.Draw(""A*"");; }; . TCrown. The crown picking did not work.; Improve help. TLatex. The text angle was not taken into account in case the; text was painted in low precision like in:; ; gStyle->SetTitleFont(60,""xy"");; TH1F* h=new TH1F(""foo"", ""bar;#int;#int"", 10, 0, 1);; h->Draw();; ; In that example the Y title was not rotated. TCanvas. A canvas is turned into GL mode only if the; canvas name starts with ""gl"". Before the; ""gl"" string could be anywhere in the name. QtRoot/ libGQt. The redundant Qt3-related code was removed.; The Q3_SUPPORT flag was eliminated.; The plug-in can be used with and without Q3_SUPPORT now.; The code was adjusted to work under the Qt 4.5.x.; Many platform depended (win32) sections; were replaced with the cross-platform code. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:3648,depend,depended,3648,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['depend'],['depended']
Integrability," that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no kno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7582,message,message,7582,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['message'],['message']
Integrability," that they use, i.e. they have a different set of; preinstalled binaries. Debian8 is very minimal, nvidia-cuda is larger, but has; preinstalled CUDA libraries and allows to access a GPU, installed on your; machine. If you need a minimal linux distribution with only clang and libstdc++ included,; you should try Debian10-based image. If you want to use CUDA libraries and have access to a GPU on your machine,; you should choose nvidia-cuda-based image and use `nvidia-docker; <https://github.com/NVIDIA/nvidia-docker>`_ to run your docker containers. Note; that you don't need nvidia-docker to build the images, but you need it in order; to have an access to GPU from a docker container that is running the built; image. If you have a different use-case, you could create your own image based on; ``example/`` folder. Any docker image can be built and run using only the docker binary, i.e. you can; run debian10 build on Fedora or any other Linux distribution. You don't need to; install CMake, compilers or any other clang dependencies. It is all handled; during the build process inside Docker's isolated environment. Stable build; ============; If you want a somewhat recent and somewhat stable build, use the; ``branches/google/stable`` branch, i.e. the following command will produce a; Debian10-based image using the latest ``google/stable`` sources for you:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	-s debian10 --d clang-debian10 -t ""staging"" \; 	--branch branches/google/stable \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Minimizing docker image size; ============================; Due to how Docker's filesystem works, all intermediate writes are persisted in; the resulting image, even if they are removed in the following commands.; To minimize the resulting image size we use `multi-stage Docker builds; <https://docs.docker.com/develop/develop-images/multistage-build/>`_.; Internally Docker builds ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:6768,depend,dependencies,6768,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['depend'],['dependencies']
Integrability," the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21942,interface,interface,21942,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['interface'],['interface']
Integrability," the TargetLoweringObjectFile class. Since the MC layer works at the level of abstraction of object files, it doesn't; have a notion of functions, global variables etc. Instead, it thinks about; labels, directives, and instructions. A key class used at this time is the; MCStreamer class. This is an abstract API that is implemented in different ways; (e.g. to output a .s file, output an ELF .o file, etc) that is effectively an; ""assembler API"". MCStreamer has one method per directive, such as EmitLabel,; EmitSymbolAttribute, switchSection, etc, which directly correspond to assembly; level directives. If you are interested in implementing a code generator for a target, there are; three important things that you have to implement for your target:. #. First, you need a subclass of AsmPrinter for your target. This class; implements the general lowering process converting MachineFunction's into MC; label constructs. The AsmPrinter base class provides a number of useful; methods and routines, and also allows you to override the lowering process in; some important ways. You should get much of the lowering for free if you are; implementing an ELF, COFF, or MachO target, because the; TargetLoweringObjectFile class implements much of the common logic. #. Second, you need to implement an instruction printer for your target. The; instruction printer takes an `MCInst`_ and renders it to a raw_ostream as; text. Most of this is automatically generated from the .td file (when you; specify something like ""``add $dst, $src1, $src2``"" in the instructions), but; you need to implement routines to print operands. #. Third, you need to implement code that lowers a `MachineInstr`_ to an MCInst,; usually implemented in ""<target>MCInstLower.cpp"". This lowering process is; often target specific, and is responsible for turning jump table entries,; constant pool indices, global variable addresses, etc into MCLabels as; appropriate. This translation layer is also responsible for expanding pseudo; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:76293,rout,routines,76293,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['rout'],['routines']
Integrability," the [coding conventions](https://root.cern.ch/coding-conventions), as this is a simple item for; > reviewers to otherwise get stuck on.; > To make your (and our own) life easier, we provide a; > [`clang-format` configuration file](https://github.com/root-project/root/blob/master/.clang-format). By providing code, you agree to transfer your copyright on the code to the ""ROOT project"".; Of course you will be duly credited: for sizable contributions your name will appear in the; [CREDITS](https://raw.githubusercontent.com/root-project/root/master/README/CREDITS); file shipped with every binary and source distribution.; The copyright transfer helps us with effectively defending the project in case of litigation. ## Your Commit. Each commit is a self-contained, _atomic_ change. This means that:; 1. **Each commit should be able to successfully build ROOT.**; Doing so makes traveling through the git history, for example during a `git bisect` much easier.; Ideally, the commit also should not depend on other commits to _run_ ROOT.; 2. **Each commit does not contain more than one independent change.**; This allows us to revert changes when needed, without affecting anything else. > [!TIP]; > During a code review, it may be useful to make smaller commits to track intermediate changes, and rebase after the PR; > is approved to ensure the above points are met and to reduce clutter. ### Your Commit Message. The commit summary (i.e. the first line of the commit message) should be preceded by the a tag indicating the scope of; ROOT that is affected by your commit, in square brackets. Most tags are self-describing (e.g., `[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:1907,depend,depend,1907,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['depend'],['depend']
Integrability," the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitHub uses the first line of the commit message truncated to 72 characters; as the pull request title, you may have to edit to reword or to undo this; truncation. Creating Pull Requests with GitHub CLI; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; With the CLI it's enough to create the branch locally and then run:. ::. gh pr create. When prompted select to create and use your own fork and follow; the instructions to add more information needed. .. note::. When you let the GitHub CLI create a fork of llvm-project to; your user, it will change the git ""remotes"" so that ""origin"" points; to your fork and ""upstream"" points to the main llvm-project repository. Updating Pull Requests; ----------------------; In order to update your pull request, the only thing you need to do is to push; your new commits to the branch in your fork. That will automatically update; the pull request. When updating a pull request, you should push additional ""fix up"" commits to; your branch instead of force pushing. This makes it easier for GitHub to; track the context of previous review comments",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:2540,message,message,2540,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability," the analyzer that this path is unreachable by teaching it about your custom assertion handlers. For example, you can modify the code segment as following. void customAssert() __attribute__((analyzer_noreturn));; int foo(int *b) {; if (!b); customAssert();; return *b;; }; Q: The analyzer reports a null dereference, but I know that the; pointer is never null. How can I tell the analyzer that a pointer can never be; null?. The reason the analyzer often thinks that a pointer can be null is because the preceding code checked compared it against null. So if you are absolutely sure that it cannot be null, remove the preceding check and, preferably, add an assertion as well. For example, in the code segment above, it will be sufficient to remove the if (!b) check. . void usePointer(int *b);; int foo(int *b) {; usePointer(b);; return *b;; }; Q: How do I tell the static analyzer that I don't care about a specific dead store?; When the analyzer sees that a value stored into a variable is never used, it's going to produce a message similar to this one:; Value stored to 'x' is never read; You can use the (void)x; idiom to acknowledge that there is a dead store in your code but you do not want it to be reported in the future.; Q: How do I tell the static analyzer that I don't care about a specific unused instance variable in Objective C?; When the analyzer sees that a value stored into a variable is never used, it is going to produce a message similar to this one:; Instance variable 'commonName' in class 'HappyBird' is never used by the methods in its @implementation; You can add __attribute__((unused)) to the instance variable declaration to suppress the warning.; Q: How do I tell the static analyzer that I don't care about a specific unlocalized string?; When the analyzer sees that an unlocalized string is passed to a method that will present that string to the user, it is going to produce a message similar to this one:; User-facing text should use localized string macro. If yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:2417,message,message,2417,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['message'],['message']
Integrability," the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17958,depend,depend,17958,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['depend']
Integrability," the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you; should also think about setting the bar size to the end of the most; right button. This way other bars can be displayed in the same row below; the menu bar. Tool bar buttons should have equal size, meaningful and unique icons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displaye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:77430,message,messages,77430,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['messages']
Integrability," the compilation pipeline proceeds, these constraints are; gradually tightened until gMIR has become MIR. The rest of this document will assume that you are familiar with the concepts; in :doc:`MachineIR (MIR) <../MIRLangRef>` and will highlight the differences; between MIR and gMIR. .. _gmir-instructions:. Generic Machine Instructions; ----------------------------. .. note::. This section expands on :ref:`mir-instructions` from the MIR Language; Reference. Whereas MIR deals largely in Target Instructions and only has a small set of; target independent opcodes such as ``COPY``, ``PHI``, and ``REG_SEQUENCE``,; gMIR defines a rich collection of ``Generic Opcodes`` which are target; independent and describe operations which are typically supported by targets.; One example is ``G_ADD`` which is the generic opcode for an integer addition.; More information on each of the generic opcodes can be found at; :doc:`GenericOpcode`. The ``MachineIRBuilder`` class wraps the ``MachineInstrBuilder`` and provides; a convenient way to create these generic instructions. .. _gmir-gvregs:. Generic Virtual Registers; -------------------------. .. note::. This section expands on :ref:`mir-registers` from the MIR Language; Reference. Generic virtual registers are like virtual registers but they are not assigned a; Register Class constraint. Instead, generic virtual registers have less strict; constraints starting with a :ref:`gmir-llt` and then further constrained to a; :ref:`gmir-regbank`. Eventually they will be constrained to a register class; at which point they become normal virtual registers. Generic virtual registers can be used with all the virtual register API's; provided by ``MachineRegisterInfo``. In particular, the def-use chain API's can; be used without needing to distinguish them from non-generic virtual registers. For simplicity, most generic instructions only accept virtual registers (both; generic and non-generic). There are some exceptions to this but in general:. * inst",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:1210,wrap,wraps,1210,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['wrap'],['wraps']
Integrability," the constructor:. ``` {.cpp}; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); ```. To create a radioactive mixture, one can use radionuclides as well as; stable elements:. ``` {.cpp}; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; ```. Once defined, one can retrieve the time evolution for the radioactive; materials/mixtures by using one of the next two methods:. 1. `TGeoMaterial::FillMaterialEvolution(TObjArray *population,`; ` Double_t precision=0.001)`. To use this method, one has to provide an empty **`TObjArray`** object; that will be filled with all elements coming from the decay chain of the; initial radionuclides contained by the material/mixture. The precision; represent the cumulative branching ratio for which decay products are; still considered. ![Concentration of C14 derived elements](pictures/030001B3.png). The population list may contain stable elements as well as; radionuclides, depending on the initial elements. To test if an element; is a radionuclide:. ``` {.cpp}; Bool_t TGeoElement::IsRadioNuclide() const; ```. All radionuclides in the output population list have attached objects; that represent the time evolution of their fraction of nuclei with; respect to the top radionuclide in the decay chain. These objects; (Bateman solutions) can be retrieved and drawn:. ``` {.cpp}; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; ```. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. 2. `TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001)`. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:20649,depend,depending,20649,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depending']
Integrability," the enclosing full-expression, subject to the usual optimizations on local; values. These casts are required in order to transfer objects in and out of ARC; control; see the rationale in the section on :ref:`conversion of retainable; object pointers <arc.objects.restrictions.conversion>`. Using a ``__bridge_retained`` or ``__bridge_transfer`` cast purely to convince; ARC to emit an unbalanced retain or release, respectively, is poor form. .. _arc.objects.restrictions:. Restrictions; ------------. .. _arc.objects.restrictions.conversion:. Conversion of retainable object pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In general, a program which attempts to implicitly or explicitly convert a; value of retainable object pointer type to any non-retainable type, or; vice-versa, is ill-formed. For example, an Objective-C object pointer shall; not be converted to ``void*``. As an exception, cast to ``intptr_t`` is; allowed because such casts are not transferring ownership. The :ref:`bridged; casts <arc.objects.operands.casts>` may be used to perform these conversions; where necessary. .. admonition:: Rationale. We cannot ensure the correct management of the lifetime of objects if they; may be freely passed around as unmanaged types. The bridged casts are; provided so that the programmer may explicitly describe whether the cast; transfers control into or out of ARC. However, the following exceptions apply. .. _arc.objects.restrictions.conversion.with.known.semantics:. Conversion to retainable object pointer type of expressions with known semantics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`; :revision:`These exceptions have been greatly expanded; they previously applied; only to a much-reduced subset which is difficult to categorize but which; included null pointers, message sends (under the given rules), and the various; global constants.`. An unbridged conversion to a retainable obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:24796,bridg,bridged,24796,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['bridg'],['bridged']
Integrability," the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21736,rout,routines,21736,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['rout'],['routines']
Integrability," the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:4438,message,message,4438,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['message'],['message']
Integrability," the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22885,interface,interface,22885,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['interface'],['interface']
Integrability," the location is returned. The modification is specified by the; operation argument:. - xchg: ``*ptr = val``; - add: ``*ptr = *ptr + val``; - sub: ``*ptr = *ptr - val``; - and: ``*ptr = *ptr & val``; - nand: ``*ptr = ~(*ptr & val)``; - or: ``*ptr = *ptr | val``; - xor: ``*ptr = *ptr ^ val``; - max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison); - min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison); - umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison); - umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison); - fadd: ``*ptr = *ptr + val`` (using floating point arithmetic); - fsub: ``*ptr = *ptr - val`` (using floating point arithmetic); - fmax: ``*ptr = maxnum(*ptr, val)`` (match the `llvm.maxnum.*`` intrinsic); - fmin: ``*ptr = minnum(*ptr, val)`` (match the `llvm.minnum.*`` intrinsic); - uinc_wrap: ``*ptr = (*ptr u>= val) ? 0 : (*ptr + 1)`` (increment value with wraparound to zero when incremented above input value); - udec_wrap: ``*ptr = ((*ptr == 0) || (*ptr u> val)) ? val : (*ptr - 1)`` (decrement with wraparound to input value when decremented below zero). Example:; """""""""""""""". .. code-block:: llvm. %old = atomicrmw add ptr %ptr, i32 1 acquire ; yields i32. .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The sec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:432046,wrap,wraparound,432046,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['wrap'],['wraparound']
Integrability," the memory allocated to maintain; this internal state. This method is called after the ``run*`` method for the; class, before the next call of ``run*`` in your pass. Registering dynamically loaded passes; =====================================. *Size matters* when constructing production quality tools using LLVM, both for; the purposes of distribution, and for regulating the resident code size when; running on the target system. Therefore, it becomes desirable to selectively; use some passes, while omitting others and maintain the flexibility to change; configurations later on. You want to be able to do all this, and, provide; feedback to the user. This is where pass registration comes into play. The fundamental mechanisms for pass registration are the; ``MachinePassRegistry`` class and subclasses of ``MachinePassRegistryNode``. An instance of ``MachinePassRegistry`` is used to maintain a list of; ``MachinePassRegistryNode`` objects. This instance maintains the list and; communicates additions and deletions to the command line interface. An instance of ``MachinePassRegistryNode`` subclass is used to maintain; information provided about a particular pass. This information includes the; command line name, the command help string and the address of the function used; to create an instance of the pass. A global static constructor of one of these; instances *registers* with a corresponding ``MachinePassRegistry``, the static; destructor *unregisters*. Thus a pass that is statically linked in the tool; will be registered at start up. A dynamically loaded pass will register on; load and unregister at unload. Using existing registries; -------------------------. There are predefined registries to track instruction scheduling; (``RegisterScheduler``) and register allocation (``RegisterRegAlloc``) machine; passes. Here we will describe how to *register* a register allocator machine; pass. Implement your register allocator machine pass. In your register allocator; ``.cpp`` fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:48675,interface,interface,48675,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability," the method family. A selector is in a certain selector family if, ignoring any leading; underscores, the first component of the selector either consists entirely of; the name of the method family or it begins with that name followed by a; character other than a lowercase letter. For example, ``_perform:with:`` and; ``performWith:`` would fall into the ``perform`` family (if we recognized one),; but ``performing:with`` would not. The families and their added restrictions are:. * ``alloc`` methods must return a retainable object pointer type.; * ``copy`` methods must return a retainable object pointer type.; * ``mutableCopy`` methods must return a retainable object pointer type.; * ``new`` methods must return a retainable object pointer type.; * ``init`` methods must be instance methods and must return an Objective-C; pointer type. Additionally, a program is ill-formed if it declares or; contains a call to an ``init`` method whose return type is neither ``id`` nor; a pointer to a super-class or sub-class of the declaring class (if the method; was declared on a class) or the static receiver type of the call (if it was; declared on a protocol). .. admonition:: Rationale. There are a fair number of existing methods with ``init``-like selectors; which nonetheless don't follow the ``init`` conventions. Typically these; are either accidental naming collisions or helper methods called during; initialization. Because of the peculiar retain/release behavior of; ``init`` methods, it's very important not to treat these methods as; ``init`` methods if they aren't meant to be. It was felt that implicitly; defining these methods out of the family based on the exact relationship; between the return type and the declaring class would be much too subtle; and fragile. Therefore we identify a small number of legitimate-seeming; return types and call everything else an error. This serves the secondary; purpose of encouraging programmers not to accidentally give methods names; in the ``in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:68858,protocol,protocol,68858,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol']
Integrability," the new files will be created in the tutorials; directory, otherwise they will be created in the user directory. You can start by executing the standard ROOT demos with a session like:. ```; root > .x demos.C; ```; or. ```; root > .x $ROOTSYS/tutorials/demos.C; ```. You can execute the standard ROOT graphics benchmark with. ```; root > .x benchmarks.C; ```. or. ```; root > .x $ROOTSYS/tutorials/benchmarks.C; ```. The `$ROOTSYS/tutorials` directory includes several sub-directories:. \defgroup tutorial_hist Histograms tutorials; \ingroup Tutorials; \brief Examples showing the ""histograms' classes"" usage. \defgroup tutorial_tree Tree tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use ROOT trees and ntuples. \defgroup tutorial_dataframe Dataframe tutorials; \ingroup Tutorials; \brief These examples show various features of [RDataFrame](classROOT_1_1RDataFrame.html): ROOT's declarative analysis interface. \defgroup tutorial_v7 ROOT 7 tutorials; \ingroup Tutorials; \brief Various examples showing the ROOT 7 interface. \defgroup tutorial_FOAM FOAM tutorials; \ingroup Tutorials; \brief Examples showing how to use FOAM. \defgroup tutorial_cont Containers tutorials; \ingroup Tutorials; \brief Examples showing the ""containers' classes"" usage. \defgroup tutorial_eve Event display tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage. \defgroup tutorial_eve7 Event display ROOT7 tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage with ROOT7. \defgroup tutorial_geom Geometry tutorials; \ingroup Tutorials; \brief Various ROOT geometry package examples. \defgroup tutorial_fft Fast Fourier Transforms tutorials; \ingroup Tutorials; \brief Example showing the Fast Fourier Transforms interface in ROOT. \defgroup tutorial_fit Fit Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:1444,interface,interface,1444,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability," the new pointee is first retained; second, the; lvalue is loaded with primitive semantics; third, the new pointee is stored; into the lvalue with primitive semantics; and finally, the old pointee is; released. This is not performed atomically; external synchronization must be; used to make this safe in the face of concurrent loads and stores.; * For ``__weak`` objects, the lvalue is updated to point to the new pointee,; unless the new pointee is an object currently undergoing deallocation, in; which case the lvalue is updated to a null pointer. This must execute; atomically with respect to other assignments to the object, to reads from the; object, and to the final release of the new pointee.; * For ``__unsafe_unretained`` objects, the new pointee is stored into the; lvalue using primitive semantics.; * For ``__autoreleasing`` objects, the new pointee is retained, autoreleased,; and stored into the lvalue using primitive semantics. :arc-term:`Initialization` occurs when an object's lifetime begins, which; depends on its storage duration. Initialization proceeds in two stages:. #. First, a null pointer is stored into the lvalue using primitive semantics.; This step is skipped if the object is ``__unsafe_unretained``.; #. Second, if the object has an initializer, that expression is evaluated and; then assigned into the object using the usual assignment semantics. :arc-term:`Destruction` occurs when an object's lifetime ends. In all cases it; is semantically equivalent to assigning a null pointer to the object, with the; proviso that of course the object cannot be legally read after the object's; lifetime ends. :arc-term:`Moving` occurs in specific situations where an lvalue is ""moved; from"", meaning that its current pointee will be used but the object may be left; in a different (but still valid) state. This arises with ``__block`` variables; and rvalue references in C++. For ``__strong`` lvalues, moving is equivalent; to loading the lvalue with primitive semantics, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:39700,depend,depends,39700,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['depends']
Integrability," the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126196,interface,interfaces,126196,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interfaces']
Integrability," the object region. In ctors, we synthesize 'this' region with; CXXRecordDecl*, which means we do not use type qualifiers. In methods, we; synthesize 'this' region with CXXMethodDecl*, which has getThisType(); taking type qualifiers into account. It does not matter we use qualified; 'this' region in one method and unqualified 'this' region in another; method, because we only need to ensure the 'this' region is consistent; when we synthesize it and create it directly from CXXThisExpr in a single; method call. = Working on the Analyzer =. If you are interested in bringing up support for C++ expressions, the; best place to look is the visitation logic in ExprEngine, which; handles the simulation of individual expressions. There are plenty of; examples there of how other expressions are handled. If you are interested in writing checkers, look at the Checker and; CheckerVisitor interfaces (Checker.h and CheckerVisitor.h). Also look; at the files named *Checker.cpp for examples on how you can implement; these interfaces. = Debugging the Analyzer =. There are some useful command-line options for debugging. For example:. $ clang -cc1 -help | grep analyze; -analyze-function <value>; -analyzer-display-progress; -analyzer-viz-egraph-graphviz; ... The first allows you to specify only analyzing a specific function.; The second prints to the console what function is being analyzed. The; third generates a graphviz dot file of the ExplodedGraph. This is; extremely useful when debugging the analyzer and viewing the; simulation results. Of course, viewing the CFG (Control-Flow Graph) is also useful:. $ clang -cc1 -analyzer-checker-help-developer. -analyzer-checker=debug.DumpCFG Display Control-Flow Graphs; -analyzer-checker=debug.ViewCFG View Control-Flow Graphs using GraphViz; (outdated below?); -cfg-add-implicit-dtors Add C++ implicit destructors to CFGs for all analyses; -cfg-add-initializers Add C++ initializers to CFGs for all analyses; -unoptimized-cfg Generate unoptimized CFGs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:5441,interface,interfaces,5441,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['interface'],['interfaces']
Integrability," the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); demonstrating how a TMemFile can be used to do parallel merge; from many clients. (TMemFile still needs to be better integrated; with TMessage and TSocket). The new TMemFile class support the TFile interface but only store; the information in memory. This version is limited to 32MB. TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMemFile *file = new TMemFile(""hsimple.memroot"",""RECREATE"");. Will create an empty in-memory of (currently fixed) size 32MB. file->ResetAfterMerge(0);. Will reset the objects in the TDirectory list of objects; so that they are ready for more data accumulations (i.e.; returns the data to 0 but keep the customizations). TFile::MakeProject. New option 'par' in to pack in a PAR file the generated; code. The first argument defines the directory and the name of the package.; For example, the following generates a PAR package equivalent to; tutorials/proof/event.par:. root [] TFile *f = TFile::Open(""http://root.cern/files/data/event_1.root""); root [] f->MakeProject(""packages/myevent.par"", ""*"", ""par"");. Not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:4284,interface,interface,4284,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['interface'],['interface']
Integrability," the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorporates the limitation as if; written in the body of this License. 13. The Free Software Foundation may publish revised and/or new; versions of the Lesser General Public License from time to time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation. 14. If y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:23667,interface,interfaces,23667,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['interface'],['interfaces']
Integrability," the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorporates the limitation as if; written in the body of this License. 13. The Free Software Foundation may publish revised and/or new; versions of the Lesser General Public License from time to time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation.; ; 14. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:21411,interface,interfaces,21411,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['interface'],['interfaces']
Integrability," the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you used this class in your own; implementations, just multiply the underlying RooAbsReal function with the; scale factor and create a RooRealBinding, e.g.:; ```c++; RooProduct scaledFunc{""scaled_func"", """", func, scaleFactor};; RooRealBinding scaleBind(scaledFunc, x) ;; ```; instead of:; ```c++; RooRealBinding binding(func, x) ;; RooScaledFunc scaledBinding(binding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14519,wrap,wrapper,14519,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['wrap'],['wrapper']
Integrability," the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) these will describe the location of the characters corresponding to; the token and the location where the token was used (i.e., the macro; expansion point or the location of the ``_Pragma`` itself). The Clang front-end inherently depends on the location of a token being tracked; correctly. If it is ever incorrect, the front-end may get confused and die.; The reason for this is that the notion of the ""spelling"" of a ``Token`` in; Clang depends on being able to find the original input characters for the; token. This concept maps directly to the ""spelling location"" for the token. ``SourceRange`` and ``CharSourceRange``; ---------------------------------------. .. mostly taken from https://discourse.llvm.org/t/code-ranges-of-tokens-ast-elements/16893/2. Clang represents most source ranges by [first, last], where ""first"" and ""last""; each point to the beginning of their respective tokens. For example consider; the ``SourceRange`` of the following statement:. .. code-block:: text. x = foo + bar;; ^first ^last. To map from this representation to a character-based representation, the ""last""; location needs to be adjusted to point to (or past) the end of that token with; either ``Lexer::MeasureTokenLength()`` or ``Lexer::getLocForEndOfToken()``. For; the rare cases where character-level source ranges information is needed we use; the ``CharSourceRange`` class. The Driver Library; ==================. The clang Driver and l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:24953,depend,depends,24953,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability," the usual way: in a case like ``if v1 then if v2 then {...} else {...}``, the; ``else`` associates with the inner ``if`` rather than the outer one. The :token:`IfBody` of the then and else arms of the ``if`` establish an; inner scope. Any ``defvar`` variables defined in the bodies go out of scope; when the bodies are finished (see `Defvar in a Record Body`_ for more details). The ``if`` statement can also be used in a record :token:`Body`. ``assert`` --- check that a condition is true; ---------------------------------------------. The ``assert`` statement checks a boolean condition to be sure that it is true; and prints an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an ``assert`` in two class definitions. .. code-block:: text. class PersonName<string name> {; assert !le(!size(name), 32), ""person name is too long: "" # name;; string Name = name;; }. class Person<string name, int age> : PersonName<name> {; assert !and(!ge(age, 1), !le(age, 120)), ""person age is invalid:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:49408,depend,depends,49408,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['depend'],['depends']
Integrability," the; OpenCL memory. The target triple environment is used to determine if the; source language is OpenCL (see :ref:`amdgpu-opencl`). ``ds/flat_load/store/atomic`` instructions to local memory are termed LDS; operations. ``buffer/global/flat_load/store/atomic`` instructions to global memory are; termed vector memory operations. Private address space uses ``buffer_load/store`` using the scratch V#; (GFX6-GFX8), or ``scratch_load/store`` (GFX9-GFX11). Since only a single thread; is accessing the memory, atomic memory orderings are not meaningful, and all; accesses are treated as non-atomic. Constant address space uses ``buffer/global_load`` instructions (or equivalent; scalar memory instructions). Since the constant address space contents do not; change during the execution of a kernel dispatch it is not legal to perform; stores, and atomic memory orderings are not meaningful, and all accesses are; treated as non-atomic. A memory synchronization scope wider than work-group is not meaningful for the; group (LDS) address space and is treated as work-group. The memory model does not support the region address space which is treated as; non-atomic. Acquire memory ordering is not meaningful on store atomic instructions and is; treated as non-atomic. Release memory ordering is not meaningful on load atomic instructions and is; treated a non-atomic. Acquire-release memory ordering is not meaningful on load or store atomic; instructions and is treated as acquire and release respectively. The memory order also adds the single thread optimization constraints defined in; table; :ref:`amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table`. .. table:: AMDHSA Memory Model Single Thread Optimization Constraints; :name: amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table. ============ ==============================================================; LLVM Memory Optimization Constraints; Ordering; ============ =======================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:203620,synchroniz,synchronization,203620,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability," the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including headers after import is problematic; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20753,wrap,wrapper,20753,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['wrap'],['wrapper']
Integrability," there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Mul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22324,synchroniz,synchronization,22324,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['synchroniz'],['synchronization']
Integrability," this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can incl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:31707,depend,depended,31707,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['depended']
Integrability," this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2729,interface,interface,2729,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability," this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description interfaces`_ for; particular targets. These machine descriptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; target-specific issues. The code for the target-independent JIT lives in; ``lib/ExecutionEngine/JIT``. Depending on which part of the code generator you are interested in working on,; different pieces of this will be useful to you. In any case, you should be; familiar with the `target description`_ and `machine code representation`_; classes. If you want to add a backend for a new target, you will need to; `implement the target description`_ classes for your new target and understand; the :doc:`LLVM code representation <LangRef>`. If you are interested in; implementing a new `code generation algorithm`_, it should only depend on the; target-description and machine code representation classes, ensuring that it is; portable. Required components in the code generator; -----------------------------------------. The two pieces of the LLVM code generator are the high-level interface to the; code generator and the set of reusable components that can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:2510,interface,interface,2510,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interface']
Integrability," thus; also for meta-classes.; In Python2, it was possible to resolve any mro conflicts automatically, but; meta-classes in Python3, although syntactically richer, have functionally; become far more limited.; In particular, the mro is checked in the builtin class builder, instead of; in the meta-class of the meta-class (which in Python3 is the builtin ``type``; rather than the meta-class itself as in Python2, another limitation, and; which actually checks the mro a second time for no reason).; The upshot is that a helper is required (``cppyy.multi``) to resolve the mro; to support Python3.; The helper is written to also work in Python2.; Example:. .. code-block:: python. >>> class PyConcrete(cppyy.multi(cppyy.gbl.Abstract1, cppyy.gbl.Abstract2)):; ... def abstract_method1(self):; ... return ""first message""; ... def abstract_method2(self):; ... return ""second message""; ...; >>> pc = PyConcrete(); >>> cppyy.gbl.call_abstract_method1(pc); first message; >>> cppyy.gbl/call_abstract_method2(pc); second message; >>>. Contrary to multiple inheritance in Python, in C++ there are no two separate; instances representing the base classes.; Thus, a single ``__init__`` call needs to construct and initialize all bases,; rather than calling ``__init__`` on each base independently.; To support this syntax, the arguments to each base class should be grouped; together in a tuple.; If there are no arguments, provide an empty tuple (or omit them altogether,; if these arguments apply to the right-most base(s)). .. _sec-methods-label:. `Methods`; ---------. C++ methods are represented as Python ones: these are first-class objects and; can be bound to an instance.; If a method is virtual in C++, the proper concrete method is called, whether; or not the concrete class is bound.; Similarly, if all classes are bound, the normal Python rules apply:. .. code-block:: python. >>> c.abstract_method(); called Concrete::abstract_method; >>> c.concrete_method(); called Concrete::concrete_method; >>> ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:6547,message,message,6547,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['message'],['message']
Integrability," to a specific function should use the operating system's native; ABI or whether it should use a variant of this ABI that also propagates labels; through function parameters and return values. The ABI list file also controls; how labels are propagated in the former case. DataFlowSanitizer comes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:2951,message,message,2951,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['message'],['message']
Integrability," to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88790,interface,interface,88790,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['interface'],['interface']
Integrability," to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51639,depend,dependence,51639,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['dependence']
Integrability," to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102773,interface,interface,102773,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['interface'],['interface']
Integrability," to draw a **`TPie`** are:. - ""`R`"" Paint the labels along the central ""`R`""adius of slices. - ""`T`"" Paint the labels in a direction ""`T`""angent to circle that; describes the TPie. - ""`3D`"" Draw the pie-chart with a pseudo 3D effect. - ""`NOL`"" No OutLine: do not draw the slices' outlines; any property; over the slices' line is ignored. The method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71422,interface,interface,71422,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['interface'],['interface']
Integrability," to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:29121,depend,dependency,29121,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['dependency']
Integrability," to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be able to declare the file in which the; diagnostic will appear, rather than placing the ``expected-*`` directive in the; actual file itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:158600,message,message,158600,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['message'],['message']
Integrability," to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide variety of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to the functions and objects in this library are implicitly; generated by Clang when compiling C++ code. While it is possible to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9829,message,messages,9829,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['message'],['messages']
Integrability," to the toy datasets, please take a look at the new; [rf613_global_observables.C](https://root.cern/doc/v626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:30362,interface,interface,30362,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability," tool that only accepts C-style; comments. #. When documenting the significance of constants used as actual parameters in; a call. This is most helpful for ``bool`` parameters, or passing ``0`` or; ``nullptr``. The comment should contain the parameter name, which ought to be; meaningful. For example, it's not clear what the parameter means in this call:. .. code-block:: c++. Object.emitName(nullptr);. An in-line C-style comment makes the intent obvious:. .. code-block:: c++. Object.emitName(/*Prefix=*/nullptr);. Commenting out large blocks of code is discouraged, but if you really have to do; this (for documentation purposes or as a suggestion for debug printing), use; ``#if 0`` and ``#endif``. These nest properly and are better behaved in general; than C style comments. Doxygen Use in Documentation Comments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use the ``\file`` command to turn the standard file header into a file-level; comment. Include descriptive paragraphs for all public interfaces (public classes,; member and non-member functions). Avoid restating the information that can; be inferred from the API name. The first sentence (or a paragraph beginning; with ``\brief``) is used as an abstract. Try to use a single sentence as the; ``\brief`` adds visual clutter. Put detailed discussion into separate; paragraphs. To refer to parameter names inside a paragraph, use the ``\p name`` command.; Don't use the ``\arg name`` command since it starts a new paragraph that; contains documentation for the parameter. Wrap non-inline code examples in ``\code ... \endcode``. To document a function parameter, start a new paragraph with the; ``\param name`` command. If the parameter is used as an out or an in/out; parameter, use the ``\param [out] name`` or ``\param [in,out] name`` command,; respectively. To describe function return value, start a new paragraph with the ``\returns``; command. A minimal documentation comment:. .. code-block:: c++. /// Sets the xyzzy property to \p Baz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:11443,interface,interfaces,11443,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interfaces']
Integrability," top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; Hyb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10385,interface,interfaces,10385,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interfaces']
Integrability," traversal of class hierarchy of the; selected object, executed from method **`TGedEditor`**`::SetModel()`.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:106470,depend,depending,106470,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['depend'],['depending']
Integrability," triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--obj-root**. Print the object root used to build LLVM. **--prefix**. Print the installation prefix for LLVM. **--shared-mode**. Print how the provided components can be collectively linked (`shared` or `static`). **--system-libs**. Print all the system libraries needed to link against the specified LLVM; *components*, including any dependencies. **--targets-built**. Print the component names for all targets supported by this copy of LLVM. **--version**. Print the version number of LLVM. COMPONENTS; ----------. To print a list of all available components, run **llvm-config; --components**. In most cases, components correspond directly to LLVM; libraries. Useful ""virtual"" components include:. **all**. Includes all LLVM libraries. The default if no components are specified. **backend**. Includes either a native backend or the C backend. **engine**. Includes either a native JIT or the bitcode interpreter. EXIT STATUS; -----------. If **llvm-config** succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:2743,depend,dependencies,2743,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,1,['depend'],['dependencies']
Integrability," tutorials illustrate the main features of [RooFit](group__Roofitmain.html): the name of the examples and their short description help in figuring out their objective. \defgroup tutorial_graphs Graphs tutorials; \ingroup Tutorials; \brief Examples showing the ""graphs classes"" usage. \defgroup tutorial_graphics Graphics tutorials; \ingroup Tutorials; \brief Various examples showing the basic ROOT graphics. \defgroup tutorial_gl OpenGL tutorials; \ingroup Tutorials; \brief Various examples showing the OpenGL graphics in ROOT. \defgroup tutorial_cocoa Tutorials specific to Mac/Cocoa; \ingroup Tutorials; \brief Various examples showing graphics done with the Mac graphics system Cocoa. \defgroup tutorial_gui GUI tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use the ROOT GUI. \defgroup tutorial_histfactory HistFactory Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the usage of the histfactory. \defgroup tutorial_http HTTP tutorials; \ingroup Tutorials; \brief Examples showing the HTTP interface. \defgroup tutorial_image Image tutorials; \ingroup Tutorials; \brief Examples showing the TImage class usage. \defgroup tutorial_io IO tutorials; \ingroup Tutorials; \brief These tutorials illustrate some of the capabilities of the ROOT IO subsystem. \defgroup tutorial_math Math tutorials; \ingroup Tutorials; \brief Examples showing the Math classes. \defgroup tutorial_matrix Matrix tutorials; \ingroup Tutorials; \brief Examples showing how to use TMatrix. \defgroup tutorial_mc Monte Carlo tutorials; \ingroup Tutorials; \brief Monte Carlo examples. \defgroup tutorial_multicore Multicore tutorials; \ingroup Tutorials; \brief These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. \defgroup tutorial_net Net tutorials; \ingroup Tutorials; \brief Examples showing the net classes. \defgroup tutorial_physics Physics tutorials; \ingroup Tutorials; \brief Physi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:3515,interface,interface,3515,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability," type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15752,depend,dependent,15752,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability," unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:23572,rout,routine,23572,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['rout'],['routine']
Integrability," unknown errors up the stack instead. For tool code, where errors can be handled by printing an error message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:26963,message,message,26963,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['interoperab', 'message']","['interoperability', 'message']"
Integrability," use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.; It thus plays well with object identity, references, etc.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... struct MyStruct { int fInt; };; ... void* create_mystruct() { return new MyStruct{42}; }; ... """"""); ... ; >>> s = cppyy.gbl.create_mystruct(); >>> print(s); <cppyy.LowLevelView object at 0x10559d430>; >>> sobj = cppyy.bind_object(s, 'MyStruct'); >>> print(sobj); <cppyy.gbl.MyStruct object at 0x7ff25e28eb20>; >>> print(sobj.fInt); 42; >>>. Instead of the type name as a string, ``bind_object`` can also take the; actual class (here: ``cppyy.gbl.MyStruct``). * **Typed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1992,interface,interface,1992,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability," used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the given range.; 2. Use `ROOT::Fit::UnBinData` as a wrapper to an external data storage. In this case the `UnBinData` object is created from an iterator or pointers to the data and the data are not copied; inside. In this case the data cannot be selected according to a specified range. All the data points will be included in the fit. The `ROOT::Fit::UnBinData` class supports also weighted data. In addition to the data points (coordinates), which can be of arbitrary `k` dimensions, the class can be constructed from a vector of; weights. This is an example of taking data from an histogram buffer of a **`TH1`** object:. ``` {.cpp}; 	double * buffer = histogram->GetBuffer();; 	// number of entry is first entry in the buffer; 	int n = buffer[0];; 	// when creating the data object it is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:33787,wrap,wrapper,33787,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['wrap'],['wrapper']
Integrability," uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, the next step is to implement a; RecursiveASTVisitor to extract the relevant information from the AST. The RecursiveASTVisitor provides hooks of the form bool; VisitNodeType(NodeType \*) for most AST nodes; the exception are TypeLoc; nodes, which are passed by-value. We only",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:1239,interface,interface,1239,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,1,['interface'],['interface']
Integrability," using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4451,interface,interface,4451,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability," values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the thir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61689,integrat,integration,61689,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability," version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an unsupported file format feature is encountered, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fIOBits (00000000000000000000000001111110) contains unknown flags (supported flags are 00000000000000000000000000000001), indicating this was written with a newer version of ROOT utilizing critical IO features this version of ROOT does not support. Refusing to deserialize.; ```; - When an older version of ROOT, without this logic, encounters the file, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fNevBufSize is incorrect (-72) ; trying to recover by setting it to zero; ```. - Added an experimental feature that allows the IO libraries to skip writing out redundant information for some split classes, resulting in disk space savings. This is disabled by default and may be enabled by setting:. ```; ROOT::TIOFeatures features;; features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; ttree_ref.SetIOFeatures(features);; ```; - Added `GetAutoSave()` and `SetAutoSave()` methods to `TBufferMerger`, to allow; it to accumulate several buffers in memory before merging, to reduce the; amount of compression work done due to `TTree` metadata. - Added a non-blocking callback mechanism to `TBufferMerger` to allow users to; control the rate at which data is pushed into the merging queue. The callback; mechanism can be used, for example, to launch tasks asynchronously whenever a; buffer is done processing. ## TTree Libraries. - Resolv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:8480,message,message,8480,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['message'],['message']
Integrability," version of) cppyy (notably `using` declarations had to be; lowered in the inheritance hierarchy for cppyy to pick them up); - `operator[](mask)` has been added, as well as several other ""numpy-like"" helper; functions (these latter ones are free functions); - logical operators `==`, `<`, `>` etc. return vectors rather than booleans; - the type of fSize and fCapacity is signed rather than unsigned, and fixed to 32 bits; - a number of minor patches have been applied for backward compatibility with the previous; implementation of RVec (which did not have a small buffer optimization and was implemented; in terms of `std::vector` with a custom allocator) and to make the code more consistent; with ROOT's coding conventions. ## RVec design. `SmallVectorBase`; - `fBeginX`; - `fSize`; - `fCapacity`. Basically the same as the corresponding LLVM class, with the template parameter removed: LLVM's SmallVectorBase; is templated over the type of fSize and fCapacity. It contains the parts of `RVec` that do not depend on the value; type.; No other classes in the hierarchy can contain data members! We expect the memory after `SmallVectorBase` to be; occupied by the small inline buffer. `SmallVectorTemplateCommon<T>`; - `getFirstEl()`: returns the address of the beginning of the small buffer; - `begin()`, `end()`, `front()`, `back()`, etc. Basically the same as the corresponding LLVM class.; It contains the parts that are independent of whether T is a POD or not. `SmallVectorTemplateBase<T, bool TriviallyCopiable>` and the specialization `SmallVectorTemplateBase<T, true>`; - `grow()`, `uninitialized_copy`, `uninitialized_move`, `push_back()`, `pop_back()`. This class contains the parts of `RVec` that can be optimized for trivially copiable types.; In particular, destruction can be skipped and memcpy can be used in place of copy/move construction.; These optimizations are inherited from LLVM's SmallVector. `RVecImpl<T>`; The analogous of LLVM's `SmallVectorImpl`, it factors out of `RVec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:2130,depend,depend,2130,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,1,['depend'],['depend']
Integrability," void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17036,depend,depends,17036,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['depends']
Integrability," volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. \image html geometry007.png ""Extruding volumes"". A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since they lead to unpredictable; results during tracking. *A)* If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an ""extrusion"".; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:91407,depend,dependent,91407,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['depend'],['dependent']
Integrability," warnings, they are used to; support the analyzer core and model known APIs. See also; Default Checkers; and Experimental (Alpha) Checkers. Core Implicit Checkers; OS X Implicit Checkers. Core Implicit Checkers. Name, DescriptionExample. core.DynamicTypePropagation; (C++, ObjC); Generate dynamic type information. // C++; class A {; public:; A(int x) {}; virtual int foo();; };. class B: public A {; public:; B(); :A(foo()); // DynamicTypeInfo for 'this' rigion will wrap type 'A'; // unless the base constructor call expression is processed; {}; virtual int foo();; };. // Objective-C; @interface MyClass : NSObject {}; @end. @implementation MyClass; + (void)foo {; MyClass *x = [[self alloc] init];; // DynamicTypeInfo from a cast: from 'id' to 'MyClass *'; }; @end. void test() {; MyClass *x = [MyClass alloc];; // DynamicTypeInfo from a call to alloc:; // from 'id' to 'MyClass *'; }. core.builtin.BuiltinFunctions; (C); Evaluate compiler builtin functions (e.g., alloca()). void test(int x) {; int *p = (int *)__builtin_alloca(8);; // evaluates to AllocaRegion. if(__builtin_expect(x > 10, 0)) // evaluates to 'x > 10'; x = 0;; }. core.builtin.NoReturnFunctions; (C, ObjC); Evaluate ""panic"" functions that are known to not return to the caller. // C; void test() {; panic(); // generate sink; }. // Objective-C; @interface MyObj : NSObject {}; - (void)foo;; @end. @implementation MyObj; - (void)foo {; [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd; object:self; file:(@""somefile.m""); lineNumber:1; description:(@""some text"")];; // generate sink; }; @end. OS X Implicit Checkers. Name, DescriptionExample. osx.cocoa.Loops; (ObjC); Improved modeling of loops using Cocoa collection types. void test() {; id x;; for (x in [NSArray testObject]) {; // assume the value of 'x' is non-nil; }; }. osx.cocoa.NonNilReturnValue; (ObjC); Model the APIs that are guaranteed to return a non-nil value. void test(NSArray *A) {; id subscriptObj = A[1]; // assume the value is non-nil; }. ; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html:1409,interface,interface,1409,interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,1,['interface'],['interface']
Integrability," were issued 306 times; (50.2%) and there were 7 cycles where no opcodes were issued. The *Scheduler's queue usage* table shows that the average and maximum number of; buffer entries (i.e., scheduler queue entries) used at runtime. Resource JFPU01; reached its maximum (18 of 18 queue entries). Note that AMD Jaguar implements; three schedulers:. * JALU01 - A scheduler for ALU instructions.; * JFPU01 - A scheduler floating point operations.; * JLSAGU - A scheduler for address generation. The dot-product is a kernel of three floating point instructions (a vector; multiply followed by two horizontal adds). That explains why only the floating; point scheduler appears to be used. A full scheduler queue is either caused by data dependency chains or by a; sub-optimal usage of hardware resources. Sometimes, resource pressure can be; mitigated by rewriting the kernel using different instructions that consume; different scheduler resources. Schedulers with a small queue are less resilient; to bottlenecks caused by the presence of long data dependencies. The scheduler; statistics are displayed by using the command option ``-all-stats`` or; ``-scheduler-stats``. The next table, *Retire Control Unit*, presents a histogram displaying a count,; representing the number of instructions retired on some number of cycles. In; this case, of the 610 simulated cycles, two instructions were retired during the; same cycle 399 times (65.4%) and there were 109 cycles where no instructions; were retired. The retire statistics are displayed by using the command option; ``-all-stats`` or ``-retire-stats``. The last table presented is *Register File statistics*. Each physical register; file (PRF) used by the pipeline is presented in this table. In the case of AMD; Jaguar, there are two register files, one for floating-point registers (JFpuPRF); and one for integer registers (JIntegerPRF). The table shows that of the 900; instructions processed, there were 900 mappings created. Since this dot-produc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:32255,depend,dependencies,32255,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability," when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; Reasonably small histograms (GetSize() <; MsgSizeHWM) are merged in one-go at the end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to compress the messages; this is; controlled by ProofServ.CompressMessage; <compression_level>; The default is still 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full hands",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:7121,message,messages,7121,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['message'],['messages']
Integrability," where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6771,message,message,6771,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability," which [can be more readable] for longer links since; it disrupts the flow less. You can put the `[link name]: <URL>` block; pretty much anywhere later in the document. [can be more readable]: http://en.wikipedia.org/wiki/LLVM. Lists can be made like this:. 1. A list starting with `[0-9].` will be automatically numbered. 1. This is a second list element. 1. Use indentation to create nested lists. You can also use unordered lists. * Stuff. + Deeper stuff. * More stuff. #### Example Subsubsection. You can make blocks of code like this:. ```; int main() {; return 0;; }; ```. As an extension to markdown, you can also specify a highlighter to use. ``` C++; int main() {; return 0;; }; ```. For a shell session, use a `console` code block. ```console; $ echo ""Goodbye cruel world!""; $ rm -rf /; ```. If you need to show LLVM IR use the `llvm` code block. ``` llvm; define i32 @test1() {; entry:; ret i32 0; }; ```. Some other common code blocks you might need are `c`, `objc`, `make`,; and `cmake`. If you need something beyond that, you can look at the [full; list] of supported code blocks. [full list]: http://pygments.org/docs/lexers/. However, don't waste time fiddling with syntax highlighting when you could; be adding meaningful content. When in doubt, show preformatted text; without any syntax highlighting like this:. .; +:.; ..:: ::; .++:+:: ::+:.:.; .:+ :; ::.::..:: .+.; ..:+ :: :; ......+:. ..; :++. .. :; .+:::+:: :; .. . .+ ::; +.: .::+.; ...+. .: .; .++:..; ... ##### Hopefully you won't need to be this deep. If you need to do fancier things than what has been shown in this document,; you can mail the list or check the [Common Mark spec]. Sphinx specific; integration documentation can be found in the [myst-parser docs]. [Common Mark spec]: http://spec.commonmark.org/0.28/; [myst-parser docs]: https://myst-parser.readthedocs.io/en/latest/. ## Generating the documentation. see [Sphinx Quickstart Template](project:SphinxQuickstartTemplate.rst#Generating the documentation); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md:4287,integrat,integration,4287,interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,1,['integrat'],['integration']
Integrability," will Merge the list of file _with_ the content of the output; file (if any). This allows make several successive Merge; into the same TFile object.; Yhe argument defines the type of merge as define by the bit values in EPartialMergeType:; ; kRegular : normal merge, overwritting the output file.; kIncremental : merge the input file with the content of the output file (if already exising) (default).; kAll : merge all type of objects (default).; kResetable : merge only the objects with a MergeAfterReset member function. ; kNonResetable : merge only the objects without a MergeAfterReset member function. . Removed TFileMerger::RecursiveMerge from the interface. Prevent TFileMerger (and hadd) from trying to open too many files.; Add a new member function TFileMerger::SetMaxOpenedFiles and; new command line option to hadd ( -n requested_max ) to allow; the user to reduce the number of files opened even further. Update hadd and TFileMerger so that they prefix all their information message; with their names (when running hadd, the TFileMerger message are prefixed by hadd):. $ hadd -v 0 -f output.root input1.root input2.root; $ hadd -v 1 -f output.root input1.root input2.root; hadd merged 2 input files in output.root.; $ hadd -v 2 -f output.root input1.root input2.root; hadd target file: output.root; hadd Source file 1: input1.root; hadd Source file 2: input2.root; hadd Target path: output.root:/. Introduce non-static version of TFile::Cp allows the copy of; an existing TFile object. Introduce new explicit interface for providing reseting; capability after a merge. If a class has a method with; the name and signature:. void ResetAfterMerge(TFileMergeInfo*);. it will be used by a TMemFile to reset its objects after; a merge operation has been done. If this method does not exist, the TClass will use; a method with the name and signature:. void Reset(Optiont_t *);. TClass now provides a quick access to these merging; function via TClass::GetResetAfterMerge. The wrapper function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:7855,message,message,7855,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['message'],['message']
Integrability," will share the Ctx member, which will exist for the; duration of the JIT. Once we switch to concurrent compilation in later chapters; we will use a new context per module. Our last method is ``lookup``, which allows us to look up addresses for; function and variable definitions added to the JIT based on their symbol names.; As noted above, lookup will implicitly trigger compilation for any symbol; that has not already been compiled. Our lookup method calls through to; `ExecutionSession::lookup`, passing in a list of dylibs to search (in our case; just the main dylib), and the symbol name to search for, with a twist: We have; to *mangle* the name of the symbol we're searching for first. The ORC JIT; components use mangled symbols internally the same way a static compiler and; linker would, rather than using plain IR symbol names. This allows JIT'd code; to interoperate easily with precompiled code in the application or shared; libraries. The kind of mangling will depend on the DataLayout, which in turn; depends on the target platform. To allow us to remain portable and search based; on the un-mangled name, we just re-produce this mangling ourselves using our; ``Mangle`` member function object. This brings us to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Cha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:12194,depend,depend,12194,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,2,['depend'],"['depend', 'depends']"
Integrability," with `Snapshot`; - Improved checks for column name validity (throw if column does not exist and if `Define`d column overrides an already existing column). #### Other changes; - Improved documentation; - TDF now avoids performing virtual calls for parts of the analysis that are not jitted; - Removed ""custom column"" nodes from the internal functional graph therewith optimising its traversal; - Improvements in Cling drastically enhanced scaling and performance of TDF jitted code; - Test coverage has been increased with the introduction of google tests; - Interface change: users must now use TDF::TArrayBranch rather than std::array\_view to specify that the column being read is a c-style array TTree branch; - Interface change: `Min` and `Max` now return results as the same type specified as template parameter, or double if no template parameter was specified. ## Histogram Libraries; - Histogram-based fits are implicitly parallelized.; - Added new options to the histogram fitting interfaces to support explicit parallelization of the fit as well.; - `TF1` gradient evaluation supports vectorization.; - Refactor of `TF1` constructors, default initialization of its data members and fixed ambiguous TF1::operator().; - Extend `TFormula` parsing capabilities.; - The parsing of arguments for defining parametric function is improved. For example a Gaussian function in y can be defined as `gaus( y , [A], [Mean], [Sigma])`.; - One can define the function variables or parameters using another function or an expression. Example: `gaus(x, [A], [m0]*y+[m1], [sigma])`.; - Support for function composition in `TFormula`, i.e. a function can be composed from another function, Again, an example: `gaus( f1(x), [A],[Mean],[Sigma])`, where `f1` is a function defined; previously.; - Facilitate using Normalized sums of TF1 objects and convolutions, by adding the `NSUM` and `CONV` operators for TF1 objects built with formula expressions; - `TF1(""model"", ""NSUM(gaus , expo)"", xmin, xmax)` will crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:15896,interface,interfaces,15896,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['interface'],['interfaces']
Integrability," with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstructs them as wide pointer Clang AST types for use in the expression; evaluator. External bounds annotations; ---------------------------. Similar to internal bounds annotations, external bound annotations are described; as a typedef to their underlying pointer type in the debug info, and the bounds; are encoded as strings in the typedef’s name (e.g.,; ``__bounds_safety$counted_by:N``). Recognizing ``-fbounds-safety`` traps; -------------------------------------. Clang emits debug info for ``-fbounds-safety`` traps as inlined functions, where; the function name encodes the error message. LLDB implements a frame recognizer; to surface a human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:9479,message,message,9479,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['message'],['message']
Integrability," with different nullability, but in the given path the two parameters might end up being the same symbol or there can be nested functions that take different view of the nullability of the same symbol). So the symbol will remain nonnull to avoid false positives but the functions that takes nullable parameters will be analyzed separately as well without inlining. Annotations on multi level pointers; -----------------------------------. Tracking multiple levels of annotations for pointers pointing to pointers would make the checker more complicated, because this way a vector of nullability qualifiers would be needed to be tracked for each symbol. This is not a big caveat, since once the top level pointer is dereferenced, the symvol for the inner pointer will have the nullability information. The lack of multi level annotation tracking only observable, when multiple levels of pointers are passed to a function which has a parameter with multiple levels of annotations. So for now the checker support the top level nullability qualifiers only.:. .. code-block:: cpp. int * __nonnull * __nullable p;; int ** q = p;; takesStarNullableStarNullable(q);. Implementation notes; --------------------. What to track?. * The checker would track memory regions, and to each relevant region a qualifier information would be attached which is either nullable, nonnull or null unspecified (or contradicted to suppress warnings for a specific region).; * On a branch, where a nullable pointer is known to be non null, the checker treat it as a same way as a pointer annotated as nonnull.; * When there is an explicit cast from a null unspecified to either nonnull or nullable I will trust the cast.; * Unannotated pointers are treated the same way as pointers annotated with nullability unspecified qualifier, unless the region is wrapped in ASSUME_NONNULL macros.; * We might want to implement a callback for entry points to top level functions, where the pointer nullability assumptions would be made.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:5924,wrap,wrapped,5924,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,1,['wrap'],['wrapped']
Integrability," with name ""GNewton"": modified Newton method . The algorithms without derivatives (see also the GSL; documentation ); are the followings:; ; ROOT::Math::GSLMultiRootFinder::kHybridS with name ""HybridS"": same as HybridSJ but using; finate difference approximation for the derivatives; ROOT::Math::GSLMultiRootFinder::kHybrid with name ""Hybrid"": unscaled version of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kDNewton with name ""DNewton"": discrete Newton algorithm ; ROOT::Math::GSLMultiRootFinder::kBroyden with name ""Broyden"": Broyden algorithm . Minuit2. Improve Printing of information and Error messages. Use the class ROOT::Minuit2::MnPrint to store a; static print level, which can be set by using the static function MnPrint::SetLevel(int ). Add new information messages in the VariableMetricBuilder (i.e. Migrad), to print some messages; during the minimization.The new printing level is now also controlled by the Minuit2Minimizer class. ; Print now in the messages the parameter names instead of the parameter indices.; fix the update of the number of function calls in Minuit2 after calling Hess after Migrad. The number is now not; reset in MnHesse; Fix a problem, when, after calling Hesse ,the edm was correct to values below the required tolerance.; Now do not flag these cases as failed minimizations but as good ones.; Correct tolerance by 2E-3 instead 2E-4 to ve conistent with what is done in F77 Minuit or TMinuit; Avoid when using the CombinedMinimumBuilder (i.e. the Minimize algorithm) to call two times; ModularFunctionMinimize::Minimum. Since this last function correct the tolerance by the Up value, a; double correction was applied in this case. ; Implement the methods Minuit2Minimizer::GetHessianMatrix(double * mat) and; Minuit2Minimizer::GetCovMatrix(double * mat).; For retrieving the Hessian, a new method has been added, MnUserParameterState::Hessian, which returns; the Hessian by inverting the covariance matrix, since the Hessian is not stored inside",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:5063,message,messages,5063,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,1,['message'],['messages']
Integrability," with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53431,depend,depending,53431,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['depending']
Integrability," with their ``++`` and ``--`` operators replaced with fallible; ``Error inc()`` and ``Error dec()`` functions. E.g.:. .. code-block:: c++. class FallibleChildIterator {; public:; FallibleChildIterator(Archive &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38546,wrap,wrapper,38546,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapper']
Integrability," with this bit set; cannot add friend trees nor can be added as friends, unless the friend `TTree` has an appropriate `TTreeIndex`. ## Histogram Libraries. ## Math Libraries. ## RooFit Libraries. ### RooWorkspace::Import() for Python; `RooWorkspace.import()` cannot be used in Python, since it is a reserved keyword. Users therefore had to resort; to; getattr(workspace, 'import')(...); Now,; workspace.Import(...); has been defined for the new PyROOT, which makes calling the function easier. ### Modernised category classes; RooFit's categories were modernised. Previously, the class RooCatType was used to store category states. It stores; two members, an integer for the category index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:3396,interface,interface,3396,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['interface'],['interface']
Integrability," with:. .. code-block:: sh. % clang -c -o test_code_harness.o test_code_harness.c; % llvm-jitlink -phony-externals test_code.o -harness test_code_harness.o; used mock utility function; Y is 42. The ``-harness`` option may be of interest to people who want to perform some; very late testing on build products to verify that compiled code behaves as; expected. On basic C test cases this is relatively straightforward. Mocks for; more complicated languages (e.g. C++) are much trickier: Any code involving; classes tends to have a lot of non-trivial surface area (e.g. vtables) that; would require great care to mock. Tips for JITLink backend developers; -----------------------------------. #. Make liberal use of assert and ``llvm::Error``. Do *not* assume that the input; object is well formed: Return any errors produced by libObject (or your own; object parsing code) and validate as you construct. Think carefully about the; distinction between contract (which should be validated with asserts and; llvm_unreachable) and environmental errors (which should generate; ``llvm::Error`` instances). #. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrapper, the ``llvm-jitlink`` tool is an; invaluable resource for developers bringing in a new JITLink backend. A standard; workflow is to start by throwing an unsupported object at the tool and seeing; what error is returned, then fixing that (you can often make a reasonable guess; at what should be done based on existing code for other formats or; architectures). In debug builds of LLVM, the ``-debug-only=jitlink`` option dumps logs from the; JITLink library during the link process. These can be useful for spotting some bugs at; a glance. The ``-debug-only=llvm_jitlink`` option dumps logs from the ``llvm-jitlink``; tool, which can be useful for debugging both testcases (it is often less verbose than; ``-debug-only=jitl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:43181,contract,contract,43181,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['contract'],['contract']
Integrability," without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to use the `RooFit::OwningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10087,interface,interfaces,10087,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability," x);; double airy_Bi_deriv(double x);; double airy_zero_Ai(unsigned int s);; double airy_zero_Bi(unsigned int s);; double airy_zero_Ai_deriv(unsigned int s);; double airy_zero_Bi_deriv(unsigned int s);; ; Wigner coefficient functions:; ; double wigner_3j(int ja, int jb, int jc, int ma, int mb, int mc);; double wigner_6j(int ja, int jb, int jc, int jd, int je, int jf);; double wigner_9j(int ja, int jb, int jc, int jd, int je, int jf, int jg, int jh, int ji);; . New statistical function: non-central chisquare probability; density function; ; double noncentral_chisquared_pdf(double x, double r, double lambda);; ; It is implemented using Bessel functions or hypergeometric function; ; New classes VavilovAccurate and VavilovFast,; derived from the abstract base class Vavilov,; provide pdf, cdf and quantile functions for the Vavilov distribution,; based on the algorithms of CERNLIB (G116 and G115, respectively).; The classes VavilovAccuratePdf,; VavilovAccurateCdf and VavilovAccurateQuantile; implement the IParametricFunctionOneDim interface; for easier use in fit problems. . Unuran. Use new version 1.7.2 ; Add new class TUnuranSampler implementing the; ROOT::Math::DistSampler interface for one dimensional; continuous and discrete distributions and for mult-dimensional ones; . Foam. Add new class TFoamSampler implementing the; ROOT::Math::DistSampler interface for generating random; numbers according to any one or multi-dim distributions using Foam.; ; All the TFoam options can be controlled via the; ROOT::Math::DistSamplerOptions class, which can be passed; as input to the virtual ROOT::Math::DistSampler::Init(..); function.; . GenVector. Add some missing copy constructor and assignment operators to; fix compilation issue observed with LLVM (Clang). Minuit. Fix a bug when using at the same time TMinuit or TFitter with; the new TMinuitMinimizer class. See bug 72909.; . Minuit2. Fix the returned error from the Minimizer class for fixed and; constant parameters. Now is set ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:8935,interface,interface,8935,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['interface'],['interface']
Integrability," you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7458,depend,depending,7458,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['depend'],['depending']
Integrability," {; entry:; ...; br i1 %cond1, label %then1, label %mid. then1:; ...; %cond2 = ...; br label %mid. mid:; %flag = phi i1 [ true, %entry ], [ %cond2, %then1 ]; br i1 %flag, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier(); ...; br label %end. end:; }. void example_jumpthreaded() {; entry:; ...; br i1 %cond1, label %then1, label %then2. then1:; ...; %cond2 = ...; br i1 %cond2, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier(); ...; br label %end. end:; }. Is the control barrier guaranteed to synchronize among the same set of threads; in both cases? Different implementations in the literature may give different; answers to this question:. * In an implementation that reconverges at post-dominators, threads reconverge; at ``mid`` in the first version, so that all threads (within a subgroup/wave); that execute the control barrier do so together. In the second version,; threads that reach the control barrier via different paths synchronize; separately: the first (and only) post-dominator is ``end``, so threads do not; reconverge before then. * An implementation that sorts basic blocks topologically and ensures maximal; reconvergence for each basic block would behave the same way in both; versions. We generally take the stance that reconvergence in acyclic control flow must; be maximal. The compiler frontend could augment the original code as follows:. .. code-block:: llvm. define void @example_original() convergent {; entry:; %entry = call token @llvm.experimental.convergence.entry(); ...; br i1 %cond1, label %then1, label %mid. then1:; ...; %cond2 = ...; br label %mid. mid:; %flag = phi i1 [ true, %entry ], [ %cond2, %then1 ]; br i1 %flag, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier() [ ""convergencectrl""(token %entry) ]; ...; br label %end. end:; }. If S is the set of threads that the entry intrinsic communicated with, then; the ``@subgroupControlBarrier`` call communicates with the subset of S ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:10129,synchroniz,synchronize,10129,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['synchroniz'],['synchronize']
Integrability," |; | | a sphere of radius `r` |; +-------------------------------------------+--------------------------------+; | `Rannor(Double_t &a,Double_t &b)` | Generate a pair of Gaussian |; | | random |; | | |; | | numbers with `mu=0` and |; | | `sigma=1` |; +-------------------------------------------+--------------------------------+. ### UNURAN. An interface to a new package, UNU.RAN, (Universal Non Uniform Random; number generator for generating non-uniform pseudo-random numbers) was; introduced in ROOT v5.16. UNU.RAN is an ANSI C library licensed under GPL. It contains universal; (also called automatic or black-box) algorithms that can generate random; numbers from large classes of continuous (in one or multi-dimensions),; discrete distributions, empirical distributions (like histograms) and; also from practically all standard distributions. An extensive online; documentation is available at the UNU.RAN Web Site; <http://statmath.wu-wien.ac.at/unuran/>. The ROOT class **`TUnuran`** is used to interface the UNURAN package. It; can be used as following:. - With the UNU.RAN native, string API for pre-defined distributions; (see UNU.RAN documentation for the allowed string values at; <http://statistik.wu-wien.ac.at/unuran/doc/unuran.html> ):. ``` {.cpp}; TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For continuous 1D distribution object via the class; **`TUnuranContDist`** that can be created for example from a; **`TF1`** function providing the pdf (probability density function); . The user can optionally provide additional information via; `TUnuranContDist::SetDomain(min,max)` like the `domain()` for; generating numbers in a restricted region. ``` {.cpp}; // 1D case: create a distribution from two TF1 object; // pointers pdfFunc; TUnuranContDist dist( pdfFunc);;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:18943,interface,interface,18943,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability," }. This class works the exact same as the `cl::list`_ class, except that the second; argument must be of **type** ``unsigned`` if external storage is used. .. _cl::alias:. The ``cl::alias`` class; ^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::alias`` class is a nontemplated class that is used to form aliases for; other arguments. .. code-block:: c++. namespace cl {; class alias;; }. The `cl::aliasopt`_ attribute should be used to specify which option this is an; alias for. Alias arguments default to being `cl::Hidden`_, and use the aliased; options parser to do the conversion from string to data. .. _cl::extrahelp:. The ``cl::extrahelp`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::extrahelp`` class is a nontemplated class that allows extra help text; to be printed out for the ``-help`` option. .. code-block:: c++. namespace cl {; struct extrahelp;; }. To use the extrahelp, simply construct one with a ``const char*`` parameter to; the constructor. The text passed to the constructor will be printed at the; bottom of the help message, verbatim. Note that multiple ``cl::extrahelp``; **can** be used, but this practice is discouraged. If your tool needs to print; additional help information, put all that help into a single ``cl::extrahelp``; instance. For example:. .. code-block:: c++. cl::extrahelp(""\nADDITIONAL HELP:\n\n This is the extra help\n"");. .. _cl::OptionCategory:. The ``cl::OptionCategory`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::OptionCategory`` class is a simple class for declaring; option categories. .. code-block:: c++. namespace cl {; class OptionCategory;; }. An option category must have a name and optionally a description which are; passed to the constructor as ``const char*``. Note that declaring an option category and associating it with an option before; parsing options (e.g. statically) will change the output of ``-help`` from; uncategorized to categorized. If an option category is declared but not; associated with an option then it will be hidden",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:57561,message,message,57561,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['message']
Integrability," }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.coc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15729,interface,interface,15729,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"![CivetWeb](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/civetweb_64x64.png ""CivetWeb"") CivetWeb; =======. **The official home of CivetWeb is [https://github.com/civetweb/civetweb](https://github.com/civetweb/civetweb)**. [![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT); [![GitHub contributors](https://img.shields.io/github/contributors/civetweb/civetweb.svg)](https://github.com/civetweb/civetweb/blob/master/CREDITS.md). Continuous integration for Linux and macOS ([Travis CI](https://app.travis-ci.com/github/civetweb/civetweb)):. [![Travis Build Status](https://api.travis-ci.com/civetweb/civetweb.svg?branch=master)](https://app.travis-ci.com/github/civetweb/civetweb). Continuous integration for Windows ([AppVeyor](https://ci.appveyor.com/project/civetweb/civetweb)):. [![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/github/civetweb/civetweb?svg=true)](https://ci.appveyor.com/project/civetweb/civetweb/branch/master). Test coverage check ([coveralls](https://coveralls.io/github/civetweb/civetweb), [codecov](https://codecov.io/gh/civetweb/civetweb/branch/master)) (using different tools/settings):. [![Coveralls](https://img.shields.io/coveralls/civetweb/civetweb.svg?maxAge=3600)](); [![Coverage Status](https://coveralls.io/repos/github/civetweb/civetweb/badge.svg?branch=master)](https://coveralls.io/github/civetweb/civetweb?branch=master). [![codecov](https://codecov.io/gh/civetweb/civetweb/branch/master/graph/badge.svg)](https://codecov.io/gh/civetweb/civetweb). Static source code analysis ([Coverity](https://scan.coverity.com/projects/5784)):. [![Coverity Scan Build Status](https://scan.coverity.com/projects/5784/badge.svg)](https://scan.coverity.com/projects/5784). Project Mission; -----------------. Project mission is to provide easy to use, powerful, C (C/C++) embeddable web server with optional CGI, SSL and Lua support.; CivetWeb has a MIT license so you can innovate wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:512,integrat,integration,512,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,2,['integrat'],['integration']
Integrability,""" """" originprefix ${originurl}); relatedrepo_GetClosestMatch(REPO_NAME roottest; ORIGIN_PREFIX ${originprefix} UPSTREAM_PREFIX ${upstreamprefix}; FETCHURL_VARIABLE roottest_url FETCHREF_VARIABLE roottest_ref); # Use `-Droottest_force_checkout=ON` to force fetch and checkout in an existing repository; if(roottest_force_checkout); set(roottest_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME roottest FETCHURL ${roottest_url} FETCHREF ""${roottest_ref}""; REPO_DIR_VARIABLE roottest_dir ${roottest_opts}); if(NOT IS_DIRECTORY ${roottest_dir}); message(FATAL_ERROR ""Expected roottest at '${roottest_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/roottest); add_subdirectory(${roottest_dir} roottest); endif(). if(rootbench); find_package(Git REQUIRED); if(rootbench_force_checkout); set(rootbench_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME rootbench FETCHURL ${upstreamprefix} FETCHREF master; REPO_DIR_VARIABLE rootbench_dir ${rootbench_opts}); if(NOT IS_DIRECTORY ${rootbench_dir}); message(FATAL_ERROR ""Expected rootbench at '${rootbench_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/rootbench); add_subdirectory(${rootbench_dir} rootbench); endif(); endif(). if(LLVM_LINKER_IS_MOLD); message(FATAL_ERROR ""The mold linker is not supported by ROOT. Please use a different linker""); endif(). cmake_host_system_information(RESULT PROCESSOR QUERY PROCESSOR_DESCRIPTION). message(STATUS ""ROOT Configuration \n; System: ${CMAKE_SYSTEM}; ROOT Platform: ${ROOT_PLATFORM}; ROOT Architecture: ${ROOT_ARCHITECTURE}; Processor: ${PROCESSOR} (${CMAKE_SYSTEM_PROCESSOR}); Build type: ${CMAKE_BUILD_TYPE}; Install path: ${CMAKE_INSTALL_PREFIX}; Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}; C++ standard: ${CMAKE_CXX_STANDARD}; Compiler flags:""); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); message(STATUS ""; - C: ${CMAKE_C_FLAGS}; - C (build type specific):; Debug: ${CMAKE_C_FLAGS_DEBUG}; Release:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:30199,message,message,30199,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,""" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:16700,contract,contracts,16700,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['contract'],['contracts']
Integrability,""" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102436,depend,dependency,102436,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependency']
Integrability,""" output):. .. code-block:: none. 0x00000100: TAG_structure_type [7] *; AT_APPLE_runtime_class( 0x10 ); AT_name( ""I1"" ); AT_decl_file( ""Objc_Property.m"" ); AT_decl_line( 3 ). 0x00000110 TAG_APPLE_property; AT_name ( ""p1"" ); AT_type ( {0x00000150} ( int ) ). 0x00000120: TAG_APPLE_property; AT_name ( ""p2"" ); AT_type ( {0x00000150} ( int ) ). 0x00000130: TAG_member [8]; AT_name( ""_p1"" ); AT_APPLE_property ( {0x00000110} ""p1"" ); AT_type( {0x00000150} ( int ) ); AT_artificial ( 0x1 ). 0x00000140: TAG_member [8]; AT_name( ""n2"" ); AT_APPLE_property ( {0x00000120} ""p2"" ); AT_type( {0x00000150} ( int ) ). 0x00000150: AT_type( ( int ) ). Note, the current convention is that the name of the ivar for an; auto-synthesized property is the name of the property from which it derives; with an underscore prepended, as is shown in the example. But we actually; don't need to know this convention, since we are given the name of the ivar; directly. Also, it is common practice in ObjC to have different property declarations in; the @interface and @implementation - e.g. to provide a read-only property in; the interface, and a read-write interface in the implementation. In that case,; the compiler should emit whichever property declaration will be in force in the; current translation unit. Developers can decorate a property with attributes which are encoded using; ``DW_AT_APPLE_property_attribute``. .. code-block:: objc. @property (readonly, nonatomic) int pr;. .. code-block:: none. TAG_APPLE_property [8]; AT_name( ""pr"" ); AT_type ( {0x00000147} (int) ); AT_APPLE_property_attribute (DW_APPLE_PROPERTY_readonly, DW_APPLE_PROPERTY_nonatomic). The setter and getter method names are attached to the property using; ``DW_AT_APPLE_property_setter`` and ``DW_AT_APPLE_property_getter`` attributes. .. code-block:: objc. @interface I1; @property (setter=myOwnP3Setter:) int p3;; -(void)myOwnP3Setter:(int)a;; @end. @implementation I1; @synthesize p3;; -(void)myOwnP3Setter:(int)a{ }; @end. The DWARF for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:52686,interface,interface,52686,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['interface'],['interface']
Integrability,"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (Ob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58519,interface,interface,58519,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,""""""""""""""""". The '``@llvm.nvvm.barrier0()``' intrinsic emits a PTX ``bar.sync 0``; instruction, equivalent to the ``__syncthreads()`` call in CUDA. Other Intrinsics; ----------------. For the full set of NVPTX intrinsics, please see the; ``include/llvm/IR/IntrinsicsNVVM.td`` file in the LLVM source tree. .. _libdevice:. Linking with Libdevice; ======================. The CUDA Toolkit comes with an LLVM bitcode library called ``libdevice`` that; implements many common mathematical functions. This library can be used as a; high-performance math library for any compilers using the LLVM NVPTX target.; The library can be found under ``nvvm/libdevice/`` in the CUDA Toolkit and; there is a separate version for each compute architecture. For a list of all math functions implemented in libdevice, see; `libdevice Users Guide <http://docs.nvidia.com/cuda/libdevice-users-guide/index.html>`_. To accommodate various math-related compiler flags that can affect code; generation of libdevice code, the library code depends on a special LLVM IR; pass (``NVVMReflect``) to handle conditional compilation within LLVM IR. This; pass looks for calls to the ``@__nvvm_reflect`` function and replaces them; with constants based on the defined reflection parameters. Such conditional; code often follows a pattern:. .. code-block:: c++. float my_function(float a) {; if (__nvvm_reflect(""FASTMATH"")); return my_function_fast(a);; else; return my_function_precise(a);; }. The default value for all unspecified reflection parameters is zero. The ``NVVMReflect`` pass should be executed early in the optimization; pipeline, immediately after the link stage. The ``internalize`` pass is also; recommended to remove unused math functions from the resulting PTX. For an; input IR module ``module.bc``, the following compilation flow is recommended:. 1. Save list of external functions in ``module.bc``; 2. Link ``module.bc`` with ``libdevice.compute_XX.YY.bc``; 3. Internalize all functions not in list from (1); 4. Elimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:8221,depend,depends,8221,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['depend'],['depends']
Integrability,""""""""""""". The '``cmpxchg``' instruction is used to atomically modify memory. It; loads a value in memory and compares it to a given value. If they are; equal, it tries to store a new value into the memory. Arguments:; """""""""""""""""""". There are three arguments to the '``cmpxchg``' instruction: an address; to operate on, a value to compare to the value currently be at that; address, and a new value to place at that address if the compared values; are equal. The type of '<cmp>' must be an integer or pointer type whose; bit width is a power of two greater than or equal to eight and less; than or equal to a target-specific size limit. '<cmp>' and '<new>' must; have the same type, and the type of '<pointer>' must be a pointer to; that type. If the ``cmpxchg`` is marked as ``volatile``, then the; optimizer is not allowed to modify the number or order of execution of; this ``cmpxchg`` with other :ref:`volatile operations <volatile>`. The success and failure :ref:`ordering <ordering>` arguments specify how this; ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters; must be at least ``monotonic``, the failure ordering cannot be either; ``release`` or ``acq_rel``. A ``cmpxchg`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Note: if the alignment is not greater or equal to the size of the `<value>`; type, the atomic operation is likely to require a lock and have poor; performance. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. If unspecified, the alignment is assumed to be equal to the; size of the '<value>' type. Note that this default alignment assumption is; different from the alignment used for the load/store instructions when align; isn't specified. The pointer passed into cmpxchg must have alignment greater than or; equal to the size in memory of the operand. Semantics:; """""""""""""""""""". The contents of memory at the location specified by the '``<pointer>``' operand; is rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:426820,synchroniz,synchronizes,426820,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes']
Integrability,""""""""""""". The ``llvm.objectsize`` intrinsic takes four arguments. The first argument is a; pointer to or into the ``object``. The second argument determines whether; ``llvm.objectsize`` returns 0 (if true) or -1 (if false) when the object size is; unknown. The third argument controls how ``llvm.objectsize`` acts when ``null``; in address space 0 is used as its pointer argument. If it's ``false``,; ``llvm.objectsize`` reports 0 bytes available when given ``null``. Otherwise, if; the ``null`` is in a non-zero address space or if ``true`` is given for the; third argument of ``llvm.objectsize``, we assume its size is unknown. The fourth; argument to ``llvm.objectsize`` determines if the value should be evaluated at; runtime. The second, third, and fourth arguments only accept constants. Semantics:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic is lowered to a value representing the size of; the object concerned. If the size cannot be determined, ``llvm.objectsize``; returns ``i32/i64 -1 or 0`` (depending on the ``min`` argument). '``llvm.expect``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.expect`` on any; integer bit width. ::. declare i1 @llvm.expect.i1(i1 <val>, i1 <expected_val>); declare i32 @llvm.expect.i32(i32 <val>, i32 <expected_val>); declare i64 @llvm.expect.i64(i64 <val>, i64 <expected_val>). Overview:; """""""""""""""""". The ``llvm.expect`` intrinsic provides information about expected (the; most probable) value of ``val``, which can be used by optimizers. Arguments:; """""""""""""""""""". The ``llvm.expect`` intrinsic takes two arguments. The first argument is; a value. The second argument is an expected value. Semantics:; """""""""""""""""""". This intrinsic is lowered to the ``val``. '``llvm.expect.with.probability``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This intrinsic is similar to ``llvm.expect``. This is an overloaded intrinsic.; You can use ``llvm.expect.with.probability`` on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:933250,depend,depending,933250,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes and returns it as an integer value. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes, such as rounding direction, precision, treatment of denormals and; so on. It is similar to the C library function 'fegetmode', however this; function does not store the set of control modes into memory but returns it as; an integer value. Interpretation of the bits in this value is target-dependent. '``llvm.set.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current floating-point control modes. ::. declare void @llvm.set.fpmode(<integer_type> <val>). Overview:; """""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes. Arguments:; """""""""""""""""""". The argument is a set of floating-point control modes, represented as an integer; value in a target-dependent way. Semantics:; """""""""""""""""""". The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point; control modes to the state specified by the argument, which must be obtained by; a call to '``llvm.get.fpmode``' or constructed in a target-specific way. It is; similar to the C library function 'fesetmode', however this function does not; read the set of control modes from memory but gets it as integer value. '``llvm.reset.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpmode(). Overview:; """""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the default dynamic floating-point; control modes. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.reset.fpmode``' intrinsic sets the current dynamic floating-point; environment to default state. It is similar to the C library function call; 'fesetmode(FE_DFL_MODE)', however this function does not return any value. Fl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:920204,depend,dependent,920204,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,""");; new Event();; }; ```. You will currently have to provide a rootmap file for libEvent (which also requires include; guards for Event.h). This might get fixed in a later version ([ROOT-4691](https://sft.its.cern.ch/jira/browse/ROOT-4691)). #### Using identifiers that are only available at runtime: gROOT->LoadMacro(""foo.h""); foo(); CINT was processing macros line by line; Cling compiles code.; During this compilation, Cling will not see identifiers provided by `gROOT->LoadMacro()`.; While this will covered by dynamic scopes, they are currently too limited to handle this.; Please `#include` the header instead. ### TInterpreter. ### TInterpreter. `TInterpreter::GetCurrentMacroName()` has a slightly different behavior in ROOT; 6 than in ROOT 5. In ROOT 5 it was a synonym for `__FILE__` (so please use; `__FILE__` to get the old value); in ROOT 6 it returns the currently executing; (.x) source file. For nested execution it returns the innermost one. The following are no longer supported and are now only issuing error; messages:. - Getgvp; - Setgvp; - SetRTLD\_NOW; - SetRTLD\_LAZY. Use of Setgvp and Getgvp should be looked at carefully as they were use; to control the behavior of the multiplexing CINT wrappers that were both; wrapper the calls to operator new with and without placement and the; constructor (and similarly for operator delete and the destructor).; Cling does not support such a multiplexing wrapper and alternatively; interface must be used (See TClass::New and TClass::Destructor for; example). The following interfaces are not yet available:. - DeleteVariable. They might be re-implemented in a later version. ### rootcling, rootcint and genreflex. rootcling is the successor to rootcint and it preserves its old commandline; arguments and provides more (see help). The executable rootcint still exists; but it is just a redirection to rootcling.; The following *backward incompatibilities* are present between rootcint in; version 5 and rootcling in version 6:. - r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:5093,message,messages,5093,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['message'],['messages']
Integrability,""",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode of operation depends on the shape of the requestion integration range. Note that in general integration over non (hyper)rectangular regions will be more computationally; intensive as only a subset of the observables can be integrated analytically (all of those that do not; have parameterized ranges plus those that have parameterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:4325,depend,depend,4325,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,3,"['depend', 'message']","['depend', 'message']"
Integrability,""".*ld64-([0-9.]+).*""); string(REGEX REPLACE "".*ld64-([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); elseif (""${LD_V_OUTPUT}"" MATCHES ""[^0-9]*([0-9.]+).*""); string(REGEX REPLACE ""[^0-9]*([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); endif(); message(STATUS ""Host linker version: ${HOST_LINK_VERSION}""); endif(). include(CMakeParseArguments); include(AddClang). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/clang include/clang-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""*.inc""; PATTERN ""*.h""; ). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(clang-headers DEPENDS clang-tablegen-targets); set_target_properties(clang-headers PROPERTIES FOLDER ""Misc""); if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-headers; DEPENDS clang-headers; COMPONENT clang-headers); endif(). add_custom_target(bash-autocomplete DEPENDS utils/bash-autocomplete.sh); install(FILES utils/bash-autocomplete.sh; DESTINATION ""${CMAKE_INSTALL_DATADIR}/clang""; COMPONENT bash-autocomplete); if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-bash-autocomplete; DEPENDS bash-autocomplete; COMPONENT bash-autocomplete); endif(); endif(). option(CLANG_BUILD_TOOLS; ""Build the Clang tools. If OFF, just generate build targets."" ON). if(LLVM_ENABLE_PLUGINS OR LLVM_EXPORT_SYMBOLS_FOR_PLUGINS); set(HAVE_CLANG_PLUGIN_SUPPORT ON); else(); set(HAVE_CLANG_PLUGIN_SUPPORT OFF); endif(); CMAKE_DEPENDENT_OPTION(CLANG_PLUGIN_SUPPORT; ""Build clang with plugin support"" ON; ""HAVE_CLANG_PLUGIN_SUPPORT"" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:14225,depend,depend,14225,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,""": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36207,depend,dependency,36207,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:52408,contract,contract,52408,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70974,message,message,70974,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35638,interface,interface,35638,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"""curve(fc(x), 0, 10, col = 'darkblue', add = TRUE)"";; // different interpolation on left and right side :; r<<""plot(approxfun(x, y, rule = 2:1), 0, 11,col = 'tomato', add = TRUE, lty = 3, lwd = 2)"";; }; ~~~; The image shows the interpolated function plotted within R:; \image html R_image3.png. ## Integration (Passing vectorized function to R); Numerical integration using R passing the function from ROOT. ~~~{.cxx}; #include<TMath.h>; #include<TRInterface.h>; #include<Math/Integrator.h>; #include<TF1.h>. //To integrate using R the function must be vectorized; //The idea is just to receive a vector like an argument,to evaluate; //every element saving the result in another vector; //and return the resultant vector.; std::vector<Double_t> BreitWignerVectorized(std::vector<Double_t> xx); {; std::vector<Double_t> result(xx.size());; for(Int_t i=0;i<xx.size();i++); {; result[i]=TMath::BreitWigner(xx[i]);; }; return result;; }. double BreitWignerWrap( double x){; return TMath::BreitWigner(x);; }. void Integration(); {. ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();. r[""BreitWigner""]=BreitWignerVectorized;. Double_t value=r.Eval(""integrate(BreitWigner, lower = -2, upper = 2)$value"");. std::cout.precision(18);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] R = ""<<value<<std::endl;. ROOT::Math::WrappedFunction<> wf(BreitWignerWrap);; ROOT::Math::Integrator i(wf);; value=i.Integral(-2,2);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] MathMore = ""<<value<<std::endl;. TF1 f1(""BreitWigner"",""BreitWignerWrap(x)"");; value=f1.Integral(-2,2);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] TF1 = ""<<value<<std::endl;. //infinte limits; value=r.Eval(""integrate(BreitWigner, lower = -Inf, upper = Inf)$value"");; std::cout<<""Integral of BreitWigner Function in the interval [-Inf, Inf] R = ""<<value<<std::endl;. }; ~~~. ## Users Guide Sites; - http://oproject.org/tiki-index.php?page=ROOT+R+Users+Guide. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:23048,integrat,integrate,23048,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,2,['integrat'],['integrate']
Integrability,"""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible, already-deserialized AST nodes visible; it is the; responsibility of the AST reader to find and update these AST nodes when it; is notified of the import. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:29395,interface,interface,29395,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37015,depend,dependency,37015,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{0:$[+]}"", make_range(V.begin(), V.end())); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17094,message,message,17094,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['message'],['message']
Integrability,"# 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins with 0 contents. Now, combined; with options E1 and E2, it avoids error bars clipping. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### Multithreaded support for FastCGI. Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests; received via FastCGI channel. This significantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for sha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:25588,protocol,protocol,25588,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['protocol'],['protocol']
Integrability,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:410,rout,routines,410,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['rout'],['routines']
Integrability,"# Adding a Class. ## The Role of TObject. The light-weight **`TObject`** class provides the default behavior and; protocol for the objects in the ROOT system. Specifically, it is the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:114,protocol,protocol,114,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,3,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:500,depend,depending,500,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['depend'],['depending']
Integrability,"# Building libclang-cpp.so fails if LLVM_ENABLE_PIC=Off; if (NOT LLVM_ENABLE_PIC); return(); endif(). get_property(clang_libs GLOBAL PROPERTY CLANG_STATIC_LIBS). foreach (lib ${clang_libs}); if(XCODE); # Xcode doesn't support object libraries, so we have to trick it into; # linking the static libraries instead.; list(APPEND _DEPS ""-force_load"" ${lib}); else(); list(APPEND _OBJECTS $<TARGET_OBJECTS:obj.${lib}>); endif(); if (BUILD_SHARED_LIBS); # If we are building static libraries, then we don't need to add the static; # libraries as a dependency, because we are already linking against the; # individual object files.; list(APPEND _DEPS $<TARGET_PROPERTY:${lib},INTERFACE_LINK_LIBRARIES>); endif(). # clang libraries are redundant since we are linking all the individual; # object files into libclang-cpp.so, so filter them out from _DEPS.; # This avoids problems with LLVM global data when building with; # BUILD_SHARED_LIBS=ON; # FIXME: We could use list(FILTER) with cmake >= 3.6; # FIXME: With cmake >= 3.15 we could use the generator expression; # $<FILTER:list,INCLUDE|EXCLUDE,regex>; get_target_property(interface ${lib} LINK_LIBRARIES); if (interface); foreach(lib ${interface}); if (NOT ${lib} MATCHES ""^clang""); list(APPEND _DEPS ${lib}); endif(); endforeach(); endif(); endforeach (). if (CLANG_LINK_CLANG_DYLIB); set(INSTALL_WITH_TOOLCHAIN INSTALL_WITH_TOOLCHAIN); endif(). add_clang_library(clang-cpp; SHARED; ${INSTALL_WITH_TOOLCHAIN}; clang-shlib.cpp; ${_OBJECTS}; LINK_LIBS; ${_DEPS}); # Optimize function calls for default visibility definitions to avoid PLT and; # reduce dynamic relocations.; if (NOT APPLE AND NOT MINGW AND NOT LLVM_LINKER_IS_SOLARISLD_ILLUMOS); target_link_options(clang-cpp PRIVATE LINKER:-Bsymbolic-functions); endif(); if (MINGW OR CYGWIN); # The clang-cpp DLL is supposed to export all symbols (except for ones; # that are explicitly hidden). Normally, this is what happens anyway, but; # if there are symbols that are marked explicitly as dllexport, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt:542,depend,dependency,542,interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # Make llvm and clang available here as we are mostly testing methods directly; # depending on them.; include_directories(SYSTEM; ${CLANG_INCLUDE_DIRS}; ${LLVM_INCLUDE_DIRS}; ${CLAD_INCLUDE_DIRS}; ). include_directories(; ../res; ../../clingutils/res; ../../foundation/res; ${CLING_INCLUDE_DIRS}; ). if(APPLE); # ignore; # ld: warning: direct access in function 'unsigned long std::__1::__str_find_first_of<char, unsigned long, std::__1::char_traits<char>, 18446744073709551615ul>(char const*, unsigned long, char const*, unsigned long, unsigned long)' from file '../CMakeFiles/ClingUtils.dir/src/TClingUtils.cxx.o' to global weak symbol 'std::__1::char_traits<char>::eq(char, char)' from file 'CMakeFiles/coreclingutilstestUnit.dir/TClingUtilsTests.cxx.o' means the weak symbol cannot be overridden at runtime. This was likely caused by different translation units being compiled with different visibility settings.; # ld: warning: direct access in function 'unsigned long std::__1::__str_find_first_of<char, unsigned long, std::__1::char_traits<char>, 18446744073709551615ul>(char const*, unsigned long, char const*, unsigned long, unsigned long)' from file '../../../interpreter/llvm-project/llvm/lib/libLLVMProfileData.a(InstrProf.cpp.o)' to global weak symbol 'std::__1::char_traits<char>::eq(char, char)' from file 'CMakeFiles/coreclingutilstestUnit.dir/TClingUtilsTests.cxx.o' means the weak symbol cannot be overridden at runtime. This was likely caused by different translation units being compiled with different visibility settings.; set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -w""); endif(). if(NOT builtin_clang); link_directories(""${LLVM_LIBRARY_DIR}""); endif(). ROOT_ADD_UNITTEST_DIR(Core RIO ${CLING_LIBRARIES} $<TARGET_OBJECTS:ClingUtils>); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/test/CMakeLists.txt:277,depend,depending,277,core/clingutils/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/test/CMakeLists.txt,1,['depend'],['depending']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT RooFitJSONInterface package; # @author Jonas Rembser, CERN; ############################################################################. # If RapidYAML can be found on the system, we will also compile the RapidYAML backend besides the; # nlohmann-json backend. Like this we can also convert to yaml. # The RapidYAML backend is always disabled because it doesn't work anymore for; # RooFitHS3. The nlohmann_json interface is always used and works well, hence; # rapidyaml was not tested anymore. The relevant code is still left in the; # CMakeLists.txt in case someone wants to revive the RapilYAML backend. # message(STATUS ""Looking for RapidYAML (used by RooFit)""); # find_package(ryml). if(${RYML_FOUND}); message(STATUS ""RapidYAML found, compiling also RooFit JSON Interface with RapidYAML parser""); set(ParserSources src/JSONParser.cxx src/RYMLParser.cxx); add_compile_definitions(ROOFIT_WITH_RYML); else(); set(ParserSources src/JSONParser.cxx); message(STATUS ""RapidYAML not found, only compiling RooFit with nlohmann-json parser""); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(RooFitJSONInterface; HEADERS; RooFit/Detail/JSONInterface.h; SOURCES; src/JSONInterface.cxx; ${ParserSources}; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LIBRARIES; Core; ). if(${RYML_FOUND}); target_include_directories(RooFitJSONInterface PRIVATE ${RYML_INCLUDE_DIRS}); target_link_libraries(RooFitJSONInterface PRIVATE -lc4core -lryml); target_link_directories(RooFitJSONInterface PRIVATE ${RYML_LIB_DIR}); endif(). if(builtin_nlohmannjson); target_include_directories(RooFitJSONInterface PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(RooFitJSONInterface PRIVATE nlohmann_json::nlohman",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt:725,interface,interface,725,roofit/jsoninterface/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt,2,"['interface', 'message']","['interface', 'message']"
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/clingutils package; ############################################################################. # These files depend on cling/clang/llvm; they need to be linked into libCling.; # They are used by rootcling_stage1, rootcling and libCling. set_property(TARGET Core APPEND PROPERTY DICT_HEADERS; root_std_complex.h; ). target_include_directories(Core PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/res>; ). ROOT_OBJECT_LIBRARY(ClingUtils; src/RStl.cxx; src/TClingUtils.cxx; ). add_dependencies(ClingUtils CLING). target_include_directories(ClingUtils PRIVATE ; ${CLING_INCLUDE_DIRS}; ${CMAKE_SOURCE_DIR}/core/foundation/res; ${CMAKE_SOURCE_DIR}/core/foundation/inc; ${CMAKE_SOURCE_DIR}/core/base/inc; ${CMAKE_SOURCE_DIR}/core/clib/inc; ${CMAKE_SOURCE_DIR}/core/meta/inc; ${CMAKE_BINARY_DIR}/ginclude). # Register the llvm include directories after clangs. This instructs the compiler to resolve; # headers from our builtin clang. That's an issue when we are building with bultin_llvm=Off; # and we have installed clang headers, too.; target_include_directories(ClingUtils SYSTEM PRIVATE ${CLANG_INCLUDE_DIRS} ${LLVM_INCLUDE_DIRS}); set_target_properties(ClingUtils PROPERTIES; COMPILE_FLAGS ""${CMAKE_CXX_FLAGS} ${CLING_CXXFLAGS}""; VISIBILITY_INLINES_HIDDEN ""ON""; ). ROOT_INSTALL_HEADERS(). #### STL dictionary (replacement for cintdlls)##############################. set(stldicts; vector; list; forward_list; deque; map map2 unordered_map; multimap multimap2 unordered_multimap; set unordered_set; multiset unordered_multiset; complex); if(NOT WIN32); list(APPEND stldicts valarray); endif(); foreach(dict ${stldicts}); stri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:430,depend,depend,430,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,1,['depend'],['depend']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/unix package; ############################################################################. if(NOT UNIX); return(); endif(). set_property(TARGET Core APPEND PROPERTY DICT_HEADERS TUnixSystem.h); target_sources(Core PRIVATE src/TUnixSystem.cxx); target_include_directories(Core PRIVATE inc ../clib/res). if (CMAKE_SYSTEM_NAME MATCHES FreeBSD); target_link_libraries(Core PRIVATE execinfo util); endif(). CHECK_CXX_SOURCE_COMPILES(""#include <stdlib.h>; int main() { char buf[32]; arc4random_buf(buf, 32); return 0;}"" found_arc4). if(found_arc4); message(STATUS ""Found arc4random_buf in stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_STDLIB); else(); set(OLD_CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES}); set(OLD_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}); if(DEFINED LIBBSDROOT); set(CMAKE_REQUIRED_INCLUDES ${LIBBSDROOT}/include); set(CMAKE_REQUIRED_LIBRARIES ${LIBBSDROOT}/lib/libbsd.so); endif(); CHECK_CXX_SOURCE_COMPILES(""#include <bsd/stdlib.h>; int main() { char buf[32]; arc4random_buf(buf, 32); return 0;}"" found_arc4_bsd); set(CMAKE_REQUIRED_INCLUDES ${OLD_CMAKE_REQUIRED_INCLUDES}); set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQUIRED_LIBRARIES}); if(found_arc4_bsd); message(STATUS ""Found arc4random_buf in bsd/stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_BSDLIB); if(DEFINED LIBBSDROOT); target_include_directories(Core PRIVATE ${LIBBSDROOT}/include); target_link_libraries(Core PRIVATE ${LIBBSDROOT}/lib/libbsd.so); endif(); else(); CHECK_CXX_SOURCE_COMPILES(""#include <sys/random.h>; int main() { char buf[32]; int res = getrandom(buf, 32, GRND_NONBLOCK); return 0;}"" found_getrandom); if(found_getrandom); message(STATUS ""Fou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt:862,message,message,862,core/unix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt,1,['message'],['message']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(RRawFile RRawFile.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TFile TFileTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TBufferFile TBufferFileTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TBufferMerger TBufferMerger.cxx LIBRARIES RIO Imt Tree); ROOT_ADD_GTEST(TBufferJSON TBufferJSONTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TFileMerger TFileMergerTests.cxx LIBRARIES RIO Tree Hist); ROOT_ADD_GTEST(TROMemFile TROMemFileTests.cxx LIBRARIES RIO Tree); if(uring AND NOT DEFINED ENV{ROOTTEST_IGNORE_URING}); ROOT_ADD_GTEST(RIoUring RIoUring.cxx LIBRARIES RIO); endif(). # Temporarily disabled. Test routinely fails on MacOS and some Linuxes.; #if(NOT WIN32 AND (NOT MACOS_VERSION OR NOT MACOSX_VERSION VERSION_LESS 13.00)); # ROOT_EXECUTABLE(TMapFileTest TMapFileTest.cxx LIBRARIES RIO Hist New); # ROOT_ADD_TEST(io-io-test-TMapFileTest COMMAND TMapFileTest complete); #endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/CMakeLists.txt:786,rout,routinely,786,io/io/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/CMakeLists.txt,1,['rout'],['routinely']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. include(ExternalProject). set(XROOTD_VERSION ""5.7.1""). set(XROOTD_PREFIX ${CMAKE_BINARY_DIR}); message(STATUS ""Downloading and building XROOTD version ${XROOTD_VERSION}""). list(REMOVE_ITEM XROOTD_CLIENT_LIBRARIES OpenSSL::SSL); list(REMOVE_ITEM XROOTD_UTILS_LIBRARIES OpenSSL::SSL). set(libname ${CMAKE_SHARED_LIBRARY_PREFIX}XrdCl${CMAKE_SHARED_LIBRARY_SUFFIX}); list(APPEND XROOTD_CLIENT_LIBRARIES ${XROOTD_PREFIX}/lib/${libname}); list(REMOVE_DUPLICATES XROOTD_CLIENT_LIBRARIES). set(libname ${CMAKE_SHARED_LIBRARY_PREFIX}XrdUtils${CMAKE_SHARED_LIBRARY_SUFFIX}); list(APPEND XROOTD_UTILS_LIBRARIES ${XROOTD_PREFIX}/lib/${libname}); list(REMOVE_DUPLICATES XROOTD_UTILS_LIBRARIES). ExternalProject_Add(; BUILTIN_XROOTD; URL http://lcgpackages.web.cern.ch/lcgpackages/tarFiles/sources/xrootd-${XROOTD_VERSION}.tar.gz; URL_HASH SHA256=c28c9dc0a2f5d0134e803981be8b1e8b1c9a6ec13b49f5fa3040889b439f4041; INSTALL_DIR ${XROOTD_PREFIX}; CMAKE_ARGS -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>; -DCMAKE_PREFIX_PATH:STRING=${OPENSSL_PREFIX}; -DCMAKE_BUILD_TYPE=Release; -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}; -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}; -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}; -DCMAKE_CXX_FLAGS=${ROOT_EXTERNAL_CXX_FLAGS}; -DCMAKE_OSX_SYSROOT=${CMAKE_OSX_SYSROOT}; -DCMAKE_OSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}; -DCMAKE_INSTALL_LIBDIR=<INSTALL_DIR>/lib; -DENABLE_PYTHON=OFF; -DENABLE_CEPH=OFF; -DXRDCL_LIB_ONLY=ON; -DCMAKE_INSTALL_RPATH:STRING=${XROOTD_PREFIX}/lib; -DOPENSSL_ROOT_DIR=${OPENSSL_ROOT_DIR}; INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install; LOG_DOWNLOAD 1 LOG_CONFIGURE 1 LOG_BUILD 1 LOG_INSTALL 1 LOG_OUTPUT_ON_FAILURE 1; BUILD_BYPRODUCTS ${XROOTD_CLIENT_LIBRARIES} ${XROOTD_UTILS_LIBRARIES}; TIMEOUT 600; ). # CMake checks for existence when a target is linked to X",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xrootd/CMakeLists.txt:290,message,message,290,builtins/xrootd/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xrootd/CMakeLists.txt,1,['message'],['message']
Integrability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. set_package_properties(Doxygen PROPERTIES; URL ""http://www.doxygen.org""; DESCRIPTION ""Documentation generator""; TYPE OPTIONAL; PURPOSE ""Requires CMake 3.9, adds docs target""). find_package(Doxygen OPTIONAL_COMPONENTS dot). # Only add docs target if Doxygen present; if(TARGET Doxygen::doxygen AND TARGET Doxygen::dot); # Setting DOXYGEN settings; set(DOXYGEN_GENERATE_LATEX YES); set(DOXYGEN_SOURCE_BROWSER YES); set(DOXYGEN_EXTRACT_ALL YES); set(DOXYGEN EXTRACT_PRIVATE YES); set(DOXYGEN_EXTRACT_STATIC YES). get_target_property(MATH_SOURCES Minuit2Math SOURCES); get_target_property(MINUIT2_SOURCES Minuit2 SOURCES). file(READ Minuit2.md MINUIT2_MAINPAGE); string(REPLACE ""\\page Minuit2Page"" ""\\mainpage"" MINUIT2_MAINPAGE ""${MINUIT2_MAINPAGE}""); file(WRITE ""${CMAKE_CURRENT_BINARY_DIR}/index.md"" ""${MINUIT2_MAINPAGE}""). # Actually add the docs target; doxygen_add_docs(docs; ""${CMAKE_CURRENT_BINARY_DIR}/index.md""; ${MATH_SOURCES}; ${MINUIT2_SOURCES}; WORKING_DIRECTORY ""${CMAKE_CURRENT_SOURCE_DIR}/..""; ); else(); message(STATUS ""Doxygen and/or Dot not found, not adding docs target""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/CMakeLists.txt:1213,message,message,1213,math/minuit2/doc/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/CMakeLists.txt,1,['message'],['message']
Integrability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. add_subdirectory(tmva); add_subdirectory(tmvagui). # Build pyMVA. Allows users to call python mva's from c++ ROOT/TMVA.; if(tmva-pymva); add_subdirectory(pymva); endif(). # Build RMVA. Allows users to call R mva's from c++ ROOT/TMVA.; if(r OR tmva-rmva); add_subdirectory(rmva); endif(). add_subdirectory(sofie); #parser depends on protobuf ; #found if flag tmva-sofie is on; if (tmva-sofie); add_subdirectory(sofie_parsers); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/CMakeLists.txt:516,depend,depends,516,tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/CMakeLists.txt,1,['depend'],['depends']
Integrability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. if(pyroot); add_subdirectory(pyroot); add_subdirectory(jupyroot). if(dataframe); message(STATUS ""Distributed RDataFrame enabled""); add_subdirectory(experimental/distrdf); else(); message(STATUS ""Requirements to enable distributed RDataFrame:""); message(STATUS "" dataframe: required:ON, actual:${dataframe}""); endif(); endif(). if(tpython); add_subdirectory(tpython); endif(). if(r); add_subdirectory(r); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/CMakeLists.txt:276,message,message,276,bindings/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/CMakeLists.txt,3,['message'],['message']
Integrability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. cmake_minimum_required(VERSION 3.20 FATAL_ERROR). if(WIN32); # Set CMP0091 (MSVC runtime library flags are selected by an abstraction) to OLD; # to keep the old way of selecting the runtime library with the -MD/-MDd compiler flag; cmake_policy(SET CMP0091 OLD); set(CMAKE_SKIP_TEST_ALL_DEPENDENCY TRUE); endif(). if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT ALLOW_IN_SOURCE); message(FATAL_ERROR; "" ROOT must be built out-of-source.\n""; "" Please see README/INSTALL for more information.""); endif(). set(policy_new CMP0072 CMP0076 CMP0077 CMP0079); foreach(policy ${policy_new}); if(POLICY ${policy}); cmake_policy(SET ${policy} NEW); endif(); endforeach(). set(policy_old CMP0116 CMP0135 CMP0144); foreach(policy ${policy_old}); if(POLICY ${policy}); cmake_policy(SET ${policy} OLD); endif(); endforeach(). include(cmake/modules/CaptureCommandLine.cmake). project(ROOT). #---Set the locale to default C to prevent issued due to localization of commands---------------; # This is necessary as we for example call `clang -v` and parse its output. But on a localized; # program, the output parsing is much more error prone as certrain strings we're looking for; # could be missing or be in a different order. To prevent those errors, let's just force all; # output to use the default C locale which is more or less identical on all systems.; set(ENV{LANG} C). #---Set paths where to put the libraries, executables and headers------------------------------; file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/lib) # prevent mkdir races; set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib); set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib); set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin). # Set permissions for installed folders and subfolders that come from the source tree in cas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:580,message,message,580,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"# Copyright (C) 1995-2023, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. #####################################################################################################################. # Details about integrating ROOT into CMake projects:; # https://root.cern/manual/integrate_root_into_my_cmake_project/. #####################################################################################################################. # CMakeLists.txt that creates a library with dictionary and a main program; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(treeUsingCustomClass). #---Locate the ROOT package and defines a number of variables (e.g. ROOT_INCLUDE_DIRS); find_package(ROOT REQUIRED COMPONENTS Tree TreePlayer ROOTDataFrame). #---Include a CMake module which makes use of the previous variables and loads modules ; # with useful macros or functions such as ROOT_GENERATE_DICTIONARY; # For further details: https://root-forum.cern.ch/t/how-to-integrate-root-into-my-project-with-cmake/37175; include(${ROOT_USE_FILE}). #---Add include directory of ROOT to the build; include_directories(${CMAKE_SOURCE_DIR}). # CMake function provided by ROOT, used to generate the dictionary file, G__data2Tree.cxx; # See this link for further details:; # https://root.cern/manual/io_custom_classes/#using-cmake; ROOT_GENERATE_DICTIONARY(G__data2Tree data2Tree.hxx LINKDEF data2TreeLinkDef.hxx). #---Create a shared library from; # * the previously generated dictionary, G__data2Tree.cxx; # * the class implementation; add_library(data2TreeLib SHARED data2Tree.cxx G__data2Tree.cxx); target_link_libraries(data2TreeLib ${ROOT_LIBRARIES} ) ; add_dependencies(data2TreeLib G__data2Tree ). #--- This is needed on Windows in order to export the symbols and create the data2TreeLib.lib file; if(MSVC); set_target_properties(data2TreeLib PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt:330,integrat,integrating,330,tutorials/tree/dictionary/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt,1,['integrat'],['integrating']
Integrability,"# Copyright (C) 1995-2023, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT gui/qt5webdisplay package; ############################################################################. find_package(Qt5 COMPONENTS Core WebEngine WebEngineWidgets CONFIG). if(NOT Qt5_FOUND); if(fail-on-missing); message(FATAL_ERROR ""Could NOT find Qt5 (WebEngine, WebEngineWidgets)""); else(); message(WARNING ""Qt5 (WebEngine, WebEngineWidgets) not found, disabling option 'qt5web'""); set(qt5web OFF CACHE BOOL ""Disabled because Qt5 not found"" FORCE); return(); endif(); endif(). set(CMAKE_AUTOMOC ON); set(CMAKE_INCLUDE_CURRENT_DIR ON). ROOT_LINKER_LIBRARY(ROOTQt5WebDisplay; rootwebview.cpp; rootwebpage.cpp; rooturlschemehandler.cpp; rootqt5.cpp; LIBRARIES; Qt5::WebEngine; Qt5::WebEngineWidgets; DEPENDENCIES; Core; RHTTP; ROOTWebDisplay; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/CMakeLists.txt:527,message,message,527,gui/qt5webdisplay/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/CMakeLists.txt,2,['message'],['message']
Integrability,"# Copyright (C) 1995-2023, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT gui/qt5webdisplay package; ############################################################################. find_package(Qt6 COMPONENTS Core WebEngineCore WebEngineWidgets CONFIG). if(NOT Qt6_FOUND); if(fail-on-missing); message(FATAL_ERROR ""Could NOT find Qt6 (WebEngineCore, WebEngineWidgets)""); else(); message(WARNING ""Qt6 (WebEngineCore, WebEngineWidgets) not found, disabling option 'qt6web'""); set(qt6web OFF CACHE BOOL ""Disabled because Qt6 not found"" FORCE); return(); endif(); endif(). set(CMAKE_AUTOMOC ON); set(CMAKE_INCLUDE_CURRENT_DIR ON). ROOT_LINKER_LIBRARY(ROOTQt6WebDisplay; ../qt5webdisplay/rootwebview.cpp; ../qt5webdisplay/rootwebpage.cpp; ../qt5webdisplay/rooturlschemehandler.cpp; rootqt6.cpp; LIBRARIES; Qt6::WebEngineCore; Qt6::WebEngineWidgets; DEPENDENCIES; Core; RHTTP; ROOTWebDisplay; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt6webdisplay/CMakeLists.txt:531,message,message,531,gui/qt6webdisplay/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt6webdisplay/CMakeLists.txt,2,['message'],['message']
Integrability,"# Discover the projects that use CMake in the subdirectories.; # Note that explicit cmake invocation is required every time a new project is; # added or removed.; file(GLOB entries *); foreach(entry ${entries}); if(IS_DIRECTORY ${entry} AND EXISTS ${entry}/CMakeLists.txt); if((NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/compiler-rt) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/dragonegg) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libcxx) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libcxxabi) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libunwind) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/test-suite) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/openmp) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/cross-project-tests)); get_filename_component(entry_name ""${entry}"" NAME); add_llvm_external_project(${entry_name}); endif(); endif(); endforeach(entry). # Also add in libc++ and compiler-rt trees if present (and we have; # a sufficiently recent version of CMake where required).; if(${LLVM_BUILD_RUNTIME}); # MSVC isn't quite working with libc++ yet, disable it until issues are; # fixed.; # FIXME: LLVM_FORCE_BUILD_RUNTIME is currently used by libc++ to force; # enable the in-tree build when targeting clang-cl.; if(NOT MSVC OR LLVM_FORCE_BUILD_RUNTIME); # Add the projects in reverse order of their dependencies so that the; # dependent projects can see the target names of their dependencies.; add_llvm_external_project(libunwind); add_llvm_external_project(pstl); add_llvm_external_project(libc); add_llvm_external_project(libcxxabi); add_llvm_external_project(libcxx); endif(); if(NOT LLVM_BUILD_EXTERNAL_COMPILER_RT); add_llvm_external_project(compiler-rt); endif(); endif(). add_llvm_external_project(dragonegg); add_llvm_external_project(openmp). if(LLVM_INCLUDE_TESTS); add_llvm_external_project(cross-project-tests); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/projects/CMakeLists.txt:1397,depend,dependencies,1397,interpreter/llvm-project/llvm/projects/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/projects/CMakeLists.txt,3,['depend'],"['dependencies', 'dependent']"
Integrability,"# Do not depend on CMake scripts from the rest of the ROOT build; set(CMAKE_MODULE_PATH """"). #--- Check if we need to build llvm and clang ------------------------------------------------------; if (NOT builtin_clang); message(WARNING ""Due to ROOT-specific patches you need a special version of clang. You cannot use vanilla clang.""); endif(). #--Set the LLVM version required for ROOT-----------------------------------------------------------; set(ROOT_LLVM_VERSION_REQUIRED_MAJOR 18). #---Define the way we want to build and what of llvm/clang/cling------------------------------------; set(LLVM_ENABLE_RTTI ON CACHE BOOL """"); set(LLVM_APPEND_VC_REV OFF CACHE BOOL """"); set(LLVM_ENABLE_BINDINGS OFF CACHE BOOL """"); set(LLVM_ENABLE_FFI OFF CACHE BOOL """"); set(LLVM_ENABLE_OCAMLDOC OFF CACHE BOOL """"); set(LLVM_ENABLE_Z3_SOLVER OFF CACHE BOOL """"); set(LLVM_ENABLE_WARNINGS OFF CACHE BOOL """"); set(CLANG_ENABLE_STATIC_ANALYZER OFF CACHE BOOL """"); set(CLANG_ENABLE_ARCMT OFF CACHE BOOL """"); set(LLVM_INCLUDE_TESTS OFF CACHE BOOL """"); set(LLVM_INCLUDE_BENCHMARKS OFF CACHE BOOL """"); set(CLANG_INCLUDE_TESTS OFF CACHE BOOL """"); set(LLVM_INCLUDE_EXAMPLES OFF CACHE BOOL """"); set(CLANG_BUILD_TOOLS OFF CACHE BOOL """"); # It looks like that turning off CLANG_BUILD_TOOLS is not enough.; set(CLANG_TOOL_ARCMT_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_CHECK_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_FORMAT_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_FORMAT_VS_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_FUZZER_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_IMPORT_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_OFFLOAD_BUNDLER_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_RENAME_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_C_ARCMT_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_C_INDEX_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_DIAGTOOL_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_LIBCLANG_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_SCAN_BUILD_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:9,depend,depend,9,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,2,"['depend', 'message']","['depend', 'message']"
Integrability,"# Don't include this target in LLVMExports. FIXME: is there a cleaner way?; set(EXCLUDE_FROM_ALL ON). # Not add_clang_library: this is not part of clang's public library interface.; # Unit tests should depend on this with target_link_libraries(), rather; # than with clang_target_link_libraries().; add_llvm_library(clangTesting; CommandLineArgs.cpp; TestAST.cpp. BUILDTREE_ONLY. LINK_COMPONENTS; MC; Support; ). clang_target_link_libraries(clangTesting; PRIVATE; clangAST; clangBasic; clangFrontend; clangLex; clangSerialization; ). target_link_libraries(clangTesting; PRIVATE; llvm_gtest; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt:170,interface,interface,170,interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"# Ensure that libLLVMTargetParser does not carry any static global initializer.; # ManagedStatic can be used to enable lazy-initialization of globals.; #; # HAS_WERROR_GLOBAL_CTORS and LLVM_HAS_NOGLOBAL_CTOR_MUTEX should have been set; # by llvm/lib/Support/CMakeLists.txt (which provides the required Support; # dependency).; if (HAS_WERROR_GLOBAL_CTORS AND NOT LLVM_HAS_NOGLOBAL_CTOR_MUTEX); SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Werror=global-constructors""); endif(). # Solaris code uses kstat, so specify dependency explicitly for shared builds.; if (${CMAKE_SYSTEM_NAME} MATCHES ""SunOS""); set(system_libs kstat); endif(). add_llvm_component_library(LLVMTargetParser; AArch64TargetParser.cpp; ARMTargetParserCommon.cpp; ARMTargetParser.cpp; CSKYTargetParser.cpp; Host.cpp; LoongArchTargetParser.cpp; RISCVTargetParser.cpp; SubtargetFeature.cpp; TargetParser.cpp; Triple.cpp; X86TargetParser.cpp. ADDITIONAL_HEADER_DIRS; Unix; Windows. LINK_LIBS; ${system_libs}. LINK_COMPONENTS; Support. DEPENDS; RISCVTargetParserTableGen; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/CMakeLists.txt:313,depend,dependency,313,interpreter/llvm-project/llvm/lib/TargetParser/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/CMakeLists.txt,2,['depend'],['dependency']
Integrability,"# Example Analysis. This chapter is an example of a typical physics analysis. Large data; files are chained together and analyzed using the **`TSelector`** class. ## Explanation. This script uses four large data sets from the H1 collaboration at DESY; Hamburg. One can access these data sets (277 Mbytes) from the ROOT web; site at: <ftp://root.cern.ch/root/h1analysis/>. The physics plots generated by this example cannot be produced using; smaller data sets. There are several ways to analyze data stored in a ROOT Tree. - Using `TTree::Draw`:. - This is very convenient and efficient for small tasks. A; **`TTree`**::Draw call produces one histogram at the time. The; histogram is automatically generated. The selection expression may; be specified in the command line. - Using the **`TTreeViewer`**:. - This is a graphical interface to `TTree::Draw` with the same; functionality. - Using the code generated by `TTree::MakeClass`:. - In this case, the user creates an instance of the analysis class. They; have the control over the event loop and can generate an unlimited; number of histograms. - Using the code generated by `TTree::MakeSelector`: Like for the code; generated by **`TTree::MakeClass`**, the user can do complex analysis.; However, they cannot control the event loop. The event loop is; controlled by `TTree::Process` called by the user. This solution is; illustrated by the code below. The advantage of this method is that; it can be run in a parallel environment using PROOF (the Parallel; Root Facility). A chain of four files (originally converted from PAW ntuples) is used to; illustrate the various ways to loop on ROOT data sets. Each contains a; ROOT Tree named ""`h42`"". The class definition in h1analysis.h has been; generated automatically by the ROOT utility **`TTree`**`::MakeSelector`; using one of the files with:. ``` {.cpp}; h42->MakeSelector(""h1analysis"");; ```. This produces two files: h1analysis.h and `h1analysis.C`. A skeleton of; `h1analysis.C` file is made ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:827,interface,interface,827,documentation/users-guide/ExampleAnalysis.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md,1,['interface'],['interface']
Integrability,"# Folders and Tasks. ## Folders. ![](pictures/030000E1.png). A **`TFolder`** is a collection of objects; visible and expandable in the ROOT object browser. Folders have a name; and a title and are identified in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:539,depend,dependencies,539,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependencies']
Integrability,"# Functions and Parameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:484,interface,interface,484,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,2,['interface'],['interface']
Integrability,# Generic helper for fuzzer binaries.; # This should not depend on LLVM IR etc.; add_llvm_component_library(LLVMFuzzerCLI; FuzzerCLI.cpp; PARTIAL_SOURCES_INTENDED. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/FuzzMutate. LINK_COMPONENTS; Support; TargetParser; ). # Library for using LLVM IR together with fuzzers.; add_llvm_component_library(LLVMFuzzMutate; IRMutator.cpp; OpDescriptor.cpp; Operations.cpp; RandomIRBuilder.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/FuzzMutate. DEPENDS; intrinsics_gen. LINK_COMPONENTS; Analysis; BitReader; BitWriter; Core; Scalar; Support; TargetParser; TransformUtils; ); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/CMakeLists.txt:57,depend,depend,57,interpreter/llvm-project/llvm/lib/FuzzMutate/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/CMakeLists.txt,1,['depend'],['depend']
Integrability,"# HTTP server in ROOT. The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. * standard http interface to ROOT application; * no any temporary ROOT files to access data; * user interface running in all browsers. ## Starting the HTTP server. To start the http server, at any time, create an instance of the [THttpServer](https://root.cern/doc/master/classTHttpServer.html) class like:. ```cpp; auto serv = new THttpServer(""http:8080"");; ```. This will start a [civetweb](https://github.com/civetweb/civetweb)-based http server on the port 8080. Then one should be able to open the address `http://localhost:8080` in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics. There is a [server snapshot](https://root.cern/js/latest/httpserver.C/?layout=simple&item=Canvases/c1) of running macro [tutorials/http/httpserver.C](https://github.com/root-project/root/blob/master/tutorials/http/httpserver.C) from ROOT tutorials. One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server return",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:140,interface,interface,140,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,3,['interface'],['interface']
Integrability,"# Histograms. This chapter covers the functionality of the histogram classes. We; begin with an overview of the histogram classes, after which we; provide instructions and examples on the histogram features. We have put this chapter ahead of the graphics chapter so that you can; begin working with histograms as soon as possible. Some of the; examples have graphics commands that may look unfamiliar to you. These; are covered in the chapter ""Input/Output"". ## The Histogram Classes; \index{histogram}. ROOT supports histograms up to three dimensions. Separate concrete; classes are provided for one-dimensional, two-dimensional and; three-dimensional classes. The histogram classes are split into; further categories, depending on the set of possible bin values:. - **`TH1C, TH2C and TH3C`** contain one char (one byte) per bin; (maximum bin content = 255). - **`TH1S, TH2S and TH3S`** contain one short (two bytes) per bin; (maximum bin content = 65 535). - **`TH1I, TH2I and TH3I`** contain one integer (four bytes) per bin; (maximum bin content = 2 147 483 647).; ; - **`TH1L, TH2L and TH3L`** contain one long64 (eight bytes) per bin; (maximum bin content = 9 223 372 036 854 775 807). - **`TH1F, TH2F and TH3F`** contain one float (four bytes) per bin; (maximum precision = 7 digits). - **`TH1D, TH2D and TH3D`** contain one double (eight bytes) per bin; (maximum precision = 14 digits). ROOT also supports profile histograms, which constitute an elegant; replacement of two-dimensional histograms in many cases. The; inter-relation of two measured quantities X and Y can always be; visualized with a two-dimensional histogram or scatter-plot. Profile; histograms, on the other hand, are used to display the mean value of Y; and its RMS for each bin in X. If Y is an unknown but single-valued; approximate function of X, it will have greater precision in a profile; histogram than in a scatter plot. - **`TProfile`** : one dimensional profiles. - **`TProfile2D`** : two dimensional profiles. ![",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:720,depend,depending,720,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['depend'],['depending']
Integrability,"# JupyROOT; A software layer to integrate Jupyter notebooks and ROOT. ## Installation; 1. [Install ROOT6](https://root.cern.ch/building-root) (> 6.05); 2. Install dependencies: `pip install jupyter metakernel`. ## Start using ROOTbooks; Set up the ROOT environment (`. $ROOTSYS/bin/thisroot.[c]sh`) and type in your; shell:; ```shell; root --notebook; ```; This will start a ROOT-flavoured notebook server in your computer. Alternatively, if you would like to use the Jupyter command directly, you; can do:; ```shell; jupyter kernelspec install $ROOTSYS/etc/root/notebook/kernels/root --user; ```. Once the server is up, you can use ROOT with two kernels:. 1. ROOT C++: new kernel provided by ROOT; 2. Python: already provided by Jupyter. ## C++ ROOTbook; ROOT offers a C++ kernel that transforms the notebook in a ROOT prompt.; Embedded graphics, syntax highlighting and tab completion are among; the features provided by this kernel. An example of how you would plot a histogram in a C++ ROOTbook is:; ```cpp; TCanvas c;; TH1F h(""h"",""ROOT Histo;X;Y"",64,-4,4);; h.FillRandom(""gaus"");; h.Draw();; c.Draw();; ```. ## Python ROOTbook; If you prefer to use Python, you can create a new Python kernel and; import the ROOT libraries:; ```python; import ROOT; ```; And then you could write something like:; ```python; c = ROOT.TCanvas(""c""); h = ROOT.TH1F(""h"",""ROOT Histo;X;Y"",64,-4,4); ```; Additionally, you can mix Python and C++ in the same notebook; by using the **%%cpp** magic:; ```cpp; %%cpp; h->FillRandom(""gaus"");; h->Draw();; c->Draw();; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/README.md:32,integrat,integrate,32,bindings/jupyroot/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/README.md,2,"['depend', 'integrat']","['dependencies', 'integrate']"
Integrability,"# Jupyter Tools for TableGen. This folder contains notebooks relating to TableGen and a Jupyter kernel for; TableGen. ## Notebooks. [LLVM_TableGen.ipynb](LLVM_TableGen.ipynb) - A demo of the kernel's capabilities. [tablegen_tutorial_part_1.ipynb](tablegen_tutorial_part_1.ipynb) - A tutorial on the TableGen language. [sql_query_backend.ipynb](sql_query_backend.ipynb) - How to write a backend using; JSON output and Python. Notebooks can be viewed in browser on Github or downloaded and run locally. If; that is not possible, there are Markdown versions next to the notebook files. ## TableGen Kernel. To use the kernel, first install it into jupyter. If you have installed Jupyter into a virtual environment, adjust `python3` to; be the interpreter for that environment. This will ensure that tools run the; kernel in the correct context. ```shell; python3 -m tablegen_kernel.install; ```. If you are going to open the notebook in an IDE like Visual Studio Code,; you should restart it now so that it will find the newly installed kernel. Then run one of:. ```shell; jupyter notebook; # Then in the notebook interface, select 'LLVM TableGen' from the 'New' menu. # To run the example notebook in this folder.; jupyter notebook LLVM_TableGen.ipynb. # To use the kernel from the command line.; jupyter console --kernel tablegen; ```. Or open the notebook in a tool with built in Jupyter support. `llvm-tblgen` is expected to be either in the `PATH` or you can set; the environment variable `LLVM_TBLGEN_EXECUTABLE` to point to it directly. If you see an error like this:; ```shell; Cell In[8], line 2; // This is some tablegen; ^; SyntaxError: invalid syntax; ```. You are probably running the notebook using the iPython kernel. Make sure you; have selected the tablegen kernel. To run the kernel's doctests do:. ```shell; python3 tablegen_kernel/kernel.py; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md:1110,interface,interface,1110,interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md,1,['interface'],['interface']
Integrability,"# Language Bindings. ### PyROOT; - Fixed support for templated functions when in need of:; - typedef resolution (`Foo<Float_t>` -> `Foo<float>`); - namespace addition (`Foo<vector<float>>` -> `Foo<std::vector<float>>`); - full name completion (`Foo<std::vector<float>>` -> `Foo<std::vector<float, std::allocator<float>>>`). ### Experimental PyROOT; - Added pythonisations for `TTree` and its subclasses (e.g. `TChain`, `TNtuple`); - Pythonic iterator (`for event in tree:`); - Access tree branches as attributes (`mytree.mybranch`); - `TTree::Branch` pythonisation; - `TTree::SetBranchAddress` pythonisation; - Added pythonisations for `TDirectory` and its subclasses (e.g `TFile`, `TDirectoryFile`); - Access directories/objects in `TDirectory`/`TDirectoryFile`/`TFile` as attributes; (`mydir1.mydir2.myhist`, `myfile.myhist`, `myfile.mydir.myhist`); - `TDirectory::Get` pythonisation; - `TDirectory::WriteObject` pythonisation; - `TFile::Open` pythonisation; - Added pretty printing generic pythonisation for all classes; - Added interoperability with NumPy arrays for STL vectors and `RVec`s (zero-copy wrapping of; vectors and `RVec`s into NumPy arrays). ### Jupyter Notebook Integration; - Make sure the ROOT C++ Jupyter kernel runs with the same Python version (major and minor) that ROOT; was built with.; - Make the Jupyter server started with `root --notebook` listen on all interfaces. This can be useful; if the user wants to connect to the server remotely. It also fixes an issue observed when starting; the Jupyter server inside a Docker container. ## JavaScript ROOT; - Support of TWebCanvas functionality. Code for ROOT 6.16 will; be maintained in v6-16-00-patches branch of JSROOT repository. ; - Singificant speed up (factor 10) when drawing canvas with many subpads; - Many small improvements and bug fixes, see JSROOT release notes for v5.4.2 - v5.6.2 . ## Tutorials; - Refurbish text in the `RDataFrame` tutorials category. ## Command line tools; - Fixed `rooteventselector` when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:20312,interoperab,interoperability,20312,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,2,"['interoperab', 'wrap']","['interoperability', 'wrapping']"
Integrability,"# Link LibCURL if the user wants it; if (LLVM_ENABLE_CURL); set(imported_libs CURL::libcurl); endif(). # Link cpp-httplib if the user wants it; if (LLVM_ENABLE_HTTPLIB); set(imported_libs ${imported_libs} httplib::httplib); endif(). # Make sure pthread is linked if this is a unix host; if (CMAKE_HOST_UNIX); set(imported_libs ${imported_libs} ${LLVM_PTHREAD_LIB}); endif(). # Note: This isn't a component, since that could potentially add a libcurl; # dependency to libLLVM.; add_llvm_library(LLVMDebuginfod; BuildIDFetcher.cpp; Debuginfod.cpp; HTTPClient.cpp; HTTPServer.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Debuginfod. LINK_LIBS; ${imported_libs}. LINK_COMPONENTS; Support; Symbolize; DebugInfoDWARF; BinaryFormat; Object; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/CMakeLists.txt:453,depend,dependency,453,interpreter/llvm-project/llvm/lib/Debuginfod/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"# Math Libraries in ROOT. The aim of Math libraries in ROOT is to provide and to support a; coherent set of mathematical and statistical functions. The latest; developments have been concentrated in providing first versions of the; `MathCore` and `MathMore` libraries, included in ROOT v5.08. Other; recent developments include the new version of `MINUIT`, which has been; re-designed and re-implemented in the C++ language. It is integrated in; ROOT. In addition, an optimized package for describing small matrices; and vector with fixed sizes and their operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:431,integrat,integrated,431,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integrated']
Integrability,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:288,depend,depends,288,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['depend'],['depends']
Integrability,"# Policies on git repositories. This document explains our current policies around git repositories. Everything; not covered in this document is most likely a case-by-case decision. In these; cases please create an issue with the; [Infrastructure Working Group](https://github.com/llvm/llvm-iwg/issues). ## New GitHub repositories. Requirements for *new* repositories as part of the; [LLVM organisation on GitHub](https://github.com/llvm):. * The repo will be used for something related to the LLVM ecosystem or community.; * The repo contains a `README.md` explaining the contents.; * The repo contains a `CONTRIBUTING.md`, ideally copy this from; [llvm-project](https://github.com/llvm/llvm-project/blob/main/CONTRIBUTING.md).; * The repo contains a `LICENSE.TXT`, preferably copy this from; [llvm-project](https://github.com/llvm/llvm-project/blob/main/LICENSE.TXT).; Other licences need to be discussed case-by-case. If you want to integrate your project as part of the Monorepo, please take a; look at the; [Developer Policy](project:DeveloperPolicy.rst#Adding an Established Project To the LLVM Monorepo). To request a new repository, please create an issue with the; [Infrastructure Working Group](https://github.com/llvm/llvm-iwg/issues). ## Repo access on GitHub. Some 3rd party applications require write access to our GitHub organisation in; order to work properly. Typical examples are continuous integration services; reporting build results back to GitHub. We consider granting access to such; application if they provide benefits to the LLVM community and do not raise; privacy or security concerns. To request access please run an RFC on the mailing list and get community; feedback.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md:936,integrat,integrate,936,interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md,2,['integrat'],"['integrate', 'integration']"
Integrability,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:137,interoperab,interoperability,137,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['interoperab'],['interoperability']
Integrability,"# ROOT Development Practice. ## Overview. The development of ROOT almost exclusively happens using the [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests); model of github. A pull request (PR) should contain a set focused changes; organized in one or more [atomic commits](https://en.wikipedia.org/wiki/Atomic_commit#Revision_control).; PRs should be well-documented and well-tested in order to allow other community; members to use, maintain and modify. If the PR contains performance-critical; code consider writing a benchmark against the [rootbench repository](https://github.com/root-project/rootbench). ## Quality Assurance. Each contribution should contain developer documentation in the form of code; comments and sufficient amount of tests in the form of unit and/or integration; tests. Unit tests are relatively small and quick programs focused to check if; small pieces of code and API work as expected. Integration tests are checks; which ensure the synergy between different (unit tested) components. Put in; practice, unit tests verify (member) function behavior whereas integration tests; check classes and their cooperation. The boundary between both kinds of testing; is blurred. ROOT has support for both kinds of tests in the [roottest repository](https://github.com/root-project/roottest); and supports ""inline"" unit tests in each component's `test` folder. Unit testing; uses the [GTest and GMock](https://github.com/google/googletest) infrastructure; along with small ROOT-specific extensions located in; [TestSupport](../core/test_support/). The documentation of GTest; and GMock is rather extensive and we will describe some of the features of; ROOT::TestSupport. In order to write an inline unit test, add a new file in the; nearest to the tested component's `test` folder and call `ROOT_ADD_GTEST` in the; `CMakeLists.txt` file. In many cases using standard GTest facility is sufficient to write a good test.; How",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md:838,integrat,integration,838,README/DEVELOPMENT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md,1,['integrat'],['integration']
Integrability,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:51,interface,interface,51,documentation/primer/root_in_python.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md,1,['interface'],['interface']
Integrability,"# ROOT requirements for third-party Python packages. # PyROOT: Interoperability with numpy arrays; numpy; pandas. # TMVA: SOFIE; dm-sonnet ; python_version < ""3.13"" # used for GNNs, not available for Python 3.13 yet; graph_nets ; python_version < ""3.13"" # not available for Python 3.13 yet; onnx. # TMVA: PyMVA interfaces; scikit-learn; tensorflow<2.16 ; python_version < ""3.12""; torch<2.5 ; python_version < ""3.13"" # no torch version that fullfills version constraint available for Python 3.13; xgboost. # PyROOT: ROOT.Numba.Declare decorator; numba>=0.48 ; python_version < ""3.13"" # no numba available for Python 3.13 yet; cffi>=1.9.1. # Notebooks: ROOT C++ kernel; notebook>=4.4.1; metakernel>=0.20.0. # Distributed RDataFrame; pyspark>=2.4 # Spark backend; dask>=2022.08.1 # Dask backend; distributed>=2022.08.1 # Dask backend. # JsMVA: Jupyter notebook magic for TMVA; ipywidgets. # Look for CPU-only versions of PyTorch to avoid pulling CUDA in the CI docker images.; -f https://download.pytorch.org/whl/cpu/torch_stable.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/requirements.txt:311,interface,interfaces,311,requirements.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/requirements.txt,1,['interface'],['interfaces']
Integrability,"# ROOT::TestSupport: the unit-test support library. This library supports ROOT's unit tests. It implements two main functions; 1. It provides a static library target `ROOT::TestSupport`. All google tests that are defined using `ROOT_ADD_GTEST` will be linked against this target.; When a test executable starts up, this will install a ROOT message handler that intercepts all messages / diagnostics.; If a message with severity > kInfo is issued, this message handler will register a test failure. This way, we are ensuring that no gtest can issue unnoticed warning or error messages.; 2. However, some warnings and errors are expected as the result of certain tests. Therefore, the library provides tools to declare when messages are expected during a test. For this,; 1. Include the header `ROOT/TestSupport.hxx`.; 2. Declare a RAII object that temporarily replaces the message handler from 1.; 3. Register the expected messages to this object, so it can check that they are indeed sent. This could look as follows:; ```c++; #include <ROOT/TestSupport.hxx>. // In a test function:; ROOT::TestSupport::CheckDiagsRAII checkDiag;; checkDiag.requiredDiag(kError, ""prepareMethod"", ""Can't compile function TFormula"", /*matchFullMessage=*/false);; checkDiag.requiredDiag(kError, ""TFormula::InputFormulaIntoCling"", ""Error compiling formula expression in Cling"", true);; // run test that generates the above errors; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/README.md:340,message,message,340,core/testsupport/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/README.md,8,['message'],"['message', 'messages']"
Integrability,"# ROOTR Users Guide. ## DESCRIPTION; ROOT R is an interface in ROOT to call R functions using an R C++ interface (Rcpp, see http://dirk.eddelbuettel.com/code/rcpp.html).; This interface opens the possibility in ROOT to use the very large set of mathematical and statistical tools provided by R.; With ROOTR you can perform a conversion from ROOT's C++ objects to R's objects, transform the returned R objects into ROOT's C++ objects, then; the R functionality can be used directly for statistical studies in ROOT. ## ROOTR BASICS; ROOTR creates a working environment to execute R coding called from `C++`. It allows to translate some datatypes from `C++` to R; inside the R environment and vice versa in an easy way to get the most from both R and ROOT.; To ease the sending and receiving of data in both environments, I overloaded the operators `<<`,`>>` and `[]`; which make look the job as a flow of data between environments, we will see more of that later.; With this tool you ca use any library or R package wich allows you to access a big amount of benefits to make statistical analysis.; ROOTR also has a R events processing system, which allows to use the R graphical system from `C++`. ## INSTALLATION; To install ROOTR please read first. - [https://root.cern.ch/building-root](https://root.cern.ch/building-root); - [https://root.cern.ch/build-prerequisites](https://root.cern.ch/build-prerequisites). ### COMPILING ROOTR ON MAC WITH CMAKE:; **NOTE:** Mac OSX Yosemite last xcode and without macports. **Prerequisites**. - xcode; - [xquartz](http://xquartz.macosforge.org/); - [R last version](https://www.r-project.org); - [cmake](https://cmake.org/download/). To compile with cmake added into ~/.profile. ~~~{.sh}; export PATH=$PATH:/Applications/CMake.app/Contents/bin/; ~~~; and. ~~~{.sh}; source ~/.profile; ~~~. Install needed R packages, open R and in the prompt type. ~~~{.sh}; install.packages(c('Rcpp','RInside')); ~~~; select a mirror and install. Install the next additional pac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:50,interface,interface,50,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,3,['interface'],['interface']
Integrability,"# Speculative Load Hardening. ## A Spectre Variant #1 Mitigation Technique. Author: Chandler Carruth - [chandlerc@google.com](mailto:chandlerc@google.com). ## Problem Statement. Recently, Google Project Zero and other researchers have found information leak; vulnerabilities by exploiting speculative execution in modern CPUs. These; exploits are currently broken down into three variants:; * GPZ Variant #1 (a.k.a. Spectre Variant #1): Bounds check (or predicate) bypass; * GPZ Variant #2 (a.k.a. Spectre Variant #2): Branch target injection; * GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load. For more details, see the Google Project Zero blog post and the Spectre research; paper:; * https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; * https://spectreattack.com/spectre.pdf. The core problem of GPZ Variant #1 is that speculative execution uses branch; prediction to select the path of instructions speculatively executed. This path; is speculatively executed with the available data, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:533,inject,injection,533,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['inject'],['injection']
Integrability,"# Support library for diagnostic handling in ROOT unit tests.; # This library is linked into all googletest executables. It installs; # a ROOT message handler that triggers test failures when diagnostics; # higher than kInfo are issued by tests.; # Stephan Hageboeck, CERN, 2022. if(NOT testsupport); return(); endif(). set(libname TestSupport); set(header_dir ROOT/). add_library(${libname} OBJECT src/TestSupport.cxx); target_include_directories(${libname} PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc/>; $<INSTALL_INTERFACE:./>; ); target_link_libraries(${libname} PUBLIC Core gtest). # Installation of header and library:; set_target_properties(${libname} PROPERTIES PUBLIC_HEADER inc/${header_dir}/TestSupport.hxx); install(TARGETS ${libname}; EXPORT ${CMAKE_PROJECT_NAME}Exports; OBJECTS DESTINATION ${CMAKE_INSTALL_LIBDIR}/${libname}; PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${header_dir}); set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${libname}). # Make it usable inside and outside of ROOT under a single name if somebody writes their own tests using ROOT_ADD_GTEST; add_library(ROOT::${libname} ALIAS ${libname}). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt:143,message,message,143,core/testsupport/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt,1,['message'],['message']
Integrability,"# TODO: This file assumes the Clang toolchain so it'd be better if it lived in; # Clang, except there already is clang/runtime directory which contains; # similar although simpler functionality. We should figure out how to merge; # the two files. set(COMMON_CMAKE_ARGS ""-DHAVE_LLVM_LIT=ON;-DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}""); foreach(proj ${LLVM_ENABLE_RUNTIMES}); set(proj_dir ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); if(IS_DIRECTORY ${proj_dir} AND EXISTS ${proj_dir}/CMakeLists.txt); list(APPEND runtimes ${proj_dir}); else(); message(FATAL_ERROR ""LLVM_ENABLE_RUNTIMES requests ${proj} but directory not found: ${proj_dir}""); endif(); string(TOUPPER ""${proj}"" canon_name); STRING(REGEX REPLACE ""-"" ""_"" canon_name ${canon_name}); set(LLVM_EXTERNAL_${canon_name}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); endforeach(). function(get_compiler_rt_path path); foreach(entry ${runtimes}); get_filename_component(projName ${entry} NAME); if(""${projName}"" MATCHES ""compiler-rt""); set(${path} ${entry} PARENT_SCOPE); return(); endif(); endforeach(); endfunction(). include(LLVMExternalProjectUtils). if(NOT LLVM_BUILD_RUNTIMES); set(EXTRA_ARGS EXCLUDE_FROM_ALL); endif(). function(check_apple_target triple builtin_or_runtime); set(error ""\; compiler-rt for Darwin builds for all platforms and architectures using a \; single configuration. Specify only a single darwin triple (e.g. x86_64-apple-darwin) \; in your targets list (and not a triple for a specific platform such as macos). \; You can use variables such as COMPILER_RT_ENABLE_IOS and DARWIN_ios_ARCHS to \; control the specific platforms and architectures to build.""). set(seen_property ${builtin_or_runtime}_darwin_triple_seen); string(REPLACE ""-"" "";"" triple_components ${triple}); foreach(component ${triple_components}); string(TOLOWER ""${component}"" component_lower); if(component_lower MATCHES ""^darwin""); get_property(darwin_triple_seen GLOBAL PROPERTY ${seen_property}); if(darwin_triple_seen); message(FATAL_E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:544,message,message,544,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['message'],['message']
Integrability,"# The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParameters() and. - FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after; some manipulation. The parameters and/or the FunctionMinimum can be; printed us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36626,message,message,36626,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['message']
Integrability,"# This tool creates a shared library from the LLVM libraries. Generating this; # library is enabled by setting LLVM_BUILD_LLVM_DYLIB=yes on the CMake; # commandline. By default the shared library only exports the LLVM C API. set(SOURCES; libllvm.cpp; ). if(LLVM_LINK_LLVM_DYLIB AND LLVM_DYLIB_EXPORTED_SYMBOL_FILE); message(WARNING ""Using LLVM_LINK_LLVM_DYLIB with LLVM_DYLIB_EXPORTED_SYMBOL_FILE may not work. Use at your own risk.""); endif(). if(LLVM_BUILD_LLVM_DYLIB); if(MSVC); message(FATAL_ERROR ""Generating libLLVM is not supported on MSVC""); endif(); if(ZOS); message(FATAL_ERROR ""Generating libLLVM is not supported on z/OS""); endif(). llvm_map_components_to_libnames(LIB_NAMES ${LLVM_DYLIB_COMPONENTS}). # Exclude libLLVMTableGen for the following reasons:; # - it is only used by internal *-tblgen utilities;; # - it pollutes the global options space.; list(REMOVE_ITEM LIB_NAMES ""LLVMTableGen""). if(LLVM_DYLIB_EXPORTED_SYMBOL_FILE); set(LLVM_EXPORTED_SYMBOL_FILE ${LLVM_DYLIB_EXPORTED_SYMBOL_FILE}); add_custom_target(libLLVMExports DEPENDS ${LLVM_EXPORTED_SYMBOL_FILE}); endif(). if (LLVM_LINK_LLVM_DYLIB); set(INSTALL_WITH_TOOLCHAIN INSTALL_WITH_TOOLCHAIN); endif(); if (WIN32); add_llvm_library(LLVM SHARED DISABLE_LLVM_LINK_LLVM_DYLIB SONAME ${INSTALL_WITH_TOOLCHAIN} ${SOURCES}); else(); add_llvm_library(LLVM SHARED DISABLE_LLVM_LINK_LLVM_DYLIB OUTPUT_NAME LLVM ${INSTALL_WITH_TOOLCHAIN} ${SOURCES}); # Add symlink for backwards compatibility with old library name; llvm_install_library_symlink(LLVM-${LLVM_VERSION_MAJOR}${LLVM_VERSION_SUFFIX} $<TARGET_FILE_NAME:LLVM> SHARED FULL_DEST COMPONENT LLVM); endif(). list(REMOVE_DUPLICATES LIB_NAMES); if(""${CMAKE_SYSTEM_NAME}"" STREQUAL ""Darwin""); set(LIB_NAMES -Wl,-all_load ${LIB_NAMES}); else(); configure_file(; ${CMAKE_CURRENT_SOURCE_DIR}/simple_version_script.map.in; ${LLVM_LIBRARY_DIR}/tools/llvm-shlib/simple_version_script.map). # GNU ld doesn't resolve symbols in the version script.; set(LIB_NAMES -Wl,--whole-archive ${LIB_NA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt:316,message,message,316,interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,3,['message'],['message']
Integrability,"# Web-based display. In this chapter discussed how web-based display can be created in the ROOT. ## Basics. Idea of web displays is implementation of user interface, which can run remotely; or locally in the web-browsers, fully decoupled from the application code.; For the communication between application and browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:155,interface,interface,155,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['interface'],['interface']
Integrability,"# Writing a Graphical User Interface; \index{Graphical User Interface}. The ROOT GUI classes support an extensive and rich set of widgets with; the Windows 95 look and feel. The widget classes interface to the; underlying graphics system via a single abstract class. Concrete; versions of this abstract class have been implemented for X11 and Win32,; thereby making the ROOT GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:193,interface,interface,193,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,"# `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62647,integrat,integration,62647,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"# into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}""); endif(); if (LLVM_CCACHE_DIR); set(CCACHE_PROGRAM ""CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}""); endif(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM}); else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:11365,message,message,11365,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"# llvm-exegesis. `llvm-exegesis` is a benchmarking tool that accepts or assembles a snippet and; can measure characteristics of that snippet by executing it while keeping track; of performance counters. ### Currently Supported Platforms. `llvm-exegesis` is quite platform-dependent and currently only supports a couple; platform configurations for benchmarking. The limitations are listed below.; Analysis mode in `llvm-exegesis` is supported on all platforms on which LLVM is. #### Currently Supported Operating Systems for Benchmarking. Currently, `llvm-exegesis` only supports benchmarking on Linux. This is mainly; due to a dependency on the Linux perf subsystem for reading performance; counters. The subprocess execution mode and memory annotations currently only supports; Linux due to a heavy reliance on many Linux specific syscalls/syscall; implementations. #### Currently Supported Architectures for Benchmarking. Currently, using `llvm-exegesis` for benchmarking is supported on the following; architectures:; * x86; * 64-bit only due to this being the only implemented calling convention; in `llvm-exegesis` currently.; * ARM; * AArch64 only; * MIPS; * PowerPC (PowerPC64LE only). Note that not benchmarking functionality is guaranteed to work on all platforms. Memory annotations are currently only supported on 64-bit X86. There is no; inherent limitations for porting memory annotations to other architectures, but; parts of the test harness are implemented as MCJITed assembly that is generated; in `./lib/X86/Target.cpp` that would need to be implemented on other architectures; to bring up support.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md:272,depend,dependent,272,interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,2,['depend'],"['dependency', 'dependent']"
Integrability,"## 2D Graphics Libraries. ### TASImage. - In some cases dashed lines with a line width greater than ""1"" were; not drawn.; - The `TLatex` symbol `#tilde`, was misplaced.; - In `TASImage::DrawtText`, `TTF::SetTextSize` was called with a rounded; value (to pixel). This cause some misplacements of character in TLatex; formulae. ### TPDF and TPostScript. - Parenthesis can be used in PDF and PS file names.; - In PDF files, italic greek characters were not correct for non null; text angle. ### TImageDump; - Fix a `TBox` clipping issue. ### TSVG; - Some markers did not show in Google-Chrome. ### New class TTeXDump: Graphics interface to TeX. This class allow to generate `PGF/TikZ` vector graphics output; which can be included in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:624,interface,interface,624,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['interface'],['interface']
Integrability,"## 2D Graphics Libraries. ### TLegend. - Due to the way the vertical text centring is done (bounding based) the; spacing between lines may appeared irregular in some cases. This was; previously fixed. But in case the text size of legend's items is smaller; than the line spacing some misalignment appeared. ### TLatex. - The interface to TMathText did not work when the size was set in pixel; (precision 3). ### TTeXDump. - The marker definition is now inside the picture definition. Being outside; produced some side effect on the picture positioning. (cf Jira Report 6470). ### Typographically correct minus sign. - Negative values as well as negative exponents were typeset with a hyphen; instead of a real minus sign in axis labels and statistics numbers. Now is the; TLatex `#minus` sign is used instead, which improve the appearance of the plots; and make them even better for publications.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v602/index.md:325,interface,interface,325,graf2d/doc/v602/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v602/index.md,1,['interface'],['interface']
Integrability,"## Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessRequests() method. The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:. ```cpp; serv->ProcessRequests();; ```. In such case, one can fully disable the timer of the server:. ```cpp; serv->SetTimer(0, kTRUE);; ```. ## Data access from command shell. The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts. If one starts a server and register an object like for example:. ```cpp; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; ```. One could request a JSON representation of such object with the command:. ```bash; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; ```. Then, its representation will look like:. ```json; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; ```. The following requests can be performed:. | Name | Description |; | :----------- | :---------------- |; | `root.bin` | binary data produced by object streaming with `TBufferFile` |; | `root.json` | ROOT JSON representation for object and objects members |; | `file.root` | Creates TMemFile with the only object, from ROOT 6",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:14428,protocol,protocol,14428,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['protocol'],['protocol']
Integrability,"## Core Libraries. ### Interpreter. The new interface `TInterpreter::Declare(const char* code)` will declare the; code to the interpreter with all interpreter extensions disabled, i.e. as; ""proper"" C++ code. No autoloading or synamic lookup will be performed. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v602/index.md:44,interface,interface,44,core/doc/v602/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v602/index.md,1,['interface'],['interface']
Integrability,## Math Libraries. ### Minuit2. - Remove the TFitterMinuit class and the similar ones used to implement the `TVirtualFitter` interface using Minuit2. users should switch to use the; `ROOT::Math::Minimizer` interface. All other changes in the Math packages have been applied also in the 5.34 patched versions of ROOT. See their release notes for the detailed list of applied improvements. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v600/index.md:125,interface,interface,125,math/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v600/index.md,2,['interface'],['interface']
Integrability,"## Networking Libraries. A new class TS3WebFile has been introduced. The new class TS3WebFile is; an extension of TWebFile and belongs to the net module. The name; TS3WebFile reflects better the fact that this solution is intended to be; generic to several S3 servers and not limited to Amazon's, in addition; to the fact that it actually extends the capabilities of TWebFile. Compared to the current support of S3 in ROOT (basically the class; TAS3File), the modifications include the improvements below:. - add support for using HTTPS : you can use different schemas for; specifying the underlying transport protocol to use ""s3:"",; ""s3http:"", ""s3https:"" [""s3"" uses HTTPS]. The current schema, namely; ""as3:"", is supported for backwards compatibility.; - extend support for other S3 service providers that do not offer the; virtual hosting functionality (currently only Amazon offers this).; - support the possibility of specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:610,protocol,protocol,610,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['protocol'],['protocol']
Integrability,"## PROOF System. All the fixes and improvements in the PROOF system occured since the release of 5.34/00 are available both in the latest 5.34 tags and in 6.00/00.; The following is a summary of the major modifications since 5.34 . ### New developments/functionality. - Several improvements in the merging phase; in particular:; - Modification of output sending protocol to control memory usage, significantly reducing the memory footprint on the master, in particular when merging; large numbers of histograms.; - Use an hash table for the output list to significantly speed up names lookups during merging.; - Add support for dynamic addition of workers to a currently running process (currently supported by the unit packetizer).; - Automatization of the usage of file-based technology to handle outputs.; - [Improved dataset management model](https://root.cern/doc/v628/classTDataSetManagerAliEn.html); where the PROOF (ROOT) dataset manager is a light frontend to the experiment file catalogs; TDataSetManagerFile is still; used as local cache of the experiment information or to store the work-in-progress status of the dataset manager daemon. This model addresses the scalability issues observed at ALICE AFs.; - Improvements in [TProofBench](https://root.cern.ch/doc/master/classTProofBench.html):; - Recording and display of the maximum rate during query, CPU efficiency calculation for PROOF-Lite runs, better measurement of wall time.; - Support for dynamic startup mode. - Test program xpdtest to test the status of xproofd (see also man page under $ROOTSYS/man/man1):. ``` {.sh}; $ xpdtest [options]; --help, -h; Gives a short list of options avaliable, and exit; -t <test>; type of test to be run:; 0 ping the daemon (includes process existence check if pid specified; see below); 1 ping the daemon and check connection for default user; 2 ping the daemon and check connection for the default user and all recent users; ...; ```; - Interface with **igprof** for fast statistic profiling.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md:362,protocol,protocol,362,proof/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md,1,['protocol'],['protocol']
Integrability,"## What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimizati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:33397,interface,interface,33397,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"######################################################. set(py_sources; DistRDF/__init__.py; DistRDF/_graph_cache.py; DistRDF/ComputationGraphGenerator.py; DistRDF/DataFrame.py; DistRDF/HeadNode.py; DistRDF/Node.py; DistRDF/Operation.py; DistRDF/Proxy.py; DistRDF/PythonMergeables.py; DistRDF/Ranges.py; DistRDF/Backends/__init__.py; DistRDF/Backends/Base.py; DistRDF/Backends/Utils.py; DistRDF/Backends/Spark/__init__.py; DistRDF/Backends/Spark/Backend.py; DistRDF/Backends/Dask/__init__.py; DistRDF/Backends/Dask/Backend.py; DistRDF/LiveVisualize.py; ). # Add custom rules to copy the Python sources into the build directory; foreach(py_source ${py_sources}); add_custom_command(; OUTPUT ${localruntimedir}/${py_source}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}; ${localruntimedir}/${py_source}; DEPENDS python/${py_source}; COMMENT ""Copying ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}""); list(APPEND py_sources_in_localruntimedir ${localruntimedir}/${py_source}); endforeach(). # A custom target that depends on the Python sources being present in the build; # directory. This will be used as a dependency of the pythonization libraries,; # such that the Python sources get re-copied to the build directory when; # changed.; add_custom_target(DistRDF ALL DEPENDS ${py_sources_in_localruntimedir}). # Compile .py files; # We include DistRDF in the build only if Python 3.8+ is used,; # so we can directly use the main Python executable to compile the sources; foreach(py_source ${py_sources}); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -m py_compile ${localruntimedir}/${py_source})""); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -O -m py_compile ${localruntimedir}/${py_source})""); endforeach(). # Install Python sources and bytecode; install(DIRECTORY ${localruntimedir}/DistRDF; DESTINATION ${CMAKE_INSTALL_PYTHONDIR}; COMPONENT libraries). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/backend); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/CMakeLists.txt:1353,depend,depends,1353,bindings/experimental/distrdf/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/CMakeLists.txt,2,['depend'],"['dependency', 'depends']"
Integrability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. cmake_minimum_required(VERSION 3.5). # Keep symbols for JIT resolution; set(LLVM_NO_DEAD_STRIP 1). # Cling needs at least C++17; so does this demo.; set(CMAKE_CXX_STANDARD 17); set(CMAKE_CXX_STANDARD_REQUIRED ON). if (CMAKE_PROJECT_NAME); # Building as part of cling; all CMake variables are set.; else(); # Building as separate project.; project(cling-demo). # This project needs cling.; find_package(cling REQUIRED); endif(). # The project has one binary:; add_executable(cling-demo cling-demo.cpp). # ...which links against clingInterpreter (and its dependencies).; target_link_libraries(cling-demo clingInterpreter). # Provide LLVMDIR to cling-demp.cpp:; target_compile_options(cling-demo PUBLIC -DLLVMDIR=""${LLVM_INSTALL_PREFIX}"" -I${LLVM_INSTALL_PREFIX}/include). set_target_properties(cling-demo; PROPERTIES ENABLE_EXPORTS 1). if(MSVC); set_target_properties(cling-demo PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/CMakeLists.txt:954,depend,dependencies,954,interpreter/cling/tools/demo/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. if (CMAKE_CFG_INTDIR STREQUAL "".""); set(LLVM_BUILD_MODE "".""); else (); set(LLVM_BUILD_MODE ""%(build_mode)s""); endif (). # Needed for '%shlibext'; set(TARGET_SHLIBEXT ""${CMAKE_SHARED_LIBRARY_SUFFIX}""). configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). option(CLING_TEST_USE_VG ""Run Cling tests under Valgrind"" OFF); if(CLING_TEST_USE_VG); set(CLING_TEST_EXTRA_ARGS ${CLING_TEST_EXTRA_ARGS} ""--vg""); endif (). list(APPEND CLING_TEST_DEPS cling); if (TARGET llvm-config); list(APPEND CLING_TEST_DEPS llvm-config); endif(); if (TARGET FileCheck); list(APPEND CLING_TEST_DEPS FileCheck); endif(); if (TARGET opt); list(APPEND CLING_TEST_DEPS opt); endif(); if (TARGET not); list(APPEND CLING_TEST_DEPS not); endif(); if (TARGET count); list(APPEND CLING_TEST_DEPS count); endif(); if (TARGET clang); list(APPEND CLING_TEST_DEPS clang); endif(). set(CLING_TEST_PARAMS; cling_site_config=${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). add_custom_target(cling-test-depends DEPENDS clingDemoPlugin ${CLING_TEST_DEPS}). set(LLVM_LIT_OUTPUT_DIR ""${LLVM_BINARY_DIR}/bin""); add_lit_testsuite(check-cling ""Running the Cling regression tests""; ${CMAKE_CURRENT_BINARY_DIR}; PARAMS ${CLING_TEST_PARAMS}; DEPENDS ${CLING_TEST_DEPS}; ARGS ${CLING_TEST_EXTRA_ARGS}; ); set_target_properties(check-cling PROPERTIES FOLDER ""Cling tests""). # Add a legacy target spelling: cling-test; add_custom_target(cling-test); add_dependencies(cling-test check-cling); set_target_properties(cling-test PROPERTIES FOLDER ""Cling tests""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt:1421,depend,depends,1421,interpreter/cling/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt,1,['depend'],['depends']
Integrability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. set(LIBS; clingUtils; clangCodeGen; clangDriver; clangFrontend; clangParse; clangSema; clangAnalysis; clangEdit; clangRewrite; clangRewriteFrontend; clangSerialization; clangAST; clangBasic; clangLex; ). set(LLVM_LINK_COMPONENTS; analysis; core; coroutines; coverage; executionengine; ipo; jitlink; lto; mc; object; option; orcjit; runtimedyld; scalaropts; support; target; transformutils; binaryformat; ${LLVM_TARGETS_TO_BUILD}; ). # clingInterpreter depends on Options.inc to be tablegen-ed; # (target ClangDriverOptions) from in-tree builds.; set(CLING_DEPENDS ClingDriverOptions); if(TARGET ClangDriverOptions); set(CLING_DEPENDS ""${CLING_DEPENDS};ClangDriverOptions""); endif(); # clangSema will make sure all of the dependencies of clingInterpreter are met.; if(TARGET clangSema); set(CLING_DEPENDS ""${CLING_DEPENDS};clangSema""); endif(). add_cling_library(clingInterpreter OBJECT; AutoSynthesizer.cpp; AutoloadCallback.cpp; ASTTransformer.cpp; BackendPasses.cpp; CheckEmptyTransactionTransformer.cpp; CIFactory.cpp; ClangInternalState.cpp; ClingCodeCompleteConsumer.cpp; ClingPragmas.cpp; DeclCollector.cpp; DeclExtractor.cpp; DefinitionShadower.cpp; DeclUnloader.cpp; DeviceKernelInliner.cpp; DynamicLibraryManager.cpp; DynamicLibraryManagerSymbol.cpp; DynamicLookup.cpp; DynamicExprInfo.cpp; Exception.cpp; ExternalInterpreterSource.cpp; ForwardDeclPrinter.cpp; IncrementalCUDADeviceCompiler.cpp; IncrementalExecutor.cpp; IncrementalJIT.cpp; IncrementalParser.cpp; Interpreter.cpp; InterpreterCallbacks.cpp; InvocationOptions.cpp; LookupHelper.cpp; NullDerefProtectionTransformer.cpp; PerfJIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CMakeLists.txt:853,depend,depends,853,interpreter/cling/lib/Interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CMakeLists.txt,1,['depend'],['depends']
Integrability,#; # This file is autogenerated by pip-compile with Python 3.11; # by the following command:; #; # pip-compile --output-file=llvm/utils/git/requirements_formatting.txt llvm/utils/git/requirements_formatting.txt.in; #; black==23.9.1; # via; # -r llvm/utils/git/requirements_formatting.txt.in; # darker; certifi==2023.7.22; # via requests; cffi==1.15.1; # via; # cryptography; # pynacl; charset-normalizer==3.2.0; # via requests; click==8.1.7; # via black; cryptography==41.0.3; # via pyjwt; darker==1.7.2; # via -r llvm/utils/git/requirements_formatting.txt.in; deprecated==1.2.14; # via pygithub; idna==3.4; # via requests; mypy-extensions==1.0.0; # via black; packaging==23.1; # via black; pathspec==0.11.2; # via black; platformdirs==3.10.0; # via black; pycparser==2.21; # via cffi; pygithub==1.59.1; # via -r llvm/utils/git/requirements_formatting.txt.in; pyjwt[crypto]==2.8.0; # via pygithub; pynacl==1.5.0; # via pygithub; requests==2.31.0; # via pygithub; toml==0.10.2; # via darker; urllib3==2.0.4; # via requests; wrapt==1.15.0; # via deprecated; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/requirements_formatting.txt:1023,wrap,wrapt,1023,interpreter/llvm-project/llvm/utils/git/requirements_formatting.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/requirements_formatting.txt,1,['wrap'],['wrapt']
Integrability,#; # This file is autogenerated by pip-compile with Python 3.11; # by the following command:; #; # pip-compile --output-file=requirements.txt requirements.txt.in; #; certifi==2023.7.22; # via; # -r requirements.txt.in; # requests; cffi==1.15.1; # via; # cryptography; # pynacl; charset-normalizer==2.1.1; # via requests; cryptography==41.0.3; # via pyjwt; deprecated==1.2.13; # via pygithub; gitdb==4.0.9; # via gitpython; gitpython==3.1.32; # via -r requirements.txt.in; idna==3.4; # via requests; pycparser==2.21; # via cffi; pygithub==1.59.1; # via -r requirements.txt.in; pyjwt[crypto]==2.5.0; # via pygithub; pynacl==1.5.0; # via pygithub; requests==2.28.1; # via pygithub; smmap==5.0.0; # via gitdb; types-cryptography==3.3.23.2; # via pyjwt; urllib3==1.26.12; # via requests; wrapt==1.14.1; # via deprecated; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/requirements.txt:783,wrap,wrapt,783,interpreter/llvm-project/llvm/utils/git/requirements.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/requirements.txt,1,['wrap'],['wrapt']
Integrability,"#include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54681,integrat,integration,54681,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"$ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. #####################################################################################################################. # Details about integrating ROOT into CMake projects:; # https://root.cern/manual/integrate_root_into_my_cmake_project/. #####################################################################################################################. # CMakeLists.txt that creates a library with dictionary and a main program; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(treeUsingCustomClass). #---Locate the ROOT package and defines a number of variables (e.g. ROOT_INCLUDE_DIRS); find_package(ROOT REQUIRED COMPONENTS Tree TreePlayer ROOTDataFrame). #---Include a CMake module which makes use of the previous variables and loads modules ; # with useful macros or functions such as ROOT_GENERATE_DICTIONARY; # For further details: https://root-forum.cern.ch/t/how-to-integrate-root-into-my-project-with-cmake/37175; include(${ROOT_USE_FILE}). #---Add include directory of ROOT to the build; include_directories(${CMAKE_SOURCE_DIR}). # CMake function provided by ROOT, used to generate the dictionary file, G__data2Tree.cxx; # See this link for further details:; # https://root.cern/manual/io_custom_classes/#using-cmake; ROOT_GENERATE_DICTIONARY(G__data2Tree data2Tree.hxx LINKDEF data2TreeLinkDef.hxx). #---Create a shared library from; # * the previously generated dictionary, G__data2Tree.cxx; # * the class implementation; add_library(data2TreeLib SHARED data2Tree.cxx G__data2Tree.cxx); target_link_libraries(data2TreeLib ${ROOT_LIBRARIES} ) ; add_dependencies(data2TreeLib G__data2Tree ). #--- This is needed on Windows in order to export the symbols and create the data2TreeLib.lib file; if(MSVC); set_target_properties(data2TreeLib PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE); endif(). #---Create a main program using the library; add_executable(treeExample main.cpp writeTree.cxx readTree.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt:1085,integrat,integrate-root-into-my-project-with-cmake,1085,tutorials/tree/dictionary/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt,1,['integrat'],['integrate-root-into-my-project-with-cmake']
Integrability,"${CMAKE_COMMAND} -E copy_directory; # ${CMAKE_SOURCE_DIR}/interpreter/cling/tools/plugins/clad/patches <SOURCE_DIR>; # && git checkout <SOURCE_DIR>; # && git apply --ignore-space-change --ignore-whitespace ${_clad_patches_list}; # ). ExternalProject_Add(; clad; GIT_REPOSITORY https://github.com/vgvassilev/clad.git; GIT_TAG v1.7; UPDATE_COMMAND """"; PATCH_COMMAND ${_clad_patch_command}; CMAKE_ARGS -G ${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}; -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}; -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}; -DCMAKE_CXX_FLAGS=${CLAD_CXX_FLAGS}; -DCMAKE_INSTALL_PREFIX=${clad_install_dir}/plugins; -DLLVM_DIR=${LLVM_BINARY_DIR}; -DCLANG_INCLUDE_DIRS=${CLANG_INCLUDE_DIRS}; ${_clad_extra_cmake_args}; # FIXME; # Building with 1 core is a temporary workaround for #16654 and has to be ; # there until the behaviour of the clad build on ubuntu 24.10 is understood.; # The performance penalty in the build is negligible.; BUILD_COMMAND ${CMAKE_COMMAND} --build . ${EXTRA_BUILD_ARGS} -j 1; INSTALL_COMMAND ${CMAKE_COMMAND} --build . ${EXTRA_BUILD_ARGS} -j 1 --target install; BUILD_BYPRODUCTS ${CLAD_BYPRODUCTS}; ${_clad_extra_settings}; # We need the target clangBasic to be built before building clad. However, we; # support building prebuilt clang and adding clangBasic breaks this case.; # Delegate the dependency resolution to the clingInterpreter target (which; # will always depend on clangBasic).; DEPENDS clingInterpreter; ). # Register cladPlugin, cladDifferentiator; foreach (lib cladPlugin cladDifferentiator); add_library(${lib} IMPORTED STATIC GLOBAL); add_dependencies(${lib} clad); endforeach(). set_property(TARGET cladPlugin PROPERTY IMPORTED_LOCATION ${_CLAD_LIBRARY_PATH}/${CMAKE_STATIC_LIBRARY_PREFIX}cladPlugin${CMAKE_STATIC_LIBRARY_SUFFIX}); set_property(TARGET cladDifferentiator PROPERTY IMPORTED_LOCATION ${_CLAD_LIBRARY_PATH}/${CMAKE_STATIC_LIBRARY_PREFIX}cladDifferentiator${CMAKE_STATIC_LIBRARY_SUFFIX}); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt:4101,depend,dependency,4101,interpreter/cling/tools/plugins/clad/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt,2,['depend'],"['depend', 'dependency']"
Integrability,"${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`` wrapper functions are; all defined in ``AddLLVM.cmake`` which is installed as part of the LLVM; distribution. It can be included and used by any LLVM sub-project that requires; LLVM. .. note::. Not all LLVM projects require LLVM for all use cases. For example compiler-rt; can be built without LLVM, and the compiler-rt sanitizer libraries are used; with GCC. Useful Built-in Commands; ========================. CMake has a bunch of useful built-in commands. This document isn't going to; go into details about them because The CMake project has excellent; documentation. To highlight a few useful functions see:. * `add_custom_command <https://cmake.org/cmake/help/v3.4/command/add_custom_command.html>`_; * `add_custom_target <https://cmake.org/cmake/help/v3.4/command/add_custom_target.html>`_; * `file <https://cmake.org/cmake/help/v3.4/command/file.html>`_; * `list <https://cmake.org/cmake/help/v3.4/command/list.html>`_; * `math <https://cmake.org/cmake/help/v3.4/command/math.html>`_; * `string <https://cm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:13704,wrap,wrapper,13704,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['wrap'],['wrapper']
Integrability,"% ROOT Version 6.10 Release Notes; % 2016-09-30; <a name=""TopOfPage""></a>. ## Introduction. ROOT version 6.10/00 is scheduled for release in 2017. For more information, see:. [http://root.cern.ch](http://root.cern.ch). The following people have contributed to this new version:. Bertrand Bellenot, CERN/SFT,\; Georgios Bitzes, CERN/IT,\; Rene Brun, CERN/SFT,\; Philippe Canal, FNAL,\; Olivier Couet, CERN/SFT,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Vassil Vassilev, Fermilab/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:743,interface,interfaces,743,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,2,['interface'],['interfaces']
Integrability,"%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to; ``%val = call i32 %f(ptr %nval, i32 %x, i32 %y)``. .. _int_it:. '``llvm.init.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.init.trampoline(ptr <tramp>, ptr <func>, ptr <nval>). Overview:; """""""""""""""""". This fills the memory pointed to by ``tramp`` with executable code,; turning it into a trampoline. Arguments:; """""""""""""""""""". The ``llvm.init.trampoline`` intrinsic takes three arguments, all; pointers. The ``tramp`` argument must point to a sufficiently large and; sufficiently aligned block of memory; this memory is written to by the; intrinsic. Note that the size and the alignment are target-specific -; LLVM currently provides no portable way of determining them, so a; front-end that generates this intrinsic needs to have some; target-specific knowledge. The ``func`` argument must hold a function. Semantics:; """""""""""""""""""". The block of memory pointed to by ``tramp`` is filled with target; dependent code, turning it into a function. Then ``tramp`` needs to be; passed to :ref:`llvm.adjust.trampoline <int_at>` to get a pointer which can; be :ref:`bitcast (to a new function) and called <int_trampoline>`. The new; function's signature is the same as that of ``func`` with any arguments; marked with the ``nest`` attribute removed. At most one such ``nest``; argument is allowed, and it must be of pointer type. Calling the new; function is equivalent to calling ``func`` with the same argument list,; but with ``nval`` used for the missing ``nest`` argument. If, after; calling ``llvm.init.trampoline``, the memory pointed to by ``tramp`` is; modified, then the effect of any later call to the returned function; pointer is undefined. .. _int_at:. '``llvm.adjust.trampoline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.adjust.trampoline(ptr <tramp>). Overview:; """""""""""""""""". This performs any required machine-specific adjustment ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:690005,depend,dependent,690005,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Configuration options for MVA method :. Configuration options reference for MVA method: SVM. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Gamma No 1 − RBF kernel parameter: Gamma (size of the Kernel). C No 1 − Cost parameter. Tol No 0.01 − Tolerance parameter. MaxIter No 1000 − Maximum number of training loops. Configuration options for MVA method :. Configuration options reference for MVA method: CFMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:7912,message,message,7912,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"'add'.; let RowFields = [""BaseOpcode""];. // List of attributes that can be used to define key and column instructions; // for a relation. Key instruction is passed as an argument; // to the function used for querying relation tables. Column instructions; // are the instructions they (key) can transform into.; //; // Here, we choose 'PredSense' as ColFields since this is the unique; // attribute of the key (non-predicated) and column (true/false); // instructions involved in this relationship model.; let ColFields = [""PredSense""];. // The key column contains non-predicated instructions.; let KeyCol = [""none""];. // Two value columns - first column contains instructions with; // PredSense=true while second column has instructions with PredSense=false.; let ValueCols = [[""true""], [""false""]];; }. TableGen uses the above relationship model to emit relation table that maps; non-predicated instructions with their predicated forms. It also outputs the; interface function; ``int getPredOpcode(uint16_t Opcode, enum PredSense inPredSense)`` to query; the table. Here, Function ``getPredOpcode`` takes two arguments, opcode of the; current instruction and PredSense of the desired instruction, and returns; predicated form of the instruction, if found in the relation table.; In order for an instruction to be added into the relation table, it needs; to include relevant information in its definition. For example, consider; following to be the current definitions of ADD, ADD_pt (true) and ADD_pf (false); instructions:. .. code-block:: text. def ADD : ALU32_rr<(outs IntRegs:$dst), (ins IntRegs:$a, IntRegs:$b),; ""$dst = add($a, $b)"",; [(set (i32 IntRegs:$dst), (add (i32 IntRegs:$a),; (i32 IntRegs:$b)))]>;. def ADD_Pt : ALU32_rr<(outs IntRegs:$dst),; (ins PredRegs:$p, IntRegs:$a, IntRegs:$b),; ""if ($p) $dst = add($a, $b)"",; []>;. def ADD_Pf : ALU32_rr<(outs IntRegs:$dst),; (ins PredRegs:$p, IntRegs:$a, IntRegs:$b),; ""if (!$p) $dst = add($a, $b)"",; []>;. In this step, we modify these instru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst:4765,interface,interface,4765,interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,1,['interface'],['interface']
Integrability,"'s PR on your local machine to run; tests or inspect code in your preferred editor. This is easily done with the; CLI:. ::. gh pr checkout <PR Number>. This is also possible with the web interface and the normal git command line; tools, but the process is a bit more complicated. See GitHub's; `documentation <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/checking-out-pull-requests-locally?platform=linux&tool=webui#modifying-an-inactive-pull-request-locally>`_; on the topic. Example Pull Request with GitHub CLI; ====================================; Here is an example for creating a Pull Request with the GitHub CLI:. ::. # Clone the repo; gh repo clone llvm/llvm-project. # Switch to the repo and create a new branch; cd llvm-project; git switch -c my_change. # Create your changes; $EDITOR file.cpp. # Don't forget clang-format; git clang-format. # and don't forget running your tests; ninja check-llvm. # Commit, use a good commit message; git commit file.cpp. # Create the PR, select to use your own fork when prompted.; # If you don't have a fork, gh will create one for you.; gh pr create. # If you get any review comments, come back to the branch and; # adjust them.; git switch my_change; $EDITOR file.cpp. # Commit your changes; git commit file.cpp -m ""Code Review adjustments"". # Format changes; git clang-format HEAD~. # Recommit if any formatting changes; git commit -a --amend. # Push your changes to your fork branch, be mindful of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/llvm-project; git push origin my_change. Before merging the PR, it is recommended that you rebase locally and re-run test; checks:. ::. # Add upstream as a remote (if you don't have it already); git remote add upstream https://github.com/llvm/llvm-project.git. # Make sure you have all the latest changes; git fetch upstream && ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:8015,message,message,8015,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability,"(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compatibility issues (__asm keyword is not allowed).; Try (as much as possible) to avoid the disturbing ""There is no disk in the drive. Please insert a disk into drive \Device\..."" popup message box when calling AccessPathName() on removable disk drives with no media installed. This should fix the problem reported on the forum.; Prevent short timers (e.g. 10ms) to keep looping in the DispatchOneEvent() infinite loop.; Better stdout/stderr redirection (it was impossible to restore stdout using freopen on Windows 7, leaving the console as a zombie...); Make sure the stdout/stderr redirection works also in the case there is no console (i.e. in stand-alone applications).; Make sure the file descriptors are valid before using them.; The shortcuts are now working on Windows. Building with CMake. ROOT can now be build using the CMake build system (version 2.8). ; The initial supported platforms are Linux(gcc), Windows (vc9), MacOSX(gcc). The installed libraries and executables should be compatible to the standard build of ROOT.  CMake generates native makefiles and workspaces (i.e. Xcode, Eclipse, Visual Studio) that can be used in the; compiler environment of your choice. The main difference with respect; the Module",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:3440,message,message,3440,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['message'],['message']
Integrability,"() now accepts a new argument ShowProgress() that will print a dot for every; function evaluation performed in the process of creating the plot. This can be useful when plotting very expensive; functions such as profile likelihoods; Automatic handling of constraint terms; It is no longer necessary to add a Constrain() argument to fitTo() calls to have internal constraints; applied. Any pdf term appearing in a product that does not contain an observable and shares one or more parameters; with another pdf term in the same product that does contain an observable is automatically picked up as a constraint term.; For example given a dataset D(x) which defines variable x as observable, the default logic works out as follows. F(x,a,b)*G(a,a0,a1) --> G is constraint term (a also appears in F(x)); F(x,a,b)*G(y,c,d) --> G is dropped (factorizing term). A Constrain(y) term in the above example will still force term G(y,c,d) to be interpreted as constraint term; Automatic caching of numeric integral calculations; Integrals that require numeric integrations in two of more dimensions are now automatically cached in the expensive object store.; The expensive object store allows to cache such values between difference instance of integral objects that represent the; same configuration. If integrals are created from an object (function or pdf) that live in a RooWorkspace the ; expensive object cache of the workspace will be used instead of the global store instance, and values stored in the workspace; store will also be persisted if the workspace is persisted. The global caching behavior of integral objects can be ; controlled through RooRealIntegral::setCacheAllNumeric(Int_t nDimNumMin). Miscellaneous improvements data classes. The RooAbsData::tree() method has been restored. It will only return a TTree* pointer for datasets; that are based on a RooTreeDataStore implementation, i.e. not for the composite datasets mentioned below; A new composite data storage class RooCompositeDataS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:7758,integrat,integrations,7758,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['integrat'],['integrations']
Integrability,"(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221002,interface,interface,221002,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CallExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<CallExpr>calleeMatcher<Stmt> InnerMatcher; Matches if the call or fold expression's callee expression matches. Given; class Y { void x() { this->x(); x(); Y y; y.x(); } };; void f() { f(); }; callExpr(callee(expr())); matches this->x(), x(), y.x(), f(); with callee(...); matching this->x, x, y.x, f respectively. Given; template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. template <typename... Args>; auto multiply(Args... args) {; return (args * ... * 1);; }; cxxFoldExpr(callee(expr())); matches (args * ... * 1); with callee(...); matching *. Note: Callee cannot take the more general internal::Matcher<Expr>; because this introduces ambiguous overloads with calls to Callee taking a; internal::Matcher<Decl>, as the matcher hierarchy is purely; implemented in terms of implicit casts. Matcher<CallExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:172583,interface,interface,172583,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CallExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CallExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CallExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CallExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the ref",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:174735,message,message-send,174735,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message-send']
Integrability,"(APPEND copy_commands COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file} ${CMAKE_BINARY_DIR}/etc/cling/cint/${file}); list(APPEND files_to_copy ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file}); install(FILES ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/cint); endforeach(). set(stamp_file ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/LLVMRES.stamp); if(MSVC); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; ${copy_commands}; COMMAND ${CMAKE_COMMAND} -E copy_directory; ${CLANG_RESOURCE_DIR}; ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include		; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; DEPENDS ${files_to_copy}; COMMENT ""Copying LLVM resource and header files""); else(); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; COMMAND ${CMAKE_COMMAND} -E copy_directory; ${CLANG_RESOURCE_DIR}; ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; ${copy_commands}; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; DEPENDS ${files_to_copy}; COMMENT ""Copying LLVM resource and header files""); endif(); add_custom_target(LLVMRES DEPENDS ${stamp_file} CLING); # CLING is a shorthand for CLING_LIBRARIES and some other clang-specific; # dependencies which ensure the correct order of building. Then the cling header; # files (such as RuntimeUniverse.h) are moved to a semi-private place in ROOT; # #ROOTSYS/etc. This is the place where ROOT will use them from and we should; # add an explcit dependency to something cling-related which ROOT knows.; # ClingUtils seems a good candidate because it is very foundational.; add_dependencies(ClingUtils LLVMRES); ROOT_ADD_TEST_SUBDIRECTORY(test). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:8114,depend,dependencies,8114,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,2,['depend'],"['dependencies', 'dependency']"
Integrability,"(CLANG_INCLUDE_TESTS; ""Generate build targets for the Clang unit tests.""; ${LLVM_INCLUDE_TESTS}). option(CLANG_ENABLE_HLSL ""Include HLSL build products"" Off); # While HLSL support is experimental this should stay hidden.; mark_as_advanced(CLANG_ENABLE_HLSL). add_subdirectory(utils/TableGen). # Export CLANG_TABLEGEN_EXE for use by flang docs.; set(CLANG_TABLEGEN_EXE ""${CLANG_TABLEGEN_EXE}"" CACHE INTERNAL """"). add_subdirectory(include). # All targets below may depend on all tablegen'd files.; get_property(CLANG_TABLEGEN_TARGETS GLOBAL PROPERTY CLANG_TABLEGEN_TARGETS); add_custom_target(clang-tablegen-targets; DEPENDS; omp_gen; ClangDriverOptions; ${CLANG_TABLEGEN_TARGETS}); set_target_properties(clang-tablegen-targets PROPERTIES FOLDER ""Misc""); list(APPEND LLVM_COMMON_DEPENDS clang-tablegen-targets). # Force target to be built as soon as possible. Clang modules builds depend; # header-wise on it as they ship all headers from the umbrella folders. Building; # an entire module might include header, which depends on intrinsics_gen.; if(LLVM_ENABLE_MODULES); list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen); endif(). add_subdirectory(lib); add_subdirectory(tools); add_subdirectory(runtime). option(CLANG_BUILD_EXAMPLES ""Build CLANG example programs by default."" OFF); add_subdirectory(examples). if(APPLE); # this line is needed as a cleanup to ensure that any CMakeCaches with the old; # default value get updated to the new default.; if(CLANG_ORDER_FILE STREQUAL """"); unset(CLANG_ORDER_FILE CACHE); unset(CLANG_ORDER_FILE); endif(). set(CLANG_ORDER_FILE ${CMAKE_CURRENT_BINARY_DIR}/clang.order CACHE FILEPATH; ""Order file to use when compiling clang in order to improve startup time (Darwin Only - requires ld64).""). if(NOT EXISTS ${CLANG_ORDER_FILE}); string(FIND ""${CLANG_ORDER_FILE}"" ""${CMAKE_CURRENT_BINARY_DIR}"" PATH_START); if(PATH_START EQUAL 0); file(WRITE ${CLANG_ORDER_FILE} ""\n""); else(); message(FATAL_ERROR ""Specified order file '${CLANG_ORDER_FILE}' does not exist.""); endi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:17711,depend,depends,17711,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depends']
Integrability,"(Function &F) = 0;. The ``runOnFunction`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. .. _writing-an-llvm-pass-doFinalization-mod:. The ``doFinalization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization(Module &M);. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` for every function in the program being; compiled. .. _writing-an-llvm-pass-LoopPass:. The ``LoopPass`` class; ----------------------. All ``LoopPass`` execute on each :ref:`loop <loop-terminology>` in the function; independent of all of the other loops in the function. ``LoopPass`` processes; loops in loop nest order such that outer most loop is processed last. ``LoopPass`` subclasses are allowed to update loop nest using ``LPPassManager``; interface. Implementing a loop pass is usually straightforward.; ``LoopPass``\ es may override three virtual methods to do their work. All; these methods should return ``true`` if they modified the program, or ``false``; if they didn't. A ``LoopPass`` subclass which is intended to run as part of the main loop pass; pipeline needs to preserve all of the same *function* analyses that the other; loop passes in its pipeline require. To make that easier,; a ``getLoopAnalysisUsage`` function is provided by ``LoopUtils.h``. It can be; called within the subclass's ``getAnalysisUsage`` override to get consistent; and correct behavior. Analogously, ``INITIALIZE_PASS_DEPENDENCY(LoopPass)``; will initialize this set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:20575,interface,interface,20575,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}""). set(LLVM_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE}""). if(WIN32 OR CYGWIN); if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB); set(LLVM_ENABLE_PLUGINS_default ON); else(); set(LLVM_ENABLE_PLUGINS_default OFF); endif(); else(); set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC}); endif(); option(LLVM_ENABLE_PLUGINS ""Enable plugin support"" ${LLVM_ENABLE_PLUGINS_default}). set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL; ""Enable the new pass manager by default.""); if(NOT LLVM_ENABLE_NEW_PASS_MANAGER); message(FATAL_ERROR ""Enabling the legacy pass manager on the cmake level is""; "" no longer supported.""); endif(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ""via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.""); else(); message(FATAL_ERROR ""The target `${t}' is not a core tier target. It may be ""; ""experimental, if so it must be passed via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:39367,depend,depend,39367,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['depend']
Integrability,"(Note: negative; matches from ``CHECK-NOT`` are not affected by this option!). Passing this option is equivalent to inserting ``{{^ *}}`` or; ``{{^}}`` before, and ``{{ *$}}`` or ``{{$}}`` after every positive; check pattern. .. option:: --strict-whitespace. By default, FileCheck canonicalizes input horizontal whitespace (spaces and; tabs) which causes it to ignore these differences (a space will match a tab).; The :option:`--strict-whitespace` argument disables this behavior. End-of-line; sequences are canonicalized to UNIX-style ``\n`` in all modes. .. option:: --ignore-case. By default, FileCheck uses case-sensitive matching. This option causes; FileCheck to use case-insensitive matching. .. option:: --implicit-check-not check-pattern. Adds implicit negative checks for the specified patterns between positive; checks. The option allows writing stricter tests without stuffing them with; ``CHECK-NOT``\ s. For example, ""``--implicit-check-not warning:``"" can be useful when testing; diagnostic messages from tools that don't have an option similar to ``clang; -verify``. With this option FileCheck will verify that input does not contain; warnings not covered by any ``CHECK:`` patterns. .. option:: --dump-input <value>. Dump input to stderr, adding annotations representing currently enabled; diagnostics. When there are multiple occurrences of this option, the; ``<value>`` that appears earliest in the list below has precedence. The; default is ``fail``. * ``help`` - Explain input dump and quit; * ``always`` - Always dump input; * ``fail`` - Dump input on failure; * ``never`` - Never dump input. .. option:: --dump-input-context <N>. In the dump requested by ``--dump-input``, print ``<N>`` input lines before; and ``<N>`` input lines after any lines specified by ``--dump-input-filter``.; When there are multiple occurrences of this option, the largest specified; ``<N>`` has precedence. The default is 5. .. option:: --dump-input-filter <value>. In the dump requested by ``--dump",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:4311,message,messages,4311,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['message'],['messages']
Integrability,"(``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88627,protocol,protocol,88627,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability,"(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:26893,interface,interface,26893,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"(e.g., meaning there are; custom derivatives defined for all external Math library functions used in; your code), it should work for AD support efforts. Please view Clad; documentation for more details. ---. ## Appendix A - What could go wrong (FAQs). ### Will my analyticalIntegral() function support AD?. Both scenarios are possible:. 1 - where `analyticalIntegral()` will be able to support AD. 2 - where `analyticalIntegral()` will *not* be able to support AD. This requires further research. ### What if my evaluate() function cannot support AD?. In some cases. the `evaluate()` function is written in a piece-wise format; (multiple evaluations based on multiple chunks of code). You can review the; `MathFuncs.h` file to find AD support for several piece-wise (`if code==1; {...} else if code==2 {...}` ) code snippets. However, there may still be some cases where AD support may not be possible; due to the way that `evaluate()` function works in that instance. ### What if my evaluate() function depends heavily on caching?. For simple caching, the caching logic can be separated from the; mathematical code that is being moved to `MathFuncs.h`, so that it can; retained in the original file. For more complicated scenarios, the `code` variable can be used to identify; use cases (parts of the mathematical code in `evaluate()`) that should be; supported, while other parts that are explicitly not be supported (e.g., using; `if code==1 {...} else if code==2 {...}`). ### Can classes using Numerical Integration support AD?. So far, no. This needs further exploration. Hint: classes using Numerical; Integration can be identified with the absence of the `analyticalIntegral()`; function. ### Why is my code falling back to Numeric Differentiation?. If you call in to an external Math library, and you use a function that has a; customized variant with an already defined custom derivative, then you may see; a warning like ""falling back to Numeric Differentiation"". In most such cases,; your ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:26729,depend,depends,26729,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['depend'],['depends']
Integrability,"(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. ### Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:19935,rout,routines,19935,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,2,['rout'],['routines']
Integrability,"(int i = 0; i < 100; i++) {; if (a[i]); x += 1;; }; }. The following is equivalent in non-concurrent situations:. .. code-block:: c. int x;; void f(int* a) {; int xtemp = x;; for (int i = 0; i < 100; i++) {; if (a[i]); xtemp += 1;; }; x = xtemp;; }. However, LLVM is not allowed to transform the former to the latter: it could; indirectly introduce undefined behavior if another thread can access ``x`` at; the same time. That thread would read `undef` instead of the value it was; expecting, which can lead to undefined behavior down the line. (This example is; particularly of interest because before the concurrency model was implemented,; LLVM would perform this transformation.). Note that speculative loads are allowed; a load which is part of a race returns; ``undef``, but does not have undefined behavior. Atomic instructions; ===================. For cases where simple loads and stores are not sufficient, LLVM provides; various atomic instructions. The exact guarantees provided depend on the; ordering; see `Atomic orderings`_. ``load atomic`` and ``store atomic`` provide the same basic functionality as; non-atomic loads and stores, but provide additional guarantees in situations; where threads and signals are involved. ``cmpxchg`` and ``atomicrmw`` are essentially like an atomic load followed by an; atomic store (where the store is conditional for ``cmpxchg``), but no other; memory operation can happen on any thread between the load and store. A ``fence`` provides Acquire and/or Release ordering which is not part; of another operation; it is normally used along with Monotonic memory; operations. A Monotonic load followed by an Acquire fence is roughly; equivalent to an Acquire load, and a Monotonic store following a; Release fence is roughly equivalent to a Release; store. SequentiallyConsistent fences behave as both an Acquire and a; Release fence, and additionally provide a total ordering with some; complicated guarantees, see the C++ standard for details. Frontends",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:4321,depend,depend,4321,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['depend'],['depend']
Integrability,"(int sz) {; ... int* iptr = (int*)malloc(sizeof(int)*sz);; ... for (int i=0; i<sz; ++i) iptr[i] = i;; ... return iptr;; ... }""""""); ...; >>> NDATA = 4; >>> d = cppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type, and number of elements (or unchecked, if unknown).; It only supports basic operations such as indexing and iterations, but also; the buffer protocol for integration with full-fledged functional arrays such; as NumPy`s ``ndarray``. In addition, specifically when dealing with ``void*`` returns, you can use; NumPy's low-level ``frombuffer`` interface to perform the cast.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* create_float_array(int sz) {; ... float* pf = (float*)malloc(sizeof(float)*sz);; ... for (int i = 0; i < sz; ++i) pf[i] = 2*i;; ... return pf;; ... }""""""); ...; >>> import numpy as np; >>> NDATA = 8; >>> arr = cppyy.gbl.create_float_array(NDATA); >>> print(arr); <cppyy.LowLevelView object at 0x109f15230>; >>> arr.reshape((NDATA,)) # adjust the llv's size; >>> v = np.frombuffer(arr, dtype=np.float32, count=NDATA) # cast to float; >>> print(len(v)); 8; >>> print(v); array([ 0., 2., 4., 6., 8., 10., 12., 14.], dtype=float32); >>>. Note that NumPy will internally check the total buffer size, so if the size; you are casting *to* is larger than the size you are casting *from*, then; the number of ele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:4802,protocol,protocol,4802,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,2,"['integrat', 'protocol']","['integration', 'protocol']"
Integrability,"(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typena",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14952,depend,dependent,14952,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"(or; ""test-suite"") and are in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_.; For historical reasons, these tests are also referred to as the ""nightly; tests"" in places, which is less ambiguous than ""test-suite"" and remains; in use although we run them much more often than nightly. Unit tests; ----------. Unit tests are written using `Google Test <https://github.com/google/googletest/blob/master/docs/primer.md>`_; and `Google Mock <https://github.com/google/googletest/blob/master/docs/gmock_for_dummies.md>`_; and are located in the ``llvm/unittests`` directory.; In general unit tests are reserved for targeting the support library and other; generic data structure, we prefer relying on regression tests for testing; transformations and analysis on the IR. Regression tests; ----------------. The regression tests are small pieces of code that test a specific; feature of LLVM or trigger a specific bug in LLVM. The language they are; written in depends on the part of LLVM being tested. These tests are driven by; the :doc:`Lit <CommandGuide/lit>` testing tool (which is part of LLVM), and; are located in the ``llvm/test`` directory. Typically when a bug is found in LLVM, a regression test containing just; enough code to reproduce the problem should be written and placed; somewhere underneath this directory. For example, it can be a small; piece of LLVM IR distilled from an actual application or benchmark. Testing Analysis; ----------------. An analysis is a pass that infer properties on some part of the IR and not; transforming it. They are tested in general using the same infrastructure as the; regression tests, by creating a separate ""Printer"" pass to consume the analysis; result and print it on the standard output in a textual format suitable for; FileCheck.; See `llvm/test/Analysis/BranchProbabilityInfo/loop.ll <https://github.com/llvm/llvm-project/blob/main/llvm/test/Analysis/BranchProbabilityInfo/loop.ll>`_; for an example o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:2093,depend,depends,2093,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['depend'],['depends']
Integrability,"(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47308,depend,dependent,47308,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,") >= SK_Square &&; S->getKind() <= SK_OtherSpecialSquare;; }. As the comment indicates, this code contains a bug. A straightforward and; non-clever way to avoid this is to introduce an explicit ``SK_LastSquare``; entry in the enum when adding the first subclass(es). For example, we could; rewrite the example at the beginning of `Concrete Bases and Deeper; Hierarchies`_ as:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if the dynamic type of the; argument is-a ``C``"". As long as your implementation fulfills this; contract, you can tweak and optimize it as much as you want. For example, LLVM-style RTTI can work fine in the presence of; multiple-inheritance by defining an appropriate ``classof``.; An example of this in practice is; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ vs.; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; inside Clang.; The ``Decl`` hierarchy is done very similarly to the example setup; demonstrated in this tutorial.; The key part is how to then incorporate ``DeclContext``: all that is needed; is in ``bool DeclContext::classof(const Decl *)``, which asks the question; ""Given a ``Decl``, how can I determine if it is-a ``DeclContext``?"".; It answers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:10705,contract,contract,10705,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['contract'],['contract']
Integrability,") for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both records (as well as any other; dependents in the tree). Miscellaneous Options; +++++++++++++++++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand:. bytes; ~~~~~. USAGE: :program:`llvm-pdbutil` bytes [*options*] <input PDB file>. .. program:: llvm-pdbutil bytes. Summary; ^^^^^^^. Like the **dump** subcommand, the **bytes** subcommand displays low level; information about the structure of a PDB file, but it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:9972,depend,dependents,9972,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['depend'],['dependents']
Integrability,") matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86269,depend,dependent,86269,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['depend'],['dependent']
Integrability,"))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47173,depend,dependentSizedExtVectorTypeMatcher,47173,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependentSizedExtVectorTypeMatcher']
Integrability,")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8742,protocol,protocol,8742,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['protocol'],['protocol']
Integrability,"), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by the promise a sub-community will take; care of the code affected, the sub-community will have a time to fix all the; issues (depending on each case, as above), and if those are not fixed in time, a; subsequent request for removal should be made and the community may elect to; eject the component without further attempts to fix. Reinstatement; -------------. If a component is removed from LLVM, it may, at a later da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:9935,depend,depend,9935,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['depend'],['depend']
Integrability,"), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6339,depend,depending,6339,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['depend'],['depending']
Integrability,"). If the loop should; not be executed at all, a **loop guard** must skip the entire loop:. .. image:: ./loop-guard.svg; :width: 500 px. Since the first thing a loop header might do is to check whether there; is another execution and if not, immediately exit without doing any work; (also see :ref:`loop-terminology-loop-rotate`), loop trip count is not; the best measure of a loop's number of iterations. For instance, the; number of header executions of the code below for a non-positive n; (before loop rotation) is 1, even though the loop body is not executed; at all. .. code-block:: C. for (int i = 0; i < n; ++i); body(i);. A better measure is the **backedge-taken count**, which is the number of; times any of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when sc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9298,interface,interface,9298,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['interface'],['interface']
Integrability,"). The first argument is the name of the; pass, which is to be used for the :option:`-help` output of programs, as well; as for debug output generated by the `--debug-pass` option. If you want your pass to be easily dumpable, you should implement the virtual; print method:. The ``print`` method; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual void print(llvm::raw_ostream &O, const Module *M) const;. The ``print`` method must be implemented by ""analyses"" in order to print a; human readable version of the analysis results. This is useful for debugging; an analysis itself, as well as for other people to figure out how an analysis; works. Use the opt ``-analyze`` argument to invoke this method. The ``llvm::raw_ostream`` parameter specifies the stream to write the results; on, and the ``Module`` parameter gives a pointer to the top level module of the; program that has been analyzed. Note however that this pointer may be ``NULL``; in certain circumstances (such as calling the ``Pass::dump()`` from a; debugger), so it should only be used to enhance debug output, it should not be; depended on. .. _writing-an-llvm-pass-interaction:. Specifying interactions between passes; --------------------------------------. One of the main responsibilities of the ``PassManager`` is to make sure that; passes interact with each other correctly. Because ``PassManager`` tries to; :ref:`optimize the execution of passes <writing-an-llvm-pass-passmanager>` it; must know how the passes interact with each other and what dependencies exist; between the various passes. To track this, each pass can declare the set of; passes that are required to be executed before the current pass, and the passes; which are invalidated by the current pass. Typically this functionality is used to require that analysis results are; computed before your pass is run. Running arbitrary transformation passes can; invalidate the computed analysis results, which is what the invalidation set; specifies. If a pass does no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:28364,depend,depended,28364,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['depended']
Integrability,"). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, limits, etc.) is; not possible then. Optionally if the user wants to provide starting values for the; covariance, they have to provide the values in a std::vector$<$double$>$; vector container stored in upper triangular packed storage format (see; [api:covariance]). ### MnUserParameters ###. A more functional interface to the user parameters is provided through M; via the class MnUserParameters. The user can add parameters giving them; a name and starting values. More information can be found in; [api:parameters]. ### MnUserCovariance ###. The user can (optionally) provide a covariance matrix as input using the; class MnUserCovariance. More information can be found in; [api:covariance]. ### MnUserParameterState ###. The MnUserParameterState contains the parameters (MnUserParameters) and; covariance (MnUserCovariance). The MnUserParameterState has to main; purposes:. - It can be used as input to minimization. - The result of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:30968,interface,interface,30968,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"). foreach (lib ${clang_libs}); if(XCODE); # Xcode doesn't support object libraries, so we have to trick it into; # linking the static libraries instead.; list(APPEND _DEPS ""-force_load"" ${lib}); else(); list(APPEND _OBJECTS $<TARGET_OBJECTS:obj.${lib}>); endif(); if (BUILD_SHARED_LIBS); # If we are building static libraries, then we don't need to add the static; # libraries as a dependency, because we are already linking against the; # individual object files.; list(APPEND _DEPS $<TARGET_PROPERTY:${lib},INTERFACE_LINK_LIBRARIES>); endif(). # clang libraries are redundant since we are linking all the individual; # object files into libclang-cpp.so, so filter them out from _DEPS.; # This avoids problems with LLVM global data when building with; # BUILD_SHARED_LIBS=ON; # FIXME: We could use list(FILTER) with cmake >= 3.6; # FIXME: With cmake >= 3.15 we could use the generator expression; # $<FILTER:list,INCLUDE|EXCLUDE,regex>; get_target_property(interface ${lib} LINK_LIBRARIES); if (interface); foreach(lib ${interface}); if (NOT ${lib} MATCHES ""^clang""); list(APPEND _DEPS ${lib}); endif(); endforeach(); endif(); endforeach (). if (CLANG_LINK_CLANG_DYLIB); set(INSTALL_WITH_TOOLCHAIN INSTALL_WITH_TOOLCHAIN); endif(). add_clang_library(clang-cpp; SHARED; ${INSTALL_WITH_TOOLCHAIN}; clang-shlib.cpp; ${_OBJECTS}; LINK_LIBS; ${_DEPS}); # Optimize function calls for default visibility definitions to avoid PLT and; # reduce dynamic relocations.; if (NOT APPLE AND NOT MINGW AND NOT LLVM_LINKER_IS_SOLARISLD_ILLUMOS); target_link_options(clang-cpp PRIVATE LINKER:-Bsymbolic-functions); endif(); if (MINGW OR CYGWIN); # The clang-cpp DLL is supposed to export all symbols (except for ones; # that are explicitly hidden). Normally, this is what happens anyway, but; # if there are symbols that are marked explicitly as dllexport, we'd only; # export them and nothing else. Therefore, add --export-all-symbols to; # make sure we export all symbols despite potential dllexports.; target_link",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt:1118,interface,interface,1118,interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-shlib/CMakeLists.txt,3,['interface'],['interface']
Integrability,"); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47924,message,message,47924,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['message'],['message']
Integrability,"); ROOT_ADD_PYUNITTEST(pyroot_roofit_rooarglist roofit/rooarglist.py). # RooDataHist pythonisations; ROOT_ADD_PYUNITTEST(pyroot_roofit_roodatahist_ploton roofit/roodatahist_ploton.py). # RooDataSet pythonisations; ROOT_ADD_PYUNITTEST(pyroot_roofit_roodataset roofit/roodataset.py). # RooWorkspace pythonizations; ROOT_ADD_PYUNITTEST(pyroot_roofit_rooabspdf_fitto roofit/rooabspdf_fitto.py); ROOT_ADD_PYUNITTEST(pyroot_roofit_rooabsreal_ploton roofit/rooabsreal_ploton.py). ROOT_ADD_PYUNITTEST(pyroot_roofit_roolinkedlist roofit/roolinkedlist.py). if(NOT MSVC OR win_broken_tests); # Test pythonizations for the RooFitHS3 package, which is not built on Windows.; ROOT_ADD_PYUNITTEST(pyroot_roofit_roojsonfactorywstool roofit/roojsonfactorywstool.py). # Other pythonizations that fail on Windows for unknown reasons; ROOT_ADD_PYUNITTEST(pyroot_roofit_rooglobalfunc roofit/rooglobalfunc.py); ROOT_ADD_PYUNITTEST(pyroot_roofit_roosimultaneous roofit/roosimultaneous.py). # RooWorkspace pythonization that fails on Windows; ROOT_ADD_PYUNITTEST(pyroot_roofit_rooworkspace roofit/rooworkspace.py); endif(). # NumPy compatibility; ROOT_ADD_PYUNITTEST(pyroot_roofit_roodataset_numpy roofit/roodataset_numpy.py PYTHON_DEPS numpy); ROOT_ADD_PYUNITTEST(pyroot_roofit_roodatahist_numpy roofit/roodatahist_numpy.py PYTHON_DEPS numpy). endif(). if (dataframe); # std::string_view in CPyCppyy; ROOT_ADD_PYUNITTEST(pyroot_string_view string_view.py); if(NOT MSVC OR win_broken_tests); if(NOT DEFINED ENV{ROOTTEST_IGNORE_NUMBA_PY3}); # Test wrapping Python callables for use in C++ using numba; ROOT_ADD_PYUNITTEST(pyroot_numbadeclare numbadeclare.py PYTHON_DEPS numba); ROOT_ADD_PYUNITTEST(pyroot_rdf_filter_pyz rdf_filter_pyz.py PYTHON_DEPS numba); ROOT_ADD_PYUNITTEST(pyroot_rdf_define_pyz rdf_define_pyz.py PYTHON_DEPS numba); endif(); endif(); endif(). # TComplex pythonizations; ROOT_ADD_PYUNITTEST(pyroot_tcomplex tcomplex_operators.py). # Tests with memory usage; ROOT_ADD_PYUNITTEST(pyroot_memory memory.py); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/CMakeLists.txt:7518,wrap,wrapping,7518,bindings/pyroot/pythonizations/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/CMakeLists.txt,1,['wrap'],['wrapping']
Integrability,"); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and return the resulting ``ErrorList``. Building fallible iterators and iterator ranges; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The archive walking examples above retrieve archive members by index, however; this requires considerable boiler-plate for iteration and error checking. We can; clean this up by using the ""fallible iterator"" pattern, which supports the; following natural iteration idiom for fallible containers like Archive:. .. code-block:: c++. Error Err = Error::success();; for (auto &Child : Ar->children(Err)) {; // Use Child - only enter the loop when it's valid. // Allow early exit from the loop body, since we know that Err is success; // when we're inside the loop.; if (BailOutOn(Child)); return;. ...; }; // Check Err after the loop to ensure it d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:36525,rout,routine,36525,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['rout'],['routine']
Integrability,"); endif(); else(); if ((NOT var MATCHES ""_(DOCS|TESTS|INSTALL)"") AND (NOT var MATCHES ""^_"")); set(ROOT_CONFIGARGS ""${ROOT_CONFIGARGS}${var}=${${var}} ""); endif(); endif(); endif(); endforeach(). #---Move (copy) directories to binary tree------------------------------------------------------; set(stamp_file ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/move_artifacts.stamp); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/LICENSE ${CMAKE_BINARY_DIR}/LICENSE; COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/README ${CMAKE_BINARY_DIR}/README; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; COMMENT ""Copying directories such as etc, icons, fonts, js, ui5, etc. to build area""). if(http); set(jsroot_files js/*); endif(); if(webgui); set(openui5_files ui5/*); endif(). #---Copy files to the build area, with dependency---------------------------------; file(GLOB_RECURSE artifact_files RELATIVE ${CMAKE_SOURCE_DIR} tutorials/* etc/* test/* icons/* fonts/* macros/* ${jsroot_files} ${openui5_files}); set(artifact_files_builddir); foreach(artifact_file ${artifact_files}); # Filter out hsimple.root; someone might have created it in the src dir, and the hsimple.root; # target below will interfere.; if (NOT (artifact_file STREQUAL ""tutorials/hsimple.root"")); add_custom_command(OUTPUT ${CMAKE_BINARY_DIR}/${artifact_file}; COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/${artifact_file} ${CMAKE_BINARY_DIR}/${artifact_file}; COMMENT ""Copying ${CMAKE_SOURCE_DIR}/${artifact_file}""; DEPENDS ${CMAKE_SOURCE_DIR}/${artifact_file}); list(APPEND artifact_files_builddir ${CMAKE_BINARY_DIR}/${artifact_file}); endif(); endforeach(); add_custom_target(move_artifacts DEPENDS ${stamp_file} ${artifact_files_builddir}). add_subdirectory (interpreter). # Update etc/gitinfo.txt for every build.; add_custom_target(gitinfotxt; ALL; COMMAND ${CMAKE_COMMAND} -DSRCDIR=${CMAKE_SOURCE_DIR} -DBINDIR=${CMAKE_BINARY_DIR} -P ${CMAK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:14418,depend,dependency,14418,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer << arr;; }; ```; which would only really stream the array at the first iteration because it will be detected has having the same address and thus assumed to be the same object. We can now do:; ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer.WriteObject(&arr, kFALSE);; }; ```; where the last argument of WriteObject tells the buffer do *not* remember this object's address and to always stream it. This feature is also available via WriteObjectAny. - Added a new mechanism for providing clean forward-compatibility breaks in a ``TTree`` (i.e., a newer version of ROOT writes a ``TTree`` an older version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an unsupported file format feature is encountered, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fIOBits (00000000000000000000000001111110) contains unknown flags (supported flags are 00000000000000000000000000000001), indicating this was written with a newer version of ROOT utilizing critical IO features this version of ROOT does not support. Refusing to deserialize.; ```; - When an older version of ROOT, without this logic, encounters the file, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fNevBufSize is incorrect (-72) ; trying to recover by set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:7661,message,message,7661,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['message'],['message']
Integrability,");; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from now on. ### RooBrowser: a graphical user interface for workspace exploration, visualization, and analysis. This experimental new feature utilises the technology from ROOT's familiar `TBrowser` in order to create an interface for graphically exploring and visualizing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statistics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `His",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:22187,interface,interface,22187,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,");; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; ```. Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore. ## Language Bindings. ### Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel.; We made it easier to use ROOT notebooks locally, by providing a 'root --notebook' command option to start a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:22724,integrat,integration,22724,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['integrat'],['integration']
Integrability,")` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8416,interface,interfaces,8416,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability,")`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing files; at that path. To get the same behavior without truncating existing files,; pass a filename pattern string to ``void __llvm_profile_set_filename(char; *)``. These calls can be placed anywhere so long as they precede all calls; to ``__llvm_profile_write_file``. * Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write; out a profile. This function returns 0 when it succeeds, and a non-zero value; otherwise. Calling this function multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports freestanding environments that lack a; filesystem. The runtime ships as a static archive that's structured to make; dependencies on a hosted environment optional, depending on what features; the client application uses. The first step is to export ``__llvm_profile_runtime``, as above, to disable; the default static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:16902,depend,dependencies,16902,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,2,['depend'],"['dependencies', 'depending']"
Integrability,"* ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53822,contract,contract,53822,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"* x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42475,wrap,wrapper,42475,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapper']
Integrability,"*************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst:1131,message,message,1131,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,1,['message'],['message']
Integrability,"*************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst:1131,message,message,1131,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,1,['message'],['message']
Integrability,"*************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst:1131,message,message,1131,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst,1,['message'],['message']
Integrability,"************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst:1132,message,message,1132,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst,1,['message'],['message']
Integrability,"***********************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst:1133,message,message,1133,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,1,['message'],['message']
Integrability,"***********************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx940_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst:1133,message,message,1133,interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst,1,['message'],['message']
Integrability,"**********************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:1134,message,message,1134,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,1,['message'],['message']
Integrability,"***************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_msg_e37f7b:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Must be 0. 0; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:1141,message,message,1141,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,1,['message'],['message']
Integrability,"*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different catego",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:173515,interface,interface,173515,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47434,depend,dependentSizedExtVectorType,47434,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependentSizedExtVectorType']
Integrability,"+--------+---------------------------+; | Line | u32 |; +--------+---------------------------+; | Column | u32 |; +--------+---------------------------+. ``RECORD_REMARK_ARG_WITHOUT_DEBUGLOC``. A remark argument with an associated debug location. +--------+---------------------------+; | Key | VBR7 (string table index) |; +--------+---------------------------+; | Value | VBR7 (string table index) |; +--------+---------------------------+. The remark container; --------------------. Bitstream remarks are designed to be used in two different modes:. ``The separate mode``. The separate mode is the mode that is typically used during compilation. It; provides a way to serialize the remark entries to a stream while some; metadata is kept in memory to be emitted in the product of the compilation; (typically, an object file). ``The standalone mode``. The standalone mode is typically stored and used after the distribution of; a program. It contains all the information that allows the parsing of all; the remarks without having any external dependencies. In order to support multiple modes, the format introduces the concept of a; bitstream remark container type. .. _bitstreamremarksseparateremarksmeta:. ``SeparateRemarksMeta: the metadata emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_STRTAB <bitstreamremarksrecordmetastrtab>`; * :ref:`RECORD_META_EXTERNAL_FILE <bitstreamremarksrecordmetaexternalfile>`. Typically, this is emitted in a section in the object files, allowing; clients to retrieve remarks and their associated metadata directly from; intermediate products. ``SeparateRemarksFile: the remark entries emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:10826,depend,dependencies,10826,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['depend'],['dependencies']
Integrability,", ""i386"", {3}, object; 5: bind-arch, ""x86_64"", {3}, object; 6: lipo, {4, 5}, object; 7: input, ""t1.c"", c; 8: preprocessor, {7}, cpp-output; 9: compiler, {8}, assembler; 10: assembler, {9}, object; 11: bind-arch, ""i386"", {10}, object; 12: bind-arch, ""x86_64"", {10}, object; 13: lipo, {11, 12}, object. After this stage is complete the compilation process is divided into; a simple set of actions which need to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:8937,integrat,integrated,8937,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['integrat'],['integrated']
Integrability,", 5.18, 5.20 and version 5.22 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version521.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Kevin Belasco, N/A, Princeton University for MCMC, ; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Or Cohen, CERN & Weizmann, TMVA; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/Atlas, RooStats; Dominik Dannheim, MPI-Munich/Atlas, TMVA ; Valeri Fine, BNL/STAR,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Mihaela Gheata, CERN/Alice,; David Gonzalez Maline, CERN/SFT, ; Roberto Gracia Del Ba�o, Universidad de Valencia, recorder, ; Andreas Hoecker, CERN/Atlas, TMVA ; Jan Iwaszkiewicz, CERN, ; Lukasz Janyst, CERN/IT, ; Anna Kreshu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v524/index.html:1114,protocol,protocols,1114,doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v524/index.html,3,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,", Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175753,contract,contract,175753,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contract']
Integrability,", but that is target specific. .. _dso_local_equivalent:. DSO Local Equivalent; --------------------. ``dso_local_equivalent @func``. A '``dso_local_equivalent``' constant represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function.; - ``dso_local_equivalent`` can be implemented with a stub that tail-calls the; function. Many targets support relocations that resolve at link time to either; a function or a stub for it, depending on if the function is defined within the; linkage unit; LLVM will use this when available. (This is commonly called a; ""PLT stub"".) On other targets, the stub may need to be emitted explicitly. This can be used wherever a ``dso_local`` instance of a function is needed without; needing to explicitly make the original function ``dso_local``. An instance where; this can be used is for static offset calculations between a function and some other; ``dso_local`` symbol. This is especially useful for the Relative VTables C++ ABI,; where dynamic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This is currently only supported for ELF binary formats. .. _no_cfi:. No CFI; ------. ``no_cfi @func``. With `Control-Flow Integrity (CFI); <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_, a '``no_cfi``'; constant represents a function reference that does not get ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:201912,depend,depending,201912,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,", debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; is performed properly. For example, the following code snippet depends on the values of XMM1 (which; will be set by the tool) and the memory buffer passed in RDI (live in). .. code-block:: none. # LLVM-EXEGESIS-LIVEIN RDI; # LLVM-EXEGESIS-DEFREG XMM1 42; vmulps	(%rdi), %xmm1, %xmm2; vhaddps	%xmm2, %xmm2, %xmm3; addq $0x10, %rdi. Example 3: benchmarking with memory annotations; -----------------------------------------------. Some snippets require memory setup in specific places to execute without; crashing. Setting up memory can be accomplished with the `LLVM-EXEGESIS-MEM-DEF`; and `LLVM-EXEGESIS-MEM-MAP` annotations. To execute the following snippet:. .. code-block:: none. movq $8192, %rax; movq (%rax), %rdi. We need to have at least eight bytes of memory allocated starting `0x2000`.; We can create the necessary execution environment with the following; annotations added to the snippet:. .. code-block:: none. # LLVM-EXEGESIS-MEM-DEF test1 4096 7fffffff; # LLVM-EXEGESIS-MEM-MAP test1 8192. movq $8192, %rax; movq (%rax), %rdi. EXAMPLE 4: analysis; -------------------. Assuming you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:6499,depend,depends,6499,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['depend'],['depends']
Integrability,", etc, which directly correspond to assembly; level directives. If you are interested in implementing a code generator for a target, there are; three important things that you have to implement for your target:. #. First, you need a subclass of AsmPrinter for your target. This class; implements the general lowering process converting MachineFunction's into MC; label constructs. The AsmPrinter base class provides a number of useful; methods and routines, and also allows you to override the lowering process in; some important ways. You should get much of the lowering for free if you are; implementing an ELF, COFF, or MachO target, because the; TargetLoweringObjectFile class implements much of the common logic. #. Second, you need to implement an instruction printer for your target. The; instruction printer takes an `MCInst`_ and renders it to a raw_ostream as; text. Most of this is automatically generated from the .td file (when you; specify something like ""``add $dst, $src1, $src2``"" in the instructions), but; you need to implement routines to print operands. #. Third, you need to implement code that lowers a `MachineInstr`_ to an MCInst,; usually implemented in ""<target>MCInstLower.cpp"". This lowering process is; often target specific, and is responsible for turning jump table entries,; constant pool indices, global variable addresses, etc into MCLabels as; appropriate. This translation layer is also responsible for expanding pseudo; ops used by the code generator into the actual machine instructions they; correspond to. The MCInsts that are generated by this are fed into the; instruction printer or the encoder. Finally, at your choosing, you can also implement a subclass of MCCodeEmitter; which lowers MCInst's into machine code bytes and relocations. This is; important if you want to support direct .o file emission, or would like to; implement an assembler for your target. Emitting function stack size information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A section ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:76892,rout,routines,76892,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['rout'],['routines']
Integrability,", hence through a return instruction. This produces undefined; behavior at runtime if the function ever does dynamically return. Annotated; functions may still raise an exception, i.a., ``nounwind`` is not implied.; ``norecurse``; This function attribute indicates that the function does not call itself; either directly or indirectly down any possible call path. This produces; undefined behavior at runtime if the function ever does recurse. .. _langref_willreturn:. ``willreturn``; This function attribute indicates that a call of this function will; either exhibit undefined behavior or comes back and continues execution; at a point in the existing call stack that includes the current invocation.; Annotated functions may still raise an exception, i.a., ``nounwind`` is not implied.; If an invocation of an annotated function does not return control back; to a point in the call stack, the behavior is undefined.; ``nosync``; This function attribute indicates that the function does not communicate; (synchronize) with another thread through memory or other well-defined means.; Synchronization is considered possible in the presence of `atomic` accesses; that enforce an order, thus not ""unordered"" and ""monotonic"", `volatile` accesses,; as well as `convergent` function calls. Note that `convergent` operations can involve communication that is; considered to be not through memory and does not necessarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:93550,synchroniz,synchronize,93550,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronize']
Integrability,", length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super deallo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14973,interface,interface,14973,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,", much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1273,interface,interface,1273,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['interface'],['interface']
Integrability,", see ``-compile-command`` in :doc:`CommandGuide/bugpoint`. * In the code generator and miscompilation debuggers, debugging will go faster; if you manually modify the program or its inputs to reduce the runtime, but; still exhibit the problem. * ``bugpoint`` is extremely useful when working on a new optimization: it helps; track down regressions quickly. To avoid having to relink ``bugpoint`` every; time you change your optimization however, have ``bugpoint`` dynamically load; your optimization with the ``-load`` option. * ``bugpoint`` can generate a lot of output and run for a long period of time.; It is often useful to capture the output of the program to file. For example,; in the C shell, you can run:. .. code-block:: console. $ bugpoint ... |& tee bugpoint.log. to get a copy of ``bugpoint``'s output in the file ``bugpoint.log``, as well; as on your terminal. * ``bugpoint`` cannot debug problems with the LLVM linker. If ``bugpoint``; crashes before you see its ""All input ok"" message, you might try ``llvm-link; -v`` on the same set of input files. If that also crashes, you may be; experiencing a linker bug. * ``bugpoint`` is useful for proactively finding bugs in LLVM. Invoking; ``bugpoint`` with the ``-find-bugs`` option will cause the list of specified; optimizations to be randomized and applied to the program. This process will; repeat until a bug is found or the user kills ``bugpoint``. * ``bugpoint`` can produce IR which contains long names. Run ``opt; -passes=metarenamer`` over the IR to rename everything using easy-to-read,; metasyntactic names. Alternatively, run ``opt -passes=strip,instnamer`` to; rename everything with very short (often purely numeric) names. What to do when bugpoint isn't enough; =====================================; 	; Sometimes, ``bugpoint`` is not enough. In particular, InstCombine and; TargetLowering both have visitor structured code with lots of potential; transformations. If the process of using bugpoint has left you with still ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:7471,message,message,7471,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['message'],['message']
Integrability,",10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50314,rout,routines,50314,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['rout'],['routines']
Integrability,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23307,interface,interface,23307,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,"['interface', 'message']","['interface', 'message-send']"
Integrability,",; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2817,interface,interface,2817,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['interface'],['interface']
Integrability,",Double_t nzlow, Double_t nxhi,; Double_t nyhi,Double_t nzhi);; ```. ![TGeoCtub Class](pictures/060001BF.png). A cut tube is a tube segment cut with two planes. The centers of the 2; sections are positioned at `dZ`. Each cut plane is therefore defined by; a point `(0,0,dZ)` and its normal unit vector pointing outside the; shape:. `Nlow=(Nx,Ny,Nz<0)`, `Nhigh=(Nx',Ny',Nz'>0)`. #### Elliptical Tubes - TGeoEltu Class. An elliptical tube is defined by the two semi-axes A and B. It ranges; from `-dZ` to `+dZ` as all other tubes:. ``` {.cpp}; TGeoEltu(Double_t a,Double_t b,Double_t dz);; ```. ![TGeoEltu Class](pictures/060001C0.png). #### Hyperboloids - TGeoHype Class. A hyperboloid is represented as a solid limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:33999,rout,rout,33999,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['rout'],['rout']
Integrability,",x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more graph examples see the scripts: `$ROOTSYS/tutorials` directory; `graph.C`, `gerrors.C`, `zdemo.C`, and `gerrors2.C`. ![A graph with axis titles](pictures/0300005D.png). ## Zooming a Graph. To zoom a graph you can create a histogram with the desired axis range; first. Draw the empty histogram and then draw the graph using the; existing axis from the histogram. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; ```. The next example is the same graph as above with a zoom in the x and y; directions. ![A zoomed graph](pictures/0300005E.png). ## The User Interface for Graphs. The class **`TGraphEditor`** provides the user interface for setting; the following graph attributes interactively:. - Title text entry field ... sets the title of the graph. - Shape radio button group - sets the graph shapes:. - *No Line*: draw unconnected points;; - *Smooth Line*: a smooth curve;; - *Simple Line*: a simple poly-line;; - *Bart Chart*: a bar chart at each point.; - *Fill Area*: a fill area is drawn. - Show Marker - sets markers as visible or invisible. - Exclusion Zone - specifies the exclusion zone parameters :. - *'+-‘ check button*: sets on which side of the line the; exclusion zone will be drawn;; - *Width combo box*: defines the width of the zone. ![](pictures/0300005F.png). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:22689,interface,interface,22689,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['interface'],['interface']
Integrability,"- Basic support library, reused from LLVM. libsystem - System abstraction library, reused from LLVM.; ; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-level declaration; at a time, allowing clients to use decl-at-a-time processing,; build up entire translation units, or even build 'whole; program' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntactic text of source code, allowing a client; to insert and delete text in very large source files using; the same source location information embedded in ASTs. This; is intended to be a low-level API that is useful for; higher-level clients and libraries such as code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such as computing live variables. It also includes a; path-sensitive ""graph-reachability"" engine for writing; analyses that reason about different possible paths of; execution through source code. This is currently being; employed to write a set of checks for finding bugs in software. libcodegen - Lower the AST to LLVM IR for optimization & codegen. Depends; on libast.; ; clang - An example driver, client",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:2152,depend,depending,2152,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depending']
Integrability,"- e.g. command line options. The old way of handling attributes; consisted of representing them as a bit mask of values. This bit mask was; stored in a ""list"" structure that was reference counted. The advantage of this; was that attributes could be manipulated with 'or's and 'and's. The; disadvantage of this was that there was limited room for expansion, and; virtually no support for attribute-value pairs other than alignment. In the new scheme, an ``Attribute`` object represents a single attribute that's; uniqued. You use the ``Attribute::get`` methods to create a new ``Attribute``; object. An attribute can be a single ""enum"" value (the enum being the; ``Attribute::AttrKind`` enum), a string representing a target-dependent; attribute, or an attribute-value pair. Some examples:. * Target-independent: ``noinline``, ``zext``; * Target-dependent: ``""no-sse""``, ``""thumb2""``; * Attribute-value pair: ``""cpu"" = ""cortex-a8""``, ``align = 4``. Note: for an attribute value pair, we expect a target-dependent attribute to; have a string for the value. ``Attribute``; =============; An ``Attribute`` object is designed to be passed around by value. Because attributes are no longer represented as a bit mask, you will need to; convert any code which does treat them as a bit mask to use the new query; methods on the Attribute class. ``AttributeList``; =================. The ``AttributeList`` stores a collection of Attribute objects for each kind of; object that may have an attribute associated with it: the function as a whole,; the return type, or the function's parameters. A function's attributes are at; index ``AttributeList::FunctionIndex``; the return type's attributes are at; index ``AttributeList::ReturnIndex``; and the function's parameters' attributes; are at indices 1, ..., n (where 'n' is the number of parameters). Most methods; on the ``AttributeList`` class take an index parameter. An ``AttributeList`` is also a uniqued and immutable object. You create an; ``AttributeList``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst:1296,depend,dependent,1296,interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,1,['depend'],['dependent']
Integrability,"-+-+-+-+-+-+-+-+-+-+; | |; + Max Key Size +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+. ```. When serialized to disk, a 64 bit checksum is appended to the anchor, calculated as the XXH3 hash of; all the (serialized) fields of the anchor object. Note that, since the anchor is serialized as a ""classic"" TFile key, all integers in the anchor, as well; as the checksum, are encoded in **big-endian**, unlike the RNTuple payload which is encoded in little-endian. The anchor may evolve in future versions only by appending new fields to the existing schema, but; fields will not be removed, renamed or reordered. `Max Key Size` represents the maximum size of an RBlob (associated to one TFile key). Payloads bigger than; that size will be written as multiple RBlobs/TKeys, and the offsets of all but the first RBlob will be; written at the end of the first one. This allows bypassing the inherent TKey size limit of 1 GiB. ## Compression Block. RNTuple envelopes and pages are wrapped in compression blocks.; In order to deserialize a page or an envelope, its compressed and uncompressed size needs to be known. If the compressed size == uncompressed size, the data is stored unmodified in uncompressed form.; Otherwise, data is represented as a series of compressed chunks.; Each chunk is prepended with the following 9 bytes header. ```; Byte; 0 1 2 3 4 5 6 7 8 9; +------+------+------+------+------+------+------+------+------+...; | Algorithm | Compressed size | Uncompressed size | <COMPRESSED DATA>; +------+------+------+------+------+------+------+------+------+...; ```. _Algorithm_: Identifies the compression algorithm used to compress the data. This can take one of the following values. | Algorithm | Meaning |; |--------------------------|----------------------------------------------|; | 'Z' 'L' '\x08' | zlib |; | 'C' 'S' '\x08' | Old Jean-loup Gailly's deflation algorithm |; | 'X' 'Z' '\x00' | LZMA |; | 'L' '4' <VERSION_MAJOR> | LZ4; third byte encodes ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:4975,wrap,wrapped,4975,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['wrap'],['wrapped']
Integrability,"-+---------+------------+; | 13 | times-medium-r-normal | ""Times New Roman"" | No | 4 |; +-----------+--------------------------+-----------------------+---------+------------+; | 14 | | ""Wingdings"" | No | 4 |; +-----------+--------------------------+-----------------------+---------+------------+. This script makes the image of the different fonts:. ``` {.cpp}; {; textc = new TCanvas(""textc"",""Example of text"",1);; for (int i=1;i<15;i++) {; cid = new char[8];; sprintf(cid,""ID %d :"",i);; cid[7] = 0;; lid = new TLatex(0.1,1-(double)i/15,cid);; lid->SetTextFont(62);; lid->Draw();; l = new TLatex(.2,1-(double)i/15,; ""The quick brown fox is not here anymore""); l->SetTextFont(i*10+2);; l->Draw();; }; }; ```. #### How to use True Type Fonts. You can activate the True Type Fonts by adding the following line in; your `.rootrc` file. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; ```. You can check that you indeed use the `TTF` in your Root session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:74808,message,message,74808,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['message'],['message']
Integrability,"---+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | alignment for allocate directive and clause | :good:`done` | D115683 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | new memory management routines | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:28177,rout,routines,28177,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routines']
Integrability,"---+; | 5 | Negative zero |; +-------+----------------------+; | 6 | Positive zero |; +-------+----------------------+; | 7 | Positive subnormal |; +-------+----------------------+; | 8 | Positive normal |; +-------+----------------------+; | 9 | Positive infinity |; +-------+----------------------+. Semantics:; """""""""""""""""""". The function checks if ``op`` belongs to any of the floating-point classes; specified by ``test``. If ``op`` is a vector, then the check is made element by; element. Each check yields an :ref:`i1 <t_integer>` result, which is ``true``,; if the element value satisfies the specified test. The argument ``test`` is a; bit mask where each bit specifies floating-point class to test. For example, the; value 0x108 makes test for normal value, - bits 3 and 8 in it are set, which; means that the function returns ``true`` if ``op`` is a positive or negative; normal value. The function never raises floating-point exceptions. The; function does not canonicalize its input value and does not depend; on the floating-point environment. If the floating-point environment; has a zeroing treatment of subnormal input values (such as indicated; by the ``""denormal-fp-math""`` attribute), a subnormal value will be; observed (will not be implicitly treated as zero). General Intrinsics; ------------------. This class of intrinsics is designed to be generic and has no specific; purpose. '``llvm.var.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.var.annotation(ptr <val>, ptr <str>, ptr <str>, i32 <int>). Overview:; """""""""""""""""". The '``llvm.var.annotation``' intrinsic. Arguments:; """""""""""""""""""". The first argument is a pointer to a value, the second is a pointer to a; global string, the third is a pointer to a global string which is the; source file name, and the last argument is the line number. Semantics:; """""""""""""""""""". This intrinsic allows annotation of local variables with arbitrary; strings. This can be useful for special ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:923713,depend,depend,923713,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"-----+; | qnan | Quiet NaN | 2 |; +-------+----------------------+---------------+; | ninf | Negative infinity | 4 |; +-------+----------------------+---------------+; | nnorm | Negative normal | 8 |; +-------+----------------------+---------------+; | nsub | Negative subnormal | 16 |; +-------+----------------------+---------------+; | nzero | Negative zero | 32 |; +-------+----------------------+---------------+; | pzero | Positive zero | 64 |; +-------+----------------------+---------------+; | psub | Positive subnormal | 128 |; +-------+----------------------+---------------+; | pnorm | Positive normal | 256 |; +-------+----------------------+---------------+; | pinf | Positive infinity | 512 |; +-------+----------------------+---------------+. ``alignstack(<n>)``; This indicates the alignment that should be considered by the backend when; assigning this parameter to a stack slot during calling convention; lowering. The enforcement of the specified alignment is target-dependent,; as target-specific calling convention rules may override this value. This; attribute serves the purpose of carrying language specific alignment; information that is not mapped to base types in the backend (for example,; over-alignment specification through language attributes). ``allocalign``; The function parameter marked with this attribute is the alignment in bytes of the; newly allocated block returned by this function. The returned value must either have; the specified alignment or be the null pointer. The return value MAY be more aligned; than the requested alignment, but not less aligned. Invalid (e.g. non-power-of-2); alignments are permitted for the allocalign parameter, so long as the returned pointer; is null. This attribute may only be applied to integer parameters. ``allocptr``; The function parameter marked with this attribute is the pointer; that will be manipulated by the allocator. For a realloc-like; function the pointer will be invalidated upon success (but the; same ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:67926,depend,dependent,67926,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"---------+---------------------------------------------------------------------------------------------+; |GENERATE_OPTIONS optio| Options which are to be passed into the rootcling |; | | command. For example, bindings which depend on Qt |; | | may need ""-D__PIC__;-Wno-macro-redefined"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LINKDEFS def | Files or lines which contain extra #pragma content |; | | for the linkdef.h file used by rootcling. See |; | | https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file. |; | | |; | | In lines, literal semi-colons must be escaped: ""\;"". |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_CODES code | Files which contain extra code needed by the bindings. |; | | Customization is by routines named ""c13n_<something>""; |; | | each such routine is passed the module for <pkg>: |; | | |; | | :: code-block python |; | | |; | | def c13n_doit(pkg_module): |; | | print(pkg_module.__dict__) |; | | |; | | The files and individual routines within files are |; | | processed in alphabetical order. |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_HEADERS hdr | Files which contain extra headers needed by the bindings. |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_PYTHONS py | Files which contain extra Python code needed by the bindings. |; +----------------------+---------------------------------------------------------------------------------------------+; |COMPILE_OPTIONS option| Options which are to be passed into the compile/link |; | | command. |; +----------------------+---------------------------------------------------------------------------------------------+; |INCLUDE_DIRS dir | Include ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:8157,rout,routines,8157,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,2,['rout'],"['routine', 'routines']"
Integrability,"----------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.llvm.org/D99914 (Supports only HOST(CPU) and Linux |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | OMPT interfaces (callback support) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | thread affinity | thread affinity | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | taskloop reduction | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | task affinity | :part:`not upstream` | https://github.com/jklinkenberg/openmp/tree/task-affinity |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | clause: depend on the taskwait construct | :good:`done` | D113540 (regular codegen only) |; +------------------------------+--------------------------------------------------------------+--------------------------+---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6632,interface,interfaces,6632,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['interface'],['interfaces']
Integrability,"-------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13914,depend,depend,13914,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depend']
Integrability,"----------------+------------------+------------------+----------+----+------+------+------+-------------+----+-----+. The file may end after any block, including immediately after a FPM1. .. note::; LLVM only supports 4096 byte blocks (sometimes referred to as the ""BigMsf""; variant), so the rest of this document will assume a block size of 4096. .. _msf_superblock:. The Superblock; ==============; At file offset 0 in an MSF file is the MSF *SuperBlock*, which is laid out as; follows:. .. code-block:: c++. struct SuperBlock {; char FileMagic[sizeof(Magic)];; ulittle32_t BlockSize;; ulittle32_t FreeBlockMapBlock;; ulittle32_t NumBlocks;; ulittle32_t NumDirectoryBytes;; ulittle32_t Unknown;; ulittle32_t BlockMapAddr;; };. - **FileMagic** - Must be equal to ``""Microsoft C / C++ MSF 7.00\\r\\n""``; followed by the bytes ``1A 44 53 00 00 00``.; - **BlockSize** - The block size of the internal file system. Valid values are; 512, 1024, 2048, and 4096 bytes. Certain aspects of the MSF file layout vary; depending on the block sizes. For the purposes of LLVM, we handle only block; sizes of 4KiB, and all further discussion assumes a block size of 4KiB.; - **FreeBlockMapBlock** - The index of a block within the file, at which begins; a bitfield representing the set of all blocks within the file which are ""free""; (i.e. the data within that block is not used). See :ref:`msf_freeblockmap`; for more information.; **Important**: ``FreeBlockMapBlock`` can only be ``1`` or ``2``!; - **NumBlocks** - The total number of blocks in the file. ``NumBlocks *; BlockSize`` should equal the size of the file on disk.; - **NumDirectoryBytes** - The size of the stream directory, in bytes. The; stream directory contains information about each stream's size and the set of; blocks that it occupies. It will be described in more detail later.; - **BlockMapAddr** - The index of a block within the MSF file. At this block is; an array of ``ulittle32_t``'s listing the blocks that the stream directory; reside",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:2523,depend,depending,2523,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['depend'],['depending']
Integrability,"----------------+-----------------------------------------------------------------------+; | loop | collapse imperfectly nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | collapse non-rectangular nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | C++ range-base for loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | clause: if for SIMD directives | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | inclusive scan (matching C++17 PSTL) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | memory allocators | :good:`done` | r341687,r357929 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6324,interface,interfaces,6324,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['interface'],['interfaces']
Integrability,"-----------------+-----------------------------------------------------------------------+; | OMPT | new barrier types added to ompt_sync_region_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:34233,interface,interfaces,34233,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['interface'],['interfaces']
Integrability,"--------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:34484,interface,interface,34484,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['interface'],['interface']
Integrability,"--------------------+--------------------------+-----------------------------------------------------------------------+; | device | indirect clause on declare target directive | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | allow virtual functions calls for mapped object on device | :part:`partial` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | interop construct | :part:`partial` | parsing/sema done: D98558, D98834, D98815 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | assorted routines for querying interoperable properties | :part:`partial` | D106674 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop tiling transformation | :good:`done` | D76342 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:26753,rout,routines,26753,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routines']
Integrability,"----------------------+-----------------------------------------------------------------------+; | device | indirect clause on declare target directive | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | allow virtual functions calls for mapped object on device | :part:`partial` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | interop construct | :part:`partial` | parsing/sema done: D98558, D98834, D98815 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | assorted routines for querying interoperable properties | :part:`partial` | D106674 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop tiling transformation | :good:`done` | D76342 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:26775,interoperab,interoperable,26775,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['interoperab'],['interoperable']
Integrability,"-------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | new memory management routines | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | error directive | :good:`done` | D139166 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+---------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:29003,depend,depend,29003,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['depend'],['depend']
Integrability,"-------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | error directive | :good:`done` | D139166 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:29763,rout,routines,29763,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routines']
Integrability,"-------------------------+; | allocation_ring_buffer_size | 32768 | If stack trace collection is requested, how |; | | | many previous allocations to keep in the |; | | | allocation ring buffer. |; | | | |; | | | This buffer is used to provide allocation and |; | | | deallocation stack traces for MTE fault |; | | | reports. The larger the buffer, the more |; | | | unrelated allocations can happen between |; | | | (de)allocation and the fault. |; | | | If your sync-mode MTE faults do not have |; | | | (de)allocation stack traces, try increasing the |; | | | buffer size. |; | | | |; | | | Stack trace collection can be requested using |; | | | the scudo_malloc_set_track_allocation_stacks |; | | | function. |; +---------------------------------+----------------+-------------------------------------------------+. Additional flags can be specified, for example if Scudo if compiled with; `GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support. The following ""mallopt"" options are available (options are defined in; ``include/scudo/interface.h``):. +---------------------------+-------------------------------------------------------+; | Option | Description |; +---------------------------+-------------------------------------------------------+; | M_DECAY_TIME | Sets the release interval option to the specified |; | | value (Android only allows 0 or 1 to respectively set |; | | the interval to the minimum and maximum value as |; | | specified at compile time). |; +---------------------------+-------------------------------------------------------+; | M_PURGE | Forces immediate memory reclaiming but does not |; | | reclaim everything. For smaller size classes, there |; | | is still some memory that is not reclaimed due to the |; | | extra time it takes and the small amount of memory |; | | that can be reclaimed. |; | | The value is ignored. |; +---------------------------+-------------------------------------------------------+; | M_PURGE_ALL | Same as M_PURGE but will force r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:12185,interface,interface,12185,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['interface'],['interface']
Integrability,--------------------------+--------------------------+-----------------------------------------------------------------------+; | base language | lambda support | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | array shaping | :good:`done` | D74144 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | library shutdown (omp_pause_resource[_all]) | :good:`done` | D55078 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | metadirectives | :part:`mostly done` | D91944 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | conditional modifier for lastprivate clause | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | iterator and multidependences | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | depobj directive and depobj dependency kind | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | user-defined function variants | :good:`done`.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:19801,depend,dependency,19801,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['depend'],['dependency']
Integrability,"----------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15086,message,messages,15086,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['message'],['messages']
Integrability,"----------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13590,interface,interface,13590,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"------------------------------------+; | 33 `->` 33 | `fUnits` | Number of bytes for file pointers |; | [41-\>41] | | |; +-------------------+------------------+---------------------------------------+; | 34 `->` 37 | `fCompress` | Zip compression level |; | [42-\>45] | | |; +-------------------+------------------+---------------------------------------+; | 38 `->` 41 | `fSeekInfo` | Pointer to **`TStreamerInfo`** record |; | [46-\>53] | | |; +-------------------+------------------+---------------------------------------+; | 42 `->` 45 | `fNBytesInfo` | Number of bytes in |; | [54-\>57] | | **`TStreamerInfo`** record |; +-------------------+------------------+---------------------------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:6402,depend,dependent,6402,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['depend'],['dependent']
Integrability,"-----------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' in defaultmap clause | :good:`done` | D92427 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24249,rout,routine,24249,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routine']
Integrability,"-----------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | has_device_addr clause on target construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24508,rout,routine,24508,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routine']
Integrability,-----------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | OMP_NUM_TEAMS and OMP_TEAMS_THREAD_LIMIT env vars | :good:`done` | D138769 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'target_device' selector in context specifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------------------------,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:30347,rout,routine,30347,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routine']
Integrability,"---------------------------------------------------+; | M_THREAD_DISABLE_MEM_INIT | Tunes the per-thread memory initialization, 0 being |; | | the normal behavior, 1 disabling the automatic heap |; | | initialization. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_COUNT_MAX | Set the maximum number of entries than can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14586,message,message,14586,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['message'],['message']
Integrability,"------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, default is ""LGPL 2.0"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LANGUAGE_STANDARD std | The version of C++ in use, ""14"" by default. |; +----------------------+---------------------------------------------------------------------------------------------+; |IMPORTS pcm | Files which contain previously-generated bindings |; | | which pkg depends on. |; +----------------------+---------------------------------------------------------------------------------------------+; |GENERATE_OPTIONS optio| Options which are to be passed into the rootcling |; | | command. For example, bindings which depend on Qt |; | | may need ""-D__PIC__;-Wno-macro-redefined"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LINKDEFS def | Files or lines which contain extra #pragma content |; | | for the linkdef.h file used by rootcling. See |; | | https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file. |; | | |; | | In lines, literal semi-colons must be escaped: ""\;"". |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_CODES code | Files which contain extra code needed by the bindings. |; | | Customization is by routines named ""c13n_<something>""; |; | | each such routine is passed the module for <pkg>: |; | | |; | | :: code-block python |; | | |; | | def c13n_doit(pkg_module): |; | | print(pkg_module.__dict__) |; | | |; | | The files and individual routines within files are |; | | processed in alphabetical order. |; +-------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:7464,depend,depend,7464,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['depend'],['depend']
Integrability,"---------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | has_device_addr clause on target construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | iterators in map clause or motion clauses | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+-------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24780,rout,routines,24780,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['rout'],['routines']
Integrability,"-------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:35007,depend,depend,35007,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['depend'],['depend']
Integrability,"---------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device image and its associated offloading entries. The offloading; entries are stored using the ``__start_omp_offloading_entries``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14202,wrap,wrapper,14202,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapper']
Integrability,"-----------------------------------------------------------------------------+; |author | The name of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |author_email | The email address of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, default is ""LGPL 2.0"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LANGUAGE_STANDARD std | The version of C++ in use, ""14"" by default. |; +----------------------+---------------------------------------------------------------------------------------------+; |IMPORTS pcm | Files which contain previously-generated bindings |; | | which pkg depends on. |; +----------------------+---------------------------------------------------------------------------------------------+; |GENERATE_OPTIONS optio| Options which are to be passed into the rootcling |; | | command. For example, bindings which depend on Qt |; | | may need ""-D__PIC__;-Wno-macro-redefined"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LINKDEFS def | Files or lines which contain extra #pragma content |; | | for the linkdef.h file used by rootcling. See |; | | https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file. |; | | |; | | In lines, literal semi-colons must be escaped: ""\;"". |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_CODES code | Files which contain extra code needed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:7210,depend,depends,7210,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['depend'],['depends']
Integrability,"-------------------------------------------------------------===//. These two functions produce different code. They shouldn't:. #include <stdint.h>; ; uint8_t p1(uint8_t b, uint8_t a) {; b = (b & ~0xc0) | (a & 0xc0);; return (b);; }; ; uint8_t p2(uint8_t b, uint8_t a) {; b = (b & ~0x40) | (a & 0x40);; b = (b & ~0x80) | (a & 0x80);; return (b);; }. define zeroext i8 @p1(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %1 = and i8 %a, -64 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; ret i8 %2; }. define zeroext i8 @p2(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %.masked = and i8 %a, 64 ; <i8> [#uses=1]; %1 = and i8 %a, -128 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; %3 = or i8 %2, %.masked ; <i8> [#uses=1]; ret i8 %3; }. //===---------------------------------------------------------------------===//. IPSCCP does not currently propagate argument dependent constants through; functions where it does not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:45627,depend,dependent,45627,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['depend'],['dependent']
Integrability,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:277,interface,interface,277,documentation/primer/abstract.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md,1,['interface'],['interface']
Integrability,"----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11341,interoperab,interoperability,11341,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['interoperab'],['interoperability']
Integrability,"----------------------------; if(ccache); find_program(CCACHE_COMMAND NAMES ccache ccache-swig); mark_as_advanced(CCACHE_COMMAND ${CCACHE_COMMAND}). if(EXISTS ${CCACHE_COMMAND}); message(STATUS ""Found ccache: ${CCACHE_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_COMMAND}); execute_process(COMMAND ${CCACHE_COMMAND} ""-V"" OUTPUT_VARIABLE CCACHE_VERSION); string(REGEX REPLACE ""ccache version ([0-9\\.]+).*"" ""\\1"" CCACHE_VERSION ${CCACHE_VERSION}); else(); message(STATUS ""Could NOT find ccache""); set(ccache OFF CACHE BOOL ""Use ccache (disabled since ccache was not found)"" FORCE); endif(); endif(). #---Enable distcc ------------------------------------------------------------------------------; if(distcc); find_program(DISTCC_COMMAND NAMES distcc); mark_as_advanced(DISTCC_COMMAND ${DISTCC_COMMAND}); if(EXISTS ${DISTCC_COMMAND}); message(STATUS ""Found distcc: ${DISTCC_COMMAND}""); if (ccache); # If ccache is enabled, use distcc as CCACHE_PREFIX; message(STATUS ""Because ccache is enabled, CCACHE_PREFIX is set to ${DISTCC_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""CCACHE_PREFIX=${DISTCC_COMMAND} ${CCACHE_COMMAND}""); else(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${DISTCC_COMMAND}); endif(); execute_process(COMMAND ${DISTCC_COMMAND} ""--version"" OUTPUT_VARIABLE DISTCC_VERSION); string(REGEX REPLACE ""distcc ([0-9\\.]+).*"" ""\\1"" DISTCC_VERSION ${DISTCC_VERSION}); else(); message(STATUS ""Could NOT find distcc""); set(distcc OFF CACHE BOOL ""Use distcc (disabled since distcc was not found)"" FORCE); endif(); endif(). #---Enable test coverage -----------------------------------------------------------------------; if(coverage); set(GCC_COVERAGE_COMPILE_FLAGS ""-fprofile-arcs -ftest-coverage""); set(GCC_COVERAGE_LINK_FLAGS ""-fprofile-arcs""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SH",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:9507,message,message,9507,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,2,['message'],['message']
Integrability,"----------------------------===//. Mar 25, 2009 - Initial Revision. Most ABIs specify that functions which return small integers do so in a; specific integer GPR. This is an efficient way to go, but raises the question:; if the returned value is smaller than the register, what do the high bits hold?. There are three (interesting) possible answers: undefined, zero extended, or; sign extended. The number of bits in question depends on the data-type that; the front-end is referencing (typically i1/i8/i16/i32). Knowing the answer to this is important for two reasons: 1) we want to be able; to implement the ABI correctly. If we need to sign extend the result according; to the ABI, we really really do need to do this to preserve correctness. 2); this information is often useful for optimization purposes, and we want the; mid-level optimizers to be able to process this (e.g. eliminate redundant; extensions). For example, lets pretend that X86 requires the caller to properly extend the; result of a return (I'm not sure this is the case, but the argument doesn't; depend on this). Given this, we should compile this:. int a();; short b() { return a(); }. into:. _b:; 	subl	$12, %esp; 	call	L_a$stub; 	addl	$12, %esp; 	cwtl; 	ret. An optimization example is that we should be able to eliminate the explicit; sign extension in this example:. short y();; int z() {; return ((int)y() << 16) >> 16;; }. _z:; 	subl	$12, %esp; 	call	_y; 	;; movswl %ax, %eax -> not needed because eax is already sext'd; 	addl	$12, %esp; 	ret. //===----------------------------------------------------------------------===//; // What we have right now.; //===----------------------------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type and a signext/zeroext marker is used. For example, we compile; Z into:. define i32 @z() nounwind {; entry:; 	%0 = tail call signext i16 (...)* @y() nounwind; 	%1 = sext i16 %0 to i32; 	re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:1257,depend,depend,1257,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['depend'],['depend']
Integrability,"--------------------------===//. These instructions describe how to build and install Clang. //===----------------------------------------------------------------------===//; // Step 1: Organization; //===----------------------------------------------------------------------===//. Clang is designed to be built as part of an LLVM build. Assuming that the LLVM; source code is located at $LLVM_SRC_ROOT, then the clang source code should be; installed as:. $LLVM_SRC_ROOT/tools/clang. The directory is not required to be called clang, but doing so will allow the; LLVM build system to automatically recognize it and build it along with LLVM. //===----------------------------------------------------------------------===//; // Step 2: Configure and Build LLVM; //===----------------------------------------------------------------------===//. Configure and build your copy of LLVM (see $LLVM_SRC_ROOT/GettingStarted.html; for more information). Assuming you installed clang at $LLVM_SRC_ROOT/tools/clang then Clang will; automatically be built with LLVM. Otherwise, run 'make' in the Clang source; directory to build Clang. //===----------------------------------------------------------------------===//; // Step 3: (Optional) Verify Your Build; //===----------------------------------------------------------------------===//. It is a good idea to run the Clang tests to make sure your build works; correctly. From inside the Clang build directory, run 'make test' to run the; tests. //===----------------------------------------------------------------------===//; // Step 4: Install Clang; //===----------------------------------------------------------------------===//. From inside the Clang build directory, run 'make install' to install the Clang; compiler and header files into the prefix directory selected when LLVM was; configured. The Clang compiler is available as 'clang' and 'clang++'. It supports a gcc like; command line interface. See the man page for clang for more information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/INSTALL.txt:2106,interface,interface,2106,interpreter/llvm-project/clang/INSTALL.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/INSTALL.txt,1,['interface'],['interface']
Integrability,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2739,depend,depends,2739,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,1,['depend'],['depends']
Integrability,"-------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. set(LIBS; clingUtils; clangCodeGen; clangDriver; clangFrontend; clangParse; clangSema; clangAnalysis; clangEdit; clangRewrite; clangRewriteFrontend; clangSerialization; clangAST; clangBasic; clangLex; ). set(LLVM_LINK_COMPONENTS; analysis; core; coroutines; coverage; executionengine; ipo; jitlink; lto; mc; object; option; orcjit; runtimedyld; scalaropts; support; target; transformutils; binaryformat; ${LLVM_TARGETS_TO_BUILD}; ). # clingInterpreter depends on Options.inc to be tablegen-ed; # (target ClangDriverOptions) from in-tree builds.; set(CLING_DEPENDS ClingDriverOptions); if(TARGET ClangDriverOptions); set(CLING_DEPENDS ""${CLING_DEPENDS};ClangDriverOptions""); endif(); # clangSema will make sure all of the dependencies of clingInterpreter are met.; if(TARGET clangSema); set(CLING_DEPENDS ""${CLING_DEPENDS};clangSema""); endif(). add_cling_library(clingInterpreter OBJECT; AutoSynthesizer.cpp; AutoloadCallback.cpp; ASTTransformer.cpp; BackendPasses.cpp; CheckEmptyTransactionTransformer.cpp; CIFactory.cpp; ClangInternalState.cpp; ClingCodeCompleteConsumer.cpp; ClingPragmas.cpp; DeclCollector.cpp; DeclExtractor.cpp; DefinitionShadower.cpp; DeclUnloader.cpp; DeviceKernelInliner.cpp; DynamicLibraryManager.cpp; DynamicLibraryManagerSymbol.cpp; DynamicLookup.cpp; DynamicExprInfo.cpp; Exception.cpp; ExternalInterpreterSource.cpp; ForwardDeclPrinter.cpp; IncrementalCUDADeviceCompiler.cpp; IncrementalExecutor.cpp; IncrementalJIT.cpp; IncrementalParser.cpp; Interpreter.cpp; InterpreterCallbacks.cpp; InvocationOptions.cpp; LookupHelper.cpp; NullDerefProtectionTransformer.cpp; PerfJITEventListener.cpp; RequiredSymbols.cpp; Transaction.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CMakeLists.txt:1122,depend,dependencies,1122,interpreter/cling/lib/Interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"-----------------------; Currently, there isn't much. LLVM supports an intermediate representation; which is useful for code representation but will not support the high level; (abstract syntax tree) representation needed by most compilers. There are no; facilities for lexical nor semantic analysis. I don't understand the ``GetElementPtr`` instruction. Help!; -----------------------------------------------------------; See `The Often Misunderstood GEP Instruction <GetElementPtr.html>`_. Using the C and C++ Front Ends; ==============================. Can I compile C or C++ code to platform-independent LLVM bitcode?; -----------------------------------------------------------------; No. C and C++ are inherently platform-dependent languages. The most obvious; example of this is the preprocessor. A very common way that C code is made; portable is by using the preprocessor to include platform-specific code. In; practice, information about other platforms is lost after preprocessing, so; the result is inherently dependent on the platform that the preprocessing was; targeting. Another example is ``sizeof``. It's common for ``sizeof(long)`` to vary; between platforms. In most C front-ends, ``sizeof`` is expanded to a; constant immediately, thus hard-wiring a platform-specific detail. Also, since many platforms define their ABIs in terms of C, and since LLVM is; lower-level than C, front-ends currently must emit platform-specific IR in; order to have the result conform to the platform ABI. Questions about code generated by the demo page; ===============================================. What is this ``llvm.global_ctors`` and ``_GLOBAL__I_a...`` stuff that happens when I ``#include <iostream>``?; -------------------------------------------------------------------------------------------------------------; If you ``#include`` the ``<iostream>`` header into a C++ translation unit,; the file will probably use the ``std::cin``/``std::cout``/... global objects.; However, C++ does no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:6087,depend,dependent,6087,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['depend'],['dependent']
Integrability,"----------------------===//. This could be a single 16-bit load. int f(char *p) {; if ((p[0] == 1) & (p[1] == 2)) return 1;; return 0;; }. //===---------------------------------------------------------------------===//. We should inline lrintf and probably other libc functions. //===---------------------------------------------------------------------===//. This code:. void test(int X) {; if (X) abort();; }. is currently compiled to:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne LBB1_1; addl $12, %esp; ret; LBB1_1:; call L_abort$stub. It would be better to produce:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne L_abort$stub; addl $12, %esp; ret. This can be applied to any no-return function call that takes no arguments etc.; Alternatively, the stack save/restore logic could be shrink-wrapped, producing; something like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; subl $12, %esp; call L_abort$stub. Both are useful in different situations. Finally, it could be shrink-wrapped; and tail called, like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; pop %eax # realign stack.; call L_abort$stub. Though this probably isn't worth it. //===---------------------------------------------------------------------===//. Sometimes it is better to codegen subtractions from a constant (e.g. 7-x) with; a neg instead of a sub instruction. Consider:. int test(char X) { return 7-X; }. we currently produce:; _test:; movl $7, %eax; movsbl 4(%esp), %ecx; subl %ecx, %eax; ret. We would use one fewer register if codegen'd as:. movsbl 4(%esp), %eax; 	neg %eax; add $7, %eax; ret. Note that this isn't beneficial if the load can be folded into the sub. In; this case, we want a sub:. int test(int X) { return 7-X; }; _test:; movl $7, %eax; subl 4(%esp), %eax; ret. //===---------------------------------------------------------------------===//. Leaf functions that require one 4-byte spill slot have a prolog like this:. _foo:; pushl %esi; subl $4, %esp; ...; and an epilog lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:12372,wrap,wrapped,12372,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['wrap'],['wrapped']
Integrability,"-------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129948,interface,interface,129948,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"-----------===//. Br, br_if, and br_table instructions can support having a value on the value; stack across the jump (sometimes). We should (a) model this, and (b) extend; the stackifier to utilize it. //===---------------------------------------------------------------------===//. The min/max instructions aren't exactly a<b?a:b because of NaN and negative zero; behavior. The ARM target has the same kind of min/max instructions and has; implemented optimizations for them; we should do similar optimizations for; WebAssembly. //===---------------------------------------------------------------------===//. AArch64 runs SeparateConstOffsetFromGEPPass, followed by EarlyCSE and LICM.; Would these be useful to run for WebAssembly too? Also, it has an option to; run SimplifyCFG after running the AtomicExpand pass. Would this be useful for; us too?. //===---------------------------------------------------------------------===//. Register stackification uses the VALUE_STACK physical register to impose; ordering dependencies on instructions with stack operands. This is pessimistic;; we should consider alternate ways to model stack dependencies. //===---------------------------------------------------------------------===//. Lots of things could be done in WebAssemblyTargetTransformInfo.cpp. Similarly,; there are numerous optimization-related hooks that can be overridden in; WebAssemblyTargetLowering. //===---------------------------------------------------------------------===//. Instead of the OptimizeReturned pass, which should consider preserving the; ""returned"" attribute through to MachineInstrs and extending the; MemIntrinsicResults pass to do this optimization on calls too. That would also; let the WebAssemblyPeephole pass clean up dead defs for such calls, as it does; for stores. //===---------------------------------------------------------------------===//. Consider implementing optimizeSelect, optimizeCompareInstr, optimizeCondBranch,; optimizeLoadInstr, and/or getMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:2592,depend,dependencies,2592,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['depend'],['dependencies']
Integrability,"----------. The libdevice library currently uses the following reflection parameters to; control code generation:. ==================== ======================================================; Flag Description; ==================== ======================================================; ``__CUDA_FTZ=[0,1]`` Use optimized code paths that flush subnormals to zero; ==================== ======================================================. The value of this flag is determined by the ""nvvm-reflect-ftz"" module flag.; The following sets the ftz flag to 1. .. code-block:: llvm. !llvm.module.flag = !{!0}; !0 = !{i32 4, !""nvvm-reflect-ftz"", i32 1}. (``i32 4`` indicates that the value set here overrides the value in another; module we link with. See the `LangRef <LangRef.html#module-flags-metadata>`; for details.). Executing PTX; =============. The most common way to execute PTX assembly on a GPU device is to use the CUDA; Driver API. This API is a low-level interface to the GPU driver and allows for; JIT compilation of PTX code to native GPU machine code. Initializing the Driver API:. .. code-block:: c++. CUdevice device;; CUcontext context;. // Initialize the driver API; cuInit(0);; // Get a handle to the first compute device; cuDeviceGet(&device, 0);; // Create a compute device context; cuCtxCreate(&context, 0, device);. JIT compiling a PTX string to a device binary:. .. code-block:: c++. CUmodule module;; CUfunction function;. // JIT compile a null-terminated PTX string; cuModuleLoadData(&module, (void*)PTXString);. // Get a handle to the ""myfunction"" kernel function; cuModuleGetFunction(&function, module, ""myfunction"");. For full examples of executing PTX assembly, please see the `CUDA Samples; <https://developer.nvidia.com/cuda-downloads>`_ distribution. Common Issues; =============. ptxas complains of undefined function: __nvvm_reflect; -----------------------------------------------------. When linking with libdevice, the ``NVVMReflect`` pass must be used. See; :ref:`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:11348,interface,interface,11348,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['interface'],['interface']
Integrability,"---------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote pointers in certain address; spaces as ""non-integral"" via the :ref:`datalayout string<langref_datalayout>`.; Non-integral pointer types represent pointers that have an *unspecified* bitwise; representation; that is, the integral representation may be target dependent or; unstable (not backed by a fixed integer). ``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for; integral (i.e. normal) pointers in that they convert integers to and from; corresponding pointer types, but there are additional implications to be; aware of. Because the bit-representation of a non-integral pointer may; not be stable, two identical casts of the same operand may or may not; return the same value. Said differently, the conversion to or from the; non-integral type depends on environmental state in an implementation; defined manner. If the frontend wishes to observe a *particular* value following a cast, the; generated IR must fence with the underlying environment in an implementation; defined manner. (In practice, this tends to require ``noinline`` routines for; such operations.). From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for; non-integral types are analogous to ones o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:28563,depend,dependent,28563,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for; patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):$mypat``.; This may also be helpful to debug issues. Patterns are *always* named, and if; they don't have a name, an ""anonymous"" one is given to them. If you're trying; to debug an error related to a MIR pattern, but the error mentions an anonymous; pattern, you can try naming your patterns to see exactly where the issue is. .. code-block:: text",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:1409,depend,depends,1409,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['depend'],['depends']
Integrability,"---------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminated in due course.; * FindCppyy.cmake provides the interface described further here. Details of the usage of these modules is within the modules themselves, but; here is a summary of the usage. ``FindLibClang.cmake`` sets the following; variables:. ::. LibClang_FOUND - True if libclang is found.; LibClang_LIBRARY - Clang library to link against.; LibClang_VERSION - Version number as a string (e.g. ""3.9"").; LibClang_PYTHON_EXECUTABLE - Compatible python version. ``FindCppyy.cmake`` sets the following variables:. ::. Cppyy_FOUND - set to true if Cppyy is found; Cppyy_DIR - the directory where Cppyy is installed; Cppyy_EXECUTABLE - the path to the Cppyy executable; Cppyy_INCLUDE_DIRS - Where to find the Cppyy header files.; Cppyy_VERSION - the version number of the Cppyy backend. and also defines the following functions::. cppyy_add_bindings - Generate a set of bindings from a set of header files.; cppyy_find_pips - Return a list of available pip programs. cppyy_add_bindings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:2638,interface,interface,2638,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['interface'],['interface']
Integrability,"-------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Information about the MemorySSA utility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a generalization of loops. :doc:`Vectorizers`; This document describes the current status of vectorization in LLVM. :doc:`LinkTimeOptimization`; This document describes the interface between LLVM intermodular optimizer; and the linker and its design. :doc:`GoldPlugin`; How to build your programs with link-time optimization on Linux. :doc:`Remarks`; A reference on the implementation of remarks in LLVM. :doc:`Source Level Debugging with LLVM <SourceLevelDebugging>`; This document describes the design and philosophy behind the LLVM; source-level debugger. :doc:`How to Update Debug Info <HowToUpdateDebugInfo>`; This document specifies how to correctly update debug info in various kinds; of code transformations. :doc:`InstrRefDebugInfo`; This document explains how LLVM uses value tracking, or instruction; referencing, to determine variable locations for debug info in the final; stages of compilation. :doc:`RemoveDIsDebugInfo`; This is a migration guide describing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:3612,interface,interface,3612,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['interface'],['interface']
Integrability,"-------. A |LLVM IR fuzzer| aimed at finding bugs in optimization passes. It receives optimization pipeline and runs it for each fuzzer input. Interface of this fuzzer almost directly mirrors ``llvm-isel-fuzzer``. Both; ``mtriple`` and ``passes`` arguments are required. Passes are specified in a; format suitable for the new pass manager. You can find some documentation about; this format in the doxygen for ``PassBuilder::parsePassPipeline``. .. code-block:: shell. % bin/llvm-opt-fuzzer <corpus-dir> -ignore_remaining_args=1 -mtriple x86_64 -passes instcombine. Similarly to the ``llvm-isel-fuzzer`` arguments in some predefined configurations; might be embedded directly into the binary file name:. .. code-block:: shell. % bin/llvm-opt-fuzzer--x86_64-instcombine <corpus-dir>. llvm-mc-assemble-fuzzer; -----------------------. A |generic fuzzer| that fuzzes the MC layer's assemblers by treating inputs as; target specific assembly. Note that this fuzzer has an unusual command line interface which is not fully; compatible with all of libFuzzer's features. Fuzzer arguments must be passed; after ``--fuzzer-args``, and any ``llc`` flags must use two dashes. For; example, to fuzz the AArch64 assembler you might use the following command:. .. code-block:: console. llvm-mc-fuzzer --triple=aarch64-linux-gnu --fuzzer-args -max_len=4. This scheme will likely change in the future. llvm-mc-disassemble-fuzzer; --------------------------. A |generic fuzzer| that fuzzes the MC layer's disassemblers by treating inputs; as assembled binary data. Note that this fuzzer has an unusual command line interface which is not fully; compatible with all of libFuzzer's features. See the notes above about; ``llvm-mc-assemble-fuzzer`` for details. .. |generic fuzzer| replace:: :ref:`generic fuzzer <fuzzing-llvm-generic>`; .. |protobuf fuzzer|; replace:: :ref:`libprotobuf-mutator based fuzzer <fuzzing-llvm-protobuf>`; .. |LLVM IR fuzzer|; replace:: :ref:`structured LLVM IR fuzzer <fuzzing-llvm-ir>`. lldb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:4322,interface,interface,4322,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['interface'],['interface']
Integrability,"-------. Following the NewBuffer record, each buffer records an absolute time as a frame; of reference for the durations recorded by timestamp counter deltas. Its data segment is as follows. +---------------+--------------+-----------------------------------------------+; | Field | Size (bytes) | Description |; +===============+==============+===============================================+; | seconds | ``8`` | Seconds on absolute timescale. The starting |; | | | point is unspecified and depends on the |; | | | implementation and platform configured by the |; | | | tracer. |; +---------------+--------------+-----------------------------------------------+; | microseconds | ``4`` | The microsecond component of the time. |; +---------------+--------------+-----------------------------------------------+; | reserved | ``3`` | Unused. |; +---------------+--------------+-----------------------------------------------+. NewCpuId Records; ----------------. Each function entry invokes a routine to determine what CPU is executing.; Typically, this is done with readtscp, which reads the timestamp counter at the; same time. If the tracing detects that the execution has switched CPUs or if this is the; first instrumented entry point, the tracer will output a NewCpuId record. Its data segment is as follows. +---------------+--------------+-----------------------------------------------+; | Field | Size (bytes) | Description |; +===============+==============+===============================================+; | cpu_id | ``2`` | CPU Id. |; +---------------+--------------+-----------------------------------------------+; | absolute_tsc | ``8`` | The absolute value of the timestamp counter. |; +---------------+--------------+-----------------------------------------------+; | reserved | ``5`` | Unused. |; +---------------+--------------+-----------------------------------------------+. TSCWrap Records; ---------------. Since each function record uses a 32 bit value to represent the n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst:11545,rout,routine,11545,interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,1,['rout'],['routine']
Integrability,"------; http://www.highproductivity.org/SSCABmks.htm. This web site does not exist any more, but there seems to be a copy of; some of the benchmarks; https://github.com/gtcasl/hpc-benchmarks/tree/master/SSCA2v2.2. Kokkos; ------; https://github.com/kokkos/kokkos-kernels/tree/master/perf_test; https://github.com/kokkos/kokkos/tree/master/benchmarks. PolyMage; --------; https://github.com/bondhugula/polymage-benchmarks. PolyBench; ---------; https://sourceforge.net/projects/polybench/. A modified version of Polybench 3.2 is already presented in; SingleSource/Benchmarks/Polybench. A newer version 4.2.1 is available. High Performance Geometric Multigrid; ------------------------------------; https://crd.lbl.gov/departments/computer-science/PAR/research/hpgmg/. RAJA Performance Suite; ----------------------; https://github.com/LLNL/RAJAPerf. CORAL-2 Benchmarks; ------------------; https://asc.llnl.gov/coral-2-benchmarks/. Many of its programs have already been integrated in; MultiSource/Benchmarks/DOE-ProxyApps-C and; MultiSource/Benchmarks/DOE-ProxyApps-C++. * Nekbone; * QMCPack; * LAMMPS; * Kripke; * Quicksilver; * PENNANT; * Big Data Analytic Suite; * Deep Learning Suite; * Stream; * Stride; * ML/DL micro-benchmark; * Pynamic; * ACME; * VPIC; * Laghos; * Parallel Integer Sort; * Havoq. NWChem; ------; http://www.nwchem-sw.org/index.php/Benchmarks. TVM; ----; https://github.com/dmlc/tvm/tree/main/apps/benchmark. HydroBench; ----------; https://github.com/HydroBench/Hydro. ParRes; ------; https://github.com/ParRes/Kernels/tree/default/Cxx11. Applications/Libraries; ======================. GnuPG; -----; https://gnupg.org/. Blitz++; -------; https://sourceforge.net/projects/blitz/. FFmpeg; ------; https://ffmpeg.org/. FreePOOMA; ---------; http://www.nongnu.org/freepooma/. FTensors; --------; http://www.wlandry.net/Projects/FTensor. rawspeed; --------; https://github.com/darktable-org/rawspeed. Its test dataset is 756 MB in size, which is too large to be included; into th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:4601,integrat,integrated,4601,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['integrat'],['integrated']
Integrability,"----. * Upgrade cppyy-cling to 6.18.2; * Various patches to upstream's pre-compiled header generation and use; * Instantiate templates with larger integer types if argument values require; * Improve cppyy.interactive and partially enable it on PyPy, IPython, etc.; * Let ``__overload__`` be more flexible in signature matching; * Make list filtering of dir(cppyy.gbl) on Windows same as Linux/Mac; * Extended documentation. 2019-08-18: 1.5.0; -----------------. * Upgrade cppyy-cling to 6.18.0; * Allow python-derived classes to be used in templates; * Stricter template resolution and better caching/performance; * Detailed memory management for make_shared and shared_ptr; * Two-way memory management for cross-inherited objects; * Reduced memory footprint of proxy objects in most common cases; * Allow implicit conversion from a tuple of arguments; * Data set on namespaces reflected on C++ even if data not yet bound; * Generalized resolution of binary operators in wrapper generation; * Proper naming of arguments in namespaces for ``std::function<>``; * Cover more cases of STL-liker iterators; * Allow ``std::vector`` initialization with a list of constructor arguments; * Consistent naming of ``__cppname__`` to ``__cpp_name__``; * Added ``__set_lifeline__`` attribute to overloads; * Fixes to the cmake fragments for Ubuntu; * Fixes linker errors on Windows in some configurations; * Support C++ naming of typedef of bool types; * Basic views of 2D arrays of builtin types; * Extended documentation. 2019-07-01 : 1.4.12; -------------------. * Automatic conversion of python functions to ``std::function`` arguments; * Fix for templated operators that can map to different python names; * Fix on p3 crash when setting a detailed exception during exception handling; * Fix lookup of ``std::nullopt``; * Fix bug that prevented certain templated constructors from being considered; * Support for enum values as data members on ""enum class"" enums; * Support for implicit conversion when passing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:18110,wrap,wrapper,18110,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['wrap'],['wrapper']
Integrability,"----. The :program:`llvm-readelf` tool displays low-level format-specific information; about one or more object files. If ``input`` is ""``-``"", :program:`llvm-readelf` reads from standard; input. Otherwise, it will read from the specified ``filenames``. OPTIONS; -------. .. option:: --all, -a. Equivalent to specifying all the main display options relevant to the file; format. .. option:: --addrsig. Display the address-significance table. .. option:: --arch-specific, -A. Display architecture-specific information, e.g. the ARM attributes section on ARM. .. option:: --bb-addr-map. Display the contents of the basic block address map section(s), which contain the; address of each function, along with the relative offset of each basic block. .. option:: --decompress, -z. Dump decompressed section content when used with ``-x`` or ``-p``.; If the section(s) are not compressed, they are displayed as is. .. option:: --demangle, -C. Display demangled symbol names in the output. .. option:: --dependent-libraries. Display the dependent libraries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:1203,depend,dependent-libraries,1203,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['depend'],['dependent-libraries']
Integrability,"--. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4165,wrap,wrap,4165,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['wrap'],['wrap']
Integrability,"--config core.autocrlf=false https://github.com/llvm/llvm-project.git. This will create an '``llvm-project``' directory in the current directory and; fully populate it with all of the source code, test directories, and local; copies of documentation files for LLVM and all the related subprojects. Note; that unlike the tarballs, which contain each subproject in a separate file, the; git repository contains all of the projects together. If you want to get a specific release (as opposed to the most recent revision),; you can check out a tag after cloning the repository. E.g., `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; command. Use `git tag -l` to list all of them. Sending patches; ^^^^^^^^^^^^^^^. See :ref:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBisecting.html>`_ for how to use ``git bisect``; on LLVM. Reverting a change; ^^^^^^^^^^^^^^^^^^. When reverting changes using git, the default message will say ""This reverts; commit XYZ"". Leave this at the end of the commit message, but add some details; before it as to why the commit is being reverted. A brief explanation and/or; links to bots that demonstrate the problem are sufficient. Local LLVM Configuration; ------------------------. Once checked out repository, the LLVM suite source code must be configured; before being built. This process uses CMake. Unlinke the normal ``configure``; script, CMake generates the build files in whatever format you request as well; as various ``*.inc`` files, and ``llvm/include/llvm/Config/config.h.cmake``. Variables are passed to ``cmake`` on the command line using the format; ``-D<variable name>=<value>``. The following variables are some common options; used by people developing LLVM. +-------------------------+----------------------------------------------------+; | Variable | Purpose |; +=========================+====================================================+; | CMAKE_C_COMP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:23220,message,message,23220,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['message']
Integrability,"--cxxflags**. Print the C++ compiler flags needed to use LLVM headers. **--has-rtti**. Print whether or not LLVM was built with rtti (YES or NO). **--help**. Print a summary of **llvm-config** arguments. **--host-target**. Print the target triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--obj-root**. Print the object root used to build LLVM. **--prefix**. Print the installation prefix for LLVM. **--shared-mode**. Print how the provided components can be collectively linked (`shared` or `static`). **--system-libs**. Print all the system libraries needed to link against the specified LLVM; *components*, including any dependencies. **--targets-built**. Print the component names for all targets supported by this copy of LLVM. **--version**. Print the version number of LLVM. COMPONENTS; ----------. To print a list of all available components, run **llvm-config; --components**. In most cases, components correspond directly to LLVM; libraries. Useful ""virtual"" components include:. **all**. Includes all LLVM libraries. The default if no components are specified. **backend**. Includes either a native ba",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:2272,depend,dependencies,2272,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,1,['depend'],['dependencies']
Integrability,"->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which configures the choice of; numeric integration algorithm. A new tutorial macro rf902_numgenconfig.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of the steering. A macro that demonstrates of the power of these newly interface numeric algorithms i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:5188,integrat,integrators,5188,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['integrat'],['integrators']
Integrability,-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Ina,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78323,depend,dependency-ordered-before,78323,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependency-ordered-before']
Integrability,"-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3811,message,message,3811,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['message'],['message']
Integrability,"-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11605,depend,dependencies,11605,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['depend'],['dependencies']
Integrability,"-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide varie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9142,integrat,integrated,9142,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['integrat'],['integrated']
Integrability,"-note-records` for the note records supported by the AMDGPU; backend. ``.rela``\ *name*, ``.rela.dyn``; For relocatable code objects, *name* is the name of the section that the; relocation records apply. For example, ``.rela.text`` is the section name for; relocation records associated with the ``.text`` section. For linked shared code objects, ``.rela.dyn`` contains all the relocation; records from each of the relocatable code object's ``.rela``\ *name* sections. See :ref:`amdgpu-relocation-records` for the relocation records supported by; the AMDGPU backend. ``.text``; The executable machine code for the kernels and functions they call. Generated; as position independent code. See :ref:`amdgpu-code-conventions` for; information on conventions used in the isa generation. .. _amdgpu-note-records:. Note Records; ------------. The AMDGPU backend code object contains ELF note records in the ``.note``; section. The set of generated notes and their semantics depend on the code; object version; see :ref:`amdgpu-note-records-v2` and; :ref:`amdgpu-note-records-v3-onwards`. As required by ``ELFCLASS32`` and ``ELFCLASS64``, minimal zero-byte padding; must be generated after the ``name`` field to ensure the ``desc`` field is 4; byte aligned. In addition, minimal zero-byte padding must be generated to; ensure the ``desc`` field size is a multiple of 4 bytes. The ``sh_addralign``; field of the ``.note`` section must be at least 4 to indicate at least 8 byte; alignment. .. _amdgpu-note-records-v2:. Code Object V2 Note Records; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. warning::; Code object V2 generation is no longer supported by this version of LLVM. The AMDGPU backend code object uses the following ELF note record in the; ``.note`` section when compiling for code object V2. The note record vendor field is ""AMD"". Additional note records may be present, but any which are not documented here; are deprecated and should not be used. .. table:: AMDGPU Code Object V2 ELF Note Records; :name: amd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:69319,depend,depend,69319,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depend']
Integrability,"-o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:16854,depend,depends,16854,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['depends']
Integrability,"-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-project/root/issues/14958)] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; * [[#14921](https://github.com/root-project/root/issues/14921)] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; * [[#14914](https://github.com/root-project/root/issues/14914)] - VecOps::Take with default argument doesn't check correctly the out of boundary condition; * [[#14910](https://github.com/root-project/root/issues/14910)] - hadd issue when using parallelization together with indirect file; * [[#14902](https://github.com/root-project/root/issues/14902)] - compilation error; * [[#14863](https://github.com/root-project/root/issues/14863)] - [hist] TH1::SaveAs missing default option argument causes compilation errors; * [[#14855](https://github.com/root-project/root/issues/14855)] - TRatioPlot crashes if loaded from the file; * [[#14842](https://github.com/root-project/root/issues/14842)] - TRatioplot gives ""different"" results with Web Graphics; * [[#14838](https://github.com/root-project/root/issues/14838)] - Problems with Confide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:27827,message,message,27827,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['message'],['message']
Integrability,. ## Python Bindings. The Python bindings are fully supported in ROOT 6. ## Ruby Bindings. The Ruby bindings have not been ported yet to the new interpreter interface in ROOT 6. We hope to have this fixed in a future release. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/doc/v600/index.md:157,interface,interface,157,bindings/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/doc/v600/index.md,1,['interface'],['interface']
Integrability,". '``llvm.loop.distribute.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Loop distribution allows splitting a loop into multiple loops. Currently,; this is only performed if the entire loop cannot be vectorized due to unsafe; memory dependencies. The transformation will attempt to isolate the unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:308511,depend,dependencies,308511,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependencies']
Integrability,". * 1st step: contact the owner of the worker. You can find the name and contact; information for the *Admin* of worker on the page of the build in the; *Worker* tab:. .. image:: buildbot_worker_contact.png. * 2nd step: If the owner does not respond or fix the worker, please escalate; to Galina Kostanova, the maintainer of the BuildBot master.; * 3rd step: If Galina could not help you, please escalate to the; `Infrastructure Working Group <mailto:iwg@llvm.org>`_. .. _new-llvm-components:. Introducing New Components into LLVM; ====================================. The LLVM community is a vibrant and exciting place to be, and we look to be; inclusive of new projects and foster new communities, and increase; collaboration across industry and academia. That said, we need to strike a balance between being inclusive of new ideas and; people and the cost of ongoing maintenance that new code requires. As such, we; have a general :doc:`support policy<SupportPolicy>` for introducing major new; components into the LLVM world, depending on the degree of detail and; responsibility required. *Core* projects need a higher degree of scrutiny; than *peripheral* projects, and the latter may have additional differences. However, this is really only intended to cover common cases; that we have seen arise: different situations are different, and we are open; to discussing unusual cases as well - just start an RFC thread on the; `LLVM Discourse forums`_. Adding a New Target; -------------------. LLVM is very receptive to new targets, even experimental ones, but a number of; problems can appear when adding new large portions of code, and back-ends are; normally added in bulk. New targets need the same level of support as other; *core* parts of the compiler, so they are covered in the *core tier* of our; :doc:`support policy<SupportPolicy>`. We have found that landing large pieces of new code and then trying to fix; emergent problems in-tree is problematic for a variety of reasons. For the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:38268,depend,depending,38268,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['depend'],['depending']
Integrability,". +----------------------------------+------------------------------------------------------------------------------+; | Section | Description |; +==================================+==============================================================================+; | omp_offloading_entries | Offloading entry information (see :ref:`table-tgt_offload_entry_structure`) |; +----------------------------------+------------------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:13817,wrap,wrapper,13817,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapper']
Integrability,". - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62569,depend,dependent,62569,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['dependent']
Integrability,". - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15170,interface,interface,15170,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,". .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The second argument is always a pointer or a vector of pointers, and is the; base address to start from. The remaining arguments are indices; that indicate which of the elements of the aggregate object are indexed.; The interpretation of each index is dependent on the type being indexed; into. The first index always indexes the pointer value given as the; second argument, the second index indexes a value of the type pointed to; (not necessarily the value directly pointed to, since the first index; can be non-zero), etc. The first type indexed into must be a pointer; value, subsequent types can be arrays, vectors, and structs. Note that; subsequent types being indexed into can never be pointers, since that; would require loading the pointer before continuing calculation. The type of each index argument depends on the type it is indexing into.; When indexing into a (optionally packed) structure, only ``i32`` integer; **constants** are allowed (when using a vector of indices they must all; be the **same** ``i32`` integer constant). When indexing into an array,; pointer or vector, integers of any width are allowed, and they are not; required to be constant. These integers are treated as signed values; where relevant. For example, let's co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:433345,depend,dependent,433345,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,". .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:15699,message,message,15699,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['message'],['message']
Integrability,". 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between templates and copy constructors; Unknown. 1081; C++11; Defaulted destructor and unusable operator delete; Unknown. 1082; C++11; Implicit copy function if subobject has none?; Unknown. 1083; C++11; Passing an object to ellipsis with non-trivial move constructor; Unknown. 1084; NAD; Conditions for a deleted move function; Unknown. 1085; NAD; Move assignment operators and virtual bases; Unknown. 1086; C++11; const_cast to rvalue reference to function type; Unknown. 1087; C++11; Additional applications of issue 899; Unknown. 1088; C++11; Dependent non-type template a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:71051,depend,dependent,71051,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant in,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:143564,depend,dependence,143564,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependence']
Integrability,". 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Du",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21699,synchroniz,synchronization,21699,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['synchroniz'],['synchronization']
Integrability,". Build System; MacOS X. On MacOS X move to a more secure way of building. We will now always use; the --enable-explicitlink ./configure option which will cause a shared lib; or executable to be linked with all its dependent libraries. The OSX linker; is quite good and processing this extended set of libraries for each link; does cost only 3s extra time for all 100+ shared libs (13s instead of 10s).; Not much for the extra security. In addition we went back to the default; linker option ""-undefined error"", so you will get an error if symbols; are unresolved. Shared libs are also linked with the option; ""-Wl,-dead_strip_dylibs"" which tells the linker to remove any shared lib; which is not used to resolve any symbols (this should; solve the long standing issue of ACliC linking all previously created; shared libs even when not needed). Linux. Make --enable-explictlink the default on linux too (was already the case for:; macosx, freebsd, openbsd, aix and win32). This adds some extra time to; the link stage, which can be recuperated by using the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:215,depend,dependent,215,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['depend'],['dependent']
Integrability,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:387,depend,dependent,387,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:259,message,messages,259,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['message'],['messages']
Integrability,". Clang - Open Projects. Open Clang Projects; Here are a few tasks that are available for anyone to work on, depending; on what your interests are. This list is provided to generate ideas, it is not; intended to be comprehensive. Please ask on; Discourse for more specifics; or to verify that one of these isn't already completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model sui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:109,depend,depending,109,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['depend'],['depending']
Integrability,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:793,integrat,integration,793,interpreter/llvm-project/clang/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html,1,['integrat'],['integration']
Integrability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Latest News; Cling goes public; July 25th, 2011; Cling was officially announced to the Clang community Read more. New website launched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Documents. TalkEvent. Creating cling, an interactive interpreter interface for clang Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev; LLVM Dev Meeting 2010, San Jose, USA. Implementing Dynamic Scopes in Cling Vassil Vassilev; LLVM Euro Dev Meeting 2011, London, UK. Cling - The LLVM-based Interpreter Vassil Vassilev; PH/SFT Group Meeting, CERN, CH. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html:523,interface,interface,523,interpreter/cling/www/old/docs.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/docs.html,1,['interface'],['interface']
Integrability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:453,interface,interface,453,interpreter/cling/www/news/ClingAnnouncement.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:453,interface,interface,453,interpreter/cling/www/old/news.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html,2,['interface'],['interface']
Integrability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; . Advantages of the current website are:; ; Hosted on the svn - enables version control of the website corresponding to the version of the project itself. Track of the modifications and authors could be kept.; Could be browsed offline (just open cling_src_folder that was checked out and open www/index.html); Pure DHTML/CSS - easy to port and maintain. << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html:389,interface,interface,389,interpreter/cling/www/news/NewWebsiteLaunched.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/NewWebsiteLaunched.html,1,['interface'],['interface']
Integrability,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:1127,integrat,integrate,1127,interpreter/cling/www/use.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html,2,"['depend', 'integrat']","['depend', 'integrate']"
Integrability,". Cling. Jupyter Kernel ; Cling is now integrated with the Jupyter technology through the Jupyter kernel. You can take advantage of creating a Jupyter notebook on top of runtime interpretation, you have runtime visualisation!; . See also the [example notebook in cling's github repo](https://github.com/root-project/cling/blob/master/tools/Jupyter/kernel/cling.ipynb).; Prerequisites. ; ipykernel ≥ 4.0. Install ; To install the kernel with sources in src/tools/cling:. export PATH=/path/to/cling/bin:$PATH; cd src/tools/cling/tools/Jupyter/kernel/. pip install -e .; # or: pip3 install -e . # register the kernelspec:; jupyter-kernelspec install [--user] cling; # or: jupyter kernelspec install [--user] cling. To run it:. jupyter-notebook; # or: jupyter notebook. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html:39,integrat,integrated,39,interpreter/cling/www/jupyter.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/jupyter.html,1,['integrat'],['integrated']
Integrability,". Core. New class TBase64 providing Base64 encoding and decoding. Base64 encoded; messages are typically used in authentication protocols and to pack binary; data in HTTP or mail messages. New method in TSystem:. TString TSystem::GetFromPipe(const char *command). which executes ""command"" in the shell and returns the output in the TString.; Multi-line output is separated by \n's. Add proper support for Microsoft Visual C++ 9.0; Add support for 'unix' sockets on Windows.; New method TString::Clear() to reset the string but not to resize it to the default; (small) size. Useful when the string was pre-allocated to a large size and; has to be re-used.; Insure that ROOT's autoloader is always enabled whenever loading rootmap files.; Add function void TAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim); ; Enable autoloading of typedef.; The statically linked roota executable and libRoot.a are currently; only supported on Linux platforms. We hope to extend this to MacOS X; soon. Meta. Add new macro ClassDefNV (ClassDef Non Virtual) which does not define any virtual function. ClassDef does define IsA, Streamer and ShowMember as virtual. This should be used only in classes that are never inherited from!; Improve performance of TClass::GetMethod (and friends). ACLiC. Implement TClassEdit::InsertStd() which puts ""std::"" in front of all STL classes.; The generated library now always checks with which version of ROOT the library was build and rebuilt the library if the running version of ROOT is different.; Add support for '+' character embedded in the script's name or directory name.; The dependency tracking file (script_C.d) is now always created when the library is built.; The dependency tracking file now records with which version of ROOT the library was built and the library is now rebuilt if it is loaded in a different version of ROOT. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html:82,message,messages,82,core/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html,5,"['depend', 'message', 'protocol']","['dependency', 'messages', 'protocols']"
Integrability,". Core. The ROOT source directory has been drastically reorganized and simplified.; Each source directory containing the code for a single library or plugin,; were all in the same top level directory, without logical grouping.; This made it difficult to see which libraries were related and belonged; together. In the new structure we've added a set of meta directories; that are used to group the sources of related libraries, and that also; reflects the ROOT team work package structure.; Note, the name and number of libraries has not been changed.; This new structure also facilitates the maintaining of the release notes; and other documentation items per meta package. On Linux, MacOS X and Windows, there is no need anymore to define the; environment variable ROOTSYS. Internally ROOTSYS is set depending on the; location of the ROOT libraries. ROOTSYS was never needed when ROOT was; configured using --prefix. On MacOS X when configure'ing with --enable-rpath (and not specifying; --prefix) the installation does not need (DY)LD_LIBRARY_PATH to be set; anymore. The installation is completely relocatable. The (DY)LD_LIBRARY_PATH; is determined relative to the location of the root executable. On Windows .root files are now associated with the most recently executed; ROOT installation, i.e. run ROOT once and .root files open with ROOT. Class TMessageHandler derives now from TQObject and does emit signals.; This allows for easier usage of this class. In this release xrootd and libAfterImage are managed in Subversion; via so called ""vendor branches"". This is completely transparent; except for people who do directly use svn. You will get the message:. $ svn up; svn: Failed to add directory 'xrootd/src/xrootd': object of the same name already exists; $ rm -rf xrootd/src/xrootd; $ svn up; svn: Failed to add directory 'asimage/src/libAfterImage': object of the same name already exists; $ rm -rf asimage/src/libAfterImage; $ svn up. Port to gcc 4.3.1. This version of gcc is much stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:802,depend,depending,802,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['depend'],['depending']
Integrability,". Core; TString. Reimplementation of the internals of TString to not use reference counting and; copy on write, but to use a more modern and thread safe Short String; Optimization (SSO) technique. Using SSO short strings (<15 on 64-bit and; <11 on 32-bit) are contained in the TString internal data structure; without the need for mallocing the required space. TObject. In TObject::ls, add support for the option 'noaddr' which ; prevents the printing of the address of the object. This; is useful in particular in roottest. Use this in hadd; and TFileMerger. TROOT. New routine CloseFiles used automatically shortly before termination to ; insure closing of files and sockets before the unload of any library.; New collection 'ClosedObjects' holding pointers to TFile or TSocket that; have been closed but not deleted it. In the case of TSocket, they are added only; if they are closed by the CloseFiles.; Add a Close member function to TProofMgr since it is added to the list of socket.; Migrate the closing of files from various to a single place (T*System::Exit).; Fill in the implementation of TROOT::FindObjectAnyFile.; Mark TROOT as TObject::kInvalidObject as soon as its destructor starts,; in order to be able to veto some action later on (like autoloading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:571,rout,routine,571,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['rout'],['routine']
Integrability,". CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Method No Fisher Fisher, Mahalanobis Discrimination method. Configuration options for MVA method :. Configuration options reference for MVA method: PDERS. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Conf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:4119,message,message,4119,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,". Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter errors. It is therefore recommended to make sure that all computations in; $\mbox{FCN}$, as well as all methods and functions called by; $\mbox{FCN}$, are done in double precision. If for some reason the; computations cannot be done to a precision comparable with that expected; by M , the user **must** infor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26626,depend,dependent,26626,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,['depend'],"['dependent', 'depending']"
Integrability,". GUI; New Classes: TRecorder TGRecorder; TRecorder classes provide interface for recording and replaying events in ROOT.; Recorded events are:; Commands typed by user in command line (e.g. 'new TCanvas'); GUI events (mouse movement, button clicks, ...); All the recorded events from one session are stored in one TFile and can be replayed again anytime.; Modifications in TRootCanvas menu:; Renamed 'Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::Se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:68,interface,interface,68,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,2,['interface'],['interface']
Integrability,". Geometry; Improvement of the standard overlap checker. The previous method was checking points on the visual mesh of volume shape against all possible overlapping partners.; The new method checks more points (currently 1000, in future configurable) on the volume outline or surface. This minimizes the number of non-detectable overlap; configurations.; The interface to activate the new checking method is the same as before:; gGeoManager->CheckOverlaps(ovlp);; where ovlp is the overlap tolerance (default 0.01 cm); An example of overlap that was not detected before but is now:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/doc/v522/index.html:359,interface,interface,359,geom/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/doc/v522/index.html,1,['interface'],['interface']
Integrability,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1007,interface,interfaces,1007,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['interface'],['interfaces']
Integrability,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:835,rout,routines,835,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,"['integrat', 'rout']","['integrating', 'routines']"
Integrability,". Here is a much more complicated example:. ""PROD::sig(BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1],; tau[1.54], dm[0.472], w[0.05], dw[0],; AddModel({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),; GaussModel(dt,0,sigmaT[3,10]),; GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),; DoubleSided ),; Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] )"". This create a double-sided Bmixing decay p.d.f. with observables dt,; per-event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:21544,interface,interfaced,21544,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interfaced']
Integrability,". Histogram Libraries; THn, THnBase, THNSparse. The new, non-sparse n-dimensional histogram THn has been introduced.; It follows the same interfaces as THnSparse, and thus also implements THnF THnD THnC THnS THnI THnL.; NOTE: the memory usage of this class increases with the number of bins, i.e. exponentially with the number of dimensions!; A 5-dimensional THnD with 100 bins per dimension uses more than 80GB of RAM!; Better use THnSparse if only a small fraction of the bins are filled.; Most algorithms are now implemented in THnBase, the new common base class of THnSparse and THn.; If a function does not care about the actual storage format on in incoming objects it might as well reference a THnBase.; The bins of THn are held by objects of the new type TNDArray: an n-dimensional array with lazy allocation (only when a bin is set) that implements an operator [].; THn and THnSparse can be created from histograms and from each other, allowing for easy conversion. There is currently no support for drawing a THnBase-derived object; project it into a TH1/2/3 first. THistPainter. When 1D histograms are painted with the options TEXT and BAR simultaneously, the text for; each bin is placed taking into account the bar offset and bar width attributes. Previously,; when several histogram were drawn that way, the texts overlapped. When a TF1 was clipped vertically, horizotal lines appeared at the maximum and minimum; when the function was draw with a line width greater than 1.; The follwoing macro reproduces the problem:. {; TCanvas *c1=new TCanvas(""c1"", ""A canvas"", 10,0, 800, 600);; c1->SetLogy();; histo_dummy=c1->DrawFrame(0,1e-4,27,10);; TF1 gaussian_func(""gaussian_func"",""gaus"",0,25.4);; gaussian_func.SetLineColor(kRed);; gaussian_func.SetParameters(1e-2,10,3);; gaussian_func.Draw(""same"");; }. When two histograms where painted on top of each other with the option BOX (the; 2nd one with BOX,SAME) the plot was wrong if the minimum of the first histogram; was not zero. Take into ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html:138,interface,interfaces,138,hist/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v534/index.html,1,['interface'],['interfaces']
Integrability,". Histogram package. The libHist library now depends on libMathCore which must be linked whenever one needs to use the histogram library. TF1. The code used for implementing numerical methods like TF1::Integration or TF1::Derivation or TF1::GetX has now been now moved in MathCore and used to implement corresponding classes like GaussIntegrator or BrentRootFinder. The implementation remains however the same.; A new method TF1::operator()(double x, double y=0, double z) which is equivalent to TF1::Eval has been added for using TF1 as a callable object.; New templated methods TF1::SetFunction for generic C++ callable objects or for class member functions. TH1. Fixed a bug in the TH1::KolmogorovTest function in the case of scaled or weighted histograms. The routine has been improved and; now could also be used for comparing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:45,depend,depends,45,hist/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html,3,"['depend', 'rout']","['depends', 'routine']"
Integrability,". I/O Libraries; LZMA Compression and compression Level setting. ROOT I/O now support the LZMA compression algorithm to compress data in; addition to the ZLIB compression algorithm.; LZMA compression typically results in smaller files, but takes more; CPU time to compress data. To use the new feature, the external XZ; package must be installed when ROOT is configured and built:. Download 5.0.3 from here tukaani.org; and make sure to configure with fPIC:; ./configure CFLAGS='-fPIC'. Then the client C++ code must call routines to explicitly request LZMA; compression. ZLIB compression is still the default. Setting the Compression Level and Algorithm. There are three equivalent ways to set the compression level and; algorithm. For example, to set the compression to the LZMA algorithm; and compression level 5. TFile f(filename, option, title);; f.SetCompressionSettings(ROOT::CompressionSettings(ROOT::kLZMA, 5));. TFile f(filename, option, title, ROOT::CompressionSettings(ROOT::kLZMA, 5));. TFile f(filename, option, title);; f.SetCompressionAlgorithm(ROOT::kLZMA);; f.SetCompressionLevel(5);. These methods work for TFile, TBranch, TMessage, TSocket, and TBufferXML.; The compression algorithm and level settings only affect compression of; data after they have been set. TFile passes its settings to a TTree's branches; only at the time the branches are created. This can be overidden by; explicitly setting the level and algorithm for the branch. These classes; also have the following methods to access the algorithm and level for; compression. Int_t GetCompressionAlgorithm() const;; Int_t GetCompressionLevel() const;; Int_t GetCompressionSettings() const;. If the compression level is set to 0, then no compression will be; done. All of the currently supported algorithms allow the level to be; set to any value from 1 to 9. The higher the level, the larger the; compression factors will be (smaller compressed data size). The; tradeoff is that for higher levels more CPU time is used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:522,rout,routines,522,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['rout'],['routines']
Integrability,". I/O. Add support for the Chirp filesystem. To configure and build, chirp 3.2.2 must be installed.; When a TFile object is deleted, make sure that CINT also 'removes' any global variables that might point to it.; Fix support for the automatic addition to the current directory (for TTree and TH1 for example) in TKey::Read(TObject*).; In TKey, properly handle error in the I/O routines.; Explicitly check the validity of the zipped buffer before calling R__unzip, this allow for better error recovery.; When double checking whether a checksum difference is sustantial, ignore the std namespace. Use CompareContent also in the case of where; the class is versioned but the 'current' streamerInfo has not yet been built.; Prevent the I/O engine from mistakenly applying schema evolution to the TObject::fBits.; Make sure that when a streamer info of a base class is used to stream memberwise that is always not-optimized. If the StreamerInfo on file; has the same version as the StreamerInfo in memory but the one on file need to be 'not optimized' while the one in memory is not yet built, make; sure it will not be optimized.; Fix the reading of empty collection of object when reading without the library.; If the sequence of actions for streaming member-wise is not created correctly (i.e. where fReadMemberWise was null previously),; we now explicitly issue a Fatal error:. Fatal in <ReadSequence>: The sequence of actions to read AliESDVertex:7 member-wise was not initialized.; aborting. Add new optional parameter maxbuf to TXMLEngine::ParseFile() allowing the specification of the XML file size to be parsed. This fixes issue #78864.; Add function TBuffer::AutoExpand to centralize the automatic buffer extension policy. This enable the ability to tweak it later (for example instead of always doubling the size, increasing by only at most 2Mb or take hints from the number of entries already; in a TBasket).; Migrate the class TFileMerger from the proofplayer library to ROOT I/O library and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:378,rout,routines,378,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['rout'],['routines']
Integrability,". I/O. Unset the kIsReferenced bit before cloning an object in order to avoid the (incorrect/unwanted) registration of the clone. Repaired writing Foreign class in XML files. Extend TDirectoryFile so it can now be derived from. In MakeProject; properly test whether a StreamerElement describe a base class (stl container were not handled correctly).; Remove requirement to have '.' in the PATH to execute the build. Add a new optional parameter to TDirectory::Append: replace.; If replace is true (the default is false), the Append will; first remove from the directory any existing object and; print the message:. Replacing existing OldClass: thename (Potential memory leak). Add a new option parameter to TDirectory::CloneObject: 'autoadd'; If autoadd is true (the default), CloneObject will call the; object 'DirectoryAutoAdd' function (if any). In TDirectory::CloneObject add support for multiple inheritance; from TObject where TObject is not the left most base class. Schema Evolution. Fix schema evolution problem in TTree::Draw by extending support in; TStreamerInfo::ReadValueAux to 'converted' numerical types, (; see issue in ROOT forum). When reading more than one TStreamerInfo for the same versioned; class, we now use the highest possible class version as the current; version of the class. Practically, we update the class version; when reading new (higher versioned) StreamerInfo until the Class; is actually used (i.e. TClass::GetClassVersion is call directly; or indirectly). In particular, if a file has several StreamerInfos for the same; versioned class, we will use the highest version number as the; 'current' class version (as opposed to the lowest until now). For backward compatibility TStreamerInfo::BuildCheck compares the checksum of; the on-file StreamerInfo not only to the current value of the class checksum; but also to the checksum calculated using the older algorithms. This patch extends this test to also be done when comparing 2 on-file StreamerInfos. This remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html:605,message,message,605,io/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html,1,['message'],['message']
Integrability,". I/O; Schema Evolution. Change TExMap hash, key and values from (U)Long_t to (U)Long64_t. This makes TExMap streamable in a portable way. On 64-bit platforms there is; no difference, but on 32-bit platforms all values will now be 64-bit. This fixes a big portability issue with THnSparse which uses TExMap internally; where the versions created on a 32-bit platform could not be read on a 64-bit platform and vice versa.; Avoid reporting I/O error for members of a class that is used only for a transient member; Concrete implementation of TClassGenerator needs to be updated to also avoid the warnings.; Fix the rule lookup based on checksum; Extend support of the schema evolution rules to fixed length array.; Prevent a process abort (due to a call to Fatal) when we are missing the dictionary for (one of) the; content of an STL collection when this collection is 'only' use has a transient member.; Fix the case where the source and target of a rule have the same name.; Avoid using the 'current' StreamerInfo to read an older streamerInfo that is missing (in case of corrupted files). Misc. New TFile plugin for the Hadoop Distributed File System (protocol hdfs:); Unregister stack objects from their TDirectory when the TList tries to delete them.; When streaming a base class without StreamerNVirtual() use an external streamer if it was set.; Many improvement to the I/O run-time performance.; DCache:; Increase readahead size from 8k to 128k and make it settable via DCACHE_RA_BUFFER env var.; dCap client does not ignore ?filetpye=raw and other options, so remove it. The function TFile::GetRelOffset is now public instead of protected.; Corrected the reading of the TFile record of large files.; MakeProject: several updates to improve support for CMS and Atlas data files (add support for auto_ptr, bitset, class name longer than 255 characters, etc.). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v526/index.html:1155,protocol,protocol,1155,io/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v526/index.html,1,['protocol'],['protocol']
Integrability,". Implicit Checks. Implicit Checkers; Even though the implicit checkers do not produce any warnings, they are used to; support the analyzer core and model known APIs. See also; Default Checkers; and Experimental (Alpha) Checkers. Core Implicit Checkers; OS X Implicit Checkers. Core Implicit Checkers. Name, DescriptionExample. core.DynamicTypePropagation; (C++, ObjC); Generate dynamic type information. // C++; class A {; public:; A(int x) {}; virtual int foo();; };. class B: public A {; public:; B(); :A(foo()); // DynamicTypeInfo for 'this' rigion will wrap type 'A'; // unless the base constructor call expression is processed; {}; virtual int foo();; };. // Objective-C; @interface MyClass : NSObject {}; @end. @implementation MyClass; + (void)foo {; MyClass *x = [[self alloc] init];; // DynamicTypeInfo from a cast: from 'id' to 'MyClass *'; }; @end. void test() {; MyClass *x = [MyClass alloc];; // DynamicTypeInfo from a call to alloc:; // from 'id' to 'MyClass *'; }. core.builtin.BuiltinFunctions; (C); Evaluate compiler builtin functions (e.g., alloca()). void test(int x) {; int *p = (int *)__builtin_alloca(8);; // evaluates to AllocaRegion. if(__builtin_expect(x > 10, 0)) // evaluates to 'x > 10'; x = 0;; }. core.builtin.NoReturnFunctions; (C, ObjC); Evaluate ""panic"" functions that are known to not return to the caller. // C; void test() {; panic(); // generate sink; }. // Objective-C; @interface MyObj : NSObject {}; - (void)foo;; @end. @implementation MyObj; - (void)foo {; [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd; object:self; file:(@""somefile.m""); lineNumber:1; description:(@""some text"")];; // generate sink; }; @end. OS X Implicit Checkers. Name, DescriptionExample. osx.cocoa.Loops; (ObjC); Improved modeling of loops using Cocoa collection types. void test() {; id x;; for (x in [NSArray testObject]) {; // assume the value of 'x' is non-nil; }; }. osx.cocoa.NonNilReturnValue; (ObjC); Model the APIs that are guaranteed to return a non-nil value.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html:558,wrap,wrap,558,interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,2,"['interface', 'wrap']","['interface', 'wrap']"
Integrability,". In future release additional implementations of RooAbsDataStore will; be provided that will support new dataset functionality such as the; ability to construct 'joint' dataset from two input datasets without; the need to copy the input data and 'filtered' datasets that represent; a reduced view (in dimensions or by selecting events) of a dataset; without the need to copy content. Various workspace improvements. A number of smaller and larger improvements has been made to the RooWorkspace class. Direct interactive access to contents from CINT -; One can now directly access the contents of any RooWorkspace; on the ROOT commandline through CINT if the RooWorkspace::exportToCint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as the RooWorkspace object. Given e.g. a workspace w, with a Gaussian p.d.f gauss in terms of variables; x,m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:16666,interface,interface,16666,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,". In; the end we get this generated assembly:. LBB0_2: ## %for.body; ## =>This Inner Loop Header: Depth=1; 	movsd	(%rdi), %xmm0; 	movslq	%edx, %r8; 	shlq	$4, %r8; 	ucomisd	(%rcx,%r8), %xmm0; 	jbe	LBB0_4; 	movl	%esi, %edx; LBB0_4: ## %for.inc; 	addq	$16, %rdi; 	incq	%rsi; 	cmpq	%rsi, %rax; 	jne	LBB0_2. All things considered this isn't too bad, but we shouldn't need the movslq or; the shlq instruction, or the load folded into ucomisd every time through the; loop. On an x86-specific topic, if the loop can't be restructure, the movl should be a; cmov. //===---------------------------------------------------------------------===//. [STORE SINKING]. GCC PR37810 is an interesting case where we should sink load/store reload; into the if block and outside the loop, so we don't reload/store it on the; non-call path. for () {; *P += 1;; if (); call();; else; ...; ->; tmp = *P; for () {; tmp += 1;; if () {; *P = tmp;; call();; tmp = *P;; } else ...; }; *P = tmp;. We now hoist the reload after the call (Transforms/GVN/lpre-call-wrap.ll), but; we don't sink the store. We need partially dead store sinking. //===---------------------------------------------------------------------===//. [LOAD PRE CRIT EDGE SPLITTING]. GCC PR37166: Sinking of loads prevents SROA'ing the ""g"" struct on the stack; leading to excess stack traffic. This could be handled by GVN with some crazy; symbolic phi translation. The code we get looks like (g is on the stack):. bb2:		; preds = %bb1; ..; 	%9 = getelementptr %struct.f* %g, i32 0, i32 0		; 	store i32 %8, i32* %9, align bel %bb3. bb3:		; preds = %bb1, %bb2, %bb; 	%c_addr.0 = phi %struct.f* [ %g, %bb2 ], [ %c, %bb ], [ %c, %bb1 ]; 	%b_addr.0 = phi %struct.f* [ %b, %bb2 ], [ %g, %bb ], [ %b, %bb1 ]; 	%10 = getelementptr %struct.f* %c_addr.0, i32 0, i32 0; 	%11 = load i32* %10, align 4. %11 is partially redundant, an in BB2 it should have the value %8. GCC PR33344 and PR35287 are similar cases. //===---------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:32415,wrap,wrap,32415,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['wrap'],['wrap']
Integrability,". It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2543,interface,interfaces,2543,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interfaces']
Integrability,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:563,message,message,563,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,3,"['interface', 'message', 'protocol']","['interfaces', 'message', 'protocol']"
Integrability,". MATLAB; A MATLAB/ROOT interface has been developped by Johannes Kissel.; It is a data interface for reading and writing ROOT files from within MATLAB; just as you do with MATLAB files. For more information, see this announcement at the ROOT Forum. PyROOT. Support for python 2.6 has been added. Older versions will compile fine, but will; have problems when using the buffer interface for C arrays. For user convenience, code was added to load a custom rootlogon.py/.C, if available.; This code is loaded on first use of the ROOT module, and the python rootlogon.py is; loaded as a module. The language was improved by added a _creates property to all MethodProxy methods.; By setting this value to True, objects returned by such methods will be owned (and; reference counted) by the python interpreter.; By default, the Clone() and DrawClone() methods will have _create equal to True. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/doc/v522/index.html:24,interface,interface,24,bindings/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/doc/v522/index.html,3,['interface'],['interface']
Integrability,". Math Libraries. MathCore. Various fixes have been applied in the fitting classes:. Fix issue #46006 for normalization of error resulting from fitting a TGraph; Fix a problem in Chi2 calculation in case of overflow; Fix issue #46601 for avoiding crashes when a linear fit fails.; Fix in the FitData classes the bug #45909 occurring when setting a function range outside histogram range; Fix default integration method to be Gauss algorithm of MathCore instead of the GSL method, when libMathmore is not built or when the plug-in manager fails to load it.; Add a protection against negative log when fitting using the Poisson log likelihood function; Improve calculation of derivative in x for fitted function. This fixes some problem observed when fitting using the error on the coordinates.; Fitter class: add new methods for calculating the error matrix after minimization, Fitter::CalculateHessErrors() and for calculating the Minos errors Fitter::CalculateMinosErrors; FitConfig: add in the configuration the possibility to select a sub-set of the parameters for calculating the Minos errors by using the method FitConfig::SetMinosErrors( listOfParameters ). If no list is passed, by default the Minos error will be computed on all parameters.; UnBinData class: add new constructor for creating a unbin data set passing a range to select the data and copy in the internal array; FitResult: the class now stores a map of the Minos error using as key the parameter index. If the Minos error has not been calculated for the parameter, FitResult::LowerError(i) and FitResult::UpperError(i) returns the parabolic error; ; Add a new class, MinimTransformFunction to perform a transformation of the function object to deal with limited and fixed variables.; This class uses the same transformation which are also used inside Minuit, a sin transformation for double bounded variables and a sqrt transformation for single bound variable defined in the class MinimizerVariableTransformation.; These classes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:400,integrat,integration,400,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['integrat'],['integration']
Integrability,". Math Libraries. MathCore; MathCore includes now classes which were previously contained in libCore, like TMath, TComplex and the TRandom classes. Furthermore, some of the algorithms implemented in the TF1 class have been moved to MathCore. This implies that all other ROOT library using one of these classes, such as libHist, have a direct dependency on the Mathcore library.; Linking with libMathCore is therefore required for running any major ROOT application. It has been added to the list of libraries obtained when doing root-config --libs. N.B.: users building ROOT applications and not using root-config MUST add libMathCore to their list of linking libraries. Together with the libraries merge, many changes have been applied to both TMath and the other mathcore classes.; TMath; A major clean-up and re-structuring has been done for the functions present in TMath. Some functions have been implemented using the STL algorithms, which have better performances in term of CPU time and a template interface has been also added.; Some of the basic special mathematical functions of TMath, like the error function or the gamma and beta functions use now the Cephes implementation from Stephen L. Moshier, which is used as well by the ROOT::Math functions. This implementation has been found to be more accurate and in some cases more efficient in term of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:342,depend,dependency,342,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,"['depend', 'interface']","['dependency', 'interface']"
Integrability,". Math Libraries; Mathcore. New interface class ROOT::Math::DistSampler for; generating random number according to a given distribution.; ; The class defines the methods to generate a single number; DistSampler::Sample()or a data sets; DistSampler::Generate(n, data). The data set; generation can be unbinned or binned in the; given range (only equidistant bins are currently supported); Sampling of 1D or multi-dim distributions is supported via; the same interface; Derived classes; implementing this interface are not provided by MathCore but by; other libraries and they can be instantiated using the plugin; manager. Implementations based on Unuran and Foam exist.; The tutorial math/multidimSampling.C is an example on; how to use this class. New class ROOT::Math::GoFTest for goodness of fit; tests of unbinned data; ; The class implements the Kolmogorov-Smirnov and; Anderson-Darling tests for two samples (data vs data ) and; one sample (data vs distribution); For the data vs distribution test, the user can compare using a; predefined distributions (Gaussian, LogNormal or Exponential) or; by passing a user defined PDF or CDF.; Example 1: perform a 2 sample GoF test from two arrays,; sample1[n1] and sample2[n2] containing the data; ; ROOT::Math::GoFTest goftest(n1, sample1, n2, sample2);; double pValueAD = goftest.AndersonDarling2SamplesTest();; double pValueKS = goftest.KolmogorovSmirnov2SamplesTest();; ; The class can return optionally also the test statistics instead of; the p value.; Example 2: perform a 1 sample test with a pre-defined; distribution starting from a data set sample[n]. ROOT::Math::GoFTest goftest(n, sample, ROOT::Math::GoFTest::kGaussian);; double pValueAD = goftest.AndersonDarlingTest();; double pValueKS = goftest.KolmogorovSmirnovTest();; . Example 3: perform a 1 sample test with a user-defined; distribution provided as cdf; ; ROOT::Math::Functor1D cdf_func(&ROOT::Math::landau_cdf);; ROOT::Math::GofTest goftest(n, sample, cdf_func, ROOT::Math::GoFTes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:32,interface,interface,32,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,3,['interface'],['interface']
Integrability,. Misc; A new directory minicern has been introduced. This directory contains; the zebra and hbook files required to build the h2root and g2root utilities.; These small files remove dependencies on the old CERNLIB files.; h2root and g2root as well as the library libHbook are; automatically built when configuring ROOT and a Fortran compiler found in the system.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v520/index.html:182,depend,dependencies,182,misc/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v520/index.html,1,['depend'],['dependencies']
Integrability,". Misc; Quick Look plugin for MacOS X. New Quick Look plugin that allows quick inspection of the content; of a ROOT file. Quick Look is available on MacOS X since version 10.5 (Leopard). To use QL; select an file icon in the Finder and hit the space bar. For all file types; supported by QL you will get a window showing the file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern.ch/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTQL.qlgenerator to /Library/QuickLook (global, i.e. for all users on a; system) or to ~/Library/QuickLook (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootql rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook directory. SpotLight plugin for MacOS X. This is a Spotlight plugin that allows ROOT files to be indexed by SL.; Once indexed SL can find ROOT files based on the names and titles of the; objects in the files. Spotlight is available on MacOS X since version 10.4 (Tiger). To use SL; select the SL icon on the top right of the menubar and type in a search text. Get the binary for the ROOTSL plugin from:. ftp://root.cern.ch/root/ROOTSL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTSL.mdimporter to /Library/Spotlight (global, i.e. for all users on a; system) or to ~/Library/Spotlight (local, this user only) directory.; You may need to create that folder if it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html:562,depend,depends,562,misc/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html,1,['depend'],['depends']
Integrability,". MonteCarlo Libraries; VMC. Update of the VMC interfaces for multi-threading:; TVirtualMC and TVirtualMCApplication instances are now declared thread local.; Added new functions in TVirtualMC and TVirtualMCApplication for multi-threading; applications with default implementation. ; In TVirtualMC:. virtual Bool_t IsMT() const { return kFALSE; }. In TVirtualMCApplication:. virtual TVirtualMCApplication* CloneForWorker() const { return 0;}; virtual void InitForWorker() const {}; virtual void BeginWorkerRun() const {}; virtual void FinishWorkerRun() const {}; virtual void Merge(TVirtualMCApplication* /*localMCApplication*/) {}. Removed default implementation of newly added functions in TVirtualMC:. virtual Bool_t IsRootGeometrySupported() const = 0;; virtual Bool_t GetMaterial(Int_t imat, TString& name,...) = 0;; virtual Bool_t CurrentBoundaryNormal(..) = 0;. Removed deprecated functions from TVirtualMC:. // Return parameters for material specified by material number imat; // Deprecated - replaced with GetMaterial(); virtual void Gfmate(Int_t imat, char *name, Float_t &a, Float_t &z,; Float_t &dens, Float_t &radl, Float_t &absl,; Float_t *ubuf, Int_t &nbuf) = 0;. // Return parameters for material specified by material number imat; // (in double precision); // Deprecated - replaced with GetMaterial(); virtual void Gfmate(Int_t imat, char *name, Double_t &a, Double_t &z,; Double_t &dens, Double_t &radl, Double_t &absl,; Double_t *ubuf, Int_t &nbuf) = 0;. // Check the parameters of a tracking medium; // Deprecated; virtual void Gckmat(Int_t imed, char *name) = 0;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v534/index.html:47,interface,interfaces,47,montecarlo/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v534/index.html,1,['interface'],['interfaces']
Integrability,". MonteCarlo; TDatabasePDG; The method ReadPDGTable of TDatabasePDG was setting the stable flags for; all particles regardless of their width. TParticlePDG; The value reported in the fLifetime variable of TParticlePDG is in seconds; while in the documentation is was indicated in nanoseconds. pdg_table.txt; Particles with a width greater than 1e-10 have now the stable flag set to 1. TVirtualMC; New functions added in the interface:. For activation of collecting TGeo tracks:; virtual void SetCollectTracks(Bool_t collectTracks);; virtual Bool_t IsCollectTracks() const;. For accessing the normal vector of the crossing volume surface; on the geometry boundary:; virtual Bool_t CurrentBoundaryNormal(Double_t &x, Double_t &y, Double_t &z) const;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v528/index.html:424,interface,interface,424,montecarlo/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v528/index.html,1,['interface'],['interface']
Integrability,". Networking Libraries; New TSSLSocket class; The new TSSLSocket class wraps a TSocket with SSL encryption. This class; is used to provide support for reading TWebFiles over https. New TUDPSocket class; The new TUDPSocket uses UDP as protocol where TSocket uses TCP. This class; can be used to talk to UDP servers. XROOTD; Starting with this version (5.32/00) Xrootd is no longer distributed with ROOT.; The package is still needed to build the modules 'netx', 'proofx' and 'proofd' and must be; provided as external. Xrootd can be downloaded from the main web site and its installation; is straightforward. A script to automatize the installation process is provided at; build/unix/installxrootd.sh ; scripts to set-up the environment at; bin/setxrd.sh and bin/setxrd.csh .; Note that the Xrootd team has dropped support for Windows,; so the Xrootd-related components of ROOT will only be built on Unices (Linux, Solaris, MacOsX).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v532/index.html:71,wrap,wraps,71,net/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v532/index.html,2,"['protocol', 'wrap']","['protocol', 'wraps']"
Integrability,". Networking. TMessage now has schema evolution and TRef (i.e. ProcessID) support. To; enable; schema evolution for all messages call; TMessage::EnableSchemaEvolutionForAll(kTRUE).; To enable it only for a specific message call; mess->EnableSchemaEvolution(kTRUE).; The default for schema evolution is off. The streamer and process id; information are send only once per socket (and is supported for all; types of; sockets, TSocket, TPSocket and TXSocket). If you communicate between; two; ROOT based applications, check the version numbers on both sides. If; they; are not the same enable the schema evolution support (in case ROOT; objects; are transferred). . XROOTD. New version 20080621-0000 containing several improvements and fixes; Server:. New daemon 'cmsd' supposed to replace 'olbd' with improved performances; Improved polling strategy; Fix problem with handling writev creating unjustified disconnections ; Fix problem with setrlimit on MacOsX Leopard. Client:; ; Fix a nasty memory leak in XrdClientCacheRead affecting; processing via TChain; Optimized file closing recipe; Fix; potential cache thrashing problem with big blocks requests. Fixes / improvements in the GSI plug-in:; ; support for large (> 32 bits) certificate serial; numbers in CRL handling; support for an external function for DN-to-username; mapping function; provide example for an LDAP based search; fixed a few problem with return code checking. netx. TXNetFile:; . Enable dynamic cache size synchronization; ; Enable per-instance control of the cache parameters; also for RAW files; by; default cache is OFF for these files, but there maybe cases in which the cache can; improve performances.; Remove call to XrdClient::Sync in SysStat. Correctly honor the create/recreate options coming from TFile::Open(); Allow the size of the (written) file to be retrieved after the Close (solves several reported file size mismatches).; . TXNetSystem:; ; Fix problem with GetDirEntry: the entry object was; going out-of-scope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:120,message,messages,120,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,2,['message'],"['message', 'messages']"
Integrability,. Networking. Xrootd; ; New version 20100913-0630; including several consolidation fixes (many due to Coverity reports); and includes the new Bonjour/Avahi interface used for worker; autodiscovery in PROOF. TMessage and TSocket; . TMessage now relies on the new interface TBuffer::TagStreamerInfo instead of TBuffer::IncrementLevel which had the disadvantage of being called not only; during writing but also during reading (where there is no need to keep track of the TStreamerInfo used).This change allows to keep the calls to IncrementLevel/DecrementLevel only in the case the buffer is a TBufferXML. The implementation of TSocket::RecvStreamerInfos has been fixed to properly handle the case where there are abstract classes (in this case GetStreamerInfo() can not be called on the abstract class until it has; been called during the processing of one of the concrete derived classes) and the case of STL containers. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v528/index.html:156,interface,interface,156,net/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v528/index.html,2,['interface'],['interface']
Integrability,". Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:5382,message,message,5382,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['message'],['message']
Integrability,". PROOF System. Added functionality; ; Added interface to simplify the creation of the performance; tree: two new methods TProof::SetPerfTree(""<file>"") and; TProof::SavePerfTree(""<file>"", ""<queryref>"") allow set; and/or save the information to a given file path. The perfomance tree; settim=ngs are diabled after each query, so they need to be enabled; each time.; Add support for a command line test run of 'proofserv'; this is; useful to test that the environment is setup correctly.; In TProofBench::DrawCPU, add possibility to extract of a couple; of numbers supposed to give an idea of the computing specs of the; cluster being benchmarked. These are the maximum rate for the standard; CPU intensive task and the normalized, per worker, rate. Both are; expressed in RNGPS (RaNdom Generation Per Second).; Add class TProofPerfAnalysis collecting a set of tools to; analyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:45,interface,interface,45,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['interface'],['interface']
Integrability,". PROOF System; NB: Starting with version 5.32/00, Xrootd; is not distributed any longer with ROOT but has become an external package.; If not avaibable the PROOF modules 'proofx' and 'proofd' will not be built.; The PROOF core modules, however, are built. Namely, PROOF-Lite will be; available even when Xrootd is not.; New functionality. Creating PAR packages from ROOT data files: it is now possible to; use TFile::MakeProject to create a PAR file to read the file.; Add support for backend-dependent record formatting of PROOF monitoring.; This is achieved by introducing a new layer, described by the abstract; interface TProofMonSender, with the record format defined in the backend; implemenation (currently TProofMonSenderML, for MonaLisa, and; TProofMonSenderSQL, for SQL backends). Currently three types of records; are sent: 'summary' (derived from what was currently posted), 'dataset',; with entries per dataset processed in the query, and 'files', with; entries per file processed in the query. In SQL terms, each of this; records corresponds to a different table. Sending of any of the three; records can be toggled independently.; In TProofMgr, add 'ping' functionality to test in non-blocking way if; a PROOF service is listening at a given port of a given host.; Improvements. In PROOF-Bench, file generation, add the possibility to change; only the generating function, passed as TMacro. Add also check on the; free space on the device and skip file generation if less than 10% or; less than 1 GB.; Record in TStatus also the max memory usage on the master and printed; via TStatus::Print; this allow a quick visualisation of the overall; memory usage at the end of the query.; Import version 0.9.6 of afdsmgrd; Make sure that the name(s) of the processed dataset(s) are registered; in the TFileInfo objects being processed, so that it can be used for; monitoring.; In XrdProofd, add possibility to skip the checks for the data; directories during session startup, as they may signi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:494,depend,dependent,494,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,". PROOF release notes. PROOF. New functionality. PROOF-Lite2-tier; realization of PROOF intended for multi-core machines; the client; starts directly the workers; no daemon is required. To start a session; just use TProof::Open("""") or TProof::Open(""lite""). From there on; everything should be as in normal PROOF, though some functionality may; not have been ported yet. To start a standard PROOF; session (i.e. via daemons) on the localhost use; TProof::Open(""localhost"").XrdProofd plug-in. Possibility to define the list worker directly in the; xrootd config file (new directive xpd.worker, see Wiki reference pages); Support for automatic reconnections in the case xrootd; is restarted; Dedicated admin area (under <xrd.admin>/.xproofd.<port>) to; keep information about active and terminated sessions, and active; clients. This is used to reguraly check the client and session; activity, to cleanup orphalin sessions and to shutdown inactive client; connections. ; domain + level control of printout message. Dynamic ""per-query"" scheduling. Dynamic worker startup. It can be enabled by the cluster; administrator with the 'xpd.putrc Proof.DynamicStartup 1' directive; in the config file. The effect is that a session starts only on; the master. When a query is submitted (call to TProof::Process),; the session master contacts the scheduler.; In response it receives a list of workers and starts the worker; processes. The environment is copied from the master to the workers.; It consist of: the include and library paths, the set of enabled; packages as well as the macros loaded by the user. . Flexible and fault-tolerant workers. A packet resubmitting mechanism. When a worker dies all the; packets that it processed are resubmitted.; Added the possibility to handle dynamically removed workers and partly processed; packets (when a worker is stopped while processing a packet it finishes; the current event and the rest of the packet is reassigned to another workers).; It's done by a new meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:1003,message,message,1003,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['message'],['message']
Integrability,". PROOF. New functionality. ; Dataset management. ; New class TProofDataSetManager definining the interface; of PROOF to dataset metainfo database; New class TProofDataSetManagerFile implementating; TProofDataSetManager using the file system as back-end;  the; separation is needed to load dataset menagers using different backends;; for example ATLAS foresees to have a MySQL-based implementation.; The instance of the appropriate TProofDataSetManager is; instantiated via the plugin manager; by default an instance; of TProofDataSetManagerFile; managing the <sandbox>/datasets; area is created. The directive 'Proof.DataSetManager' can be used to; modify the settings for TProofDataSetManagerFile or to load a; different dataset manager; for example, to '/pool/datasets' as area for; the dataset information, the following directive can be added to the; xrootd config file; xpd.putrc Proof.DataSetManager file dir:/pool/datasets. Interface to TProofMgr::GetSessionLogs() in the dialog; box. The graphics layout of the logbox has been re-designed, with new; buttons to grep the logs and to save them to a file. It is also; possible to choose the range of lines to be displayed and the subset of; nodes.; ; Support for connection control base on the UNIX group; (new directive 'xpd.allowedgroups; <grp1>,<grp2>, ...'). Improvements:. ; In the case of mismatch between the expected and actual; number of processed events, send back to the client the list of failed; packets.; Implement the classic strategy of the TPacketizer in; TPacketizerAdaptive; the strategy can be changed from adaptive; (default) to TPacketizer with: ""PROOF_PacketizerStrategy"" parameter to; PROOF; The max workers per node can now be also set in the; xrootd config file with.        xpd.putrc ; Packetizer.MaxWorkersPerNode: <desired number>. Make fCacheDir and fPackageDir controllable via directive; . Fixes. ; Two memory leaks in TProofServ affecting repeated runs; withing the same session. Fix a problem cleaning-up the in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html:98,interface,interface,98,proof/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html,1,['interface'],['interface']
Integrability,". ROOT Version 5.20/00 Release Notes. ROOT Version 5.20/00 Release Notes. ROOT version 5.20/00 has been released June 25, 2008.; In case you are upgrading from version 5.14, please read the releases notes; of version 5.16 and version 5.18 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version520.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html:539,interface,interface,539,doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.22/00 Release Notes. ROOT Version 5.22/00 Release Notes. ROOT version 5.22/00 has been released on December 18, 2008.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18 and version 5.20 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version521.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Kyle Cranmer,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Josef Leydold,; Sergei Linev,; An",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html:554,interface,interface,554,doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.24/00 Release Notes. ROOT Version 5.24/00 Release Notes. ROOT version 5.24/00 will be released end of June 2009.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20 and version 5.22 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version521.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Kevin Belasco, N/A, Princeton University for MCMC, ; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Or Cohen, CERN & Weizmann, TMVA; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/Atlas, RooStats; Dominik Dannheim, MPI-Munich/Atlas, TMVA ; Valeri Fine, BNL/STAR,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v524/index.html:555,interface,interface,555,doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v524/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.26/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.26/00 Release Notes. ROOT version 5.26/00 will be released on December 15 2009.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22 and version 5.24 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52600/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Brian Bockelman, UNL,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/Atlas, RooStats; Valeri Fine, BNL/STAR,; Lucie Flekova, CERN/SFT summer student,; Fabrizio Furano, CERN/IT, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Ali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html:663,interface,interface,663,doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v526/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.28/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.28/00 Release Notes. ROOT version 5.28/00 has been released on December 15 2010.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22, 5.24 and version 5.26 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Alberto Annovi, INFN, TH1, ; Kevin Belasco, Princeton University, RooStats,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Jason Detwiler, LBL, TClonesArray, ; Valeri Fine, BNL/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html:670,interface,interface,670,doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.30/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.30/00 Release Notes. ROOT version 5.28/00 has been released on December 15 2010.; In case you are upgrading from an old version, please read the releases notes; of version 5.16, 5.18, 5.20, 5.22, 5.24, 5,26 and version 5.28 in addition to these notes. The release of version 5.30 is scheduled for June 27, 2011. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Dario Berzano, INFN and University of Torino, ALICE, Proof,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html:736,interface,interface,736,doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.32/00 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.32/00 Release Notes. ROOT version 5.32/00 has been released on Nov 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 29, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/ATLAS, RooStats,; Sven Kreiss, NYU/ATLAS, RooStats,; Gena Kukartsev, CERN and FNAL/CMS, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Christian Gumpert, CERN and University Dresden/ATLAS, Math,; Wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html:707,interface,interface,707,doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". ROOT Version 5.33/01 Release Notes. Quick Links:; ROOT Homepage; Download; Reference Guide. Search. ROOT. » Download; » Release Notes. ROOT Version 5.33/01 Release Notes. ROOT version 5.32/00 has been released on November 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 30, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html:712,interface,interface,712,doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html,3,['interface'],"['interface', 'interfaces']"
Integrability,". Running the analyzer from the command line. Running the analyzer from the command line; Static Analyzer is by design a GUI tool. Its purpose is to find buggy execution; paths in the program, and such paths are very hard to comprehend by looking at; a non-interactive standard output. It is possible, however, to invoke the; Static Analyzer from the command line in order to obtain analysis results, and; then later view them interactively in a graphical interface. The following; tools are used commonly to run the analyzer from the command line. Both tools; are wrapper scripts to drive the analysis and the underlying invocations of the; Clang compiler:. Scan-Build; is an old and simple command-line tool that emits static analyzer warnings as HTML files while compiling your project. You can view the analysis results in your web browser.; . Useful for individual developers who simply want to view static analysis results at their desk, or in a very simple collaborative environment.; . Works on all major platforms (Windows, Linux, macOS) and is available as a package in many Linux distributions.; . Does not include support for cross-translation-unit analysis.; . CodeChecker; is a web server that runs the Static Analyzer on your projects on demand and maintains a database of issues.; . Perfect for managing large amounts of Static Analyzer warnings in a collaborative environment.; . Generally much more feature-rich than scan-build.; ; Supports incremental analysis: Results can be stored in a database, subsequent analysis runs can be compared to list the newly added defects.; Cross Translation Unit (CTU) analysis is supported fully on Linux via CodeChecker.; Can run clang-tidy checkers too.; Open source, but out-of-tree, i.e. not part of the LLVM project. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html:456,interface,interface,456,interpreter/llvm-project/clang/www/analyzer/command-line.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,". Running the analyzer within Xcode. Running the analyzer within Xcode. What is it?; Since Xcode 3.2, users have been able to run the Clang Static Analyzer; directly; within Xcode.; It integrates directly with the Xcode build system and; presents analysis results directly within Xcode's editor.; Can I use the open source analyzer builds with Xcode?; Yes. Instructions are included below. Viewing static analyzer results in Xcode. Key features:. Integrated workflow: Results are integrated within Xcode. There is; no experience of using a separate tool, and activating the analyzer requires a; single keystroke or mouse click.; Transparency: Works effortlessly with Xcode projects (including iPhone projects).; Cons: Doesn't work well with non-Xcode projects. For those,; consider using scan-build. Getting Started; Xcode is available as a free download from Apple on the Mac; App Store, with instructions; available for using the analyzer.; Using open source analyzer builds with Xcode; By default, Xcode uses the version of clang that came bundled with; it to analyze your code. It is possible to change Xcode's behavior to use an; alternate version of clang for this purpose while continuing to use; the clang that came with Xcode for compiling projects.; Why try open source builds?; The advantage of using open source analyzer builds (provided on this website); is that they are often newer than the analyzer provided with Xcode, and thus can; contain bug fixes, new checks, or simply better analysis.; On the other hand, new checks can be experimental, with results of variable; quality. Users are encouraged to file bug reports; (for any version of the analyzer) where they encounter false positives or other; issues.; set-xcode-analyzer; Starting with analyzer build checker-234, analyzer builds contain a command; line utility called set-xcode-analyzer that allows users to change what; copy of clang that Xcode uses for analysis:. $ set-xcode-analyzer -h; Usage: set-xcode-analyzer [options",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html:185,integrat,integrates,185,interpreter/llvm-project/clang/www/analyzer/xcode.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html,2,['integrat'],"['integrated', 'integrates']"
Integrability,". Source Languages; ================. What source languages are supported?; ------------------------------------. LLVM currently has full support for C and C++ source languages through; `Clang <https://clang.llvm.org/>`_. Many other language frontends have; been written using LLVM, and an incomplete list is available at; `projects with LLVM <https://llvm.org/ProjectsWithLLVM/>`_. I'd like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?; ----------------------------------------------------------------------------------------------------------------------------------------; Your compiler front-end will communicate with LLVM by creating a module in the; LLVM intermediate representation (IR) format. Assuming you want to write your; language's compiler in the language itself (rather than C++), there are 3; major ways to tackle generating LLVM IR from a front-end:. 1. **Call into the LLVM libraries code using your language's FFI (foreign; function interface).**. * *for:* best tracks changes to the LLVM IR, .ll syntax, and .bc format. * *for:* enables running LLVM optimization passes without a emit/parse; overhead. * *for:* adapts well to a JIT context. * *against:* lots of ugly glue code to write. 2. **Emit LLVM assembly from your compiler's native language.**. * *for:* very straightforward to get started. * *against:* the .ll parser is slower than the bitcode reader when; interfacing to the middle end. * *against:* it may be harder to track changes to the IR. 3. **Emit LLVM bitcode from your compiler's native language.**. * *for:* can use the more-efficient bitcode reader when interfacing to the; middle end. * *against:* you'll have to re-engineer the LLVM IR object model and bitcode; writer in your language. * *against:* it may be harder to track changes to the IR. If you go with the first option, the C bindings in include/llvm-c should help; a lot, since most languages have strong support fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:3700,interface,interface,3700,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['interface'],['interface']
Integrability,". Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9217,message,messaged,9217,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['message'],['messaged']
Integrability,". TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMemFile *file = new TMemFile(""hsimple.memroot"",""RECREATE"");. Will create an empty in-memory of (currently fixed) size 32MB. file->ResetAfterMerge(0);. Will reset the objects in the TDirectory list of objects; so that they are ready for more data accumulations (i.e.; returns the data to 0 but keep the customizations). TFile::MakeProject. New option 'par' in to pack in a PAR file the generated; code. The first argument defines the directory and the name of the package.; For example, the following generates a PAR package equivalent to; tutorials/proof/event.par:. root [] TFile *f = TFile::Open(""http://root.cern/files/data/event_1.root""); root [] f->MakeProject(""packages/myevent.par"", ""*"", ""par"");. Note that, because a PAR file is a tarball, for the time being, on Windows; only the package directory and the files are generated and a warning message; is printed. Properly handle the case of class which version is zero and to properly initialization array of objects (streamerElement type kStreamLoop). Fix support for call to MakeProject like:. gFile->MakeProject(""./classCode/"",""*"",""RECREATE++""). Better error handling if the source file failed to be created; or if the project directory can not be created. TParallelMergingFile. Introduce the class TParallelMergingFile part of the net package. This class connect ot a parallel merge server; and upload its content every time Write is called on the file object. After the upload the object of classes; with a ResetAfterMerge function are reset. A TParallelMergingFile is created whether a ?pmerge option is passed to TFile::Open as part of the file name.; For example:. TFile::Open(""mergedClient.root?pmerge"",""RECREATE""); // For now contact localhost:1095; TFile::Open(""mergedClient.root?pmerge=localhost:1095"",""RECREATE"");; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:5431,message,message,5431,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['message'],['message']
Integrability,". The ``flags`` field is set to either 0 if no helper functions are needed; or (1<<25) if they are. d. The helper functions are initialized (if present). e. The variable itself is set to its initial value. f. The ``isa`` field is set to ``NULL``. Access to ``__block`` variables from within its lexical scope; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to ""move"" the variable to the heap upon a ``copy_helper`` operation the; compiler must rewrite access to such a variable to be indirect through the; structures ``forwarding`` pointer. For example:. .. code-block:: c. int __block i = 10;; i = 11;. would be rewritten to be:. .. code-block:: c. struct _block_byref_i {; void *isa;; struct _block_byref_i *forwarding;; int flags; //refcount;; int size;; int captured_i;; } i = { NULL, &i, 0, sizeof(struct _block_byref_i), 10 };. i.forwarding->captured_i = 11;. In the case of a ``Block`` reference variable being marked ``__block`` the; helper code generated must use the ``_Block_object_assign`` and; ``_Block_object_dispose`` routines supplied by the runtime to make the; copies. For example:. .. code-block:: c. __block void (voidBlock)(void) = blockA;; voidBlock = blockB;. would translate into:. .. code-block:: c. struct _block_byref_voidBlock {; void *isa;; struct _block_byref_voidBlock *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);; void (*byref_dispose)(struct _block_byref_voidBlock *);; void (^captured_voidBlock)(void);; };. void _block_byref_keep_helper(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src) {; //_Block_copy_assign(&dst->captured_voidBlock, src->captured_voidBlock, 0);; _Block_object_assign(&dst->captured_voidBlock, src->captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);; }. void _block_byref_dispose_helper(struct _block_byref_voidBlock *param) {; //_Block_destroy(param->captured_voidBlock, 0);; _Block_object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:13807,rout,routines,13807,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['rout'],['routines']
Integrability,". The; number of entries in the reorder buffer defaults to the value specified by field; `MicroOpBufferSize` in the target scheduling model. Instructions that are dispatched to the schedulers consume scheduler buffer; entries. :program:`llvm-mca` queries the scheduling model to determine the set; of buffered resources consumed by an instruction. Buffered resources are; treated like scheduler resources. Instruction Issue; """"""""""""""""""""""""""""""""""; Each processor scheduler implements a buffer of instructions. An instruction; has to wait in the scheduler's buffer until input register operands become; available. Only at that point, does the instruction becomes eligible for; execution and may be issued (potentially out-of-order) for execution.; Instruction latencies are computed by :program:`llvm-mca` with the help of the; scheduling model. :program:`llvm-mca`'s scheduler is designed to simulate multiple processor; schedulers. The scheduler is responsible for tracking data dependencies, and; dynamically selecting which processor resources are consumed by instructions.; It delegates the management of processor resource units and resource groups to a; resource manager. The resource manager is responsible for selecting resource; units that are consumed by instructions. For example, if an instruction; consumes 1cy of a resource group, the resource manager selects one of the; available units from the group; by default, the resource manager uses a; round-robin selector to guarantee that resource usage is uniformly distributed; between all units of a group. :program:`llvm-mca`'s scheduler internally groups instructions into three sets:. * WaitSet: a set of instructions whose operands are not ready.; * ReadySet: a set of instructions ready to execute.; * IssuedSet: a set of instructions executing. Depending on the operands availability, instructions that are dispatched to the; scheduler are either placed into the WaitSet or into the ReadySet. Every cycle, the scheduler checks if instru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:37359,depend,dependencies,37359,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,". These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7091,interface,interface,7091,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,". This is called a; divergent cycle exit. If the cycle is irreducible, the diverged path; may re-enter and eventually reach a join within the cycle. Such a join; should be examined for the :ref:`diverged entry; <convergence-diverged-entry>` criterion. Nodes along the diverged path that lie outside the cycle experience; *temporal divergence*, when two threads executing convergently inside; the cycle produce uniform values, but exit the cycle along the same; divergent path after executing the header a different number of times; (informally, on different iterations of the cycle). For a node ``N``; inside the cycle the outputs may be uniform for the two threads, but; any use ``U`` outside the cycle receives a value from non-converged; dynamic instances of ``N``. An output of ``U`` may be divergent,; depending on the semantics of the instruction. .. _uniformity-analysis:. Static Uniformity Analysis; ==========================. Irreducible control flow results in different cycle hierarchies; depending on the choice of headers during depth-first traversal. As a; result, a static analysis cannot always determine the convergence of; nodes in irreducible cycles, and any uniformity analysis is limited to; those static instances whose convergence is independent of the cycle; hierarchy:. .. _convergence-m-converged:. **m-converged static instances:**. A static instance ``X`` is *m-converged* for a given CFG if and only; if the maximal converged-with relation for its dynamic instances is; the same in every cycle hierarchy that can be constructed for that CFG. .. note::. In other words, two dynamic instances ``X1`` and ``X2`` of an; m-converged static instance ``X`` are converged in some cycle; hierarchy if and only if they are also converged in every other; cycle hierarchy for the same CFG. As noted earlier, for brevity, we restrict the term *converged* to; mean ""related under the maximal converged-with relation for a given; cycle hierarchy"". Each node ``X`` in a given CFG is rep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:17990,depend,depending,17990,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['depend'],['depending']
Integrability,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6528,interface,interfaces,6528,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interfaces']
Integrability,". To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a suffix ""`_N`"" where `N` is equal to; `fFileNumber+1`. By default a Root session starts with `fFileNumber=0`.; One can set `fFileNumber` to a different value via; `TTree::SetFileNumber()`. In case a file named ""`_N`"" already exists,; the function will try a file named ""`__N`"", then ""`___N`"", etc. The; maximum tree size can be set via the static function; `TTree::SetMaxTreeSize()`. The default value of `fgMaxTreeSize` is 100; GB. If the current file contains other objects (like **`TH1`** and; **`TTree`**), these objects are automatically moved to the new file. ### User Info Attached to a TTree Object. The function `TTree::GetUserInfo()` allows adding any object defined by; a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:16444,depend,depending,16444,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depending']
Integrability,". Tree Libraries; Performance. Automatic support for multiple TTreeCache per TFile.; Multiple TTreeCache per TFile for reading are supported by using the existing TTree::SetCacheSize(Long64_t) interface.; In addition, a TTreeCache for a TTree can be added using TFile::SetCacheRead(TFileCacheRead*, TObject*), where the second (optional) argument is a pointer to the TTree. The cache can be removed by setting the pointer to 0. In that case the user will have to take ownership for the cache.; Similarily, a pointer to the TTreeCache for a TTree can be obtained using TFile::GetCacheRead(TObject*). In TBuffer::Expand, when shrinking the buffer do not shrink below the size of the; data already accumulated in the buffer (i. no less than the value of TBuffer::Length). In TBranch::SetBasketSize, instead of using the hard minimum of 100, use; 100 + the length of the branch name (as 100 is too small to hold the; basket's key information for any branch name larger than 30 characters). Reading form text file. Reworked TTree::ReadStream and TTree::ReadFile mainly to fix delimited reading of string columns:. TLeaf::ReadValue now takes an optional delimiter argument that is ignored for all but TLeafC. Here, input stops when reading this character, instead of at the first whitespace.; Use that in TTree::ReadStream() to delimit reading of TLeafC.; TTree::ReadStream now tokenizes the row itself, and passes a stringstream containing nothing but the current column to TLeaf::ReadValue.; Separate concepts of number of input line (for communication with user) and number of good lines (as returned).; Fix windows files leaving '\n' in branch names when reading them from the file.; Add error message for TLeaf::ReadValue(), i.e. if ReadValue() is called on a derived class that doesn't implement it.; Updated and clarified the documentation. TEntryList. Add new methods to find the base location of files and to modify it.; This allows to relocate the entry-lists to be able to use them of a; system w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html:193,interface,interface,193,tree/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html,1,['interface'],['interface']
Integrability,". Tree. Restore support for IsAutoDelete in a TBranchElement (IsAutoDelete is an explicit request by the user to have the object deleted/newed each time GetEntry is called).; Allow .root in the name of directory in TChain::Add and TChain::AddFile (however in this case the root file must be ending .root.); Improve support for circular TTree friendship in LoadTree.; Insure that the in-memory tree (not attached to a file) are saved in their new style (i.e. each basket saved separately) and prevent the printing of the misleading error message:; Error in : Cannot create key without file ; Repaired TTreeSQL:; The existing code was not compatible with the change made in TTree to reduce the number of baskets in memory.; If the TreeFriend is entered via a TTree*, properly detect that it is in the same file and do not record the filename (since we will alway know where to find it.); Add "","" in the list of special characters replaced by ""_"" in the TTree::MakeClass; and TTree::MakeCode functions.; The fast cloning now explicitly rejects trying to merge TTrees with different split level; The fast cloning now supports the case where one of the branch in the output tree in; not present and also supports the case where branch are not the same order.; New bit flag kMapObject [mybranch->ResetBit(kMapObject)] to explicitly disable the; object registration during streaming within a branch (Use only if you are sure that there; is not a pointer pointing back to the nesting object within this branch). Fix tree->Draw(""s1.value"");; when the top level branch does not have a trailing dot; (and hence the real branch name is only 'value'). Fixed support for vector<bool> and vector<string> ; Added support for top level object that do not inherit from TObject _AND_ have a custom streamer (like std::string and TString);; Tree Viewer. In TParallelCoordVar the ""average marker"" for candle plots was not painted at; the right place in case of horizontal view.; Protection added in:; TParallelCoord::TPara",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v522/index.html:537,message,message,537,tree/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v522/index.html,1,['message'],['message']
Integrability,". Tree; Performance. Introduce support for TTree with variable cluster size (i.e. value of fAutoFlush).; Iterating through the cluster should be done via the new class TTree::TClusterIterator (i.e. this replaces += fAutoFlush):. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(which_entry_to_start_from);; Long64_t clusterStart;; while( (clusterStart = clusterIter()) < tree-<GetEntries()) {; printf(""The cluster starts at %lld and ends at %lld\n"",clusterStart,clusterIter.GetNextEntry()-1);; }; See TTreeCache::FillBuffer for a concrete usage example. Significant improvement of the performance of SetBranchAddress/SetAddress (by a factor 3 to 10 depending on the length/complexity of the classname).; Prevent the unlimited growth of the TBasket's buffer even if the basket is reused.; When the basket is Reset (this happens when it is written and will be reused),; if the TBuffer size is greater than. - twice the data in the current basket; and - twice the average data in each basket (of this branch); and - twice the requeste basket size (TBranch::GetBasketSize).; the size of the buffer is reduced to the max of; 'the data in the current basket' and 'the average' and the requested; buffer size and aligned to next highest multiple of 512.; In TBranchRef distinguish between the entry we need (now called RequestedEntry) and the; entry we have read (fReadEntry) so that we can avoid re-reading the same entry too many; times when executing TRef::GetObject.; Reduce by 40% the time taken GetEntry for a branch created using a leaflist (exclusive of the decompression time).; Introduce TVirtualPerfStats::FileUnzipEvent to be able to keep track of the cost of unzipping and use this in TTreePerfStats and TBasket ... This give a good picture of where the time in unzip or in unstreaming; Add more clusters to the TTreeCache buffer until fBufferMinSize is hit to avoid severely underfilled buffer when; a low number of branches is selected/used.; When reading backwards, make sure to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:663,depend,depending,663,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,1,['depend'],['depending']
Integrability,". Tutorials. New tutorial $ROOTSYS/tutorials/graphics/mass_spectrum.C. It; produces the following output:; . New tutorial $ROOTSYS/math/goftest.C showing the example; usage of the new ROOT::Math::GoFTest class. New tutorial $ROOTSYS/math/multiDimSampling.C showing the example; usage of the new ROOT::Math::DistSampler interface for; random generation from arbitrary functions using Unuran or Foam. New tutorial $ROOTSYS/math/kdTreeBinning.C showing the example; usage of the new TKDTreeBinning class. New tutorial $ROOTSYS/fit/NumericalMinimization.C showing; a minimization example (Rosenbrock function) using the; ROOT::Math::Minimizer interface. New tutorial $ROOTSYS/fit/exampleFit3D.C showing; a simple fit example of 3D points with a 3D function. New tutorial $ROOTSYS/fit/TSVDUnfoldExample.C showing; an example of the new TSVDUnfold class. New Roostats tutorials:. New Demos that take name for file, workspace, modelconfig, and data, then use the corresponding calculator tool. If the file is not specified it will read an file produced from running the HistFactory tutorial example. StandardProfileLikelihoodDemo.C: ; StandardFeldmanCousinsDemo.C: ; StandardBayesianMCMCDemo.C: ; StandardBayesianNumericalDemo.C: ; StandardProfileInspectorDemo.C: . Demonstrate some new PDFs. TestNonCentral.C: demonstrates non central chi-square; JeffreysPriorDemo.C: demonstrates Jeffreys Prior. Instructional Examples. IntervalExamples.C: Standard Gaussian with known answer using 4 techniques; FourBinInstructional.C: Example of a standard data-driven approach for estimating backgrounds. A lot of discussion.; HybridInstructional.C: Example of protoype on/off problem with a data-driven background estimate. A lot of discussion; HybridStandardForm.C: Variant on above in 'standard form'; MultivariateGaussianTest.C: A validation example with an N-D multivariate Gaussian . Renamed the rs201_hybridcalculator.C to; HybridOriginalDemo.C; Removed some obsolete roostats tutorials (all the rs500 types). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html:319,interface,interface,319,tutorials/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html,2,['interface'],['interface']
Integrability,". Understanding Collections. Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, collections of; points and lines might be managed by a graphics pad. A vertex will have a; collection of tracks. A detector geometry contains collections of shapes,; materials, rotation matrices and sub-detectors.; Collections act as flexible alternatives to traditional data structures; of computer science such as arrays, lists, and trees. Collections can be thought of as polymorphic containers that can contain; different types of elements. For this release of the ROOT system, elements; to be placed in collections must be instances of classes.; These may be classes defined by you or provided by ROOT. Collection elements; must be instances of classes descending from ; TObject. The dependence of collections on TObject may disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:878,depend,dependence,878,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,1,['depend'],['dependence']
Integrability,". Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (Prof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2185,interface,interface,2185,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['interface'],['interface']
Integrability,". You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6603,message,messages,6603,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['message'],['messages']
Integrability,". _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized right; now. These limitations impose restrictions on what you can test with the MIR format.; For now, tests that would like to test some behaviour that depends on the state; of temporary or local ``MCSymbol`` operands or the exception handling state in; MMI, can't use the MIR format. As well as that, tests that test some behaviour; that depends on the state of the target specific ``MachineFunctionInfo`` or; ``MachineConstantPoolValue`` subclasses can't use the MIR format at the moment. High Level Structure; ====================. .. _embedded-module:. Embedded Module; ---------------. When the first YAML document contains a `YAML block literal string`_, the MIR; parser will treat this string as an LLVM assembly language string that; represents an embedded LLVM IR module.; Here is an example of a YAML document that contains an LLVM module:. .. code-block:: llvm. define i32 @inc(i32* %x) {; entry:; %0 = load i32, i32* %x; %1 = add i32 %0, 1; store i32 %1, i32* %x; ret i32 %1; }. .. _YAML block literal string: http://www.yaml.org/spec/1.2/spec.html#id2795688. Machine Functions; -----------------. The remaining YAML documents contain the machine functions. This is an example; of such YAML document:. .. code-block:: text. ---; name: inc; tracksRegLiveness: true; liveins:; - { reg: '$rdi' }; callSites:; - { bb: 0, offset: 3, fwdArgRegs:; - { arg: 0, reg: '$edi' } }; body:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:6209,depend,depends,6209,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['depends']
Integrability,". _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:9141,depend,depending,9141,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['depending']
Integrability,". `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50866,rout,routine,50866,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['rout'],['routine']
Integrability,". ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/thisroot.[c]sh` scripts will set correctly the; `ROOTSYS`, `LD_LIBRARY_PATH` or other paths depending on the platform; and the `MANPATH`. To run the program just type: `root`. ## Start and Quit a ROOT Session. ```; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:2089,depend,depending,2089,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['depend'],['depending']
Integrability,. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.co,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41251,message,message,41251,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['message'],['message']
Integrability,". eBPF maps are provided for sharing data between kernel and user-space.; Currently implemented types are hash and array, with potential extension to; support bloom filters, radix trees, etc. A map is defined by its type,; maximum number of elements, key size and value size in bytes. eBPF syscall; supports create, update, find and delete functions on maps. Function calls; ^^^^^^^^^^^^^^. Function call arguments are passed using up to five registers (R1 - R5).; The return value is passed in a dedicated register (R0). Four additional; registers (R6 - R9) are callee-saved, and the values in these registers; are preserved within kernel functions. R0 - R5 are scratch registers within; kernel functions, and eBPF programs must therefor store/restore values in; these registers if needed across function calls. The stack can be accessed; using the read-only frame pointer R10. eBPF registers map 1:1 to hardware; registers on x86_64 and other 64-bit architectures. For example, x86_64; in-kernel JIT maps them as. ::. R0 - rax; R1 - rdi; R2 - rsi; R3 - rdx; R4 - rcx; R5 - r8; R6 - rbx; R7 - r13; R8 - r14; R9 - r15; R10 - rbp. since x86_64 ABI mandates rdi, rsi, rdx, rcx, r8, r9 for argument passing; and rbx, r12 - r15 are callee saved. Program start; ^^^^^^^^^^^^^. An eBPF program receives a single argument and contains; a single eBPF main routine; the program does not contain eBPF functions.; Function calls are limited to a predefined set of kernel functions. The size; of a program is limited to 4K instructions: this ensures fast termination and; a limited number of kernel function calls. Prior to running an eBPF program,; a verifier performs static analysis to prevent loops in the code and; to ensure valid register usage and operand types. The AMDGPU backend; ------------------. The AMDGPU code generator lives in the ``lib/Target/AMDGPU``; directory. This code generator is capable of targeting a variety of; AMD GPU processors. Refer to :doc:`AMDGPUUsage` for more information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:107843,rout,routine,107843,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['rout'],['routine']
Integrability,". import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: false:; if (foo) { vs. if (foo) {; bar();; bar(); }; }. .. _LambdaBodyIndentation:. **LambdaBodyIndentation** (``LambdaBodyIndentationKind``) :versionbadge:`clang-format 13` :ref:`¶ <LambdaBodyIndentation>`; The indentation style of lambd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:81175,wrap,wrap,81175,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,". plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19367,protocol,protocol,19367,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['protocol'],['protocol']
Integrability,". scan-build: running the analyzer from the command line. scan-build: running the analyzer from the command line. What is it?; scan-build is a command line utility that enables a user to run the; static analyzer over their codebase as part of performing a regular build (from; the command line).; How does it work?; During a project build, as source files are compiled they are also analyzed; in tandem by the static analyzer.; Upon completion of the build, results are then presented to the user within a; web browser.; Will it work with any build system?; scan-build has little or no knowledge about how you build your code.; It works by overriding the CC and CXX environment variables to; (hopefully) change your build to use a ""fake"" compiler instead of the; one that would normally build your project. This fake compiler executes either; clang or gcc (depending on the platform) to compile your; code and then executes the static analyzer to analyze your code.; This ""poor man's interposition"" works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:857,depend,depending,857,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['depend'],['depending']
Integrability,". struct Hello : public FunctionPass {. This declares a ""``Hello``"" class that is a subclass of :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>`. The different builtin pass subclasses; are described in detail :ref:`later <writing-an-llvm-pass-pass-classes>`, but; for now, know that ``FunctionPass`` operates on a function at a time. .. code-block:: c++. static char ID;; Hello() : FunctionPass(ID) {}. This declares pass identifier used by LLVM to identify pass. This allows LLVM; to avoid using expensive C++ runtime information. .. code-block:: c++. bool runOnFunction(Function &F) override {; errs() << ""Hello: "";; errs().write_escaped(F.getName()) << '\n';; return false;; }; }; // end of struct Hello; } // end of anonymous namespace. We declare a :ref:`runOnFunction <writing-an-llvm-pass-runOnFunction>` method,; which overrides an abstract virtual method inherited from :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>`. This is where we are supposed to do our; thing, so we just print out our message with the name of each function. .. code-block:: c++. char Hello::ID = 0;. We initialize pass ID here. LLVM uses ID's address to identify a pass, so; initialization value is not important. .. code-block:: c++. static RegisterPass<Hello> X(""hello"", ""Hello World Pass"",; false /* Only looks at CFG */,; false /* Analysis Pass */);. Lastly, we :ref:`register our class <writing-an-llvm-pass-registration>`; ``Hello``, giving it a command line argument ""``hello``"", and a name ""Hello; World Pass"". The last two arguments describe its behavior: if a pass walks CFG; without modifying it then the third argument is set to ``true``; if a pass is; an analysis pass, for example dominator tree pass, then ``true`` is supplied as; the fourth argument. As a whole, the ``.cpp`` file looks like:. .. code-block:: c++. #include ""llvm/Pass.h""; #include ""llvm/IR/Function.h""; #include ""llvm/Support/raw_ostream.h"". #include ""llvm/IR/LegacyPassManager.h"". using namespace llvm;. namespace {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:5846,message,message,5846,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['message'],['message']
Integrability,". virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-dependent representation of each LLVM function in the program. Code generator passes are registered and initialized specially by; ``TargetMachine::addPassesToEmitFile`` and similar routines, so they cannot; generally be run from the :program:`opt` or :program:`bugpoint` commands. A ``MachineFunctionPass`` is also a ``FunctionPass``, so all the restrictions; that apply to a ``FunctionPass`` also apply to it. ``MachineFunctionPass``\ es; also have additional restrictions. In particular, ``MachineFunctionPass``\ es; are not allowed to do any of the following:. #. Modify or create any LLVM IR ``Instruction``\ s, ``BasicBlock``\ s,; ``Argument``\ s, ``Function``\ s, ``GlobalVariable``\ s,; ``GlobalAlias``\ es, or ``Module``\ s.; #. Modify a ``MachineFunction`` other than the one currently being processed.; #. Maintain state across invocations of :ref:`runOnMachineFunction; <writing-an-llvm-pass-runOnMachineFunction>` (including global data). .. _writing-an-llvm-pass-runOnMachineFunction:. The ``runOnMachineFunction(MachineFunction &MF)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnMachineFunction(M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:25004,rout,routines,25004,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['rout'],['routines']
Integrability,". vmulps %xmm0, %xmm1, %xmm2; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]; +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; |; | < loop carried >; |; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]. According to the analysis, throughput is limited by resource pressure and not by; data dependencies. The analysis observed increases in backend pressure during; 48.07% of the simulated run. Almost all those pressure increase events were; caused by contention on processor resources JFPA/JFPU0. The `critical sequence` is the most expensive sequence of instructions according; to the simulation. It is annotated to provide extra information about critical; register dependencies and resource interferences between instructions. Instructions from the critical sequence are expected to significantly impact; performance. By construction, the accuracy of this analysis is strongly; dependent on the simulation and (as always) by the quality of the processor; model in llvm. Bottleneck analysis is currently not supported for processors with an in-order; backend. Extra Statistics to Further Diagnose Performance Issues; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``-all-stats`` command line option enables extra statistics and performance; counters for the dispatch logic, the reorder buffer, the retire control unit,; and the register file. Below is an example of ``-all-stats`` output generated by :program:`llvm-mca`; for 300 iterations of the dot-product example discussed in the previous; sections. .. code-block:: none. Dynamic Dispatch Stall Cycles:; RAT - Register unavailable: 0; RCU - Retire tokens unavailable: 0; SCHEDQ - Scheduler full: 272 (44.6%); LQ - Load queue full: 0; SQ - Store queue full: 0; GROUP - Static restrictions on the dispatch group: 0. Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; [# dispatched], [# cycles]; 0, 24 (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:28360,depend,dependent,28360,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependent']
Integrability,".. -*- mode: rst -*-. CPyCppyy: Python-C++ bindings interface based on Cling/LLVM; ===========================================================. CPyCppyy is the CPython equivalent of _cppyy in PyPy.; It provides dynamic Python-C++ bindings by leveraging the Cling C++; interpreter and LLVM.; Details and performance are described in; `this paper <http://conferences.computer.org/pyhpc/2016/papers/5220a027.pdf>`_. CPyCppyy is a CPython extension module built on top of the same backend API; as PyPy/_cppyy.; It thus requires the installation of the; `cppyy backend <https://pypi.python.org/pypi/cppyy-backend/>`_; for use, which will pull in Cling.; CPython/cppyy and PyPy/cppyy are designed to be compatible, although there; are differences due to the former being reference counted and the latter; being garbage collected, as well as temporary differences due to different; release cycles of the respective projects. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst:52,interface,interface,52,bindings/pyroot/cppyy/CPyCppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst,1,['interface'],['interface']
Integrability,".. -*- mode: rst -*-. cppyy: Python-C++ bindings interface based on Cling/LLVM; ========================================================. cppyy provides fully automatic, dynamic Python-C++ bindings by leveraging; the Cling C++ interpreter and LLVM.; It supports both PyPy (natively), CPython, and C++ language standards; through C++17 (and parts of C++20). Details and performance are described in; `this paper <http://cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf>`_,; originally presented at PyHPC'16, but since updated with improved performance; numbers. Full documentation: `cppyy.readthedocs.io <http://cppyy.readthedocs.io/>`_. Notebook-based tutorial: `Cppyy Tutorial <https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb>`_. For Anaconda/miniconda, install cppyy from `conda-forge <https://anaconda.org/conda-forge/cppyy>`_. ----. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst:49,interface,interface,49,bindings/pyroot/cppyy/cppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst,1,['interface'],['interface']
Integrability,".. _cmake_interface:. CMake interface; ===============. CMake fragments are provided for an Automated generation of an end-user; bindings package from a CMake-based project build.; The bindings generated by rootcling, are 'raw' in the sense that:. * The .cpp file be compiled. The required compilation steps are; platform-dependent.; * The bindings are not packaged for distribution. Typically, users expect; to have a pip-compatible package.; * The binding are in the 'cppyy.gbl' namespace. This is an inconvenience at; best for users who might expect C++ code from KF5::Config to appear in; Python via ""import KF5.Config"".; * The bindings are loaded lazily, which limits the discoverability of the; content of the bindings.; * ``cppyy`` supports customization of the bindings via 'Pythonization' but; there is no automated way to load them. These issues are addressed by the CMake support. This is a blend of Python; packaging and CMake where CMake provides:. * Platform-independent scripting of the creation of a Python 'wheel' package; for the bindings.; * An facility for CMake-based projects to automate the entire bindings; generation process, including basic automated tests. .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. Python packaging; ----------------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:28,interface,interface,28,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,".. _convergence-and-uniformity:. ==========================; Convergence And Uniformity; ==========================. .. contents::; :local:. Introduction; ============. Some parallel environments execute threads in groups that allow; communication within the group using special primitives called; *convergent* operations. The outcome of a convergent operation is; sensitive to the set of threads that executes it ""together"", i.e.,; convergently. A value is said to be *uniform* across a set of threads if it is the; same across those threads, and *divergent* otherwise. Correspondingly,; a branch is said to be a uniform branch if its condition is uniform,; and it is a divergent branch otherwise. Whether threads are *converged* or not depends on the paths they take; through the control flow graph. Threads take different outgoing edges; at a *divergent branch*. Divergent branches constrain; program transforms such as changing the CFG or moving a convergent; operation to a different point of the CFG. Performing these; transformations across a divergent branch can change the sets of; threads that execute convergent operations convergently. While these; constraints are out of scope for this document, the described; *uniformity analysis* allows these transformations to identify; uniform branches where these constraints do not hold. Convergence and; uniformity are inter-dependent: When threads diverge at a divergent; branch, they may later *reconverge* at a common program point.; Subsequent operations are performed convergently, but the inputs may; be non-uniform, thus producing divergent outputs. Uniformity is also useful by itself on targets that execute threads in; groups with shared execution resources (e.g. waves, warps, or; subgroups):. - Uniform outputs can potentially be computed or stored on shared; resources.; - These targets must ""linearize"" a divergent branch to ensure that; each side of the branch is followed by the corresponding threads in; the same group. But linea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:738,depend,depends,738,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['depend'],['depends']
Integrability,".. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130813,integrat,integrated,130813,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrat'],['integrated']
Integrability,".. _debugging:; ; Debugging; =========. By default, the ``clang`` JIT as used by cppyy does not generate debugging; information.; This is first of all because it has proven to be not reliable in all cases,; but also because in a production setting this information, being internal to; the wrapper generation, goes unused.; However, that does mean that a debugger that starts from python will not be; able to step through JITed code into the C++ function that needs debugging,; even when such information is available for that C++ function. To enable debugging information in JITed code, set the ``EXTRA_CLING_ARGS``; envar to ``-g`` (and any further compiler options you need, e.g. add ``-O2``; to debug optimized code). On a crash in C++, the backend will attempt to provide a stack trace.; This works quite well on Linux (through ``gdb``) and decently on MacOS; (through ``unwind``), but is currently unreliable on MS Windows.; To prevent printing of this trace, which can be slow to produce, set the; envar ``CPPYY_CRASH_QUIET`` to '1'. It is even more useful to obtain a traceback through the Python code that led; up to the problem in C++.; Many modern debuggers allow mixed-mode C++/Python debugging (for example; `gdb`_ and `MSVC`_), but cppyy can also turn abortive C++ signals (such as a; segmentation violation) into Python exceptions, yielding a normal traceback.; This is particularly useful when working with cross-inheritance and other; cross-language callbacks. To enable the signals to exceptions conversion, import the lowlevel module; ``cppyy.ll`` and use:. .. code-block:: python. import cppyy.ll; cppyy.ll.set_signals_as_exception(True). Call ``set_signals_as_exception(False)`` to disable the conversion again.; It is recommended to only have the conversion enabled around the problematic; code, as it comes with a performance penalty.; If the problem can be localized to a specific function, you can use its; ``__sig2exc__`` flag to only have the conversion active in that functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst:289,wrap,wrapper,289,bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,1,['wrap'],['wrapper']
Integrability,".. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SVN bridge, which is an extra dependency. Maintaining this locks us; into GitHub and could restrict future workflow changes. Workflows; ^^^^^^^^^. * :ref:`Checkout/Clone a Single Project, without Commit Access <workflow-checkout-commit>`.; * :ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-monocheckout-multicommit>`.; * :ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-cross-repo-commit>`.; * :ref:`Branching/Stashing/Updating for Local Development or Experiments <workflow-mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:11468,bridg,bridge,11468,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['bridg'],['bridge']
Integrability,".. _history:. History; =======. .. toctree::; :hidden:. What is now called `cppyy` started life as `RootPython` from `CERN`_, but; cppyy is not associated with CERN (it is still used there, however,; underpinning `PyROOT`_). Back in late 2002, Pere Mato of CERN, had the idea of using the `CINT`_ C++; interpreter, which formed the interactive interface to `ROOT`_, to call from; Python into C++: this became RootPython.; This binder interfaced with Python through `boost.python`_ (v1), transpiling; Python code into C++ and interpreting the result with CINT.; In early 2003, I ported this code to boost.python v2, then recently released.; In practice, however, re-interpreting the transpiled code was unusably slow,; thus I modified the code to make direct use of CINT's internal reflection; system, gaining about 25x in performance.; I presented this work as `PyROOT` at the ROOT Users' Workshop in early 2004,; and, after removing the boost.python dependency by using the C-API directly; (gaining another factor 7 in speedup!), it was included in ROOT.; PyROOT was presented at the SciPy'06 conference, but was otherwise not; advocated outside of High Energy Physics (HEP). In 2010, the PyPy core developers and I held a `sprint at CERN`_ to use; `Reflex`, a standalone alternative to CINT's reflection of C++, to add; automatic C++ bindings, PyROOT-style, to `PyPy`_.; This is where the name ""cppyy"" originated.; Coined by Carl Friedrich Bolz, if you want to understand the meaning, just; pronounce it slowly: cpp-y-y. After the ROOT team replaced CINT with `Cling`_, PyROOT soon followed.; As part of Google's Summer of Code '16, Aditi Dutta moved PyPy/cppyy to Cling; as well, and packaged the code for use through `PyPI`_.; I continued this integration with the Python eco-system by forking PyROOT,; reducing its dependencies, and repackaging it as CPython/cppyy.; The combined result is the current cppyy project.; Mid 2018, version 1.0 was released. .. _`CERN`: https://cern.ch/; .. _`PyROOT`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst:344,interface,interface,344,bindings/pyroot/cppyy/cppyy/doc/source/history.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/history.rst,3,"['depend', 'interface']","['dependency', 'interface', 'interfaced']"
Integrability,".. _numba:. Numba support; =============. .. caution::. This is an **experimental** feature, available starting with release; 2.4.0.; It is still incomplete (see listing below) and has only been tested on; Linux on x86_64. Numba `is a JIT compiler`_ for Python functions that can be statically typed; based on their input arguments.; Since C++ objects are always statically typed and already implemented at the; machine level, they can be dynamically integrated into the Numba type tracing; and lowering by exposing type details through C++ reflection at runtime. JIT-compiling traces of mixed Python/bound C++ code reduces, and in some; cases removes, the overhead of boxing/unboxing native data into their Python; proxies and vice versa.; It can also reduce or remove temporaries, especially for template; expressions.; Thus, there can be significant speedups for mixed code, beyond the Numba; compilation of Python code itself.; The current implementation integrates compiled C++ through function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; woul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:451,integrat,integrated,451,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['integrat'],['integrated']
Integrability,".. _phabricator-reviews:. =============================; Code Reviews with Phabricator; =============================. .. warning::. Phabricator is deprecated and will be switched to read-only mode in October; 2023, for new code contributions use :ref:`GitHub Pull Requests <github-reviews>`. .. contents::; :local:. If you prefer to use a web user interface for code reviews, you can now submit; your patches for Clang and LLVM at `LLVM's Phabricator`_ instance. While Phabricator is a useful tool for some, the relevant -commits mailing list; is the system of record for all LLVM code review. The mailing list should be; added as a subscriber on all reviews, and Phabricator users should be prepared; to respond to free-form comments in mail sent to the commits list. Sign up; -------. To get started with Phabricator, navigate to `https://reviews.llvm.org`_ and; click the power icon in the top right. You can register with a GitHub account,; a Google account, or you can create your own profile. Make *sure* that the email address registered with Phabricator is subscribed; to the relevant -commits mailing list. If you are not subscribed to the commit; list, all mail sent by Phabricator on your behalf will be held for moderation. Note that if you use your git user name as Phabricator user name,; Phabricator will automatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:349,interface,interface,349,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,".. _repositories:. Repositories; ============. The ``cppyy`` module is a frontend that requires an intermediate (Python; interpreter dependent) layer, and a backend (see; :ref:`Package Structure <package-structure>`).; Because of this layering and because it leverages several existing packages; through reuse, the relevant codes are contained across a number of; repositories. * Frontend, cppyy: https://github.com/wlav/cppyy; * CPython (v2/v3) intermediate: https://github.com/wlav/CPyCppyy; * PyPy intermediate (module _cppyy): https://foss.heptapod.net/pypy; * Backend, cppyy: https://github.com/wlav/cppyy-backend. The backend repo contains both the cppyy-cling (under ""cling"") and; cppyy-backend (under ""clingwrapper"") packages. .. _building_from_source:. Building from source; --------------------. Except for cppyy-cling, the structure in the repositories follows a normal; PyPA package and they are thus ready to build with `setuptools`_: simply; clone the package and either run ``python setup.py``, or use ``pip``. It is highly recommended to follow the dependency chain when manually; upgrading packages individually (i.e. ``cppyy-cling``, ``cppyy-backend``,; ``CPyCppyy`` if on CPython, and then finally ``cppyy``), because upstream; packages expose headers that are used by the ones downstream.; Of course, if only building for a patch/point release, there is no need to; re-install the full chain (or follow the order).; Always run the local updates from the package directories (i.e. where the; ``setup.py`` file is located), as some tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:133,depend,dependent,133,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['depend'],['dependent']
Integrability,".. _starting:. Trying it out; =============. This is a basic guide to try cppyy and see whether it works for you.; Large code bases will benefit from more advanced features such as; :doc:`pythonizations <pythonizations>` for a cleaner interface to clients;; precompiled modules for faster parsing and reduced memory usage;; "":ref:`dictionaries <dictionaries>`"" to package locations and manage; dependencies; and mapping files for automatic, lazy, loading.; You can, however, get very far with just the basics and it may even be; completely sufficient for small packages with fewer classes. cppyy works by parsing C++ definitions through ``cling``, generating tiny; wrapper codes to honor compile-time features and create standardized; interfaces, then compiling/linking those wrappers with the ``clang`` JIT.; It thus requires only those two ingredients: *C++ definitions* and; *linker symbols*.; All cppyy uses, the basic and the more advanced, are variations on the; theme of bringing these two together at the point of use. Definitions typically live in header files and symbols in libraries.; Headers can be loaded with ``cppyy.include`` and libraries with the; ``cppyy.load_library`` call.; Loading the header is sufficient to start exploring, with ``cppyy.gbl`` the; starting point of all things C++, while the linker symbols are only needed at ; the point of first use. Here is an example using the `zlib`_ library, which is likely available on; your system:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('zlib.h') # bring in C++ definitions; >>> cppyy.load_library('libz') # load linker symbols; >>> cppyy.gbl.zlibVersion() # use a zlib API; '1.2.11'; >>>. Since header files can include other header files, it is easy to aggregate; all relevant ones into a single header to include.; If there are project-specific include paths, you can add those paths through; ``cppyy.add_include_path``.; If a header is C-only and not set for use with C++, use ``cppyy.c_include``,; which ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst:235,interface,interface,235,bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,5,"['depend', 'interface', 'wrap']","['dependencies', 'interface', 'interfaces', 'wrapper', 'wrappers']"
Integrability,".. _stl:. STL; ===. Parts of the Standard Template Library (STL), in particular its container; types, are the de facto equivalent of Python's builtin types.; STL is written in C++ and Python bindings of it are fully functional as-is,; but are much more useful when pluggable into idiomatic expressions where; Python builtin containers are expected (e.g. in list contractions). There are two extremes to achieve such drop-in behavior: copy into Python; builtins, so that the Python-side always deals with true Python objects; or; adjust the C++ interfaces to be the same as their Python equivalents.; Neither is very satisfactory: the former is not because of the existence of; global/static variables and return-by-reference.; If only a copy is available, then expected modifications do not propagate.; Copying is also either slow (when copying every time) or memory intensive (if; the results are cached).; Filling out the interfaces may look more appealing, but all operations then; involve C++ function calls, which can be slower than the Python equivalents,; and C++-style error handling. Given that neither choice will satisfy all cases, ``cppyy`` aims to maximize; functionality and minimum surprises based on common use.; Thus, for example, ``std::vector`` grows a pythonistic ``__len__`` method,; but does not lose its C++ ``size`` method.; Passing a Python container through a const reference to a ``std::vector``; will trigger automatic conversion, but such an attempt through a non-const; reference will fail since a non-temporary C++ object is required [#f1]_ to; return any updates/changes. ``std::string`` is almost always converted to Python's ``str`` on function; returns (the exception is return-by-reference when assigning), but not when; its direct use is more likely such as in the case of (global) variables or; when iterating over a ``std::vector<std::string>``. The rest of this section shows examples of how STL containers can be used in; a natural, pythonistic, way. `std::vec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:362,contract,contractions,362,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,3,"['contract', 'interface']","['contractions', 'interfaces']"
Integrability,".. _testing:. Test suite; ==========. The cppyy tests live in the top-level cppyy package, can be run for; both CPython and PyPy, and exercises the full setup, including the backend.; Most tests are standalone and can be run independently, with a few exceptions; in the template tests (see file ``test_templates.py``). To run the tests, first install cppyy by any usual means, then clone the; cppyy repo, and enter the ``test`` directory::. $ git clone https://github.com/wlav/cppyy.git; $ cd cppyy/test. Next, build the dictionaries, the manner of which depends on your platform.; On Linux or MacOS-X, run ``make``::. $ make all. On Windows, run the dictionary building script::. $ python make_dict_win32.py all. Next, make sure you have `pytest`_ installed, for example with ``pip``::. $ python -m pip install pytest. and finally run the tests::. $ python -m pytest -sv. On Linux and MacOS-X, all tests should succeed.; On MS Windows 32bit there are 4 failing tests, on 64bit there are 5 still; failing. .. _`pytest`: https://docs.pytest.org/en/latest/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/testing.rst:555,depend,depends,555,bindings/pyroot/cppyy/cppyy/doc/source/testing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/testing.rst,1,['depend'],['depends']
Integrability,".. _utilities:. Utilities; =========. The ``cppyy-backend`` package brings in the following utilities to help; with repackaging and redistribution:. * cling-config: for compile time flags; * rootcling and genreflex: for dictionary generation; * cppyy-generator: part of the :doc:`CMake interface <cmake_interface>`. Compiler/linker flags; ---------------------. ``cling-config`` is a small utility to provide access to the as-installed; configuration, such as compiler/linker flags and installation directories, of; other components.; Usage examples::. $ cling-config --help; Usage: cling-config [--cflags] [--cppflags] [--cmake]; $ cling-config --cmake; /usr/local/lib/python2.7/dist-packages/cppyy_backend/cmake. .. _dictionaries:. Dictionaries; ------------. Loading header files or code directly into ``cling`` is fine for interactive; work and smaller packages, but large scale applications benefit from; pre-compiling code, using the automatic class loader, and packaging; dependencies in so-called ""dictionaries."". A `dictionary` is a generated C++ source file containing references to the; header locations used when building (and any additional locations provided),; a set of forward declarations to reduce the need of loading header files, and; a few I/O helper functions.; The name ""dictionary"" is historic: before ``cling`` was used, it contained; the complete generated C++ reflection information, whereas now that is; derived at run-time from the header files.; It is still possible to fully embed header files rather than only storing; their names and search locations, to make the dictionary more self-contained. After generating the dictionary, it should be compiled into a shared library.; This provides additional dependency control: by linking it directly with any; further libraries needed, you can use standard mechanisms such as ``rpath``; to locate those library dependencies.; Alternatively, you can add the additional libraries to load to the mapping; files of the class load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:286,interface,interface,286,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,"['depend', 'interface']","['dependencies', 'interface']"
Integrability,".. role:: raw-html(raw); :format: html. ========================; LLVM Bitcode File Format; ========================. .. contents::; :local:. Abstract; ========. This document describes the LLVM bitstream file format and the encoding of the; LLVM IR into it. Overview; ========. What is commonly known as the LLVM bitcode file format (also, sometimes; anachronistically known as bytecode) is actually two things: a `bitstream; container format`_ and an `encoding of LLVM IR`_ into the container format. The bitstream format is an abstract encoding of structured data, very similar to; XML in some ways. Like XML, bitstream files contain tags, and nested; structures, and you can parse the file without having to understand the tags.; Unlike XML, the bitstream format is a binary encoding, and unlike XML it; provides a mechanism for the file to self-describe ""abbreviations"", which are; effectively size optimizations for the content. LLVM IR files may be optionally embedded into a `wrapper`_ structure, or in a; `native object file`_. Both of these mechanisms make it easy to embed extra; data along with LLVM IR files. This document first describes the LLVM bitstream format, describes the wrapper; format, then describes the record structure used by LLVM IR files. .. _bitstream container format:. Bitstream Format; ================. The bitstream format is literally a stream of bits, with a very simple; structure. This structure consists of the following concepts:. * A ""`magic number`_"" that identifies the contents of the stream. * Encoding `primitives`_ like variable bit-rate integers. * `Blocks`_, which define nested content. * `Data Records`_, which describe entities within the file. * Abbreviations, which specify compression optimizations for the file. Note that the :doc:`llvm-bcanalyzer <CommandGuide/llvm-bcanalyzer>` tool can be; used to dump and inspect arbitrary bitstreams, which is very useful for; understanding the encoding. .. _magic number:. Magic Numbers; -------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:984,wrap,wrapper,984,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['wrap'],['wrapper']
Integrability,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:409,interface,interface,409,interpreter/llvm-project/clang/docs/LibClang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst,2,['interface'],['interface']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1013_vaddr_a5639c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 1-12 dwords. Actual size depends on opcode, :ref:`dim<amdgpu_synid_dim>` and :ref:`a16<amdgpu_synid_a16>`. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_a5639c.rst:518,depend,depends,518,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_a5639c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_a5639c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1013_vaddr_c5ab43:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 8-12 dwords. Actual size depends on opcode and :ref:`a16<amdgpu_synid_a16>`. Examples:. .. parsed-literal::. image_bvh_intersect_ray v[4:7], v[9:16], s[4:7]; image_bvh64_intersect_ray v[5:8], v[1:12], s[8:11]; image_bvh_intersect_ray v[39:42], [v5, v4, v2, v1, v7, v3, v0, v6], s[12:15] a16; image_bvh64_intersect_ray v[39:42], [v50, v46, v23, v17, v16, v15, v21, v20, v19, v37, v40, v42], s[12:15]. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_c5ab43.rst:518,depend,depends,518,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_c5ab43.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vaddr_c5ab43.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1013_vdst_eae4c8:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vdst_eae4c8.rst:274,depend,depends,274,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vdst_eae4c8.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1013_vdst_eae4c8.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_fx_operand.rst:261,depend,depending,261,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; =====",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:216,message,message,216,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vaddr_9aeece:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx1030_vaddr_9aeece>` + :ref:`offset12s<amdgpu_synid_flat_offset12s>`. :ref:`vaddr<amdgpu_synid_gfx1030_vaddr_9aeece>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx1030_saddr_beaa25>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx1030_saddr_beaa25>` + :ref:`vaddr<amdgpu_synid_gfx1030_vaddr_9aeece>` + :ref:`offset12s<amdgpu_synid_flat_offset12s>`. :ref:`vaddr<amdgpu_synid_gfx1030_vaddr_9aeece>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx1030_saddr_beaa25>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_9aeece.rst:268,depend,depending,268,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_9aeece.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_9aeece.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vaddr_a5639c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 1-12 dwords. Actual size depends on opcode, :ref:`dim<amdgpu_synid_dim>` and :ref:`a16<amdgpu_synid_a16>`. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_a5639c.rst:518,depend,depends,518,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_a5639c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_a5639c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vaddr_c5ab43:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 8-12 dwords. Actual size depends on opcode and :ref:`a16<amdgpu_synid_a16>`. Examples:. .. parsed-literal::. image_bvh_intersect_ray v[4:7], v[9:16], s[4:7]; image_bvh64_intersect_ray v[5:8], v[1:12], s[8:11]; image_bvh_intersect_ray v[39:42], [v5, v4, v2, v1, v7, v3, v0, v6], s[12:15] a16; image_bvh64_intersect_ray v[39:42], [v50, v46, v23, v17, v16, v15, v21, v20, v19, v37, v40, v42], s[12:15]. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_c5ab43.rst:518,depend,depends,518,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_c5ab43.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vaddr_c5ab43.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vcc:. vcc; ===. Vector condition code. This operand depends on wavefront size:. * Should be :ref:`vcc_lo<amdgpu_synid_vcc_lo>` if wavefront size is 32.; * Should be :ref:`vcc<amdgpu_synid_vcc>` if wavefront size is 64.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vcc.rst:243,depend,depends,243,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vcc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vcc.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdata_21b58d:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_21b58d.rst:281,depend,depends,281,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_21b58d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_21b58d.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_84fab6.rst:418,depend,depends,418,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_aa5a53.rst:418,depend,depends,418,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_c08393.rst:281,depend,depends,281,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdst_5ec176:. vdst; ====. Image data to be loaded by an *image_gather4* instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` affects operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_5ec176.rst:366,depend,depending,366,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_5ec176.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_5ec176.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_dfa6da.rst:274,depend,depends,274,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx1030_vdst_eae4c8:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_eae4c8.rst:274,depend,depends,274,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_eae4c8.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_vdst_eae4c8.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_fx_operand.rst:259,depend,depending,259,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; =======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst:214,message,message,214,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vaddr_9aeece:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx10_vaddr_9aeece>` + :ref:`offset12s<amdgpu_synid_flat_offset12s>`. :ref:`vaddr<amdgpu_synid_gfx10_vaddr_9aeece>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx10_saddr_beaa25>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx10_saddr_beaa25>` + :ref:`vaddr<amdgpu_synid_gfx10_vaddr_9aeece>` + :ref:`offset12s<amdgpu_synid_flat_offset12s>`. :ref:`vaddr<amdgpu_synid_gfx10_vaddr_9aeece>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx10_saddr_beaa25>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_9aeece.rst:266,depend,depending,266,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_9aeece.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_9aeece.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vaddr_a5639c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 1-12 dwords. Actual size depends on opcode, :ref:`dim<amdgpu_synid_dim>` and :ref:`a16<amdgpu_synid_a16>`. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_a5639c.rst:516,depend,depends,516,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_a5639c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vaddr_a5639c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vcc:. vcc; ===. Vector condition code. This operand depends on wavefront size:. * Should be :ref:`vcc_lo<amdgpu_synid_vcc_lo>` if wavefront size is 32.; * Should be :ref:`vcc<amdgpu_synid_vcc>` if wavefront size is 64.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vcc.rst:241,depend,depends,241,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vcc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vcc.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdata_21b58d:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_21b58d.rst:279,depend,depends,279,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_21b58d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_21b58d.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_84fab6.rst:416,depend,depends,416,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_aa5a53.rst:416,depend,depends,416,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_c08393.rst:279,depend,depends,279,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdst_5ec176:. vdst; ====. Image data to be loaded by an *image_gather4* instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` affects operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_5ec176.rst:364,depend,depending,364,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_5ec176.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_5ec176.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_dfa6da.rst:272,depend,depends,272,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx10_vdst_eae4c8:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_eae4c8.rst:272,depend,depends,272,interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_eae4c8.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx10_vdst_eae4c8.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_delay:. delay; =====. A delay between dependent SALU/VALU instructions.; This operand may specify a delay for 2 instructions:; the one after the current *s_delay_alu* instruction; and for the second instruction indicated by *SKIP*. The bits of this operand have the following meaning:. ===== ========================================================== ============; Bits Description Value Range; ===== ========================================================== ============; 3:0 ID0: indicates a delay for the first instruction. 0..11; 6:4 SKIP: indicates the position of the second instruction. 0..5; 10:7 ID1: indicates a delay for the second instruction. 0..11; ===== ========================================================== ============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A combination of *instid0*, *instskip*, *instid1* values which are described below. ======================== =========================== ===============; Syntax Description Default Value; ======================== =========================== ===============; instid0(<*ID name*>) A symbolic *ID0* value. instid0(NO_DEP); instskip(<*SKIP name*>) A symbolic *SKIP* value. instskip(SAME); instid1(<*ID name*>) A symbolic *ID1* value. instid1(NO_DEP); ======================== =========================== ===============. These values may be specified in any order.; When more than one value is specified, the values must be separated from each other by a '|'. Valid *ID names* are defined below. =================== ===================================================================; Name Description; =================== ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst:227,depend,dependent,227,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,1,['depend'],['dependent']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_fx_operand.rst:259,depend,depending,259,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_msg_b8ff6d:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 6:0 Message *type*. 0..127; 7:7 Must be 1. 1; 15:8 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(MSG_RTN_GET_DOORBELL) Get doorbell ID.; sendmsg(MSG_RTN_GET_DDID) Get Draw/Dispatch ID.; sendmsg(MSG_RTN_GET_TMA) Get TMA value.; sendmsg(MSG_RTN_GET_TBA) Get TBA value.; sendmsg(MSG_RTN_GET_REALTIME) Get REALTIME value.; sendmsg(MSG_RTN_SAVE_WAVE) Report that this wave is ready to be context-saved.; ==================================== ====================================================. Examples:. .. parsed-literal::. s_sendmsg_rtn_b32 s0, 132; s_sendmsg_rtn_b32 s0, sendmsg(MSG_GET_REALTIME); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_b8ff6d.rst:221,message,message,221,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_b8ff6d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_b8ff6d.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_msg_e37f7b:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Must be 0. 0; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:221,message,message,221,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_type_deviation_8d2078:. Type Deviation; ==============. The *type* of this operand differs from the *type* :ref:`implied by the opcode<amdgpu_syn_instruction_mnemo>`. This tag specifies the actual operand *type*.; The number of data components depends on wavesize: 8 in wave32 mode and 4 in wave64 mode.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_type_deviation_8d2078.rst:433,depend,depends,433,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_type_deviation_8d2078.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_type_deviation_8d2078.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vaddr_0212e3:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx11_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx11_vaddr_0212e3>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx11_saddr_beaa25>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx11_saddr_beaa25>` + :ref:`vaddr<amdgpu_synid_gfx11_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx11_vaddr_0212e3>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx11_saddr_beaa25>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0212e3.rst:266,depend,depending,266,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0212e3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0212e3.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vaddr_0bfea4:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 8-12 dwords. Actual size depends on opcode and :ref:`a16<amdgpu_synid_a16>`. This instruction expects NSA address to be partitioned into 5 groups; registers within each group must be contiguous. Examples:. .. parsed-literal::. image_bvh_intersect_ray v[4:7], v[9:16], s[4:7]; image_bvh64_intersect_ray v[5:8], v[1:12], s[8:11]; image_bvh_intersect_ray v[39:42], [v50, v46, v[20:22], v[40:42], v[47:49]], s[12:15]; image_bvh64_intersect_ray v[39:42], [v[50:51], v46, v[20:22], v[40:42], v[47:49]], s[12:15]. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0bfea4.rst:516,depend,depends,516,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0bfea4.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_0bfea4.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vaddr_a5639c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. This operand may be specified using either :ref:`standard VGPR syntax<amdgpu_synid_v>` or special :ref:`NSA VGPR syntax<amdgpu_synid_nsa>`. *Size:* 1-12 dwords. Actual size depends on opcode, :ref:`dim<amdgpu_synid_dim>` and :ref:`a16<amdgpu_synid_a16>`. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_a5639c.rst:516,depend,depends,516,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_a5639c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vaddr_a5639c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vcc:. vcc; ===. Vector condition code. This operand depends on wavefront size:. * Should be :ref:`vcc_lo<amdgpu_synid_vcc_lo>` if wavefront size is 32.; * Should be :ref:`vcc<amdgpu_synid_vcc>` if wavefront size is 64.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vcc.rst:241,depend,depends,241,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vcc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vcc.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdata_21b58d:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_21b58d.rst:279,depend,depends,279,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_21b58d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_21b58d.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_84fab6.rst:416,depend,depends,416,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_aa5a53.rst:416,depend,depends,416,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_c08393.rst:279,depend,depends,279,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdst_5ec176:. vdst; ====. Image data to be loaded by an *image_gather4* instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` affects operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_5ec176.rst:364,depend,depending,364,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_5ec176.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_5ec176.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_dfa6da.rst:272,depend,depends,272,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdst_e2d005:. vdst; ====. Image data to be loaded by an image instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` and :ref:`tfe<amdgpu_synid_tfe>` affect operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_e2d005.rst:354,depend,depending,354,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_e2d005.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_e2d005.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx11_vdst_eae4c8:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_eae4c8.rst:272,depend,depends,272,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_eae4c8.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_vdst_eae4c8.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst:213,message,message,213,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_vaddr_887f26:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. *Size:* 1-12 dwords. Actual size depends on opcode and specific image being handled. Note. Image format and dimensions are encoded in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vaddr_887f26.rst:375,depend,depends,375,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vaddr_887f26.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vaddr_887f26.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_84fab6.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_aa5a53.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_c08393.rst:278,depend,depends,278,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx7_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdst_dfa6da.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst:213,message,message,213,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vaddr_887f26:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. *Size:* 1-12 dwords. Actual size depends on opcode and specific image being handled. Note. Image format and dimensions are encoded in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vaddr_887f26.rst:375,depend,depends,375,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vaddr_887f26.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vaddr_887f26.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_4f639e:. vdata; =====. 16-bit data to store by a buffer instruction. *Size:* depends on GFX8 GPU revision:. * 3 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_4f639e.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_4f639e.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_4f639e.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_629a92:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` has different meanings for GFX8.0 and GFX8.1:. * For GFX8.0, this modifier does not affect the size of data elements in registers. Values in registers are stored in low 16 bits, high 16 bits are unused. There is no packing.; * Starting from GFX8.1, this modifier specifies that values in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_629a92.rst:278,depend,depends,278,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_629a92.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_629a92.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_84fab6.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_886702:. vdata; =====. 16-bit data to store by a buffer instruction. *Size:* depends on GFX8 GPU revision:. * 4 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_886702.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_886702.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_886702.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_aa5a53.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_c08393.rst:278,depend,depends,278,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdata_f2bf57:. vdata; =====. 16-bit data to store by a buffer instruction. *Size:* depends on GFX8 GPU revision:. * 2 dwords for GFX8.0. This H/W supports no packing.; * 1 dword for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_f2bf57.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_f2bf57.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdata_f2bf57.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_2d89ba:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision and :ref:`tfe<amdgpu_synid_tfe>`:. * 4 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_2d89ba.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_2d89ba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_2d89ba.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_4730df:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` has different meanings for GFX8.0 and GFX8.1:. * For GFX8.0, this modifier does not affect the size of data elements in registers. Values in registers are stored in low 16 bits, high 16 bits are unused. There is no packing.; * Starting from GFX8.1, this modifier specifies that values in registers are packed; each value occupies 16 bits. * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_4730df.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_4730df.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_4730df.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_6f591e:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision:. * 4 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_6f591e.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_6f591e.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_6f591e.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_829fc5:. vdst; ====. Image data to be loaded by an *image_gather4* instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` and :ref:`tfe<amdgpu_synid_tfe>` affect operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` has different meanings for GFX8.0 and GFX8.1:. * For GFX8.0, this modifier does not affect the size of data elements in registers. Values in registers are stored in low 16 bits, high 16 bits are unused. There is no packing.; * Starting from GFX8.1, this modifier specifies that values in registers are packed; each value occupies 16 bits. * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_829fc5.rst:363,depend,depending,363,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_829fc5.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_829fc5.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_b61114:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision and :ref:`tfe<amdgpu_synid_tfe>`:. * 2 dwords for GFX8.0. This H/W supports no packing.; * 1 dword for GFX8.1+. This H/W supports data packing.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_b61114.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_b61114.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_b61114.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_c360a5:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision:. * 3 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_c360a5.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_c360a5.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_c360a5.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_d809e2:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision:. * 2 dwords for GFX8.0. This H/W supports no packing.; * 1 dword for GFX8.1+. This H/W supports data packing. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_d809e2.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_d809e2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_d809e2.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_de9309:. vdst; ====. Instruction output: data read from a memory buffer and converted to 16-bit format. *Size:* depends on GFX8 GPU revision and :ref:`tfe<amdgpu_synid_tfe>`:. * 3 dwords for GFX8.0. This H/W supports no packing.; * 2 dwords for GFX8.1+. This H/W supports data packing.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_de9309.rst:305,depend,depends,305,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_de9309.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_de9309.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx8_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_dfa6da.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx900_fx_operand:. FX Operand; ==========. This is an *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx900_fx_operand.rst:261,depend,depending,261,interpreter/llvm-project/llvm/docs/AMDGPU/gfx900_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx900_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx904_fx_operand:. FX Operand; ==========. This is an *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx904_fx_operand.rst:261,depend,depending,261,interpreter/llvm-project/llvm/docs/AMDGPU/gfx904_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx904_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx906_fx_operand:. FX Operand; ==========. This is an *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx906_fx_operand.rst:261,depend,depending,261,interpreter/llvm-project/llvm/docs/AMDGPU/gfx906_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx906_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx908_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_fx_operand.rst:260,depend,depending,260,interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx908_vaddr_0212e3:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx908_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx908_vaddr_0212e3>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx908_saddr>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx908_saddr>` + :ref:`vaddr<amdgpu_synid_gfx908_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx908_vaddr_0212e3>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx908_saddr>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_vaddr_0212e3.rst:267,depend,depending,267,interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_vaddr_0212e3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx908_vaddr_0212e3.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_fx_operand.rst:260,depend,depending,260,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst:215,message,message,215,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vaddr_0212e3:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx90a_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx90a_vaddr_0212e3>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx90a_saddr_a37373>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx90a_saddr_a37373>` + :ref:`vaddr<amdgpu_synid_gfx90a_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx90a_vaddr_0212e3>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx90a_saddr_a37373>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_0212e3.rst:267,depend,depending,267,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_0212e3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_0212e3.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vaddr_cc213c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. *Size:* 1-12 dwords. Actual size depends on opcode, specific image being handled and :ref:`a16<amdgpu_synid_a16>`. Note. Image format and dimensions are encoded in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_cc213c.rst:377,depend,depends,377,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_cc213c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vaddr_cc213c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdata_898c08:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_898c08.rst:417,depend,depends,417,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_898c08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_898c08.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdata_929b59:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_929b59.rst:280,depend,depends,280,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_929b59.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_929b59.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdata_999247:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_999247.rst:417,depend,depends,417,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_999247.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_999247.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdata_cbb01e:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_cbb01e.rst:280,depend,depends,280,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_cbb01e.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdata_cbb01e.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdst_a9ee3f:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_a9ee3f.rst:273,depend,depends,273,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_a9ee3f.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_a9ee3f.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx90a_vdst_f5eb9d:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`, :ref:`a<amdgpu_synid_a>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_f5eb9d.rst:273,depend,depends,273,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_f5eb9d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_vdst_f5eb9d.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx940_fx_operand:. FX Operand; ==========. This is a *f32* or *f16* operand depending on instruction modifiers:. * Operand size is controlled by :ref:`m_op_sel_hi<amdgpu_synid_mad_mix_op_sel_hi>`.; * Location of the 16-bit operand is controlled by :ref:`m_op_sel<amdgpu_synid_mad_mix_op_sel>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_fx_operand.rst:260,depend,depending,260,interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_fx_operand.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_fx_operand.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx940_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst:215,message,message,215,interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx940_vaddr_0212e3:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx940_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx940_vaddr_0212e3>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx940_saddr_a37373>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx940_saddr_a37373>` + :ref:`vaddr<amdgpu_synid_gfx940_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx940_vaddr_0212e3>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx940_saddr_a37373>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_vaddr_0212e3.rst:267,depend,depending,267,interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_vaddr_0212e3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx940_vaddr_0212e3.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_msg:. msg; ===. A 16-bit message code. The bits of this operand have the following meaning:. ============ =============================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst:213,message,message,213,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_msg.rst,1,['message'],['message']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vaddr_0212e3:. vaddr; =====. A 64-bit flat global address or a 32-bit offset depending on addressing mode:. * Address = :ref:`vaddr<amdgpu_synid_gfx9_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx9_vaddr_0212e3>` is a 64-bit address. This mode is indicated by :ref:`saddr<amdgpu_synid_gfx9_saddr_a37373>` set to :ref:`off<amdgpu_synid_off>`.; * Address = :ref:`saddr<amdgpu_synid_gfx9_saddr_a37373>` + :ref:`vaddr<amdgpu_synid_gfx9_vaddr_0212e3>` + :ref:`offset13s<amdgpu_synid_flat_offset13s>`. :ref:`vaddr<amdgpu_synid_gfx9_vaddr_0212e3>` is a 32-bit offset. This mode is used when :ref:`saddr<amdgpu_synid_gfx9_saddr_a37373>` is not :ref:`off<amdgpu_synid_off>`. *Size:* 1 or 2 dwords. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_0212e3.rst:265,depend,depending,265,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_0212e3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_0212e3.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vaddr_cc213c:. vaddr; =====. Image address which includes from one to four dimensional coordinates and other data used to locate a position in the image. *Size:* 1-12 dwords. Actual size depends on opcode, specific image being handled and :ref:`a16<amdgpu_synid_a16>`. Note. Image format and dimensions are encoded in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_cc213c.rst:375,depend,depends,375,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_cc213c.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vaddr_cc213c.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdata_21b58d:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_21b58d.rst:278,depend,depends,278,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_21b58d.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_21b58d.rst,2,['depend'],"['depending', 'depends']"
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdata_84fab6:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 2 data elements for 32-bit-per-pixel surfaces or 4 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_84fab6.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_84fab6.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_84fab6.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdata_aa5a53:. vdata; =====. Input data for an atomic instruction. Optionally, this operand may be used to store output data:. * If :ref:`glc<amdgpu_synid_glc>` is specified, gets the memory value before the operation. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify 1 data element for 32-bit-per-pixel surfaces or 2 data elements for 64-bit-per-pixel surfaces. Each data element occupies 1 dword. Note: the surface data format is indicated in the image resource constant, but not in the instruction. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_aa5a53.rst:415,depend,depends,415,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_aa5a53.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_aa5a53.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdata_c08393:. vdata; =====. Image data to store by an *image_store* instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` which may specify from 1 to 4 data elements. Each data element occupies 1 dword. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_c08393.rst:278,depend,depends,278,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_c08393.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdata_c08393.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdst_5ec176:. vdst; ====. Image data to be loaded by an *image_gather4* instruction. *Size:* 4 data elements by default. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`. :ref:`d16<amdgpu_synid_d16>` affects operand size as follows:. * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_5ec176.rst:363,depend,depending,363,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_5ec176.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_5ec176.rst,1,['depend'],['depending']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdst_dfa6da:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>` and :ref:`tfe<amdgpu_synid_tfe>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies 1 dword.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_dfa6da.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_dfa6da.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_dfa6da.rst,1,['depend'],['depends']
Integrability,"..; **************************************************; * *; * Automatically generated file, do not edit! *; * *; **************************************************. .. _amdgpu_synid_gfx9_vdst_eae4c8:. vdst; ====. Image data to be loaded by an image instruction. *Size:* depends on :ref:`dmask<amdgpu_synid_dmask>`, :ref:`tfe<amdgpu_synid_tfe>` and :ref:`d16<amdgpu_synid_d16>`:. * :ref:`dmask<amdgpu_synid_dmask>` may specify from 1 to 4 data elements. Each data element occupies either 32 bits or 16 bits, depending on :ref:`d16<amdgpu_synid_d16>`.; * :ref:`d16<amdgpu_synid_d16>` specifies that data elements in registers are packed; each value occupies 16 bits.; * :ref:`tfe<amdgpu_synid_tfe>` adds 1 dword if specified. *Operands:* :ref:`v<amdgpu_synid_v>`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_eae4c8.rst:271,depend,depends,271,interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_eae4c8.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx9_vdst_eae4c8.rst,2,['depend'],"['depending', 'depends']"
Integrability,".; - `SetParameters(…)` or `SetParameter(…)` on a TF1 reset the properties of the axis that have been previously defined.; This was due to the `Update()` that was done after the parameters definition.; - Update fonts' documentation (CMS request).; - Delaunay triangles were computed by the package `triangle.c` included in the ROOT code.; This package had several problems:; - It was not maintained anymore.; - Its license was not compatible with LGPL.; It is now replaced by the CDT package which is properly maintained and has a license (MLP) compatible with LGPL. ## 3D Graphics Libraries. ### REve; * Introduce lightweight visualization of instanced shapes on the level of 100.000 instances. This is integrated in digit visualization of the type REveBoxSet. List of typed instances are boxes, hexagons, and cones. The digit sets support different types of transformation: positioning, rotation, and scaling in different combinations. With the digit set a palette GUI interface has also been added to enable setting digits threshold and value to color mapping. <figure>; <img src=""reve-boxset-cones.png"" >; <figcaption>REveBoxSet screenshot with cone shape type. The set is using value to color map with overflow and underflow mark. The single REveBoxet object has a secondary selection enabled, where one can set a custom tooltip on mouse hover of an individual instance.</figcaption>; </figure>. * Update version of RenderCore to fix tone mapping of transparent objects. ## PROOF Libraries. By default, PROOF is not configured and built any more. It will be deprecated in the future given that its functionality is now provided by the superior RDataFrame and its distributed version, [DistRDF](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#distrdf). ## PyROOT. PyROOT was rebased on the latest version of the [cppyy library](https://cppyy.readthedocs.io/en/latest/).; This means PyROOT benefits from many upstream improvements and fixes, for example related to the conversion of NumP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:18432,interface,interface,18432,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interface']
Integrability,".; See the section on :ref:`STL <stl>`. `Arrays`; """""""""""""""". Builtin arrays are supported through arrays from module ``array`` (or any; other builtin-type array that implements the Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avoided; in C++ anyway:. .. code-block:: python. >>> cppyy.cppdef('std::string str_array[3][2] = {{""aa"", ""bb""}, {""cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:4047,depend,depending,4047,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['depend'],['depending']
Integrability,".; While loadScript and AssertPrerequisites functions moved to JSROOT, one; can easily build many different kinds of GUIs, reusing provided JSRootCore.js functions.; 8. In example.htm also use AssertPrerequisites to load necessary scripts.; This helps to keep code up-to-date even by big changes in JavaScript code.; 9. Provide monitoring of online THttpServer with similar interface as for ROOT files.; 10. Fix several errors in TKey Streamer, use member names as in ROOT itself.; 11. Keep the only version identifier JSROOT.version for JS code; 12. One can specify in JSROOT.AssertPrerequisites functionality which is required.; One could specify '2d', 'io' (default) or '3d'.; 13. Use new AssertPrerequisites functionality to load only required functionality.; 14. When displaying single element, one could specify draw options and monitor property like:; <http://localhost:8080/Files/job1.root/hpxpy/draw.htm?opt=col&monitor=2000>; Such link is best possibility to integrate display into different HTML pages,; using `<iframe/>` tag like:; `<iframe src=""http://localhost:8080/Files/job1.root/hpx/draw.htm""`; `style=""width: 800px; height:600px""></iframe>`; 15. Remove 'JSROOTIO.' prefix from _typename. Now real class name is used.; 16. Use in all scripts JSROOT as central 'namespace'; 17. Introduce context menu in 3D, use it for switch between 2D/3D modes; 18. Use own code to generate hierarchical structure in HTML, replace dtree.js which is; extremely slow for complex hierarchies. Dramatically improve performance for; structures with large (~1000) number of items.; 19. Deliver to the server title of the objects, display it as hint in the browser.; 20. Better handling of special characters in the hierarchies - allows to display; symbols like ' or "" in the file structure. ### July 2014; 1. Migration to d3.v3.js and jQuery v2.1.1; 2. Fix errors in filling of histogram statbox; 3. Possibility of move and resize of statbox, title, color palete; 4. Remove many (not all) global variables",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:75585,integrat,integrate,75585,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['integrat'],['integrate']
Integrability,".access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustprogress`` metadata indicates that this loop is required to; terminate, unwind, or interact with the environment in an observable way e.g.; via a volatile memory access, I/O, or other synchronization. If such a loop is; not found to interact with the environment in an observable way, the loop may; be removed. This corresponds to the ``mustprogress`` function attribute. '``irr_loop``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^. ``irr_loop`` metadata may be attached to the terminator instruction of a basic; block that's an irreducible loop header (note that an irreducible loop has more; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreducible loop; header, the behavior is undefined. The intent of this metadata is to improve the; accuracy of the block frequency propagation. For example, in the code below, the; block ``header0`` may have a loop header weight (relative to the other headers of; the irreducible loop) of 100:. .. code-block:: llvm. header0:; ...; br i1 %cmp, label %t1, label %t2, !irr_loop !0. ...; !0 = !{""loop_header_weight"", i64 100}. Irreducible loop heade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:314788,synchroniz,synchronization,314788,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronization']
Integrability,".com; D: Loop Vectorizer. N: Sundeep Kushwaha; E: sundeepk@codeaurora.org; D: Implemented DFA-based target independent VLIW packetizer. N: Christopher Lamb; E: christopher.lamb@gmail.com; D: aligned load/store support, parts of noalias and restrict support; D: vreg subreg infrastructure, X86 codegen improvements based on subregs; D: address spaces. N: Jim Laskey; E: jlaskey@apple.com; D: Improvements to the PPC backend, instruction scheduling; D: Debug and Dwarf implementation; D: Auto upgrade mangler; D: llvm-gcc4 svn wrangler. N: Chris Lattner; E: sabre@nondot.org; W: http://nondot.org/~sabre/; D: Primary architect of LLVM. N: Tanya Lattner (Tanya Brethour); E: tonic@nondot.org; W: http://nondot.org/~tonic/; D: The initial llvm-ar tool, converted regression testsuite to dejagnu; D: Modulo scheduling in the SparcV9 backend; D: Release manager (1.7+). N: Sylvestre Ledru; E: sylvestre@debian.org; W: http://sylvestre.ledru.info/; W: https://apt.llvm.org/; D: Debian and Ubuntu packaging; D: Continuous integration with jenkins. N: Andrew Lenharth; E: alenhar2@cs.uiuc.edu; W: http://www.lenharth.org/~andrewl/; D: Alpha backend; D: Sampling based profiling. N: Nick Lewycky; E: nicholas@mxc.ca; D: PredicateSimplifier pass. N: Tony Linthicum, et. al.; E: tlinth@codeaurora.org; D: Backend for Qualcomm's Hexagon VLIW processor. N: Bruno Cardoso Lopes; E: bruno.cardoso@gmail.com; I: bruno; W: http://brunocardoso.cc; D: Mips backend; D: Random ARM integrated assembler and assembly parser improvements; D: General X86 AVX1 support. N: Weining Lu; E: luweining@loongson.cn; D: LoongArch backend. N: Duraid Madina; E: duraid@octopus.com.au; W: http://kinoko.c.u-tokyo.ac.jp/~duraid/; D: IA64 backend, BigBlock register allocator. N: John McCall; E: rjmccall@apple.com; D: Clang semantic analysis and IR generation. N: Michael McCracken; E: michael.mccracken@gmail.com; D: Line number support for llvmgcc. N: Fanbo Meng; E: fanbo.meng@ibm.com; D: z/OS support. N: Vladimir Merzliakov; E: wand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:7735,integrat,integration,7735,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['integrat'],['integration']
Integrability,.cpp; clang/lib/Tooling/Syntax/Tree.cpp; clang/lib/Tooling/Syntax/Pseudo/Grammar.cpp; clang/lib/Tooling/Syntax/Pseudo/GrammarBNF.cpp; clang/lib/Tooling/Syntax/Pseudo/Lex.cpp; clang/lib/Tooling/Syntax/Pseudo/LRGraph.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTable.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:27838,wrap,wrapper,27838,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['wrap'],['wrapper']
Integrability,".cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13771,message,message,13771,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['message'],['message']
Integrability,".d.f evaluates to zero or negative number @ x=x=2.48563, mean=m=-7.39713, sigma=sx=0.1. The new-style error logging is active whenever MINUIT is operating on such a p.d.f. The default value for N is 3.; Outside the MINUIT context the evaluation error each evualuation error will generate a separate message through; RooMsgService; Other new features. The RooAddPdf constructor has been augmented with an additional boolean argument that allows to; interpret the supplied fraction parameters as recursive fractions rather than plain fractions.; If activated, an example RooAddPdf with three input p.d.f. A,B,C and two fractions fA and fB will; result in the expression; fA*A + (1-fA)(fB*B + 1-fB*C) rather than fA*A + fB*B + (1-fA-fB)*C. Recursive fraction have the advantage that all fraction can be defined to be in the range [0-1]; without resulting in configuration where the sum of all fractions exceeds 1.; The low-level object printing interface printToStream() has been deprecated in favor of a new; printStream() method which allows much greater control over the information printed. ; The printing of almost all RooFit objects has been reworked to present a more uniform look and feel.; The standard one-line result of the high-level Print() method without option now looks like. // Variable; x.Print() ;; RooRealVar::x = 0 L(-10 - 10) . // Function or p.d.f; gx.Print() ;; RooGaussian::gx[ x=x mean=m sigma=sx ] = 1. // Dataset; d.Print() ;; RooDataSet::gData[x,y] = 1000 entries. // RooPlot; frame.Print() ;; framex[x] = (RooHist::h_gData,RooCurve::g_Int[y]_Norm[x,y]_Comp[g]). Inside class RooPlot the default name of contained curves and histograms has been ; reworked in something more self descriptive as is shown in the above example. A usual,; a user supplied name can always be set by supplying the Name(const char*) argument; to plotOn(). Verbose printing with ""v"" options is mostly unchanged except for RooPlot. In addition; printing with the ""s"" option will show the 'old' standar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:18205,interface,interface,18205,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['interface'],['interface']
Integrability,".followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] = B[0];. into:. .. code-block:: c. if (rtc) {; auto b = B[0];; for (int i = 0; i < n; i+=1) // versioned loop; A[i] = b;; } else {; for (int i = 0; i < n; i+=1) // unversioned loop; A[i] = B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop Interchange; ----------------. Currently, the ``LoopInterchange`` pass does not use any metadata. Ambiguous Transformation Order; ==============================. If there multiple transformations defined, the order in which they are; executed depends on the order in LLVM's pass pipeline, which is subject; to change. The default optimization pipeline (anything higher than; ``-O0``) has the following order. When using the legacy pass manager:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - VersioningLICM (if enabled); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). When using the legacy pass manager with LTO:. - LoopInterchange (if enabled); - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopVectorizer; - LoopUnroll (partial and runtime unrolling). When using the new pass manager:. - SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling); - LoopDistribute; - LoopVectorizer; - LoopUnrollAndJam (if enabled); - LoopUnroll (partial and runtime unrolling). Leftover Transformations; ========================. Forced transformations that have not been applied after the last; transfor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:13597,depend,depends,13597,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['depend'],['depends']
Integrability,".g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2412,depend,depend,2412,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['depend']
Integrability,".hatSize = 7;; std::vector<Person> persons;; persons.push_back(tom);; persons.push_back(dan);. Output yout(llvm::outs());; yout << persons;. This would write the following:. .. code-block:: yaml. - name: Tom; hat-size: 8; - name: Dan; hat-size: 7. And you can also read such YAML documents with the following code:. .. code-block:: c++. using llvm::yaml::Input;. typedef std::vector<Person> PersonList;; std::vector<PersonList> docs;. Input yin(document.getBuffer());; yin >> docs;. if ( yin.error() ); return;. // Process read document; for ( PersonList &pl : docs ) {; for ( Person &person : pl ) {; cout << ""name="" << person.name;; }; }. One other feature of YAML is the ability to define multiple documents in a; single file. That is why reading YAML produces a vector of your document type. Error Handling; ==============. When parsing a YAML document, if the input does not match your schema (as; expressed in your XxxTraits<> specializations). YAML I/O; will print out an error message and your Input object's error() method will; return true. For instance the following document:. .. code-block:: yaml. - name: Tom; shoe-size: 12; - name: Dan; hat-size: 7. Has a key (shoe-size) that is not defined in the schema. YAML I/O will; automatically generate this error:. .. code-block:: yaml. YAML:2:2: error: unknown key 'shoe-size'; shoe-size: 12; ^~~~~~~~~. Similar errors are produced for other input not conforming to the schema. Scalars; =======. YAML scalars are just strings (i.e. not a sequence or mapping). The YAML I/O; library provides support for translating between YAML scalars and specific; C++ types. Built-in types; --------------; The following types have built-in support in YAML I/O:. * bool; * float; * double; * StringRef; * std::string; * int64_t; * int32_t; * int16_t; * int8_t; * uint64_t; * uint32_t; * uint16_t; * uint8_t. That is, you can use those types in fields of MappingTraits or as element type; in sequence. When reading, YAML I/O will validate that the string f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:5536,message,message,5536,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['message'],['message']
Integrability,".inline.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the; source location to the destination location and guarantees that no external; functions are called. Note that, unlike the standard libc function, the ``llvm.memcpy.inline.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is a constant integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy.inline`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the; source location to the destination location, which are not allowed to; overlap. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on; the argument.; The behavior of '``llvm.memcpy.inline.*``' is equivalent to the behavior of; '``llvm.memcpy.*``', but the generated code is guaranteed not to call any; external functions. .. _int_memmove:. '``llvm.memmove``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.memmove on any integer; bit width and for different address space. Not all targets support all; bit widths however. ::. declare void @llvm.memmove.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memmove.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Ov",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:550044,depend,depend,550044,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,".py; ${PYROOT_EXTRA_PYTHON_SOURCES}; ). set(cpp_sources; src/PyROOTModule.cxx; src/PyROOTWrapper.cxx; src/RPyROOTApplication.cxx; src/GenericPyz.cxx; src/TClassPyz.cxx; src/TMemoryRegulator.cxx; src/TObjectPyz.cxx; src/TTreePyz.cxx; src/CPPInstancePyz.cxx; src/TPyDispatcher.cxx; inc/TPyDispatcher.h; ). set(ROOTPySrcDir python/ROOT); set(ROOT_headers_dir inc). # Add custom rules to copy the Python sources into the build directory; foreach(py_source ${py_sources}); add_custom_command(; OUTPUT ${localruntimedir}/${py_source}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}; ${localruntimedir}/${py_source}; DEPENDS python/${py_source}; COMMENT ""Copying ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}""); list(APPEND py_sources_in_localruntimedir ${localruntimedir}/${py_source}); endforeach(). # A custom target that depends on the Python sources being present in the build; # directory. This will be used as a dependency of the pythonization libraries,; # such that the Python sources get re-copied to the build directory when; # changed.; add_custom_target(ROOTPythonizationsPySources ALL DEPENDS ${py_sources_in_localruntimedir}). # Copy headers inside build_dir/include/ROOT; file(COPY ${ROOT_headers_dir}/ DESTINATION ${CMAKE_BINARY_DIR}/include/ROOT). set(libname ROOTPythonizations). add_library(${libname} SHARED ${cpp_sources}). # Insert the ROOTPythonizationsPySources in the dependency graph; add_dependencies(${libname} ROOTPythonizationsPySources). # Set the suffix to '.so' and the prefix to 'lib'; set_target_properties(${libname} PROPERTIES ${ROOT_LIBRARY_PROPERTIES_NO_VERSION}); if(MSVC); set_target_properties(${libname} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE); set_target_properties(${libname} PROPERTIES SUFFIX "".pyd""); target_link_libraries(${libname} PUBLIC Core Tree cppyy); elseif(APPLE); target_link_libraries(${libname} PUBLIC -Wl,-bind_at_load -Wl,-w -Wl,-undefined -Wl,dynamic_lookup Core Tree cppyy); else(); target_link_librarie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt:4693,depend,dependency,4693,bindings/pyroot/pythonizations/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"/ warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer over",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8869,interface,interface,8869,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['interface'],['interface']
Integrability,"/""); !2 = !{}; !3 = !{i32 5}; !4 = !{i32 2}; !5 = !{i32 2, !""Debug Info Version"", i32 3}; !6 = distinct !DISubprogram(name: ""f"", linkageName: ""f"", scope: null, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: true, unit: !0, retainedNodes: !8); !7 = !DISubroutineType(types: !2); !8 = !{!9, !11}; !9 = !DILocalVariable(name: ""1"", scope: !6, file: !1, line: 1, type: !10); !10 = !DIBasicType(name: ""ty64"", size: 64, encoding: DW_ATE_unsigned); !11 = !DILocalVariable(name: ""2"", scope: !6, file: !1, line: 3, type: !10); !12 = !DILocation(line: 1, column: 1, scope: !6); !13 = !DILocation(line: 2, column: 1, scope: !6); !14 = !DILocation(line: 3, column: 1, scope: !6); !15 = !DILocation(line: 4, column: 1, scope: !6); !16 = !DILocation(line: 5, column: 1, scope: !6). Using ``debugify``; ^^^^^^^^^^^^^^^^^^. A simple way to use ``debugify`` is as follows:. .. code-block:: bash. $ opt -debugify -pass-to-test -check-debugify sample.ll. This will inject synthetic DI to ``sample.ll`` run the ``pass-to-test`` and; then check for missing DI. The ``-check-debugify`` step can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:12141,inject,inject,12141,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['inject'],['inject']
Integrability,"/.git; remote get-url origin OUTPUT_VARIABLE originurl OUTPUT_STRIP_TRAILING_WHITESPACE). else(); # The fetch URL of the 'origin' remote is used to determine the prefix for other repositories by; # removing the `/root(\.git)?` part. If `GITHUB_PR_ORIGIN` is defined in the environment, its; # value is used instead.; if(DEFINED ENV{GITHUB_PR_ORIGIN}); set(originurl $ENV{GITHUB_PR_ORIGIN}); else(); execute_process(COMMAND ${GIT_EXECUTABLE} --git-dir=${CMAKE_CURRENT_SOURCE_DIR}/.git; remote get-url origin OUTPUT_VARIABLE originurl OUTPUT_STRIP_TRAILING_WHITESPACE); endif(); endif(); string(REGEX REPLACE ""/root(test)?(\.git)?$"" """" originprefix ${originurl}); relatedrepo_GetClosestMatch(REPO_NAME roottest; ORIGIN_PREFIX ${originprefix} UPSTREAM_PREFIX ${upstreamprefix}; FETCHURL_VARIABLE roottest_url FETCHREF_VARIABLE roottest_ref); # Use `-Droottest_force_checkout=ON` to force fetch and checkout in an existing repository; if(roottest_force_checkout); set(roottest_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME roottest FETCHURL ${roottest_url} FETCHREF ""${roottest_ref}""; REPO_DIR_VARIABLE roottest_dir ${roottest_opts}); if(NOT IS_DIRECTORY ${roottest_dir}); message(FATAL_ERROR ""Expected roottest at '${roottest_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/roottest); add_subdirectory(${roottest_dir} roottest); endif(). if(rootbench); find_package(Git REQUIRED); if(rootbench_force_checkout); set(rootbench_opts FORCE); endif(); relatedrepo_Checkout(REPO_NAME rootbench FETCHURL ${upstreamprefix} FETCHREF master; REPO_DIR_VARIABLE rootbench_dir ${rootbench_opts}); if(NOT IS_DIRECTORY ${rootbench_dir}); message(FATAL_ERROR ""Expected rootbench at '${rootbench_dir}' (not a directory?)""); endif(); file(REMOVE_RECURSE ${CMAKE_CURRENT_BINARY_DIR}/rootbench); add_subdirectory(${rootbench_dir} rootbench); endif(); endif(). if(LLVM_LINKER_IS_MOLD); message(FATAL_ERROR ""The mold linker is not supported by ROOT. Please use a different linker"");",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:29711,message,message,29711,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"// version 2. The TZIPFile compressed archive reader now supports the Zip64 format for; archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the code/dictonary only for pair type that do not already have a dictionary. Object Merging; We introduced a new explicit interface for providing merging; capability. If a class has a method with the name and; signature:. Long64_t Merge(TCollection *input, TFileMergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a collection). In TFileMerger, we added a PrintLevel to allow hadd to request; more output than regular TFileMerger. We removed all hard dependencies of TFileMerger on TH1 and TTree.; (Soft dependencies still exist to be able to disable the; merging of TTrees and to be able to disable the AutoAdd; behavior of TH1). The object TFileMergeInfo can be used inside the Merge; function to pass information between runs of the Merge; (see below). In particular it contains:. TDirectory *fOutputDirectory; // Target directory where the merged object will be written.; Bool_t fIsFirst; // True if this is the fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:3155,wrap,wrapper,3155,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['wrap'],['wrapper']
Integrability,"//===-- README.txt - Notes for WebAssembly code gen -----------------------===//. The object format emitted by the WebAssembly backed is documented in:. * https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md. The C ABI is described in:. * https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md. For more information on WebAssembly itself, see the home page:. * https://webassembly.github.io/. Emscripten provides a C/C++ compilation environment based on clang which; includes standard libraries, tools, and packaging for producing WebAssembly; applications that can run in browsers and other environments. wasi-sdk provides a more minimal C/C++ SDK based on clang, llvm and a libc based; on musl, for producing WebAssembly applications that use the WASI ABI. Rust provides WebAssembly support integrated into Cargo. There are two; main options:; - wasm32-unknown-unknown, which provides a relatively minimal environment; that has an emphasis on being ""native""; - wasm32-unknown-emscripten, which uses Emscripten internally and; provides standard C/C++ libraries, filesystem emulation, GL and SDL; bindings; For more information, see:; * https://www.hellorust.com/. The following documents contain some information on the semantics and binary; encoding of WebAssembly itself:; * https://github.com/WebAssembly/design/blob/main/Semantics.md; * https://github.com/WebAssembly/design/blob/main/BinaryEncoding.md. Some notes on ways that the generated code could be improved follow:. //===---------------------------------------------------------------------===//. Br, br_if, and br_table instructions can support having a value on the value; stack across the jump (sometimes). We should (a) model this, and (b) extend; the stackifier to utilize it. //===---------------------------------------------------------------------===//. The min/max instructions aren't exactly a<b?a:b because of NaN and negative zero; behavior. The ARM target has the same kind of min/max instruc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:825,integrat,integrated,825,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['integrat'],['integrated']
Integrability,"//===----------------------------------------------------------------------===//; // Clang Static Analyzer; //===----------------------------------------------------------------------===//. = Library Structure =. The analyzer library has two layers: a (low-level) static analysis; engine (ExprEngine.cpp and friends), and some static checkers; (*Checker.cpp). The latter are built on top of the former via the; Checker and CheckerVisitor interfaces (Checker.h and; CheckerVisitor.h). The Checker interface is designed to be minimal; and simple for checker writers, and attempts to isolate them from much; of the gore of the internal analysis engine. = How It Works =. The analyzer is inspired by several foundational research papers ([1],; [2]). (FIXME: kremenek to add more links). In a nutshell, the analyzer is basically a source code simulator that; traces out possible paths of execution. The state of the program; (values of variables and expressions) is encapsulated by the state; (ProgramState). A location in the program is called a program point; (ProgramPoint), and the combination of state and program point is a; node in an exploded graph (ExplodedGraph). The term ""exploded"" comes; from exploding the control-flow edges in the control-flow graph (CFG). Conceptually the analyzer does a reachability analysis through the; ExplodedGraph. We start at a root node, which has the entry program; point and initial state, and then simulate transitions by analyzing; individual expressions. The analysis of an expression can cause the; state to change, resulting in a new node in the ExplodedGraph with an; updated program point and an updated state. A bug is found by hitting; a node that satisfies some ""bug condition"" (basically a violation of a; checking invariant). The analyzer traces out multiple paths by reasoning about branches and; then bifurcating the state: on the true branch the conditions of the; branch are assumed to be true and on the false branch the conditions; of the branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:438,interface,interfaces,438,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,2,['interface'],"['interface', 'interfaces']"
Integrability,"//===----------------------------------------------------------------------===//; // Representing sign/zero extension of function results; //===----------------------------------------------------------------------===//. Mar 25, 2009 - Initial Revision. Most ABIs specify that functions which return small integers do so in a; specific integer GPR. This is an efficient way to go, but raises the question:; if the returned value is smaller than the register, what do the high bits hold?. There are three (interesting) possible answers: undefined, zero extended, or; sign extended. The number of bits in question depends on the data-type that; the front-end is referencing (typically i1/i8/i16/i32). Knowing the answer to this is important for two reasons: 1) we want to be able; to implement the ABI correctly. If we need to sign extend the result according; to the ABI, we really really do need to do this to preserve correctness. 2); this information is often useful for optimization purposes, and we want the; mid-level optimizers to be able to process this (e.g. eliminate redundant; extensions). For example, lets pretend that X86 requires the caller to properly extend the; result of a return (I'm not sure this is the case, but the argument doesn't; depend on this). Given this, we should compile this:. int a();; short b() { return a(); }. into:. _b:; 	subl	$12, %esp; 	call	L_a$stub; 	addl	$12, %esp; 	cwtl; 	ret. An optimization example is that we should be able to eliminate the explicit; sign extension in this example:. short y();; int z() {; return ((int)y() << 16) >> 16;; }. _z:; 	subl	$12, %esp; 	call	_y; 	;; movswl %ax, %eax -> not needed because eax is already sext'd; 	addl	$12, %esp; 	ret. //===----------------------------------------------------------------------===//; // What we have right now.; //===----------------------------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:612,depend,depends,612,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['depend'],['depends']
Integrability,"/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21860,rout,routine,21860,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['rout'],['routine']
Integrability,"/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30625,depend,dependent,30625,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,/CodeGen/IslAst.cpp; polly/lib/CodeGen/IslExprBuilder.cpp; polly/lib/CodeGen/IslNodeBuilder.cpp; polly/lib/CodeGen/LoopGenerators.cpp; polly/lib/CodeGen/LoopGeneratorsGOMP.cpp; polly/lib/CodeGen/LoopGeneratorsKMP.cpp; polly/lib/CodeGen/ManagedMemoryRewrite.cpp; polly/lib/CodeGen/PerfMonitor.cpp; polly/lib/CodeGen/PPCGCodeGeneration.cpp; polly/lib/CodeGen/RuntimeDebugBuilder.cpp; polly/lib/CodeGen/Utils.cpp; polly/lib/Exchange/JSONExporter.cpp; polly/lib/External/isl/isl_local_private.h; polly/lib/External/isl/imath/iprime.h; polly/lib/External/isl/include/isl/id_type.h; polly/lib/External/isl/include/isl/isl-noexceptions.h; polly/lib/External/isl/include/isl/map_type.h; polly/lib/External/isl/include/isl/printer_type.h; polly/lib/External/isl/include/isl/set_type.h; polly/lib/External/isl/include/isl/union_map_type.h; polly/lib/External/isl/include/isl/union_set_type.h; polly/lib/External/isl/include/isl/val_type.h; polly/lib/External/isl/include/isl/version.h; polly/lib/External/isl/interface/extract_interface.h; polly/lib/Plugin/Polly.cpp; polly/lib/Support/DumpFunctionPass.cpp; polly/lib/Support/DumpModulePass.cpp; polly/lib/Support/GICHelper.cpp; polly/lib/Support/ISLTools.cpp; polly/lib/Support/Mainpage.h; polly/lib/Support/RegisterPasses.cpp; polly/lib/Support/SCEVAffinator.cpp; polly/lib/Support/SCEVValidator.cpp; polly/lib/Support/ScopHelper.cpp; polly/lib/Support/ScopLocation.cpp; polly/lib/Support/VirtualInstruction.cpp; polly/lib/Transform/Canonicalization.cpp; polly/lib/Transform/CodePreparation.cpp; polly/lib/Transform/DeadCodeElimination.cpp; polly/lib/Transform/DeLICM.cpp; polly/lib/Transform/FlattenAlgo.cpp; polly/lib/Transform/FlattenSchedule.cpp; polly/lib/Transform/ForwardOpTree.cpp; polly/lib/Transform/ManualOptimizer.cpp; polly/lib/Transform/MatmulOptimizer.cpp; polly/lib/Transform/MaximalStaticExpansion.cpp; polly/lib/Transform/ScheduleOptimizer.cpp; polly/lib/Transform/ScheduleTreeTransform.cpp; polly/lib/Transform/ScopInliner.cpp; polly/lib/T,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:415199,interface,interface,415199,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['interface'],['interface']
Integrability,/FIRAttr.h; flang/include/flang/Optimizer/Dialect/FIRDialect.h; flang/include/flang/Optimizer/Dialect/FIROps.h; flang/include/flang/Optimizer/Dialect/FIROpsSupport.h; flang/include/flang/Optimizer/Dialect/FIRType.h; flang/include/flang/Optimizer/Support/FatalError.h; flang/include/flang/Optimizer/Support/FIRContext.h; flang/include/flang/Optimizer/Support/InitFIR.h; flang/include/flang/Optimizer/Support/InternalNames.h; flang/include/flang/Optimizer/Support/KindMapping.h; flang/include/flang/Optimizer/Support/Matcher.h; flang/include/flang/Optimizer/Support/TypeCode.h; flang/include/flang/Optimizer/Support/Utils.h; flang/include/flang/Optimizer/Transforms/Passes.h; flang/include/flang/Parser/char-block.h; flang/include/flang/Parser/char-buffer.h; flang/include/flang/Parser/char-set.h; flang/include/flang/Parser/characters.h; flang/include/flang/Parser/dump-parse-tree.h; flang/include/flang/Parser/format-specification.h; flang/include/flang/Parser/instrumented-parser.h; flang/include/flang/Parser/message.h; flang/include/flang/Parser/parse-state.h; flang/include/flang/Parser/parse-tree-visitor.h; flang/include/flang/Parser/parsing.h; flang/include/flang/Parser/provenance.h; flang/include/flang/Parser/source.h; flang/include/flang/Parser/tools.h; flang/include/flang/Parser/unparse.h; flang/include/flang/Parser/user-state.h; flang/include/flang/Runtime/allocatable.h; flang/include/flang/Runtime/assign.h; flang/include/flang/Runtime/c-or-cpp.h; flang/include/flang/Runtime/character.h; flang/include/flang/Runtime/command.h; flang/include/flang/Runtime/cpp-type.h; flang/include/flang/Runtime/derived-api.h; flang/include/flang/Runtime/descriptor.h; flang/include/flang/Runtime/entry-names.h; flang/include/flang/Runtime/extensions.h; flang/include/flang/Runtime/inquiry.h; flang/include/flang/Runtime/io-api.h; flang/include/flang/Runtime/iostat.h; flang/include/flang/Runtime/main.h; flang/include/flang/Runtime/matmul.h; flang/include/flang/Runtime/memory.h; flang/include/flan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:114039,message,message,114039,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['message'],['message']
Integrability,"/GIDs; to write archives in a deterministic mode. This is equivalent to the; :option:`D` modifier being enabled by default. If you wish to maintain; compatibility with other :program:`ar` implementations, you can pass the; :option:`U` modifier to write actual timestamps and UIDs/GIDs. *Windows Paths*. When on Windows :program:`llvm-ar` treats the names of archived *files* in the same; case sensitive manner as the operating system. When on a non-Windows machine; :program:`llvm-ar` does not consider character case. OPTIONS; -------. :program:`llvm-ar` operations are compatible with other :program:`ar`; implementations. However, there are a few modifiers (:option:`L`) that are not; found in other :program:`ar` implementations. The options for; :program:`llvm-ar` specify a single basic Operation to perform on the archive,; a variety of Modifiers for that Operation, the name of the archive file, and an; optional list of file names. If the *files* option is not specified, it; generally means either ""none"" or ""all"" members, depending on the operation. The; Options, Operations and Modifiers are explained in the sections below. The minimal set of options is at least one operator and the name of the; archive. Operations; ~~~~~~~~~~. .. option:: d [NT]. Delete files from the ``archive``. The :option:`N` and :option:`T` modifiers; apply to this operation. The *files* options specify which members should be; removed from the archive. It is not an error if a specified file does not; appear in the archive. If no *files* are specified, the archive is not; modified. .. option:: m [abi]. Move files from one location in the ``archive`` to another. The :option:`a`,; :option:`b`, and :option:`i` modifiers apply to this operation. The *files*; will all be moved to the location given by the modifiers. If no modifiers are; used, the files will be moved to the end of the archive. If no *files* are; specified, the archive is not modified. .. option:: p [v]. Print *files* to the standard outp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:2682,depend,depending,2682,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['depend'],['depending']
Integrability,"/_pythonization/_tstring.py; ROOT/_pythonization/_ttree.py; ROOT/_pythonization/_tvector3.py; ROOT/_pythonization/_tvectort.py; ${PYROOT_EXTRA_PYTHON_SOURCES}; ). set(cpp_sources; src/PyROOTModule.cxx; src/PyROOTWrapper.cxx; src/RPyROOTApplication.cxx; src/GenericPyz.cxx; src/TClassPyz.cxx; src/TMemoryRegulator.cxx; src/TObjectPyz.cxx; src/TTreePyz.cxx; src/CPPInstancePyz.cxx; src/TPyDispatcher.cxx; inc/TPyDispatcher.h; ). set(ROOTPySrcDir python/ROOT); set(ROOT_headers_dir inc). # Add custom rules to copy the Python sources into the build directory; foreach(py_source ${py_sources}); add_custom_command(; OUTPUT ${localruntimedir}/${py_source}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}; ${localruntimedir}/${py_source}; DEPENDS python/${py_source}; COMMENT ""Copying ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}""); list(APPEND py_sources_in_localruntimedir ${localruntimedir}/${py_source}); endforeach(). # A custom target that depends on the Python sources being present in the build; # directory. This will be used as a dependency of the pythonization libraries,; # such that the Python sources get re-copied to the build directory when; # changed.; add_custom_target(ROOTPythonizationsPySources ALL DEPENDS ${py_sources_in_localruntimedir}). # Copy headers inside build_dir/include/ROOT; file(COPY ${ROOT_headers_dir}/ DESTINATION ${CMAKE_BINARY_DIR}/include/ROOT). set(libname ROOTPythonizations). add_library(${libname} SHARED ${cpp_sources}). # Insert the ROOTPythonizationsPySources in the dependency graph; add_dependencies(${libname} ROOTPythonizationsPySources). # Set the suffix to '.so' and the prefix to 'lib'; set_target_properties(${libname} PROPERTIES ${ROOT_LIBRARY_PROPERTIES_NO_VERSION}); if(MSVC); set_target_properties(${libname} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE); set_target_properties(${libname} PROPERTIES SUFFIX "".pyd""); target_link_libraries(${libname} PUBLIC Core Tree cppyy); elseif(APPLE); target_link_libraries(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt:4599,depend,depends,4599,bindings/pyroot/pythonizations/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/CMakeLists.txt,1,['depend'],['depends']
Integrability,"/from functions which may use a different SVE vector length.; This includes functions with a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1; on return). ``SC``; functions with a Streaming-Compatible interface (PSTATE.SM can be; either 0 or 1 on entry, and is unchanged on return). Functions with ``__attribute__((arm_locally_streaming))`` are excluded from this; table because for the caller the attribute is synonymous to 'streaming', and; for the callee it is merely an implementation detail that is explicitly not; exposed to the caller. .. table:: Combinations of calls for functions with different attributes. ==== ==== =============================== ============================== ==============================; From To Before call After call After exception; ==== ==== =============================== ============================== ==============================; N N; N S SMSTART SMSTOP; N SC; S N SMSTOP SMSTART SMSTART; S S SMSTART; S SC SMSTART; SC N If PSTATE.SM before call is 1, I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:4187,interface,interface,4187,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['interface'],['interface']
Integrability,/generic/include/clc/cl_khr_local_int32_base_atomics; - `6`; - `5`; - `1`; - :part:`83%`; * - libclc/generic/include/clc/cl_khr_local_int32_extended_atomics; - `5`; - `5`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/common; - `6`; - `6`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/explicit_fence; - `1`; - `1`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/float; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/generic/include/clc/geometric; - `8`; - `8`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/image; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/integer; - `16`; - `13`; - `3`; - :part:`81%`; * - libclc/generic/include/clc/math; - `95`; - `92`; - `3`; - :part:`96%`; * - libclc/generic/include/clc/misc; - `2`; - `0`; - `2`; - :none:`0%`; * - libclc/generic/include/clc/relational; - `18`; - `12`; - `6`; - :part:`66%`; * - libclc/generic/include/clc/shared; - `5`; - `3`; - `2`; - :part:`60%`; * - libclc/generic/include/clc/synchronization; - `2`; - `2`; - `0`; - :good:`100%`; * - libclc/generic/include/clc/workitem; - `8`; - `8`; - `0`; - :good:`100%`; * - libclc/generic/include/integer; - `1`; - `1`; - `0`; - :good:`100%`; * - libclc/generic/include/math; - `15`; - `15`; - `0`; - :good:`100%`; * - libclc/generic/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/generic/lib/math; - `8`; - `1`; - `7`; - :part:`12%`; * - libclc/generic/lib/relational; - `1`; - `0`; - `1`; - :none:`0%`; * - libclc/utils; - `1`; - `0`; - `1`; - :none:`0%`; * - libcxx/benchmarks; - `28`; - `10`; - `18`; - :part:`35%`; * - libcxx/include; - `22`; - `0`; - `22`; - :none:`0%`; * - libcxx/include/__algorithm; - `102`; - `15`; - `87`; - :part:`14%`; * - libcxx/include/__bit; - `2`; - `0`; - `2`; - :none:`0%`; * - libcxx/include/__charconv; - `3`; - `0`; - `3`; - :none:`0%`; * - libcxx/include/__chrono; - `8`; - `0`; - `8`; - :none:`0%`; * - libcxx/include/__compare; - `13`; - `1`; - `12`; - :part:`7%`; * - libcxx/include/__concepts; - `2,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:37280,synchroniz,synchronization,37280,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['synchroniz'],['synchronization']
Integrability,"0 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface of Clang modules for header units is that; there are some differences between header units and Clang modules and that ignoring those; differences now would likely become a problem in the future. Discover Dependencies; =====================. Prior to modules, all the translation units can be compiled parallelly.; But it is not true for the module units. The presence of module units requires; us to compile the translation units in a (topological) order. The clang-scan-deps scanner implemented; `P1689 paper <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_; to describe the order. Only named modules are supported now. We need a compilation database to use clang-scan-deps. See; `JSON Compilation Database Format Specification <JSONCompilationDatabase.html>`_; for example. Note that the ``output`` entry is necessary for clang-scan-deps; to scan P1689 format. Here is an example:. .. code-block:: c++. //--- M.cppm; export module M;; export import :interface_part;; import :impl_part;; export int Hello();. //--- interface_part.cppm; export",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:32388,interface,interface,32388,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"0 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16761,message,message,16761,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['message'],['message']
Integrability,"0 then the collection; will be written in split mode. Ie. if it contains objects of any; types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode.; The ROOT test example in ROOTSYS/test/bench.cxx shows many examples of collections; and storage in a TTree when using split mode or not. This program illustrates the important; gain in space and time when using this new facility. Parallel unzipping. Introducing a parallel unzipping algorithm for pre-fetched buffers. Since we already know what buffers are going to be read, we can decompress a few of them in advance in an additional thread and give the impression that the data decompression comes for free (we gain up to 30% in reading intensive jobs). The size of this unzipping cache is 20% the size of the TTreeCache and can be modified with TTreeCache::SetUnzipBufferSize(Long64_t bufferSize). Theoretically, we only need one buffer in advance but in practice we might fall short if the unzipping cache is too small (synchronization costs). This experimental feature is disabled by default, to activate it use the static function TTreeCache::SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable). The possible values to pass are: TTreeCacheUnzip::kEnable to enable itTTreeCacheUnzip::kDisable to disable itTTreeCacheUnzip::kForce to force it.The TTreeCacheUnzip is actived; only if you have more than one core. To activate it with only one core useTTreeCacheUnzip::kForce option (for example to measure the overhead). Disk and Memory Space Gain. In ROOT older than v5.20/00, the branches' last basket, also known as the write basket, was always saved in the same ""key"" as the TTree object and was always present in memory when reading or writing.; When reading this write basket was always present in memory even if the branch was never accessed. Starting in v5.20/00, TTree::Write closes out, compresses (when requested) and writes to di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html:5249,synchroniz,synchronization,5249,tree/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html,1,['synchroniz'],['synchronization']
Integrability,"0,1]. .. _amdgpu_synid_dpp_op_sel:. dpp_op_sel; ~~~~~~~~~~. This is a special version of *op_sel* used for *permlane* opcodes to specify; dpp-like mode bits - :ref:`fi<amdgpu_synid_fi16>` and; :ref:`bound_ctrl<amdgpu_synid_bound_ctrl>`. ======================================== =================================================================; Syntax Description; ======================================== =================================================================; op_sel:[{0..1},{0..1}] The first bit specifies :ref:`fi<amdgpu_synid_fi16>`, the second; bit specifies :ref:`bound_ctrl<amdgpu_synid_bound_ctrl>`.; ======================================== =================================================================. Note: numeric values may be specified as either; :ref:`integer numbers<amdgpu_synid_integer_number>` or; :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Examples:. .. parsed-literal::. op_sel:[0,0]. .. _amdgpu_synid_clamp:. clamp; ~~~~~. Clamp meaning depends on instruction. For *v_cmp* instructions, clamp modifier indicates that the compare signals; if a floating-point exception occurs. By default, signaling is disabled. For integer operations, clamp modifier indicates that the result must be clamped; to the largest and smallest representable value. By default, there is no clamping. For floating-point operations, clamp modifier indicates that the result must be clamped; to the range [0.0, 1.0]. By default, there is no clamping. Note: clamp modifier is applied after :ref:`output modifiers<amdgpu_synid_omod>` (if any). ======================================== ================================================; Syntax Description; ======================================== ================================================; clamp Enables clamping (or signaling).; ======================================== ================================================. .. _amdgpu_synid_omod:. omod; ~~~~. Specifies if an output modifier must be applied to the re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:53352,depend,depends,53352,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['depend'],['depends']
Integrability,"0. root-indent; innamespace 0. 1. namespace REX; using namespace REX. namespace ROOT { namespace Experimental; {. using namespace ROOT::Experimental;; namespace REX = ROOT::Experimental;. includes: TEve*.h -> ROOT/TEve*.hxx; include guard: ROOT_TEveVSD -> ROOT_TEveVSD_hxx. 3. Remove Editor GL friends. //==============================================================================. Issues:. * Exporting top level collection(s): events, viewers, scenes. * Emitting signals. * Serialization of EveElements; - separate internal ""links"" - componds, parents, projectables/eds; - separate hierarchy ?; - request children separately ?. * What does redraw do? We know which elements / scenes have changed.; Has to be synchronized with expectations of the client. * Event scene / EventManager - is it needed?. * SceneInfo. * Review ownership of shape in TEveGeoShape. * Argh, CSG/Boolean shapes were generated through GL.; Need to re-extract Timur's stuff and hack a TPad krappe around it.; ! Ask what is the plan for TGeo !. -----. * Inverted sign of magnetic field ... fix it. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/notex.txt:712,synchroniz,synchronized,712,graf3d/eve7/notex.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/notex.txt,1,['synchroniz'],['synchronized']
Integrability,"0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and theref",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59664,contract,contract,59664,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"00>`). Clang also supports :ref:`the C++ for OpenCL kernel language <cxx_for_opencl_impl>`. There are also other :ref:`new and experimental features <opencl_experimenal>`; available. Details about usage of clang for OpenCL can be found in :doc:`UsersManual`. Missing features or with limited support; ========================================. - For general issues and bugs with OpenCL in clang refer to `the GitHub issue; list; <https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+label%3Aopencl>`__. - Command-line flag :option:`-cl-ext` (used to override extensions/; features supported by a target) is missing support of some functionality i.e. that is; implemented fully through libraries (see :ref:`library-based features and; extensions <opencl_ext_libs>`). Internals Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:1444,integrat,integrating,1444,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['integrat'],['integrating']
Integrability,"088/1742-6596/396/5/052071>`_; - *V Vasilev et al* 2012 J. Phys.: Conf. Ser. 396 052071; - This paper describes the link between Cling and ROOT. The concepts of REPL and JIT compilation. Cling’s methods for handling errors, expression evaluation, streaming out of execution results, runtime dynamism.; * - `Interactive, Introspected C++ at CERN <https://www.youtube.com/watch?v=K2KqEV866Ro>`_; - *V Vasilev*, CERN PH-SFT, 2013; - Vassil Vasilev (Princeton University) explains how Cling enables interactivity in C++, and illustrates the type introspection mechanism provided by the interpreter.; * - `Introducing Cling, a C++ Interpreter Based on Clang/LLVM <https://www.youtube.com/watch?v=f9Xfh8pv3Fs>`_; - *Axel Naumann* 2012 Googletechtalks; - Axel Naumann (CERN) discusses Cling’s most relevant features: abstract syntax tree (AST) production, wrapped functions, global initialization of a function, delay expression evaluation at runtime, and dynamic scopes.; * - `Creating Cling, an interactive interpreter interface <https://www.youtube.com/watch?v=BjmGOMJWeAo>`_; - *Axel Naumann* 2010 LLVM Developers’ meeting; - This presentation introduces Cling, an ahead-of-time compiler that extends C++ for ease of use as an interpreter.; . ; .. list-table:: Demos, tutorials, Cling’s ecosystem:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Cling integration | CLion <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_; - 2022.2 Version; - CLion uses Cling to integrate the `Quick Documentation <https://www.jetbrains.com/help/clion/2022.2/viewing-inline-documentation.html>`_ popup by allowing you to view the value of the expressions evaluated at compile time.; * - `Interactive C++ for Data Science <https://www.youtube.com/watch?v=23E0S3miWB0&t=2716s>`_; - *Vassil Vassilev* 2021 CppCon (The C++ Conference); - In this video, the author discusses how Cling enables interactive C++ for Data Science projects. ; * - `Cling -- Beyond Just Inter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:1603,interface,interface,1603,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['interface'],['interface']
Integrability,"0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union foo; {; int x;; }. false:; union foo {; int x;; }. * ``bool AfterExternBlock`` Wrap extern blocks. .. code-block:: c++. true:; extern ""C""; {; int foo();; }. false:; extern ""C"" {; int foo();; }. * ``bool BeforeCatch`` Wrap before ``catch``. .. code-block:: c++. true:; try {; foo();; }; catch () {; }. false:; try {; foo();; } catch () {; }. * ``bool BeforeElse`` Wrap before ``else``. .. code-block:: c++. true:; if (foo()) {; }; else {; }. false:; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:40554,synchroniz,synchronized,40554,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['synchroniz', 'wrap']","['synchronized', 'wrapped']"
Integrability,"1 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https:/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73974,message,messages,73974,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['message'],['messages']
Integrability,"1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3087,depend,dependent,3087,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"1.0; -----------------. * Support for vector calls with CPython 3.8 and newer; * Support for typed C++ literals as defaults when mixing with keywords; * Enable reshaping of multi-dim LowLevelViews; * Refactored multi-dim arrays and support for multi-dim assignment; * Support tuple-based indexing for multi-dim arrays; * Direct support for C's _Complex (_Complex_double/_float on Windows); * sizeof() forwards to ctypes.sizeof() for ctypes' types; * Upgrade cmake fragments for Clang9; * Prevent clash with Julia's LLVM when loading cppyy into PyCall; * Upgrade to latest Cling patch release. 2021-05-14: 2.0.0; -----------------. * Upgrade to latest Cling based on Clang/LLVM 9; * Make C++17 the default standard on Windows. 2021-04-28: 1.9.6; -----------------. * Reverse operators for ``std::complex`` targeting Python's ``complex``; * Version the precompiled header with the ``cppyy-cling`` package version; * Cover more iterator protocol use cases; * Add missing cppyy/__pyinstaller pkg to sdist; * Single-inheritance support for cross-inherited templated constructors; * Disallow ``float`` -> ``const long long&`` conversion; * Capture python exception message string in PyException from callbacks; * Thread safety in enum lookups. 2021-03-22: 1.9.5; -----------------. * Do not regulate direct smart pointers (many to one can lead to double deletion); * Use pkg_resources of ``CPyCppyy``, if available, to find the API include path. 2021-03-17: 1.9.4; -----------------. * Fix for installing into a directory that has a space in the name; * Fix empty collection printing through Cling on 64b Windows; * Fix accidental shadowing of derived class typedefs by same names in base; * Streamlined templated function lookups in namespaces; * Fix edge cases when decomposing std::function template arguments; * Enable multi-cross inheritance with non-C++ python bases; * Support Bound C++ functions as template argument; * Python functions as template arguments from ``__annotations__`` or ``__cpp_nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:6462,protocol,protocol,6462,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,"['message', 'protocol']","['message', 'protocol']"
Integrability,"1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13043,depend,dependent,13043,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templates; Yes. 229; NAD; Partial specialization of function templates; Clang 2.9. 230; NAD; Calls to pure virtual functions; Clang 3.0. 231; NAD; Visibility of names after using-directives; Yes. 232; NAD; Is indirection through a null pointer undefined behavior?; Unknown. 233; drafting; References vs pointers in UDC overload resolution; Not resolved. 234; NAD; Reuse of base class subobjects; N/A. 235; TC1; Assignment vs initialization; N/A. 236; NAD; Explicit temporaries and integral constant expressions; Clang 3.2. 237; CD1; Explicit instantiation and base class members; Duplicate of 470. 238; CD4; Precision and accuracy constraints on floating point; Unknown. 239; CD1; Footnote 116 and Koenig lookup; Yes. 240; CD3; Uninitialized values and un,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14793,depend,dependent,14793,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:5157,rout,routing,5157,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['rout'],['routing']
Integrability,"1F * h2 = new TH1F(""h2"", ""h2"", 100, -3., 3.);; h1->FillRandom(""gaus"", 5000);; h2->FillRandom(""gaus"", 4000);; h1->SetMaximum(100);; h1->Draw();; h2->Draw(""same"");; }; . In some case, when a graph had some vertical parts, the exclusion; zone was not drawn correctly. The following small example shows the; problem:; ; {; TCanvas *c1 = new TCanvas();; gPad->DrawFrame(-1,-1,3,3);. TGraph * graph=new TGraph(3);; graph->SetFillColor(3);; graph->SetFillStyle(3001);; graph->SetLineWidth(2000);. graph->SetPoint(0,1.,1.);; graph->SetPoint(1,1.,0);; graph->SetPoint(2,0.,0.);; graph->Draw(""*L"");; }; . TUnfold. Add a new version. A new class TUnfoldSys provides support for the propagation of systematic errors.; Some bugs were also fixed due to multiplication of addition of sparse matrices. Fitting Methods. Introduce a better treatment of the step size used when fitting an object with a TF1. Use now by default is not zero the error provided by TF1. In case of limits use an appropriate step size to avoid Minuit to go over the limits.; Fix bug https://savannah.cern.ch/bugs/?45909 when fitting with bad range values (outside the histogram range).; detect the case when the data set is empty and don't perform any minimizationin this case but exits from fitting and produce a warning message; Fix a bug when fitting histograms with option W and the bin errors are = 0.; Fix a bug in the InitGaus function when having only one data point (see https://savannah.cern.ch/bugs/?48936); Fix a bug in calculating the error on the integral after having fitted when fix parameters were present; Fix a bug in calculating the confidence intervas when the number of bins for the given object is different from the number of bins of the fitted object.; ; FitPanel. Add support for drawing the fit function confidence levels.; Make gaus the default function when fitting 1D objects.; Add GSL minimizer and use now a new widget for showing and selecting the list of available algorithms according to the minimizer.; ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html:8500,message,message,8500,hist/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v524/index.html,1,['message'],['message']
Integrability,"1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48314,integrat,integration,48314,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct the argument list types; and return type and the library description elements from; [library.description.structure.specifications]/3 in the C++ standard. Definitions:. * *M*, *M1*, *M2*, *M3* - Matrix types; * *T* - Element type; * *row*, *col* - Row and column arguments respectively. ``M2 __builtin_matrix_transpose(M1 matrix)``. **Remarks**: The return type is a cv-unqualified matrix type that has the same; element type as ``M1`` and has the same number of rows as ``M1`` has columns and; the same number of columns as ``M1`` has rows. **Returns**: A matrix ``Res`` equivalent to the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:8047,contract,contraction,8047,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['contract'],['contraction']
Integrability,"2 %offset; }. The key here is that the function really doesn't care which set of threads it; is being called with. It takes whatever set of threads it can get. What the; implementation of the function cares about is that the initial; ``@subgroupBallot`` -- which is used to retrieve the bitmask of threads that; executed the anchor together -- executes with the same set of threads as the; final ``@subgroupBroadcastFirst``. Nothing else is required for correctness as; far as convergence is concerned. The function ``@reserveSpaceInBuffer`` itself is _not_ ``convergent``: callers; are free to move call sites of the function as they see fit. This can change; the behavior in practice, by changing the sets of threads that are grouped; together for the atomic operation. This can be visible in the output of the; program, since the order in which outputs appear in the buffer is changed.; However, this does not break the overall contract that ``@reserveSpaceInBuffer``; has with its caller -- which makes sense: the order of outputs is; non-deterministic anyway because of the atomic operation that is involved. If the function is inlined, the use of the anchor intrinsic similarly indicates; that certain transforms which are usually forbidden by the presence of; convergent operations are in fact allowed, as long as they don't break up the; region of code that is controlled by the anchor. .. _convergence_high-level_break:. Extended Cycles: Divergent Exit from a Loop; -------------------------------------------. High-level languages typically provide a ``break`` statement that transfers; control out of a loop statement. In most cases, the loop is structured and hence; there is no ambiguity about convergence inside the loop. But an ambiguity arises; when a ``break`` is control dependent on a divergent condition inside the loop.; Consider the following example:. .. code-block:: c++. void example() {; // A; ...; for (...) {; // B; if (condition) { // divergent condition; // C; convergent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:15042,contract,contract,15042,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['contract'],['contract']
Integrability,"2' and 'R * 4'; functionDecl(forEachTemplateArgument(refersToType(builtinType()))); matches the specialization f<unsigned, bool> twice, for 'unsigned'; and 'bool'. Matcher<FunctionDecl>hasAnyBodyMatcher<Stmt> InnerMatcher; Matches a function declaration that has a given body present in the AST.; Note that this matcher matches all the declarations of a function whose; body is present in the AST. Given; void f();; void f() {}; void g();; functionDecl(hasAnyBody(compoundStmt())); matches both 'void f();'; and 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void g();'. Matcher<FunctionDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<FunctionDecl>hasAnyTemplateArgumentMatcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl that have at least one TemplateArgument matching the given; InnerMatcher. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;. template<typename T> f() {};; void func() { f<int>(); };. classTemplateSpecializationDecl(hasAnyTemplateArgument(; refersToType(asString(""int"")))); matches the specialization A<int>. functionDecl(hasAnyTemplateArgument(refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<FunctionDecl>hasBodyMatcher<Stmt> InnerMatche",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:203026,interface,interface,203026,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Cocoa; object that the caller is responsible for releasing (via sending a; release message to the object). The Foundation framework defines a; macro NS_RETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:3529,message,message,3529,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['message'],['message']
Integrability,"32""); if(NOT DEFINED CPACK_PACKAGE_INSTALL_REGISTRY_KEY); set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY ""LLVM""); endif(); set(CPACK_PACKAGE_ICON ""${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_logo.bmp""); set(CPACK_NSIS_MUI_ICON ""${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico""); set(CPACK_NSIS_MUI_UNIICON ""${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico""); set(CPACK_NSIS_MODIFY_PATH ""ON""); set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL ""ON""); if( CMAKE_CL_64 ); if(NOT DEFINED CPACK_NSIS_INSTALL_ROOT); set(CPACK_NSIS_INSTALL_ROOT ""$PROGRAMFILES64""); endif(); endif(); endif(); include(CPack). # Sanity check our source directory to make sure that we are not trying to; # generate an in-source build (unless on MSVC_IDE, where it is ok), and to make; # sure that we don't have any stray generated files lying around in the tree; # (which would end up getting picked up by header search, instead of the correct; # versions).; if( CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed.; Please create a directory and run cmake from there, passing the path; to this source directory as the last argument.; This process created the file `CMakeCache.txt' and the directory `CMakeFiles'.; Please delete them.""); endif(). string(TOUPPER ""${CMAKE_BUILD_TYPE}"" uppercase_CMAKE_BUILD_TYPE). option(LLVM_ADDITIONAL_BUILD_TYPES ""Additional build types that are allowed to be passed into CMAKE_BUILD_TYPE"" """"). set(ALLOWED_BUILD_TYPES DEBUG RELEASE RELWITHDEBINFO MINSIZEREL ${LLVM_ADDITIONAL_BUILD_TYPES}); string (REPLACE "";"" ""|"" ALLOWED_BUILD_TYPES_STRING ""${ALLOWED_BUILD_TYPES}""); string (TOUPPER ""${ALLOWED_BUILD_TYPES_STRING}"" uppercase_ALLOWED_BUILD_TYPES). if (CMAKE_BUILD_TYPE AND; NOT uppercase_CMAKE_BUILD_TYPE MATCHES ""^(${uppercase_ALLOWED_BUILD_TYPES})$""); message(FATAL_ERROR ""Unknown value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}""); endif(). # LLVM_INSTALL_PACKAGE_DIR needs to be declared prior to adding th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:16994,message,message,16994,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"36c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ```c++; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; ```. Also some `virtual` RooFit functions like [RooAbsReal::createIntegral()](https://root.cern.ch/doc/master/classRooAbsReal.html#aff4be07dd6a131721daeeccf6359aea9); are returning a different type conditional on `ROOFIT_MEMORY_SAFE_INTERFACES`.; If you are overriding such a function, you need to use the `RooFit::OwningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:9006,wrap,wrap,9006,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,2,"['interface', 'wrap']","['interfaces', 'wrap']"
Integrability,3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 14,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:97111,depend,dependent,97111,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"3d Viewer. By default 3-D views are shown in the pad, if the; next line is activated, the default viewer will be OpenGL. ``` {.cpp}; Viewer3D.DefaultDrawOption: ogl; ```. Default Fitter (current choices are `Minuit`, `Minuit2`, `Fumili` and; `Fumili2`). ``` {.cpp}; Root.Fitter: Minuit; ```. Specify list of file endings which **`TTabCom`** (TAB completion) should; ignore. ``` {.cpp}; TabCom.FileIgnore: .cpp:.h:.cmz; ```. ### TCanvas Specific Settings. Opaque move and resize show full pad during the operation instead of; only the outline. Especially for resize you will need serious CPU power.; `UseScreenFactor=true` means to size canvas according to size of screen,; so a canvas still looks good on a low resolution laptop screen without; having to change canvas size in macros. ``` {.cpp}; Canvas.MoveOpaque: false; Canvas.ResizeOpaque: false; Canvas.UseScreenFactor: true; ```. Hight color 2 is the red one. ``` {.cpp}; Canvas.HighLightColor: 2; ```. Next three settings are related to different user interface parts of; canvas window. If they are set to true, the corresponding event status; bar, tool bar, graphics editor will be activated by default. ``` {.cpp}; Canvas.ShowEventStatus: false; Canvas.ShowToolBar: false; Canvas.ShowEditor: false; ```. AutoExec allows **`TExec`** objects to be executed on mouse and key; events. ``` {.cpp}; Canvas.AutoExec: true; ```. Canvas print directory is set to the current one by default:. ``` {.cpp}; Canvas.PrintDirectory .; ```. Printer settings:. ``` {.cpp}; WinNT.*.Print.Command: AcroRd32.exe; #Unix.*.Print.Command: a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; ```. Default histogram binnings used by `TTree::Draw()` method. ``` {.cpp}; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:5736,interface,interface,5736,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['interface'],['interface']
Integrability,"4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PATH=""$PREFIX/bin:$PATH""; export CC=""clang -flto""; export CXX=""clang++ -flto""; export RANLIB=/bin/true; * Configure and build the project as usual:. .. code-block:: bash. % ./configure && make && make check. The environment variable settings may work for non-autotooled projects too,; but you may need to set the ``LD`` environment variable as well. Licensing; =========. Gold is licensed under the GPLv3. LLVMgold uses the interface file; ``plugin-api.h`` from gold which means that the resulting ``LLVMgold.so``; binary is also GPLv3. This can still be used to link non-GPLv3 programs; just as much as gold could without the plugin.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:5970,interface,interface,5970,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['interface'],['interface']
Integrability,"4. Thus, we appreciate feedback and suggestions for improvement. If you have been trying RNTuple for a while, these are the other important changes that you will notice:. - Support for aligned friends (PR [#6979](https://github.com/root-project/root/pull/6979)). Refer to the `RNTupleReader::OpenFriends()` function.; - Cluster and page sizes in `RNTupleWriteOptions` now refer to their target size in bytes (as opposed to the number of entries). Defaults are 64 kB for the page size and 50 MB for the cluster size (PR [#8703](https://github.com/root-project/root/pull/8703)).; - Storing objects of user-defined classes via `TClass` now also includes members inherited from all the base classes (PR [#8552](https://github.com/root-project/root/pull/8552)).; - Support for RFields whose type is a typedef to some other type. ## RDataFrame. ### New features. - Add [`Redefine`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a4e882a949c8a1022a38ec6936c2ff29c) to the `RDataFrame` interface, which allows to overwrite the value of an existing column.; - Add [`Describe`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a53f3e3d81e041a804481df228fe0081c) to the `RDataFrame` interface, which allows to get useful information, e.g. the columns and their types.; - Add [`DescribeDataset`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a1bc5b86a2a834bb06711fb535451146d) to the `RDataFrame` interface, which allows to get information about the dataset (subset of the output of Describe()).; - Add [`DefinePerSample`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a29d77593e95c0f84e359a802e6836a0e), a method which makes it possible to define columns based on the sample and entry range being processed. It is also a useful way to register callbacks that should only be called when the input dataset/TTree changes.; - Add [`HistoND`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a0c9956a0f48c26f8e4294e17376c7fea) ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:7311,interface,interface,7311,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability,"435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30557,depend,dependent,30557,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"484). ### TGraph2D. Add a new implementation for Delauney interpolation using the triangle code from Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. ; A new class for Delauney triangulator and interpolation has been added in the MathCore library ( `ROOT::Math::Delauney2D` ). ### Fitting. * Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Grap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:13478,interface,interface,13478,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interface']
Integrability,"5-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT RooFitJSONInterface package; # @author Jonas Rembser, CERN; ############################################################################. # If RapidYAML can be found on the system, we will also compile the RapidYAML backend besides the; # nlohmann-json backend. Like this we can also convert to yaml. # The RapidYAML backend is always disabled because it doesn't work anymore for; # RooFitHS3. The nlohmann_json interface is always used and works well, hence; # rapidyaml was not tested anymore. The relevant code is still left in the; # CMakeLists.txt in case someone wants to revive the RapilYAML backend. # message(STATUS ""Looking for RapidYAML (used by RooFit)""); # find_package(ryml). if(${RYML_FOUND}); message(STATUS ""RapidYAML found, compiling also RooFit JSON Interface with RapidYAML parser""); set(ParserSources src/JSONParser.cxx src/RYMLParser.cxx); add_compile_definitions(ROOFIT_WITH_RYML); else(); set(ParserSources src/JSONParser.cxx); message(STATUS ""RapidYAML not found, only compiling RooFit with nlohmann-json parser""); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(RooFitJSONInterface; HEADERS; RooFit/Detail/JSONInterface.h; SOURCES; src/JSONInterface.cxx; ${ParserSources}; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LIBRARIES; Core; ). if(${RYML_FOUND}); target_include_directories(RooFitJSONInterface PRIVATE ${RYML_INCLUDE_DIRS}); target_link_libraries(RooFitJSONInterface PRIVATE -lc4core -lryml); target_link_directories(RooFitJSONInterface PRIVATE ${RYML_LIB_DIR}); endif(). if(builtin_nlohmannjson); target_include_directories(RooFitJSONInterface PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(RooFitJSONInterface PRIVATE nlohmann_json::nlohmann_json); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt:1022,message,message,1022,roofit/jsoninterface/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt,2,['message'],['message']
Integrability,502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” clas,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35291,depend,dependent,35291,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; ```. Together these allow clients to publish objects to any one of the 3D; vi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:122679,interface,interface,122679,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a Roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:30455,adapter,adapter,30455,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['adapter'],['adapter']
Integrability,"691)). #### Using identifiers that are only available at runtime: gROOT->LoadMacro(""foo.h""); foo(); CINT was processing macros line by line; Cling compiles code.; During this compilation, Cling will not see identifiers provided by `gROOT->LoadMacro()`.; While this will covered by dynamic scopes, they are currently too limited to handle this.; Please `#include` the header instead. ### TInterpreter. ### TInterpreter. `TInterpreter::GetCurrentMacroName()` has a slightly different behavior in ROOT; 6 than in ROOT 5. In ROOT 5 it was a synonym for `__FILE__` (so please use; `__FILE__` to get the old value); in ROOT 6 it returns the currently executing; (.x) source file. For nested execution it returns the innermost one. The following are no longer supported and are now only issuing error; messages:. - Getgvp; - Setgvp; - SetRTLD\_NOW; - SetRTLD\_LAZY. Use of Setgvp and Getgvp should be looked at carefully as they were use; to control the behavior of the multiplexing CINT wrappers that were both; wrapper the calls to operator new with and without placement and the; constructor (and similarly for operator delete and the destructor).; Cling does not support such a multiplexing wrapper and alternatively; interface must be used (See TClass::New and TClass::Destructor for; example). The following interfaces are not yet available:. - DeleteVariable. They might be re-implemented in a later version. ### rootcling, rootcint and genreflex. rootcling is the successor to rootcint and it preserves its old commandline; arguments and provides more (see help). The executable rootcint still exists; but it is just a redirection to rootcling.; The following *backward incompatibilities* are present between rootcint in; version 5 and rootcling in version 6:. - rootcling does not support multiline \#pragma without a line; continuation as rootcint did (rootcint support \#pragma link with a; line continutation only in ROOT v5.34/02 and above).; - rootcling no longer re-\#defines the private and p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:5279,wrap,wrappers,5279,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,2,['wrap'],"['wrapper', 'wrappers']"
Integrability,"6_t floatArray[7];; Double32_t doubleVal;; Double32_t doubleArray[5];; TTree *tree = new TTree(""tree"", ""An example tree using the new data types"");; tree->Branch(""floatVal"", &floatVal, ""floatVal/f""); // Float16_t value with default settings; tree->Branch(""floatArray"", floatArray, ""floatArray[7]/f[0,100]""); // Float16_t array with range from 0 to 100; tree->Branch(""doubleVal"", &doubleVal, ""doubleVal/d[0,1000,20]""); // Double32_t value with range from 0 to 1000 and 20 bits; tree->Branch(""doubleArray"", doubleArray, ""doubleArray[5]/d[0,0,18]""); // Double32_t array without range and 18 bits; ~~~. ### Bulk I/O; - The new `TBulkBranchRead` class (inside the `ROOT::Experimental::Internal` namespace) provides; a mechanism for reading, in a single library call, many events' worth of simple data (primitive types,; arrays of primitives, split structures) stored in a `TTree`. This allows for extremely fast delivery; of event data to the process. This is meant as an internal interface that allows the ROOT team to; implement faster high-level interface.; - The `TTreeReaderFast ` class (inside the `ROOT::Experimental::Internal` namespace) provides a simple; mechanism for reading ntuples with the bulk IO interface. ## Histogram Libraries. ### TH1; - Add a search range to the `TH1::FindFirstBinAbove(..)` and `TH1::FindLastBinAvove(..)` functions. ### TH2Poly; - Add implementation of `SetBinError` and fix a bug in `GetBinError` in case of weighted events. ### TF1; - The implementation of `TF1::GetX` has been improved. In case of the presence of multiple roots, the function will return the root with the lower x value. In case of no-roots a NaN will be returned instead of returning a random incorrect value. ### TKDE; - Add support for I/O. ## Math Libraries; - Add `TComplex` value printer for printing the value of object at the root prompt and in python; - Add to the documentation of `TLorentzVector` a link to `ROOT::Math::LorentzVector`, which is a superior tool.; - Add new implementat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:11205,interface,interface,11205,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,2,['interface'],['interface']
Integrability,"765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknown. 782; CD2; Lambda expressions and argument-dependent lookup; Unknown. 783; open; Definition of “argument”; Not resolved. 784; C++11; List of incompatibilities with the previous Standard; Unknown. 785; CD2; “Execution sequence” is inappropriate phraseology; Unknown. 786; CD2; Definition of “thread”; Unknown. 787; CD2; Unnecessary lexical undefined behavior; Unknown. 788; CD2; Relationship between locale and values of the execution character set; Unknown. 789; CD2; Deprecating trigraphs; Unknown. 790; CD2; Concatenation of raw and non-raw string literals; Unknown. 792; CD2; Effects of std::quick_exit; Unknown. 793; CD2; Use of class members during destruction; Unknown. 794; NAD; Base-derived conversion in member type of pointer-to-member conversion; Unknown. 795; NAD; Dependency of lambdas on <functional>; Unknown. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:53357,depend,dependent,53357,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the object. If left alone, two branches called; `fBits` and `fUniqueID` will appear. ## Motivation. If you want to integrate and use your classes with ROOT, to enjoy; features like, extensive RTTI (Run Time Type Information) and ROOT; object I/O and inspection, you have to add the following line to your; class header files:. ``` {.cpp}; ClassDef(ClassName,ClassVersionID); //The class title; ```. For example in `TLine.h` we have:. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:7764,integrat,integrate,7764,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['integrat'],['integrate']
Integrability,"900 simulated instructions. The total number of simulated micro; opcodes (uOps) is also 900. The report is structured in three main sections. The first section collects a; few performance numbers; the goal of this section is to give a very quick; overview of the performance throughput. Important performance indicators are; **IPC**, **uOps Per Cycle**, and **Block RThroughput** (Block Reciprocal; Throughput). Field *DispatchWidth* is the maximum number of micro opcodes that are dispatched; to the out-of-order backend every simulated cycle. For processors with an; in-order backend, *DispatchWidth* is the maximum number of micro opcodes issued; to the backend every simulated cycle. IPC is computed dividing the total number of simulated instructions by the total; number of cycles. Field *Block RThroughput* is the reciprocal of the block throughput. Block; throughput is a theoretical quantity computed as the maximum number of blocks; (i.e. iterations) that can be executed per simulated clock cycle in the absence; of loop carried dependencies. Block throughput is superiorly limited by the; dispatch rate, and the availability of hardware resources. In the absence of loop-carried data dependencies, the observed IPC tends to a; theoretical maximum which can be computed by dividing the number of instructions; of a single iteration by the `Block RThroughput`. Field 'uOps Per Cycle' is computed dividing the total number of simulated micro; opcodes by the total number of cycles. A delta between Dispatch Width and this; field is an indicator of a performance issue. In the absence of loop-carried; data dependencies, the observed 'uOps Per Cycle' should tend to a theoretical; maximum throughput which can be computed by dividing the number of uOps of a; single iteration by the `Block RThroughput`. Field *uOps Per Cycle* is bounded from above by the dispatch width. That is; because the dispatch width limits the maximum size of a dispatch group. Both IPC; and 'uOps Per Cycle' are limit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:16529,depend,dependencies,16529,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:83494,interface,interface,83494,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,": Auto upgrade mangler; D: llvm-gcc4 svn wrangler. N: Chris Lattner; E: sabre@nondot.org; W: http://nondot.org/~sabre/; D: Primary architect of LLVM. N: Tanya Lattner (Tanya Brethour); E: tonic@nondot.org; W: http://nondot.org/~tonic/; D: The initial llvm-ar tool, converted regression testsuite to dejagnu; D: Modulo scheduling in the SparcV9 backend; D: Release manager (1.7+). N: Sylvestre Ledru; E: sylvestre@debian.org; W: http://sylvestre.ledru.info/; W: https://apt.llvm.org/; D: Debian and Ubuntu packaging; D: Continuous integration with jenkins. N: Andrew Lenharth; E: alenhar2@cs.uiuc.edu; W: http://www.lenharth.org/~andrewl/; D: Alpha backend; D: Sampling based profiling. N: Nick Lewycky; E: nicholas@mxc.ca; D: PredicateSimplifier pass. N: Tony Linthicum, et. al.; E: tlinth@codeaurora.org; D: Backend for Qualcomm's Hexagon VLIW processor. N: Bruno Cardoso Lopes; E: bruno.cardoso@gmail.com; I: bruno; W: http://brunocardoso.cc; D: Mips backend; D: Random ARM integrated assembler and assembly parser improvements; D: General X86 AVX1 support. N: Weining Lu; E: luweining@loongson.cn; D: LoongArch backend. N: Duraid Madina; E: duraid@octopus.com.au; W: http://kinoko.c.u-tokyo.ac.jp/~duraid/; D: IA64 backend, BigBlock register allocator. N: John McCall; E: rjmccall@apple.com; D: Clang semantic analysis and IR generation. N: Michael McCracken; E: michael.mccracken@gmail.com; D: Line number support for llvmgcc. N: Fanbo Meng; E: fanbo.meng@ibm.com; D: z/OS support. N: Vladimir Merzliakov; E: wanderer@rsu.ru; D: Test suite fixes for FreeBSD. N: Scott Michel; E: scottm@aero.org; D: Added STI Cell SPU backend. N: Kai Nacke; E: kai@redstar.de; D: Support for implicit TLS model used with MS VC runtime; D: Dumping of Win64 EH structures. N: Takumi Nakamura; I: chapuni; E: geek4civic@gmail.com; E: chapuni@hf.rim.or.jp; D: Maintaining the Git monorepo; W: https://github.com/llvm-project/; S: Ebina, Japan. N: Edward O'Callaghan; E: eocallaghan@auroraux.org; W: http://www.aurorau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:8181,integrat,integrated,8181,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['integrat'],['integrated']
Integrability,": merge only the objects without a MergeAfterReset member function. . Removed TFileMerger::RecursiveMerge from the interface. Prevent TFileMerger (and hadd) from trying to open too many files.; Add a new member function TFileMerger::SetMaxOpenedFiles and; new command line option to hadd ( -n requested_max ) to allow; the user to reduce the number of files opened even further. Update hadd and TFileMerger so that they prefix all their information message; with their names (when running hadd, the TFileMerger message are prefixed by hadd):. $ hadd -v 0 -f output.root input1.root input2.root; $ hadd -v 1 -f output.root input1.root input2.root; hadd merged 2 input files in output.root.; $ hadd -v 2 -f output.root input1.root input2.root; hadd target file: output.root; hadd Source file 1: input1.root; hadd Source file 2: input2.root; hadd Target path: output.root:/. Introduce non-static version of TFile::Cp allows the copy of; an existing TFile object. Introduce new explicit interface for providing reseting; capability after a merge. If a class has a method with; the name and signature:. void ResetAfterMerge(TFileMergeInfo*);. it will be used by a TMemFile to reset its objects after; a merge operation has been done. If this method does not exist, the TClass will use; a method with the name and signature:. void Reset(Optiont_t *);. TClass now provides a quick access to these merging; function via TClass::GetResetAfterMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetResetAfterMerge. The wrapper function should have; the signature/type ROOT::ResetAfterMergeFunc_t:. void (*)(void *thisobj, TFileMergeInfo*);. ResetAfterMerge functions were added to the following classes:; TDirectoryFile, TMemFile, TTree, TChain, TBranch, TBranchElement,; TBranchClones, TBranchObject and TBranchRef. Avoid leaking the inner object in a container like vector<vector<MyClass*> > ; and vector<vector<MyClass*> *> . Put in place the infrastructure to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:8389,interface,interface,8389,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['interface'],['interface']
Integrability,": text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Using these functions, the goal is to produce the most specific error ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:24043,message,message,24043,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67770,inject,inject,67770,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['inject'],['inject']
Integrability,":. - Default constructor for a zero vector (all elements equal to zero). - Constructor (and assignment) from a vector expression, like; `v=p*q+w`. Due to the expression template technique, no temporary; objects are created in this operation. - Constructor by passing directly the elements. This is possible only; for vectors up to size 10. - Constructor from an iterator copying the data referred by the; iterator. It is possible to specify the *begin* and *end* of the; iterator or the *begin* and the *size*. Note that for the Vector the; iterator is not generic and must be of type `T*`, where `T` is the; type of the contained elements. In the following example we assume that we are using the namespace; **`ROOT::Math`**. ``` {.cpp}; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:103432,interface,interface,103432,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,":. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotations change a pointer into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7773,wrap,wrap,7773,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['wrap'],['wrap']
Integrability,":. .. code:: console. $ bin/clang --version. There's also a target for building and running all the clang tests:. .. code:: console. $ ninja check-clang. This is a common pattern in LLVM: check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that makes sense… and the test output suggests it's looking for; the old string ""call itself"" and finding our new message instead.; Note that more tests may fail in a similar way as new tests are; added time to time. Let's fix it by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:5985,message,message,5985,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['message']
Integrability,":. ``` {.cpp}; TGeoEltu(Double_t a,Double_t b,Double_t dz);; ```. ![TGeoEltu Class](pictures/060001C0.png). #### Hyperboloids - TGeoHype Class. A hyperboloid is represented as a solid limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34492,rout,rout,34492,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['rout'],['rout']
Integrability,://github.com/root-project/root/issues/10221)] - ROOT interpreter built with C++17 does not find `std::optional` without including it first; * [[#10146](https://github.com/root-project/root/issues/10146)] - Byte swapped floats in TMVA sofie on big endian architectures (s390x); * [[#10061](https://github.com/root-project/root/issues/10061)] - Distributed RDataFrame test failures on Mac/ARM; * [[#9917](https://github.com/root-project/root/issues/9917)] - SetRange and SetRangeUser fail silently; * [[#9594](https://github.com/root-project/root/issues/9594)] - Systematic build failure of ROOT master in the LCG DEBUG builds since Jan 15th; * [[#9524](https://github.com/root-project/root/issues/9524)] - Failure to build/run when MACOSX_DEPLOYMENT_TARGET is set to 11 or higher; * [[#9514](https://github.com/root-project/root/issues/9514)] - Printed SVG image contains newline cutting through XML tags; * [[#9489](https://github.com/root-project/root/issues/9489)] - [RF] Cannot turn off useless messages with RooMCStudy unbinned fits + Progress bar would be better.; * [[#9292](https://github.com/root-project/root/issues/9292)] - Integer overflow in TTreeCache::FillBuffer; * [[#8959](https://github.com/root-project/root/issues/8959)] - `ninja clean` does not remove `modules.idx`; * [[#8952](https://github.com/root-project/root/issues/8952)] - Make hadd return a non-zero exit code when encountering a corrupted file; * [[#8942](https://github.com/root-project/root/issues/8942)] - cannot buid the dependent project; * [[#8794](https://github.com/root-project/root/issues/8794)] - [TGNumberEntry] centiseconds; * [[#8720](https://github.com/root-project/root/issues/8720)] - Apply TChain::SetImplicitMT() to underlying trees; * [[#8639](https://github.com/root-project/root/issues/8639)] - (RDataFrame) AsNumpy returns Boolean branches as 'object' dtype numpy arrays; * [[#8582](https://github.com/root-project/root/issues/8582)] - TThreadTimer behavior; * [[#8581](https://github.com/root-pro,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:46153,message,messages,46153,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['message'],['messages']
Integrability,"://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features>`__).; Command-line flag :option:`-cl-ext` can be used to override features supported by a target. For cases when there is an associated extension for a specific feature (fp64 and 3d image writes); user should specify both (extension and feature) in command-line flag:. .. code-block:: console. $ clang -cl-std=CL3.0 -cl-ext=+cl_khr_fp64,+__opencl_c_fp64 ...; $ clang -cl-std=CL3.0 -cl-ext=-cl_khr_fp64,-__opencl_c_fp64 ... OpenCL C 3.0 Implementation Status; ----------------------------------. The following table provides an overview of features in OpenCL C 3.0 and their; implementation status. +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Category | Feature | Status | Reviews |; +==============================+=========================+=========================================+======================+================================================================================================================================+; | Command line interface | New value for ``-cl-std`` flag | :good:`done` | https://reviews.llvm.org/D88300 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Predefined macros | New version macro | :good:`done` | https://reviews.llvm.org/D88300 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Predefined macros | Feature macros | :good:`done` | https:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:15702,interface,interface,15702,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['interface'],['interface']
Integrability,"://www.sphinx-doc.org/en/stable/ and published to; http://cppyy.readthedocs.io/en/latest/index.html using a webhook. To create; the docs::. $ pip install sphinx_rtd_theme; Collecting sphinx_rtd_theme; ...; Successfully installed sphinx-rtd-theme-0.2.4; $ cd docs; $ make html. The Python code in this module supports:. * Interfacing to the correct backend for CPython or PyPy.; * Pythonizations (TBD). Cppyy-backend; -------------. The ``cppyy-backend`` module contains two areas:. * A patched copy of cling; * Wrapper code. Package structure; -----------------; .. _package-structure:. There are four PyPA packages involved in a full installation, with the; following structure::. (A) _cppyy (PyPy); / \; (1) cppyy (3) cppyy-backend -- (4) cppyy-cling; \ /; (2) CPyCppyy (CPython). The user-facing package is always ``cppyy`` (1).; It is used to select the other (versioned) required packages, based on the; python interpreter for which it is being installed. Below (1) follows a bifurcation based on interpreter.; This is needed for functionality and performance: for CPython, there is the; CPyCppyy package (2).; It is written in C++, makes use of the Python C-API, and installs as a Python; extension module.; For PyPy, there is the builtin module ``_cppyy`` (A).; This is not a PyPA package.; It is written in RPython as it needs access to low-level pointers, JIT hints,; and the ``_cffi_backend`` backend module (itself builtin). Shared again across interpreters is the backend, which is split in a small; wrapper (3) and a large package that contains Cling/LLVM (4).; The former is still under development and expected to be updated frequently.; It is small enough to download and build very quickly.; The latter, however, takes a long time to build, but since it is very stable,; splitting it off allows the creation of binary wheels that need updating; only infrequently (expected about twice a year). All code is publicly available; see the; :doc:`section on repositories <repositories>`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/packages.rst:1788,wrap,wrapper,1788,bindings/pyroot/cppyy/cppyy/doc/source/packages.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/packages.rst,1,['wrap'],['wrapper']
Integrability,":: MCJIT-load.png. The PassManager::run call causes the MC code generation mechanisms to emit; a complete relocatable binary object image (either in either ELF or MachO; format, depending on the target) into the ObjectBufferStream object, which; is flushed to complete the process. If an ObjectCache is being used, the; image will be passed to the ObjectCache here. At this point, the ObjectBufferStream contains the raw object image.; Before the code can be executed, the code and data sections from this; image must be loaded into suitable memory, relocations must be applied and; memory permission and code cache invalidation (if required) must be completed. Object Loading; ==============. Once an object image has been obtained, either through code generation or; having been retrieved from an ObjectCache, it is passed to RuntimeDyld to; be loaded. The RuntimeDyld wrapper class examines the object to determine; its file format and creates an instance of either RuntimeDyldELF or; RuntimeDyldMachO (both of which derive from the RuntimeDyldImpl base; class) and calls the RuntimeDyldImpl::loadObject method to perform that; actual loading. .. image:: MCJIT-dyld-load.png. RuntimeDyldImpl::loadObject begins by creating an ObjectImage instance; from the ObjectBuffer it received. ObjectImage, which wraps the; ObjectFile class, is a helper class which parses the binary object image; and provides access to the information contained in the format-specific; headers, including section, symbol and relocation information. RuntimeDyldImpl::loadObject then iterates through the symbols in the; image. Information about common symbols is collected for later use. For; each function or data symbol, the associated section is loaded into memory; and the symbol is stored in a symbol table map data structure. When the; iteration is complete, a section is emitted for the common symbols. Next, RuntimeDyldImpl::loadObject iterates through the sections in the; object image and for each section iterates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst:3696,wrap,wrapper,3696,interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,1,['wrap'],['wrapper']
Integrability,"::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kLEGENDRE);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:52709,integrat,integration,52709,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:10988,wrap,wrap,10988,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['wrap'],['wrap']
Integrability,":; """""""""""""""""""". None. '``llvm.experimental.get.vector.length``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare i32 @llvm.experimental.get.vector.length.i32(i32 %cnt, i32 immarg %vf, i1 immarg %scalable); declare i32 @llvm.experimental.get.vector.length.i64(i64 %cnt, i32 immarg %vf, i1 immarg %scalable). Overview:; """""""""""""""""". The '``llvm.experimental.get.vector.length.*``' intrinsics take a number of; elements to process and returns how many of the elements can be processed; with the requested vectorization factor. Arguments:; """""""""""""""""""". The first argument is an unsigned value of any scalar integer type and specifies; the total number of elements to be processed. The second argument is an i32; immediate for the vectorization factor. The third argument indicates if the; vectorization factor should be multiplied by vscale. Semantics:; """""""""""""""""""". Returns a positive i32 value (explicit vector length) that is unknown at compile; time and depends on the hardware specification.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. This intrinsic is intended to be used by loop vectorization with VP intrinsics; in order to get the number of elements to process on each loop iteration. The; result should be used to decrease the count for the next iteration until the; count reaches zero. If the count is larger than the number of lanes in the type described by the; last 2 arguments, this intrinsic may return a value less than the number of; lanes implied by the type. The result will be at least as large as the result; will be on any later loop iteration. This intrinsic will only return 0 if the input count is also 0. A non-zero input; count will produce a non-zero result. Matrix Intrinsics; -----------------. Operations on matrixes requiring shape information (like number of rows/columns; or the memory layout) can be expressed using the matrix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:674447,depend,depends,674447,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,":Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28449,interface,interface,28449,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,":Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54392,integrat,integration,54392,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,":Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43765,wrap,wrapping,43765,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapping']
Integrability,":`N` is not specified the first member of that name will; be selected. If *count* is not supplied, the operation fails.*count* cannot be. .. option:: o. When extracting files, use the modification times of any *files* as they; appear in the ``archive``. By default *files* extracted from the archive; use the time of extraction. .. option:: O. Display member offsets inside the archive. .. option:: T. Alias for ``--thin``. In many ar implementations ``T`` has a different; meaning, as specified by X/Open System interface. .. option:: v. When printing *files* or the ``archive`` table of contents, this modifier; instructs :program:`llvm-ar` to include additional information in the output. Modifiers (generic); ~~~~~~~~~~~~~~~~~~~. The modifiers below may be applied to any operation. .. option:: c. For the :option:`r` (replace)and :option:`q` (quick update) operations,; :program:`llvm-ar` will always create the archive if it doesn't exist.; Normally, :program:`llvm-ar` will print a warning message indicating that the; ``archive`` is being created. Using this modifier turns off; that warning. .. option:: D. Use zero for timestamps and UIDs/GIDs. This is set by default. .. option:: P. Use full paths when matching member names rather than just the file name.; This can be useful when manipulating an ``archive`` generated by another; archiver, as some allow paths as member names. This is the default behavior; for thin archives. .. option:: s. This modifier requests that an archive index (or symbol table) be added to the; ``archive``, as if using ranlib. The symbol table will contain all the; externally visible functions and global variables defined by all the bitcode; files in the archive. By default :program:`llvm-ar` generates symbol tables in; archives. This can also be used as an operation. .. option:: S. This modifier is the opposite of the :option:`s` modifier. It instructs; :program:`llvm-ar` to not build the symbol table. If both :option:`s` and; :option:`S` are used, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:8452,message,message,8452,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['message'],['message']
Integrability,":ref:`RegisterBankInfo <api-registerbankinfo>`. .. _gmir-llt:. Low Level Type; --------------. Additionally, every generic virtual register has a type, represented by an; instance of the ``LLT`` class. Like ``EVT``/``MVT``/``Type``, it has no distinction between unsigned and signed; integer types. Furthermore, it also has no distinction between integer and; floating-point types: it mainly conveys absolutely necessary information, such; as size and number of vector lanes:. * ``sN`` for scalars; * ``pN`` for pointers; * ``<N x sM>`` for vectors. ``LLT`` is intended to replace the usage of ``EVT`` in SelectionDAG. Here are some LLT examples and their ``EVT`` and ``Type`` equivalents:. ============= ========= ======================================; LLT EVT IR Type; ============= ========= ======================================; ``s1`` ``i1`` ``i1``; ``s8`` ``i8`` ``i8``; ``s32`` ``i32`` ``i32``; ``s32`` ``f32`` ``float``; ``s17`` ``i17`` ``i17``; ``s16`` N/A ``{i8, i8}`` [#abi-dependent]_; ``s32`` N/A ``[4 x i8]`` [#abi-dependent]_; ``p0`` ``iPTR`` ``i8*``, ``i32*``, ``%opaque*``; ``p2`` ``iPTR`` ``i8 addrspace(2)*``; ``<4 x s32>`` ``v4f32`` ``<4 x float>``; ``s64`` ``v1f64`` ``<1 x double>``; ``<3 x s32>`` ``v3i32`` ``<3 x i32>``; ============= ========= ======================================. Rationale: instructions already encode a specific interpretation of types; (e.g., ``add`` vs. ``fadd``, or ``sdiv`` vs. ``udiv``). Also encoding that; information in the type system requires introducing bitcast with no real; advantage for the selector. Pointer types are distinguished by address space. This matches IR, as opposed; to SelectionDAG where address space is an attribute on operations.; This representation better supports pointers having different sizes depending; on their addressspace. .. note::. .. caution::. Is this still true? I thought we'd removed the 1-element vector concept.; Hypothetically, it could be distinct from a scalar but I think we failed to; find a real",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:7697,depend,dependent,7697,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,2,['depend'],['dependent']
Integrability,":ref:`callbr <i_callbr>` instruction) can result in a; convergent operation. A function in LLVM IR is said to be *convergent* if it has the; :ref:`convergent <attr_convergent>` attribute. A call-site in LLVM IR is said to be *convergent* if it is a direct; call to a convergent function or it has the :ref:`convergent; <attr_convergent>` attribute or a :ref:`convergencectrl operand bundle; <convergencectrl>`. Informational notes:. A function may have to be treated as convergent if that function, or; transitively, any function called from it, contains a convergent call-site. A; frontend generating the ``convergent`` attribute should take this into account; when emitting functions and function calls. But this is not always the case:. A non-convergent function may contain convergent operations; such operations; do not directly depend on the set of threads that enter the function as a; single communicating group. Instead, these operations depend on an; implementation-defined subset of threads within the body of the function, as; shown in :ref:`opportunistic_convergence`. Examples of Convergent Operations; ========================================. (This section is informative.). Texture sampling in a pixel shader; ----------------------------------. The following stylized pixel shader samples a texture at a given set of; coordinates, using the builtin function `textureSample`. Texture sampling; requires screen-space derivatives of the coordinates to determine the level of; detail (mipmap level) of the sample. They are commonly approximated by taking; the difference between neighboring pixels, which are computed by different; threads in the same group:. .. code-block:: c++. void example_shader() {; ...; color = textureSample(texture, coordinates);; if (condition) {; use(color);; }; ...; }. From a purely single-threaded perspective, sinking the `textureSample` into; the if-statement appears legal. However, if the condition is false for some; neighboring pixels, then their cor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:3372,depend,depend,3372,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['depend']
Integrability,":versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84131,protocol,protocol-buffers,84131,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol-buffers']
Integrability,"; # point unit).; - Dir: thumb/v7-m; # Here, the flags generated by Clang must be a superset of; # {--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16} for this multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a lim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9276,interface,interface,9276,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interface']
Integrability,"; ## Platform Support. Temporarily for version 6.00/00, ROOT has a reduced set of supported; platforms. Most notably Windows is not supported until at least 6.02.; 6.00/00 supports only. - Linux 32 bit and 64 bit, i32 and x86-64 and x32 (see below).; - OSX 64 bit on x86-64. More platforms are expected to be available later; the lack of support; stems from Cling and Clang/LLVM not being ported to these platforms yet. To aleviate the pain for Windows users who want to try ROOT 6 we provide; a recipe on how to run ROOT 6 in a VM on Windows. Building ROOT also requires a C++11 compatible compiler, so one needs to either have installed gcc >= 4.8 or Clang >= 3.4. On most lecagy platforms these newer compilers are available via a special install.; See the [build prerequisites](https://root.cern/install/dependencies/) page. Despite that, an additional platform as been added: the [x32; psAPI](https://sites.google.com/site/x32abi/), called linuxx32gcc. It is; a regular x86-64 ABI but with shorter pointers (4 bytes instead of 8).; This reduces the addressable memory per process to 4GB - but that is; usally sufficient. The advantages are reduced memory consumption (due to; the smaller pointers) and increased performance compared to 32 bit; applications due to the availability of the 64 bit instructions. The; Clang developers mailing list archive [contains a good; comparison](http://clang-developers.42468.n3.nabble.com/Re-PATCH-add-x32-psABI-support-td4024297.html). To build and run binaries compiled in x32, toolchain support is needed.; That is available in the in binutils (2.22), GCC (4.8), glibc (2.16),; Linux kernel (3.4) and even GDB (7.5). These versions are not available; in regular distributions yet (except for [this beta Gentoo; distro](http://dev.gentoo.org/~vapier/x32/stage3-amd64-x32-20120605.tar.xz); built in x32); once they are, building and running x86-64 and x32; side-by-side will be possible. ## Build System; ROOT 6.00/00 can be built either using the classic "".",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:808,depend,dependencies,808,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['depend'],['dependencies']
Integrability,"; $\mbox{eps}$. The method can be used to override M 's own; determination, when the user knows that the $\mbox{FCN}$ function; value is not calculated to the nominal machine accuracy. Typical values; of $\mbox{eps}$ are between $10^{-5}$ and $10^{-14}$. ## MnMigrad and VariableMetricMinimizer ##. [api:migrad]. MnMigrad provides minimization of the function by the method of; $\mbox{MIGRAD}$, the most efficient and complete single method,; recommended for general functions (see also [api:minimize]), and the; functionality for parameters interaction. It also retains the result; from the last minimization in case the user may want to do subsequent; minimization steps with parameter interactions in between the; minimization requests. The minimization is done by the; VariableMetricMinimizer. Minimization of the function can be done by; directly using the VariableMetricMinimizer if no parameters interaction; is required. The minimization produces as a by-product the error matrix; of the parameters, which is usually reliable unless warning messages are; produced. ### MnMigrad(const FCNBase&, const std::vector$<$double$>$&, const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:42551,message,messages,42551,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['messages']
Integrability,"; - Proxies are now properly re-used when multiple TTreeReader{Value,Array}s are associated to a single branch. Deserialisation is therefore performed once. This is an advantage for complex TDataFrame graphs.; - Add TBranch::BackFill to allow the addition of new branches to an existing tree and keep the new basket clustered in the same way as the rest of the TTree. Use with the following pattern,; make sure to to call BackFill for the same entry for all the branches consecutively:; ```; for(auto e = 0; e < tree->GetEntries(); ++e) { // loop over entries.; for(auto branch : branchCollection) {; ... Make change to the data associated with the branch ...; branch->BackFill();; }; }; ```; Since we loop over all the branches for each new entry all the baskets for a cluster are consecutive in the file. ### RDataFrame (formerly TDataFrame); #### Behaviour, interface and naming changes; - `TDataFrame` and `TDataSource` together with their federation of classes have been renamed according to the coding conventions for new interfaces and extracted from the `Experimental` namespace: they can now be found in the ROOT namespace and they are called `ROOT::RDataFrame` and `ROOT::RDataSource`.; - `ROOT::Experimental::TDF::TResultProxy` has been renamed to `ROOT::RDF::RResultPtr`.; - `Report` now behaves identically to all other actions: it executes lazily and returns a `RResultPtr` (see the `New features` section for more details).; - `Snapshot` now returns a `RResultPtr` like all other actions: specifically, this is a pointer to a new `RDataFrame` which will run on the snapshotted dataset.; - `RDataFrame` has been removed from tree/treeplayer and put in its own package, tree/dataframe. The library where this code can be found is `libROOTDataFrame`. This new library is included in the list provided by `root-config --libs`.; - The `TArrayBranch` class has been removed and replaced by the more powerful `RVec` (see the `New features` section for more details).; - All `RDataFrame` tutori",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:5662,interface,interface,5662,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,2,['interface'],"['interface', 'interfaces']"
Integrability,"; - ``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers are; available, otherwise the 32-bit register name; do nothing on a memory operand.; - ``n``: Negate and print an unadorned integer, or, for operands other than an; immediate integer (e.g. a relocatable symbol expression), print a '-' before; the operand. (The behavior for relocatable symbol expressions is a; target-specific behavior for this typically target-independent modifier); - ``H``: Print a memory reference with additional offset +8.; - ``p``: Print a raw symbol name (without syntax-specific prefixes).; - ``P``: Print a memory reference used as the argument of a call instruction or; used with explicit base reg and index reg as its offset. So it can not use; additional regs to present the memory reference. (E.g. omit ``(rip)``, even; though it's PC-relative.). XCore:. No additional modifiers. Inline Asm Metadata; ^^^^^^^^^^^^^^^^^^^. The call instructions that wrap inline asm nodes may have a; ""``!srcloc``"" MDNode attached to it that contains a list of constant; integers. If present, the code generator will use the integer as the; location cookie value when report errors through the ``LLVMContext``; error reporting mechanisms. This allows a front-end to correlate backend; errors that occur with inline asm back to the source code that produced; it. For example:. .. code-block:: llvm. call void asm sideeffect ""something bad"", """"(), !srcloc !42; ...; !42 = !{ i32 1234567 }. It is up to the front-end to make sense of the magic numbers it places; in the IR. If the MDNode contains multiple constants, the code generator; will use the one that corresponds to the line of the asm that the error; occurs on. .. _metadata:. Metadata; ========. LLVM IR allows metadata to be attached to instructions and global objects in the; program that can convey extra information about the code to the optimizers and; code generator. One example application of metadata is source-level; debug information. There a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:241739,wrap,wrap,241739,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5303,depend,dependence,5303,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,"['depend', 'mediat']","['dependence', 'mediated']"
Integrability,"; 11. Change algorithm of building smooth (bezier) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibility level for geo drawing (#258); 36. Fix - use more factor for number of nodes in geo drawing (#258). ## Changes in 7.3.4; 1. Fix - failure in normal_cdf calculation; 2. Fix - check in TTree::Draw for null buffer; 3. Fix - do not rise exception in treeProcess; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13640,inject,inject,13640,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['inject'],['inject']
Integrability,"; ; {; TCanvas *c = new TCanvas;; TLatex *l = new TLatex(0.5, 0.5, ""#font[122]{a = b + c - d #pm e}"");; l->Draw();; c->SaveAs(""c.eps"");; }; ; The font 122 is the greek one. With a such TLatex ""a"" becomes ""alpha"",; ""b"" becomes "" beta"" etc ... It is not the recommended way to do greek; characters with TLatex, but it should work anyway.; In TPostScript::DrawPolyMarker: do not draw the markers is the marker size; is 0.; Right aligned or centered text was not correctly positioned when rotated. TASImage. The text size adjustment applied TASImage::DrawText; was not valid (scale factor of 1.044). The text size was wrong and the; following macro produced a wrong title when ran in batch:; ; {; TCanvas *canvas = new TCanvas(""c5"",""c5"",900,900);; TH1F *histo = new TH1F(""Histo"",""123456x_{i}abcdefy^{2}"",100,0,20);; canvas->Print(""drawing.gif"");; }; ; Suppress annoying messages like:; ; root : looking for image ""filename"" in path [/home/username/icons]; ; printed by libAfterImage when using TImage::Open(""filename""); In TImageDump the hollow filled areas were not correct:; ; they used the line attributes,; a line was drawn around the polygons filled with patterns. This fixes the problem mentionned here:; https://savannah.cern.ch/bugs/index.php?59263; as well as the test #22 in stressGraphics (no need to change; the reference file). Interface to graphviz. Thanks to three new classes (TGraphStruct, TGraphNode and; TGraphEdge) ROOT provides; an interface to the graphs visualization package graphviz. Graph; visualization is a way of representing structural information as diagrams of; abstract graphs and networks. Example:. The previous image is produced by the following ROOT macro:; ; // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:960,message,messages,960,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['message'],['messages']
Integrability,"; === TextInput. = Purpose. Read and edit text lines, and write what was read. This library is a simplistic alternative to readline / editline. It offers; less functionality but it has a more liberal license (see LICENSE.TXT in; the topmost) directory, it has no external dependencies, and it works on; all platforms that I tested:; - Linux; - Windows (probably >= 2000); - MacOS; - Solaris; Adding other platforms is trivial. = Internal Design. TextInput.h contains the main interface. The reading can be extended by; adding classes that derive from Reader; the displaying can be extended; by deriving from Display. There can be multiple readers and multiple displays. All displays are; equal, all readers are equal. All displays show the input of all; readers. The terminal / console implementations for readers and; displays are provided. Both readers and displays only attach while; textinput is acively reading input. As soon as the input is done (enter; was pressed), they detach from the terminal, allowing the application; to take control of the terminal, and even to crash without leaving the; terminal in a non-default state. The editor provides basic emacs-like keybinding, as known from e.g.; bash. It supports ^O, ^R (for now without regex), and most word-centric; editing commands. See KeyBinding for details. KeyBinding maps the InputData read from the Reader to Editor::Commands.; The Editor performs the requested editing actions, and the Displays; are informed about the changes. TextInput gives access to the read; state (""are we done?"") and the input. = Why no [N]Curses?. Because of platform independence (well, one could still have a; TerminalDisplayCurses) and because nowadays this is actually rarely; needed. Sure, it's the ""right"" way of interfacing terminals. But the; number of terminal types in the wild has siginifantly decreased, so; just hard-coding escape sequences became a viable alternative. = References. These pages helped when writing libtextinput:; http://tldp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt:272,depend,dependencies,272,core/textinput/src/textinput/doc/textinput.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt,2,"['depend', 'interface']","['dependencies', 'interface']"
Integrability,"; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109864,depend,dependent,109864,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"; For example::. > set TMP=C:\TMP; > set TEMP=C:\TMP. The first package to build is ``cppyy-cling``.; It may take a long time, especially on a laptop (Mac ARM being a notable; exception), since Cling comes with a builtin version of LLVM/Clang.; Consider therefore for a moment your reasons for building from source: there; being no pre-built wheel for the platform that you're interested in or simply; needing the latest version from the repository; or perhaps you are planning; to develop/modify the sources. If the former, clone the repository, check out a specific tagged release as; needed, then run the following steps to add Cling and build a wheel.; Once built, install the wheel as appropriate::. $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ python setup.py bdist_wheel; $ python -m pip install dist/cppyy_cling-* --upgrade. .. note::; ``cppyy-cling`` wheels do not depend on the Python interpreter and can; thus be re-used for any version of Python or PyPy. The ``egg_info`` setup command is needed for ``create_src_directory.py`` to; find the right version.; That script in turn downloads the proper release from `upstream`_, trims and; patches it,; and installs the result in the ""src"" directory.; When done, the structure of ``cppyy-cling`` looks again like a PyPA package; and can be used/installed as expected, here done with ``pip``. By default, the setup script will use all cores (x2 if hyperthreading is; enabled).; You can change this behavior by setting the ``MAKE_NPROCS`` envar to the; desired number of allowable sub jobs. If on the other hand you are building from source to develop/modify; ``cppyy-cling``, consider using the ``cmake`` interface.; The first installation will still be just as slow, but subsequent builds can; be incremental and thus much faster.; For this use, first install the latest version from a pre-built wheel, which; will setup the proper directory st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:3144,depend,depend,3144,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['depend'],['depend']
Integrability,"; In general, the lower the Block RThroughput, the better. In this example, ``uOps per iteration/Block RThroughput`` is 1.50. Since there; are no loop-carried dependencies, the observed `uOps Per Cycle` is expected to; approach 1.50 when the number of iterations tends to infinity. The delta between; the Dispatch Width (2.00), and the theoretical maximum uOp throughput (1.50) is; an indicator of a performance bottleneck caused by the lack of hardware; resources, and the *Resource pressure view* can help to identify the problematic; resource usage. The second section of the report is the `instruction info view`. It shows the; latency and reciprocal throughput of every instruction in the sequence. It also; reports extra information related to the number of micro opcodes, and opcode; properties (i.e., 'MayLoad', 'MayStore', and 'HasSideEffects'). Field *RThroughput* is the reciprocal of the instruction throughput. Throughput; is computed as the maximum number of instructions of a same type that can be; executed per clock cycle in the absence of operand dependencies. In this; example, the reciprocal throughput of a vector float multiply is 1; cycles/instruction. That is because the FP multiplier JFPM is only available; from pipeline JFPU1. Instruction encodings are displayed within the instruction info view when flag; `-show-encoding` is specified. Below is an example of `-show-encoding` output for the dot-product kernel:. .. code-block:: none. Instruction Info:; [1]: #uOps; [2]: Latency; [3]: RThroughput; [4]: MayLoad; [5]: MayStore; [6]: HasSideEffects (U); [7]: Encoding Size. [1] [2] [3] [4] [5] [6] [7] Encodings: Instructions:; 1 2 1.00 4 c5 f0 59 d0 vmulps	%xmm0, %xmm1, %xmm2; 1 4 1.00 4 c5 eb 7c da vhaddps	%xmm2, %xmm2, %xmm3; 1 4 1.00 4 c5 e3 7c e3 vhaddps	%xmm3, %xmm3, %xmm4. The `Encoding Size` column shows the size in bytes of instructions. The; `Encodings` column shows the actual instruction encodings (byte sequences in; hex). The third section is the *Resource",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:19023,depend,dependencies,19023,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"; Inter-Procedural Optimization. Refers to any variety of code optimization; that occurs between procedures, functions or compilation units (modules). **ISel**; Instruction Selection. L; -. **LCSSA**; Loop-Closed Static Single Assignment Form. **LGTM**; ""Looks Good To Me"". In a review thread, this indicates that the; reviewer thinks that the patch is okay to commit. **LICM**; Loop Invariant Code Motion. **LSDA**; Language Specific Data Area. C++ ""zero cost"" unwinding is built on top a; generic unwinding mechanism. As the unwinder walks each frame, it calls; a ""personality"" function to do language specific analysis. Each function's; FDE points to an optional LSDA which is passed to the personality function.; For C++, the LSDA contain info about the type and location of catch; statements in that function. **Load-VN**; Load Value Numbering. **LTO**; Link-Time Optimization. M; -. **MC**; Machine Code. N; -; .. _nfc:. **NFC**; ""No functional change"". Used in a commit message to indicate that a patch; is a pure refactoring/cleanup.; Usually used in the first line, so it is visible without opening the; actual commit email. O; -; .. _object pointer:; .. _object pointers:. **Object Pointer**; A pointer to an object such that the garbage collector is able to trace; references contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:5763,message,message,5763,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['message'],['message']
Integrability,"; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29397,inject,inject,29397,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['inject']
Integrability,"; Major changes. GLEW - The OpenGL Extension Wrangler Library - has been added to; facilitate detection of OpenGL version and available extensions at; run-time. This will allow usage of advanced visualization techniques; while still allowing fall-back solutions to be used on systems not; supporting the required functionality. If GLEW and GLEW-devel packages; are detected during configure, the ROOT provided GLEW is not; built. See also:; http://glew.sourceforge.net/. Latest (1.3.3) version of gl2ps has been imported (we had 1.2.6; before). See http://www.geuz.org/gl2ps/; for detailed change-log. New implementation of GL-in-TPad - instead of mixture of GL and; non-GL graphics in a pixmap all pad graphics (2D/3D) is now; done by OpenGL. To make this possible new TVirtualPadPainter,; TPadPainter, TGLPadPainter classes were introduced; and painting operations inside TPad class were modified to; use TVirtualPadPainter instead of TVirtualX.; TVirtualPadPainter is an abstract base class, interface for; drawing 2D primitives and pixmap management. TPadPainter is; a default, non-GL implementation, based on TVirtualX; (gVirtualX). TGLPadPainter is a GL; implementation. Currently, TGLPadPainter does not support; off-screen rendering (support for frame-buffer objects is planned). Current limitations:. The glpad can be saved only as PS now.; Several sub-pads with complex 3d geometry can be slow due to lack; of off-screen rendering which would allow for caching of resulting images. Future directions:. Use frame-buffer objects for off-screen rendering.; Support ""Save as"" png, jpg, pdf, etc.; With GLEW and GL-shading-language, use of hardware anti-aliasing and; shaders is possible. Prototype visualization of 5-dimensional distributions:. New option for TTree::Draw - ""gl5d"", for the case you have 5 and; more dimensional dataset.; Set of iso-surfaces created, 4-th dimension is used to select iso-level.; ""gl5d"" is now very similar to ""gliso"" option, but instead of; filling TH3 object (v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html:1003,interface,interface,1003,graf3d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html,1,['interface'],['interface']
Integrability,; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145446,depend,dependent,145446,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"; Omar, Zapata, Medellin, Columbia \; Maciej Zimnoch, GSoC, Poland. ## ROOT reference manual. The ROOT reference manual has been moved into Doxygen. Still some work and; polish has to be done but the reference guide in this new format is now online; and can be seen from the [ROOT home page](https://root.cern.ch/doc/master/index.html). ## Core Libraries. ### Dictionary generation. Fixed the dictionary generation in the case of class inside a namespace; marked inlined. Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates. Fix [ROOT-7760] : fully allow the usage of the dylib extension on OSx. Fix [ROOT-7723] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock). We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: `ROOT::EnableThreadSafety()` which is the successor of the existing `TThread::Initialize`. This call must take place if ROOT needs to be used in a thread safe manner. The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost. ### TDirectory::TContext. We added a default constructor to `TDirectory::TContext` which record the current directory; and will restore it at des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:2168,wrap,wrapper,2168,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['wrap'],['wrapper']
Integrability,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54772,integrat,integration,54772,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``Pass::getAnalysis<>`` method is automatically inherited by your class,; providing you with access to the passes that you declared that you required; with the :ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>`; method. It takes a single template argument that specifies which pass class; you want, and returns a reference to that pass. For example:. .. code-block:: c++. bool LICM::runOnFunction(Function &F) {; LoopInfo &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();; //...; }. This method call returns a reference to the pass desired. You may get a; runtime assertion failure if you attempt to get an analysis that you did not; declare as required in your :ref:`getAnalysisUsage; <writing-an-llvm-pass-getAnalysisUsage>` implementation. This method can be; called by your ``run*`` method implementation, or by any other local method; invoked by your ``run*`` method. A module level pass can use function level analysis info using this interface.; For example:. .. code-block:: c++. bool ModuleLevelPass::runOnModule(Module &M) {; //...; DominatorTree &DT = getAnalysis<DominatorTree>(Func);; //...; }. In above example, ``runOnFunction`` for ``DominatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:33864,interface,interface,33864,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric function. Similarly to the one dimensional version, the user needs to provide the; method `void SetParameters(double* p)` as well as the getter methods `const double * Parameters()` and `uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const dou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:39565,interface,interfaces,39565,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"; ```; grabs all the root files with the path `/path/to/tree/somedir/file.root` (but not `/path/to/tree/file.root` and `/path/to/tree/somedir/anotherdir/file.root`). Another example:; ```; TChain::Add(""/path/to/tree/subdir[0-9]/*.root""); ```; This grabs all the root files in subdirectories that have a name starting with `subdir` and ending with some digit. ### Improved efficiency of TTree friends with indices. `TTreeIndex` and `TChainIndex` classes now implement the `Clone` method such that it does not use the ROOT I/O to clone the; index but just does a copy in memory. Notably, this improves processing efficiency for RDataFrame in multithreaded; execution since the same index must be copied over to all the threads and attached to the current tree for proper; event matching. ## RNTuple; ROOT's experimental successor of TTree has seen a number of updates since the last release. Specifically, 6.32 includes the following changes:. - A major refactoring of the interface, improving consistency across different parts and improving overall robustness. **Note that this is a breaking change with regard to 6.30!**; - The on-disk format has been updated to release candidate 2. **It will not be possible to read RNTuples written in the previous format anymore.**; - Support has been added for several new field types: `std::unordered_set<T>`, `std::map<K,V>`, `std::unordered_map<K,V>`; - Support has been added for on-disk half-precision (IEEE 754-2008 16-bit) float fields. This can be enabled through `RField<float>::SetHalfPrecision()`. On reading, values of such fields are represented as regular, 32-bit floats.; - A new `RNTupleInspector` utility class has been added, to provide information about the on-disk metadata of an RNTuple.; - A new `RNTupleParallelWriter` class has been added, providing (initial) support for parallel writing of RNTuples.; - A new static method `RFieldBase::Check()` has been added, which produces a support status report of a type with regards to RNTuple I/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:4465,interface,interface,4465,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interface']
Integrability,"; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stronger) operations on the same address. If an address is written; ``monotonic``-ally by one thread, and other threads ``monotonic``-ally; read that address repeatedly, the other threads must eventually see; the write. This corresponds to the C/C++ ``memory_order_relaxed``.; ``acquire``; In addition to the guarantees of ``monotonic``, a; *synchronizes-with* edge may be formed with a ``release`` operation.; This is intended to model C/C++'s ``memory_order_acquire``.; ``release``; In addition to the guarantees of ``monotonic``, if this operation; writes a value which is subsequently read by an ``acquire``; operation, it *synchronizes-with* that operation. Furthermore,; this occurs even if the value written by a ``release`` operation; has been modified by a read-modify-write operation before being; read. (Such a set of operations comprises a *release; sequence*). This corresponds to the C/C++; ``memory_order_release``.; ``acq_rel`` (acquire+release); Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:154544,synchroniz,synchronizes-with,154544,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes-with']
Integrability,"; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53447,contract,contract,53447,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:493551,depend,dependent,493551,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"; colors are not shown) are shown. The color numbers specified in the; basic palette, and the picture above, can be viewed by selecting the; menu entry Colors in the View canvas menu. The user may define other; colors. To do this, one has to build a new **`TColor`**:. ``` {.cpp}; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); ```. One has to give the color number and the three Red, Green, Blue values,; each being defined from 0 (min) to 1(max). An optional name may be; given. When built, this color is automatically added to the existing; list of colors. If the color number already exists, one has to extract; it from the list and redefine the RGB values. This may be done for; example with:. ``` {.cpp}; root[] color=(TColor*)(gROOT->GetListOfColors()->At(index_color)); root[] color->SetRGB(r,g,b); ```. Where `r`, `g` and `b` go from 0 to 1 and `index_color` is the color; number you wish to change. ![](pictures/030000D4.png) The user interface for changing the fill; color and style looks like shown in this picture. It takes place in the; editor frame anytime the selected object inherits the class; **`TAttFill`**. #### Color Palette (for Histograms). Defining one color at a time may be tedious. The histogram classes (see; Draw Options) use the color palette. For example, `TH1::Draw(""col"")`; draws a 2-D histogram with cells represented by a box filled with a; color `CI` function of the cell content. If the cell content is `N`, the; color `CI` used will be the color number in `colors[N]`. If the maximum; cell content is `>ncolors`, all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:81141,interface,interface,81141,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored category functions are now also printed under their own heading in Print(); Parameterized ranges. It is now possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:3635,depend,depending,3635,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['depend'],['depending']
Integrability,"; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.; It thus plays well with object identity, references, etc.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... struct MyStruct { int fInt; };; ... void* create_mystruct() { return new MyStruct{42}; }; ... """"""); ... ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1576,interface,interface,1576,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,2,['interface'],['interface']
Integrability,"; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-met",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172911,contract,contract,172911,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contract']
Integrability,"; don't support this, and are known to trigger errors when run with the; ``AliasAnalysisDebugger``. The ``AliasSetTracker`` class (which is used by ``LICM``) makes a; non-deterministic number of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19571,depend,dependence,19571,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependence']
Integrability,"; else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ""Dependency debugging is only currently supported on Darwin hosts.""); endif(); if(LLVM_CCACHE_BUILD); message(FATAL_ERROR ""Cannot enable dependency debugging while using ccache.""); endif(); endif(). option(LLVM_ENABLE_DAGISEL_COV ""Debug: Prints tablegen patterns that were used for selecting"" OFF); option(LLVM_ENABLE_GISEL_COV ""Enable collection of GlobalISel rule coverage"" OFF); if(LLVM_ENABLE_GISEL_COV); set(LLVM_GISEL_COV_PREFIX ""${CMAKE_BINARY_DIR}/gisel-coverage-"" CACHE STRING ""Provide a filename prefix to collect the GlobalISel rule coverage""); endif(). # Add path for custom modules; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake""; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # Generate a Compilati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:12251,depend,dependency,12251,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;; };; fieldDecl(hasBitWidth(2)); matches 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:87024,depend,dependent,87024,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14194,adapter,adapter,14194,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['adapter'],['adapter']
Integrability,"; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46170,wrap,wrap,46170,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,"; if (foo()) {; } else {; }. * ``bool BeforeLambdaBody`` Wrap lambda block. .. code-block:: c++. true:; connect(; [](); {; foo();; bar();; });. false:; connect([]() {; foo();; bar();; });. * ``bool BeforeWhile`` Wrap before ``while``. .. code-block:: c++. true:; do {; foo();; }; while (1);. false:; do {; foo();; } while (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42330,wrap,wrapped,42330,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Undefined values are useful because they indicate to the compiler that; the program is well defined no matter what value is used. This gives the; compiler more freedom to optimize. Here are some examples of; (potentially surprising) transformations that are valid (in pseudo IR):. .. code-block:: llvm. %A = add %X, undef; %B = sub %X, undef; %C = xor %X, undef; Safe:; %A = undef; %B = undef; %C = undef. This is safe because all of the output bits are affected by the undef; bits. Any output bit can have a zero or one depending on the input bits. .. code-block:: llvm. %A = or %X, undef; %B = and %X, undef; Safe:; %A = -1; %B = 0; Safe:; %A = %X ;; By choosing undef as 0; %B = %X ;; By choosing undef as -1; Unsafe:; %A = undef; %B = undef. These logical operations have bits that are not always affected by the; input. For example, if ``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:191826,depend,depending,191826,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"; is a reference, just use the object region as the initializer value. Before entering a C++ method (or ctor/dtor), the 'this' region is bound; to the object region. In ctors, we synthesize 'this' region with; CXXRecordDecl*, which means we do not use type qualifiers. In methods, we; synthesize 'this' region with CXXMethodDecl*, which has getThisType(); taking type qualifiers into account. It does not matter we use qualified; 'this' region in one method and unqualified 'this' region in another; method, because we only need to ensure the 'this' region is consistent; when we synthesize it and create it directly from CXXThisExpr in a single; method call. = Working on the Analyzer =. If you are interested in bringing up support for C++ expressions, the; best place to look is the visitation logic in ExprEngine, which; handles the simulation of individual expressions. There are plenty of; examples there of how other expressions are handled. If you are interested in writing checkers, look at the Checker and; CheckerVisitor interfaces (Checker.h and CheckerVisitor.h). Also look; at the files named *Checker.cpp for examples on how you can implement; these interfaces. = Debugging the Analyzer =. There are some useful command-line options for debugging. For example:. $ clang -cc1 -help | grep analyze; -analyze-function <value>; -analyzer-display-progress; -analyzer-viz-egraph-graphviz; ... The first allows you to specify only analyzing a specific function.; The second prints to the console what function is being analyzed. The; third generates a graphviz dot file of the ExplodedGraph. This is; extremely useful when debugging the analyzer and viewing the; simulation results. Of course, viewing the CFG (Control-Flow Graph) is also useful:. $ clang -cc1 -analyzer-checker-help-developer. -analyzer-checker=debug.DumpCFG Display Control-Flow Graphs; -analyzer-checker=debug.ViewCFG View Control-Flow Graphs using GraphViz; (outdated below?); -cfg-add-implicit-dtors Add C++ implicit des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:5308,interface,interfaces,5308,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['interface'],['interfaces']
Integrability,"; message(STATUS ""Could NOT find ccache""); set(ccache OFF CACHE BOOL ""Use ccache (disabled since ccache was not found)"" FORCE); endif(); endif(). #---Enable distcc ------------------------------------------------------------------------------; if(distcc); find_program(DISTCC_COMMAND NAMES distcc); mark_as_advanced(DISTCC_COMMAND ${DISTCC_COMMAND}); if(EXISTS ${DISTCC_COMMAND}); message(STATUS ""Found distcc: ${DISTCC_COMMAND}""); if (ccache); # If ccache is enabled, use distcc as CCACHE_PREFIX; message(STATUS ""Because ccache is enabled, CCACHE_PREFIX is set to ${DISTCC_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""CCACHE_PREFIX=${DISTCC_COMMAND} ${CCACHE_COMMAND}""); else(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${DISTCC_COMMAND}); endif(); execute_process(COMMAND ${DISTCC_COMMAND} ""--version"" OUTPUT_VARIABLE DISTCC_VERSION); string(REGEX REPLACE ""distcc ([0-9\\.]+).*"" ""\\1"" DISTCC_VERSION ${DISTCC_VERSION}); else(); message(STATUS ""Could NOT find distcc""); set(distcc OFF CACHE BOOL ""Use distcc (disabled since distcc was not found)"" FORCE); endif(); endif(). #---Enable test coverage -----------------------------------------------------------------------; if(coverage); set(GCC_COVERAGE_COMPILE_FLAGS ""-fprofile-arcs -ftest-coverage""); set(GCC_COVERAGE_LINK_FLAGS ""-fprofile-arcs""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHAREDLINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS ""${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); endif(). #--- Enable build timing -----------------------------------------------------------------------; if (build_timing); # FIXME: This currently will override the use of ccache if -Dbuild_timing=On -Dccache=On is passed.; set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""${CMAKE_COMMAND} -E time""); set_prope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:10081,message,message,10081,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"; necessary ``__sync_*`` implementations are available. Code using; ``+forced-atomics`` is ABI-incompatible with code not using the feature, if; atomic variables cross the ABI boundary. In either of these cases, the Target in LLVM can claim support for atomics of an; appropriate size, and then implement some subset of the operations via libcalls; to a ``__sync_*`` function. Such functions *must* not use locks in their; implementation, because unlike the ``__atomic_*`` routines used by; AtomicExpandPass, these may be mixed-and-matched with native instructions by the; target lowering. Further, these routines do not need to be shared, as they are stateless. So,; there is no issue with having multiple copies included in one binary. Thus,; typically these routines are implemented by the statically-linked compiler; runtime support library. LLVM will emit a call to an appropriate ``__sync_*`` routine if the target; ISelLowering code has set the corresponding ``ATOMIC_CMPXCHG``, ``ATOMIC_SWAP``,; or ``ATOMIC_LOAD_*`` operation to ""Expand"", and if it has opted-into the; availability of those library functions via a call to ``initSyncLibcalls()``. The full set of functions that may be called by LLVM is (for ``N`` being 1, 2,; 4, 8, or 16)::. iN __sync_val_compare_and_swap_N(iN *ptr, iN expected, iN desired); iN __sync_lock_test_and_set_N(iN *ptr, iN val); iN __sync_fetch_and_add_N(iN *ptr, iN val); iN __sync_fetch_and_sub_N(iN *ptr, iN val); iN __sync_fetch_and_and_N(iN *ptr, iN val); iN __sync_fetch_and_or_N(iN *ptr, iN val); iN __sync_fetch_and_xor_N(iN *ptr, iN val); iN __sync_fetch_and_nand_N(iN *ptr, iN val); iN __sync_fetch_and_max_N(iN *ptr, iN val); iN __sync_fetch_and_umax_N(iN *ptr, iN val); iN __sync_fetch_and_min_N(iN *ptr, iN val); iN __sync_fetch_and_umin_N(iN *ptr, iN val). This list doesn't include any function for atomic load or store; all known; architectures support atomic loads and stores directly (possibly by emitting a; fence on either side of a normal l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:28883,rout,routine,28883,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['rout'],['routine']
Integrability,; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16128,interface,interface,16128,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"; only with MSVC. Defaults to ON. **LLVM_ENABLE_DOXYGEN**:BOOL; Enables the generation of browsable HTML documentation using doxygen.; Defaults to OFF. **LLVM_ENABLE_DOXYGEN_QT_HELP**:BOOL; Enables the generation of a Qt Compressed Help file. Defaults to OFF.; This affects the make target ``doxygen-llvm``. When enabled, apart from; the normal HTML output generated by doxygen, this will produce a QCH file; named ``org.llvm.qch``. You can then load this file into Qt Creator.; This option is only useful in combination with ``-DLLVM_ENABLE_DOXYGEN=ON``;; otherwise this has no effect. **LLVM_ENABLE_EH**:BOOL; Build LLVM with exception-handling support. This is necessary if you wish to; link against LLVM libraries and make use of C++ exceptions in your own code; that need to propagate through LLVM code. Defaults to OFF. **LLVM_ENABLE_EXPENSIVE_CHECKS**:BOOL; Enable additional time/memory expensive checking. Defaults to OFF. **LLVM_ENABLE_HTTPLIB**:BOOL; Enables the optional cpp-httplib dependency which is used by llvm-debuginfod; to serve debug info over HTTP. `cpp-httplib <https://github.com/yhirose/cpp-httplib>`_; must be installed, or `httplib_ROOT` must be set. Defaults to OFF. **LLVM_ENABLE_FFI**:BOOL; Indicates whether the LLVM Interpreter will be linked with the Foreign Function; Interface library (libffi) in order to enable calling external functions.; If the library or its headers are installed in a custom; location, you can also set the variables FFI_INCLUDE_DIR and; FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found,; respectively. Defaults to OFF. **LLVM_ENABLE_IDE**:BOOL; Tell the build system that an IDE is being used. This in turn disables the; creation of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:21481,depend,dependency,21481,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['dependency']
Integrability,"; pipeline, after most optimization is already done. This helps to improve; the quality of the generated code when compiled with garbage collection support. .. _RewriteStatepointsForGC_intrinsic_lowering:. RewriteStatepointsForGC intrinsic lowering; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. As a part of lowering to the explicit model of relocations; RewriteStatepointsForGC performs GC specific lowering for the following; intrinsics:. * ``gc.get.pointer.base``; * ``gc.get.pointer.offset``; * ``llvm.memcpy.element.unordered.atomic.*``; * ``llvm.memmove.element.unordered.atomic.*``. There are two possible lowerings for the memcpy and memmove operations:; GC leaf lowering and GC parseable lowering. If a call is explicitly marked with; ""gc-leaf-function"" attribute the call is lowered to a GC leaf call to; '``__llvm_memcpy_element_unordered_atomic_*``' or; '``__llvm_memmove_element_unordered_atomic_*``' symbol. Such a call can not; take a safepoint. Otherwise, the call is made GC parseable by wrapping the; call into a statepoint. This makes it possible to take a safepoint during; copy operation. Note that a GC parseable copy operation is not required to; take a safepoint. For example, a short copy operation may be performed without; taking a safepoint. GC parseable calls to '``llvm.memcpy.element.unordered.atomic.*``',; '``llvm.memmove.element.unordered.atomic.*``' intrinsics are lowered to calls; to '``__llvm_memcpy_element_unordered_atomic_safepoint_*``',; '``__llvm_memmove_element_unordered_atomic_safepoint_*``' symbols respectively.; This way the runtime can provide implementations of copy operations with and; without safepoints. GC parseable lowering also involves adjusting the arguments for the call.; Memcpy and memmove intrinsics take derived pointers as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:30063,wrap,wrapping,30063,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['wrap'],['wrapping']
Integrability,"; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52530,depend,depends,52530,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['depend'],['depends']
Integrability,"; relevant for users of cross-DSO CFI:. - There is a performance and code size overhead associated with each; exported function, because each such function must have an associated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13086,wrap,wrapper,13086,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,2,['wrap'],"['wrapper', 'wrappers']"
Integrability,"; return 0;}"" found_arc4). if(found_arc4); message(STATUS ""Found arc4random_buf in stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_STDLIB); else(); set(OLD_CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES}); set(OLD_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}); if(DEFINED LIBBSDROOT); set(CMAKE_REQUIRED_INCLUDES ${LIBBSDROOT}/include); set(CMAKE_REQUIRED_LIBRARIES ${LIBBSDROOT}/lib/libbsd.so); endif(); CHECK_CXX_SOURCE_COMPILES(""#include <bsd/stdlib.h>; int main() { char buf[32]; arc4random_buf(buf, 32); return 0;}"" found_arc4_bsd); set(CMAKE_REQUIRED_INCLUDES ${OLD_CMAKE_REQUIRED_INCLUDES}); set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQUIRED_LIBRARIES}); if(found_arc4_bsd); message(STATUS ""Found arc4random_buf in bsd/stdlib.h""); target_compile_definitions(Core PRIVATE R__ARC4_BSDLIB); if(DEFINED LIBBSDROOT); target_include_directories(Core PRIVATE ${LIBBSDROOT}/include); target_link_libraries(Core PRIVATE ${LIBBSDROOT}/lib/libbsd.so); endif(); else(); CHECK_CXX_SOURCE_COMPILES(""#include <sys/random.h>; int main() { char buf[32]; int res = getrandom(buf, 32, GRND_NONBLOCK); return 0;}"" found_getrandom); if(found_getrandom); message(STATUS ""Found getrandom in sys/random.h""); target_compile_definitions(Core PRIVATE R__GETRANDOM_CLIB); else(); CHECK_CXX_SOURCE_RUNS(""; #include <fstream>. int main() {; std::ifstream urandom{\""/dev/urandom\""};; if (!urandom) {; // This will make the CMake command fail; return 1;; }; ; constexpr int len{32};; char buf[len];; for (int n = 0; n < len; n++) buf[n] = 0;; urandom.read(buf, len);; ; int nmatch = 0;; for (int n = 0; n < len; n++); if (buf[n] == 0) nmatch++;; ; // Fail if no values have changed; return nmatch != len ? 0 : 1;; }"" found_urandom); if(found_urandom); message(STATUS ""Found random device in /dev/urandom""); target_compile_definitions(Core PRIVATE R__USE_URANDOM); else(); message(FATAL_ERROR ""Fail to detect cryptographic random generator""); endif(); endif(); endif(); endif(). ROOT_INSTALL_HEADERS(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt:1982,message,message,1982,core/unix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/CMakeLists.txt,3,['message'],['message']
Integrability,"; rs301_splot.C Demonstrates use of RooStats sPlot; implementation; rs401c_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with a Poisson problem, reproduces; results from table IV and V of the original; paper�Phys.Rev.D57:3873-3889,1998.; rs401d_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with the neutrino oscillation toy; example described in the original paper�Phys.Rev.D57:3873-3889,1998.; Reproduces figure 12.; rs_bernsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with or without; interpolation). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:26176,interface,interface,26176,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:3825,message,messages,3825,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['message'],['messages']
Integrability,"; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9235,interface,interfaces,9235,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['interface'],['interfaces']
Integrability,"; time.; ; * -parse-ast builds ASTs, but doesn't print them. This is most; useful for timing AST building vs -parse-noop.; ; * -parse-ast-print pretty prints most expression and statements nodes. * -parse-ast-check checks that diagnostic messages that are expected; are reported and that those which are reported are expected. * -dump-cfg builds ASTs and then CFGs. CFGs are then pretty-printed. * -view-cfg builds ASTs and then CFGs. CFGs are then visualized by; invoking Graphviz. For more information on getting Graphviz to work with clang/LLVM,; see: https://llvm.org/docs/ProgrammersManual.html#ViewGraph. III. Current advantages over GCC:. * Column numbers are fully tracked (no 256 col limit, no GCC-style pruning).; * All diagnostics have column numbers, includes 'caret diagnostics', and they; highlight regions of interesting code (e.g. the LHS and RHS of a binop).; * Full diagnostic customization by client (can format diagnostics however they; like, e.g. in an IDE or refactoring tool) through DiagnosticClient interface.; * Built as a framework, can be reused by multiple tools.; * All languages supported linked into same library (no cc1,cc1obj, ...).; * mmap's code in read-only, does not dirty the pages like GCC (mem footprint).; * LLVM License, can be linked into non-GPL projects.; * Full diagnostic control, per diagnostic. Diagnostics are identified by ID.; * Significantly faster than GCC at semantic analysis, parsing, preprocessing; and lexing.; * Defers exposing platform-specific stuff to as late as possible, tracks use of; platform-specific features (e.g. #ifdef PPC) to allow 'portable bytecodes'.; * The lexer doesn't rely on the ""lexer hack"": it has no notion of scope and; does not categorize identifiers as types or variables -- this is up to the; parser to decide. Potential Future Features:. * Fine grained diag control within the source (#pragma enable/disable warning).; * Better token tracking within macros? (Token came from this line, which is; a macro argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:6002,interface,interface,6002,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['interface'],['interface']
Integrability,"; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72757,message,message,72757,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15167,interface,interface,15167,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"; ~~~~~~~. In this document, the term ``Modules``/``modules`` refers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2597,interface,interface,2597,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,";. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38804,wrap,wrapping,38804,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapping']
Integrability,";; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; ```. #### Linear Algebra Matrix Functions (Inversion, Determinant). Only limited linear algebra functionality is available for `SMatrix`. It; is possible for squared matrices `NxN`, to find the inverse or to; calculate the determinant. Different inversion algorithms are used if; the matrix is smaller than `6x6` or if it is symmetric. In the case of a; small matrix, a faster direct inversion is used. For a large; `(N>6) `symmetric matrix the Bunch-Kaufman diagonal pivoting method is; used while for a large `(N>6)` general matrix an LU factorization is; performed using the same algorithm as in the CERNLIB routine `dinv`. ``` {.cpp}; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; ```. ### Example: Matrix and Vector Functions and Operators. #### Matrix and Vector Operators. The **`ROOT::Math::SVector`** and **`ROOT::Math::SMatrix`** classes; define the following operators described below. The `m1`, `m2`, `m3` are; vectors or matrices of the same type (and size) and `a` is a scalar; value:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:112428,rout,routine,112428,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['rout'],['routine']
Integrability,";; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalIm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4521,depend,dependent,4521,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,2,['depend'],"['dependencies', 'dependent']"
Integrability,";; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107305,message,message,107305,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,";; int b[] = { 2, 3 };; int c[b[0]];; }; constantArrayType(); matches ""int a[2]"". Matcher<Type>decayedTypeMatcher<DecayedType>...; Matches decayed type; Example matches i[] in declaration of f.; (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))); Example matches i[1].; (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:46913,depend,dependentSizedArrayTypeMatcher,46913,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependentSizedArrayTypeMatcher']
Integrability,";; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7547,rout,routine,7547,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['rout'],['routine']
Integrability,";; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal lit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76921,wrap,wrapped,76921,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCProp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15092,interface,interface,15092,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"<ExprAST> Body); : Proto(std::move(Proto)), Body(std::move(Body)) {}; };. In Kaleidoscope, functions are typed with just a count of their; arguments. Since all values are double precision floating point, the; type of each argument doesn't need to be stored anywhere. In a more; aggressive and realistic language, the ""ExprAST"" class would probably; have a type field. With this scaffolding, we can now talk about parsing expressions and; function bodies in Kaleidoscope. Parser Basics; =============. Now that we have an AST to build, we need to define the parser code to; build it. The idea here is that we want to parse something like ""x+y""; (which is returned as three tokens by the lexer) into an AST that could; be generated with calls like this:. .. code-block:: c++. auto LHS = std::make_unique<VariableExprAST>(""x"");; auto RHS = std::make_unique<VariableExprAST>(""y"");; auto Result = std::make_unique<BinaryExprAST>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:5769,rout,routines,5769,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['rout'],['routines']
Integrability,"<https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1349,message,message,1349,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['message'],['message']
Integrability,"<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12633,interface,interface,12633,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"= ================ ================= =================================================================. Examples of enabled conversions:. .. parsed-literal::. // GFX9. v_add_f16 v0, 1.0, 0 // src0 = 0x3C00 (1.0); v_add_u16 v0, 1.0, 0 // src0 = 0x3C00; //; v_add_f32 v0, 1.0, 0 // src0 = 0x3F800000 (1.0); v_add_u32 v0, 1.0, 0 // src0 = 0x3F800000. // src0 before conversion:; // 1.7976931348623157e308 = 0x7fefffffffffffff; // src0 after conversion:; // 1.7976922776554302e308 = 0x7fefffff00000000; v_ceil_f64 v[0:1], 1.7976931348623157e308. v_add_f16 v1, 65500.0, v2 // ok for f16.; v_add_f32 v1, 65600.0, v2 // ok for f32, but would result in overflow for f16. Examples of disabled conversions:. .. parsed-literal::. // GFX9. v_add_f16 v1, 65600.0, v2 // overflow. .. _amdgpu_synid_rl_conv:. Conversion of Relocatable Values; --------------------------------. :ref:`Relocatable expressions<amdgpu_synid_relocatable_expression>`; may be used with 32-bit integer operands and jump targets. When the value of a relocatable expression is resolved by a linker, it is; converted as needed and truncated to the operand size. The conversion depends; on :ref:`relocation type<amdgpu-relocation-records>` and operand kind. For example, when a 32-bit operand of an instruction refers; to a relocatable expression *expr*, this reference is evaluated; to a 64-bit offset from the address after the; instruction to the address being referenced, *counted in bytes*.; Then the value is truncated to 32 bits and encoded as a literal:. .. parsed-literal::. expr = .; v_add_co_u32_e32 v0, vcc, expr, v1 // 'expr' operand is evaluated to -4; // and then truncated to 0xFFFFFFFC. As another example, when a branch instruction refers to a label,; this reference is evaluated to an offset from the address after the; instruction to the label address, *counted in dwords*.; Then the value is truncated to 16 bits:. .. parsed-literal::. label:; s_branch label // 'label' operand is evaluated to -1 and truncated to 0xFFFF; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:39992,depend,depends,39992,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['depend'],['depends']
Integrability,"= A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4879,depend,dependence,4879,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependence']
Integrability,"= true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value specified, 'Force' == false. ... you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -q - Don't print informational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:11359,message,messages,11359,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['message'],['messages']
Integrability,"==. .. contents::; :local:. Description; ===========. LLVM features powerful intermodular optimizations which can be used at link; time. Link Time Optimization (LTO) is another name for intermodular; optimization when performed during the link stage. This document describes the; interface and design between the LTO optimizer and the linker. Design Philosophy; =================. The LLVM Link Time Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static int foo3() {; foo4();; return 10;; }. int foo1(void) {; int data = 0;. if (i < 0); data = foo3();. data = data + 42;; return data;; }. --- main.c ---; #include <std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:1113,integrat,integration,1113,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['integrat'],['integration']
Integrability,"===. .. contents::; :local:. Introduction; ============. TableGen backends are at the core of TableGen's functionality. The source; files provide the classes and records that are parsed and end up as a; collection of record instances, but it's up to the backend to interpret and; print the records in a way that is meaningful to the user (normally a C++; include file or a textual list of warnings, options, and error messages). TableGen is used by both LLVM, Clang, and MLIR with very different goals.; LLVM uses it as a way to automate the generation of massive amounts of; information regarding instructions, schedules, cores, and architecture; features. Some backends generate output that is consumed by more than one; source file, so they need to be created in a way that makes it is easy for; preprocessor tricks to be used. Some backends can also print C++ code; structures, so that they can be directly included as-is. Clang, on the other hand, uses it mainly for diagnostic messages (errors,; warnings, tips) and attributes, so more on the textual end of the scale. MLIR uses TableGen to define operations, operation dialects, and operation; traits. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen, and the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for a guide to writing a new backend. LLVM BackEnds; =============. .. warning::; This portion is incomplete. Each section below needs three subsections:; description of its purpose with a list of users, output generated from; generic input, and finally why it needed a new backend (in case there's; something similar). Overall, each backend will take the same TableGen file type and transform into; similar output for different targets/uses. There is an implicit contract between; the TableGen files, the back-ends and their users. For instance, a global contract is that each back-end produces macro-guarded; sections. Based on whether the file is included by a header or a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:1035,message,messages,1035,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['message'],['messages']
Integrability,"======; Building clang-objc-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-objc-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-objc-fuzzer. ======================; Running clang-objc-fuzzer; ======================; bin/clang-objc-fuzzer CORPUS_DIR. e.g. using the example objc corpus,. bin/clang-objc-fuzzer <path to corpus_examples/objc> <path to new directory to store corpus findings>. =======================================================; Building clang-proto-fuzzer (Linux-only instructions); =======================================================; Install the necessary dependencies:; - binutils // needed for libprotobuf-mutator; - liblzma-dev // needed for libprotobuf-mutator; - libz-dev // needed for libprotobuf-mutator; - docbook2x // needed for libprotobuf-mutator; - Recent version of protobuf [3.3.0 is known to work]. Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address; - CLANG_ENABLE_PROTO_FUZZER=ON. Then build the clang-proto-fuzzer and clang-proto-to-cxx targets. Optionally,; you may also build clang-fuzzer with this setup. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address \; -DCLANG_ENABLE_PROTO_FUZZER=ON; ninja clang-proto-fuzzer clang-proto-to-cxx. This directory also contains a Dockerfile which sets up all required; dependencies and builds the fuzzers. ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:2575,depend,dependencies,2575,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['depend'],['dependencies']
Integrability,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:338,interface,interface,338,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,2,['interface'],['interface']
Integrability,"========; 0 Generic; 1 Global; 2 Internal Use; 3 Shared; 4 Constant; 5 Local; ============= ======================. Every global variable and pointer type is assigned to one of these address; spaces, with 0 being the default address space. Intrinsics are provided which; can be used to convert pointers between the generic and non-generic address; spaces. As an example, the following IR will define an array ``@g`` that resides in; global device memory. .. code-block:: llvm. @g = internal addrspace(1) global [4 x i32] [ i32 0, i32 1, i32 2, i32 3 ]. LLVM IR functions can read and write to this array, and host-side code can; copy data to it by name with the CUDA Driver API. Note that since address space 0 is the generic space, it is illegal to have; global variables in address space 0. Address space 0 is the default address; space in LLVM, so the ``addrspace(N)`` annotation is *required* for global; variables. Triples; -------. The NVPTX target uses the module triple to select between 32/64-bit code; generation and the driver-compiler interface to use. The triple architecture; can be one of ``nvptx`` (32-bit PTX) or ``nvptx64`` (64-bit PTX). The; operating system should be one of ``cuda`` or ``nvcl``, which determines the; interface used by the generated code to communicate with the driver. Most; users will want to use ``cuda`` as the operating system, which makes the; generated PTX compatible with the CUDA Driver API. Example: 32-bit PTX for CUDA Driver API: ``nvptx-nvidia-cuda``. Example: 64-bit PTX for CUDA Driver API: ``nvptx64-nvidia-cuda``. .. _nvptx_intrinsics:. NVPTX Intrinsics; ================. Address Space Conversion; ------------------------. '``llvm.nvvm.ptr.*.to.gen``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". These are overloaded intrinsics. You can use these on any pointer types. .. code-block:: llvm. declare i8* @llvm.nvvm.ptr.global.to.gen.p0i8.p1i8(i8 addrspace(1)*); declare i8* @llvm.nvvm.ptr.shared.to.gen.p0i8.p3i8(i8 ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:3231,interface,interface,3231,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['interface'],['interface']
Integrability,"========; GWP-ASan; ========. .. contents::; :local:; :depth: 2. Introduction; ============. GWP-ASan is a sampled allocator framework that assists in finding use-after-free; and heap-buffer-overflow bugs in production environments. It informally is a; recursive acronym, ""**G**\WP-ASan **W**\ill **P**\rovide **A**\llocation; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:844,depend,depending,844,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['depend'],['depending']
Integrability,"=========; LibFormat; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:161,interface,interface,161,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,3,"['integrat', 'interface', 'rout']","['integrated', 'interface', 'routine']"
Integrability,"==========. Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit; the ``smstart`` and ``smstop`` instructions before register allocation, so that; the register allocator can spill/reload registers around the mode change. The compiler should also have sufficient information on which operations are; part of the call/function's arguments/result and which operations are part of; the function's body, so that it can place the mode changes in exactly the right; position. The suitable place to do this seems to be SelectionDAG, where it lowers; the call's arguments/return values to implement the specified calling convention.; SelectionDAG provides Chains and Glue to specify the order of operations and give; preliminary control over the instruction's scheduling. Example of preserving state; ---------------------------. When passing and returning a ``float`` value to/from a function; that has a streaming interface from a function that has a normal interface, the; call-site will need to ensure that the argument/result registers are preserved; and that no other code is scheduled in between the ``smstart/smstop`` and the call. .. code-block:: llvm. define float @foo(float %f) nounwind {; %res = call float @bar(float %f) ""aarch64_pstate_sm_enabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [sp, #64] // 8-byte Folded Spill; str s0, [sp, #76] // 4-byte Folded Spill; smstart sm; ldr s0, [sp, #76] // 4-byte Folded Reload; bl bar; str s0, [sp, #76] // 4-byte Folded Spill; smstop sm; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; ldp d11, d10, [sp, #32] // 16-byte Folded Re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:6496,interface,interface,6496,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,2,['interface'],['interface']
Integrability,"==========. First, you should pick a collector strategy. LLVM includes a number of built; in ones, but you can also implement a loadable plugin with a custom definition.; Note that the collector strategy is a description of how LLVM should generate; code such that it interacts with your collector and runtime, not a description; of the collector itself. Next, mark your generated functions as using your chosen collector strategy.; From c++, you can call:. .. code-block:: c++. F.setGC(<collector description name>);. This will produce IR like the following fragment:. .. code-block:: llvm. define void @foo() gc ""<collector description name>"" { ... }. When generating LLVM IR for your functions, you will need to:. * Use ``@llvm.gcread`` and/or ``@llvm.gcwrite`` in place of standard load and; store instructions. These intrinsics are used to represent load and store; barriers. If you collector does not require such barriers, you can skip; this step. * Use the memory allocation routines provided by your garbage collector's; runtime library. * If your collector requires them, generate type maps according to your; runtime's binary interface. LLVM is not involved in the process. In; particular, the LLVM type system is not suitable for conveying such; information though the compiler. * Insert any coordination code required for interacting with your collector.; Many collectors require running application code to periodically check a; flag and conditionally call a runtime function. This is often referred to; as a safepoint poll. You will need to identify roots (i.e. references to heap objects your collector; needs to know about) in your generated IR, so that LLVM can encode them into; your final stack maps. Depending on the collector strategy chosen, this is; accomplished by using either the ``@llvm.gcroot`` intrinsics or an; ``gc.statepoint`` relocation sequence. Don't forget to create a root for each intermediate value that is generated when; evaluating an expression. In ``h(f(),",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:1352,rout,routines,1352,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['rout'],['routines']
Integrability,"==========; ClangCheck; ==========. `ClangCheck` is a small wrapper around :doc:`LibTooling` which can be used to; do basic error checking and AST dumping. .. code-block:: console. $ cat <<EOF > snippet.cc; > void f() {; > int a = 0; > }; > EOF; $ ~/clang/build/bin/clang-check snippet.cc -ast-dump --; Processing: /Users/danieljasper/clang/llvm/tools/clang/docs/snippet.cc.; /Users/danieljasper/clang/llvm/tools/clang/docs/snippet.cc:2:12: error: expected ';' at end of; declaration; int a = 0; ^; ;; (TranslationUnitDecl 0x7ff3a3029ed0 <<invalid sloc>>; (TypedefDecl 0x7ff3a302a410 <<invalid sloc>> __int128_t '__int128'); (TypedefDecl 0x7ff3a302a470 <<invalid sloc>> __uint128_t 'unsigned __int128'); (TypedefDecl 0x7ff3a302a830 <<invalid sloc>> __builtin_va_list '__va_list_tag [1]'); (FunctionDecl 0x7ff3a302a8d0 </Users/danieljasper/clang/llvm/tools/clang/docs/snippet.cc:1:1, line:3:1> f 'void (void)'; (CompoundStmt 0x7ff3a302aa10 <line:1:10, line:3:1>; (DeclStmt 0x7ff3a302a9f8 <line:2:3, line:3:1>; (VarDecl 0x7ff3a302a980 <line:2:3, col:11> a 'int'; (IntegerLiteral 0x7ff3a302a9d8 <col:11> 'int' 0)))))); 1 error generated.; Error while processing snippet.cc. The '--' at the end is important as it prevents :program:`clang-check` from; searching for a compilation database. For more information on how to setup and; use :program:`clang-check` in a project, see :doc:`HowToSetupToolingForLLVM`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangCheck.rst:60,wrap,wrapper,60,interpreter/llvm-project/clang/docs/ClangCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangCheck.rst,1,['wrap'],['wrapper']
Integrability,"===========; ClangFormat; ===========. `ClangFormat` describes a set of tools that are built on top of; :doc:`LibFormat`. It can support your workflow in a variety of ways including a; standalone tool and editor integrations. Standalone Tool; ===============. :program:`clang-format` is located in `clang/tools/clang-format` and can be used; to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code. .. START_FORMAT_HELP. .. code-block:: console. $ clang-format --help; OVERVIEW: A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code. If no arguments are specified, it formats the code from standard input; and writes the result to the standard output.; If <file>s are given, it reformats the files. If -i is specified; together with <file>s, the files are edited in-place. Otherwise, the; result is written to the standard output. USAGE: clang-format [options] [@<file>] [<file> ...]. OPTIONS:. Clang-format options:. --Werror - If set, changes formatting warnings to errors; --Wno-error=<value> - If set don't error out on the specified warning type.; =unknown - If set, unknown format options are only warned about.; This can be used to enable formatting, even if the; configuration contains unknown (newer) options.; Use with caution, as this might lead to dramatically; differing format depending on an option being; supported or not.; --assume-filename=<string> - Set filename used to determine the language and to find; .clang-format file.; Only used when reading from stdin.; If this is not passed, the .clang-format file is searched; relative to the current working directory when reading stdin.; Unrecognized filenames are treated as C++.; supported:; CSharp: .cs; Java: .java; JavaScript: .mjs .js .ts; Json: .json; Objective-C: .m .mm; Proto: .proto .protodevel; TableGen: .td; TextProto: .textpb .pb.txt .textproto .asciipb; Verilog: .sv .svh .v .vh; --cursor=<uint> - The position of the cursor when invoking; clang-format from an editor integration; --dry-ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:212,integrat,integrations,212,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integrations']
Integrability,"============. Alias Analysis (aka Pointer Analysis) is a class of techniques which attempt to; determine whether or not two pointers ever can point to the same object in; memory. There are many different algorithms for alias analysis and many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1044,interface,interface,1044,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"============; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_HS_TESSFACTOR 2 \- \- \-; MSG_DEALLOC_VGPRS 3 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC). // sendmsg with validation of value range only; msg = 2; op = 3; s_sendmsg sendmsg(msg, op); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:2491,depend,depending,2491,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,4,"['depend', 'message']","['depending', 'message']"
Integrability,"===============. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber numberWithLong:42L]; NSNumber *fortyTwoLongLong = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:964,wrap,wrap,964,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['wrap'],['wrap']
Integrability,"===============; Support Library; ===============. Abstract; ========. This document provides some details on LLVM's Support Library, located in the; source at ``lib/Support`` and ``include/llvm/Support``. The library's purpose; is to shield LLVM from the differences between operating systems for the few; services LLVM needs from the operating system. Much of LLVM is written using; portability features of standard C++. However, in a few areas, system dependent; facilities are needed and the Support Library is the wrapper around those; system calls. By centralizing LLVM's use of operating system interfaces, we make it possible; for the LLVM tool chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:455,depend,dependent,455,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,4,"['depend', 'interface', 'wrap']","['dependent', 'interfaces', 'wrapper']"
Integrability,"===============; The LLVM gold plugin; ====================. Introduction; ============. Building with link time optimization requires cooperation from; the system linker. LTO support on Linux systems is available via the; `gold linker`_ which supports LTO via plugins. This is the same mechanism; used by the `GCC LTO`_ project. The LLVM gold plugin implements the gold plugin interface on top of; :ref:`libLTO`. The same plugin can also be used by other tools such as; ``ar`` and ``nm``. Note that ld.bfd from binutils version 2.21.51.0.2; and above also supports LTO via plugins. However, usage of the LLVM; gold plugin with ld.bfd is not tested and therefore not officially; supported or recommended. As of LLVM 15, the gold plugin will ignore bitcode from the ``.llvmbc``; section inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:1001,interface,interface,1001,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['interface'],['interface']
Integrability,"================ ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_HOST_TRAP_ACK 3 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst:2584,depend,depending,2584,interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx8_msg.rst,4,"['depend', 'message']","['depending', 'message']"
Integrability,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:451,integrat,integrates,451,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst,1,['integrat'],['integrates']
Integrability,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:871,message,messages,871,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['message'],['messages']
Integrability,"=================; TableGen BackEnds; =================. .. contents::; :local:. Introduction; ============. TableGen backends are at the core of TableGen's functionality. The source; files provide the classes and records that are parsed and end up as a; collection of record instances, but it's up to the backend to interpret and; print the records in a way that is meaningful to the user (normally a C++; include file or a textual list of warnings, options, and error messages). TableGen is used by both LLVM, Clang, and MLIR with very different goals.; LLVM uses it as a way to automate the generation of massive amounts of; information regarding instructions, schedules, cores, and architecture; features. Some backends generate output that is consumed by more than one; source file, so they need to be created in a way that makes it is easy for; preprocessor tricks to be used. Some backends can also print C++ code; structures, so that they can be directly included as-is. Clang, on the other hand, uses it mainly for diagnostic messages (errors,; warnings, tips) and attributes, so more on the textual end of the scale. MLIR uses TableGen to define operations, operation dialects, and operation; traits. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen, and the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for a guide to writing a new backend. LLVM BackEnds; =============. .. warning::; This portion is incomplete. Each section below needs three subsections:; description of its purpose with a list of users, output generated from; generic input, and finally why it needed a new backend (in case there's; something similar). Overall, each backend will take the same TableGen file type and transform into; similar output for different targets/uses. There is an implicit contract between; the TableGen files, the back-ends and their users. For instance, a global contract is that each back-end produces macro-guarded; sections. Bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:470,message,messages,470,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['message'],['messages']
Integrability,"====================; Clang Linker Wrapper; ====================. .. contents::; :local:. .. _clang-linker-wrapper:. Introduction; ============. This tool works as a wrapper of the normal host linking job. This tool is used; to create linked device images for offloading and the necessary runtime calls to; register them. It works by first scanning the linker's input for embedded device; offloading data stored at the ``.llvm.offloading`` section. This section; contains binary data created by the :doc:`ClangOffloadPackager`. The extracted; device files will then be linked. The linked modules will then be wrapped into a; new object file containing the code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:107,wrap,wrapper,107,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,6,['wrap'],"['wrapped', 'wrapper']"
Integrability,"====================; Standard C++ Modules; ====================. .. contents::; :local:. Introduction; ============. The term ``modules`` has a lot of meanings. For the users of Clang, modules may; refer to ``Objective-C Modules``, ``Clang C++ Modules`` (or ``Clang Header Modules``,; etc.) or ``Standard C++ Modules``. The implementation of all these kinds of modules in Clang; has a lot of shared code, but from the perspective of users, their semantics and; command line interfaces are very different. This document focuses on; an introduction of how to use standard C++ modules in Clang. There is already a detailed document about `Clang modules <Modules.html>`_, it; should be helpful to read `Clang modules <Modules.html>`_ if you want to know; more about the general idea of modules. Since standard C++ modules have different semantics; (and work flows) from `Clang modules`, this page describes the background and use of; Clang with standard C++ modules. Modules exist in two forms in the C++ Language Specification. They can refer to; either ""Named Modules"" or to ""Header Units"". This document covers both forms. Standard C++ Named modules; ==========================. This document was intended to be a manual first and foremost, however, we consider it helpful to; introduce some language background here for readers who are not familiar with; the new language feature. This document is not intended to be a language; tutorial; it will only introduce necessary concepts about the; structure and building of the project. Background and terminology; --------------------------. Modules; ~~~~~~~. In this document, the term ``Modules``/``modules`` refers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:475,interface,interfaces,475,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interfaces']
Integrability,"====================; The LLVM gold plugin; ====================. Introduction; ============. Building with link time optimization requires cooperation from; the system linker. LTO support on Linux systems is available via the; `gold linker`_ which supports LTO via plugins. This is the same mechanism; used by the `GCC LTO`_ project. The LLVM gold plugin implements the gold plugin interface on top of; :ref:`libLTO`. The same plugin can also be used by other tools such as; ``ar`` and ``nm``. Note that ld.bfd from binutils version 2.21.51.0.2; and above also supports LTO via plugins. However, usage of the LLVM; gold plugin with ld.bfd is not tested and therefore not officially; supported or recommended. As of LLVM 15, the gold plugin will ignore bitcode from the ``.llvmbc``; section inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:383,interface,interface,383,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['interface'],['interface']
Integrability,"====================; Writing an LLVM Pass; ====================. .. program:: opt. .. contents::; :local:. Introduction --- What is a pass?; ================================. The LLVM pass framework is an important part of the LLVM system, because LLVM; passes are where most of the interesting parts of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. Unlike passes under the legacy pass manager where the pass interface is; defined via inheritance, passes under the new pass manager rely on; concept-based polymorphism, meaning there is no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:607,interface,interface,607,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,2,['interface'],['interface']
Integrability,"=====================. Introduction; ------------. The Virtual Analysis Facility can be easily used by having installed on; your client the following software:. - [ROOT](http://root.cern.ch/). - [PROOF on Demand](http://pod.gsi.de/). - The VAF client *(see below)*: a convenience tool that sets up the; environment for your experiment's software both on your client and; on the PROOF worker nodes. > If you are the end user, you'll probably might skip the part that; > concerns how to configure the VAF client: your system administrator; > has probably and conveniently set it up for you. The Virtual Analysis Facility client; ------------------------------------. The Virtual Analysis Facility client takes care of setting the; environment for the end user required by your software's experiment. The; environment will both be set on the client and on each PROOF node. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot eve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:1144,depend,dependencies,1144,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['depend'],['dependencies']
Integrability,"=====================; Debugging JIT-ed Code; =====================. Background; ==========. Without special runtime support, debugging dynamically generated code can be; quite painful. Debuggers generally read debug information from object files on; disk, but for JITed code there is no such file to look for. In order to hand over the necessary debug info, `GDB established an; interface <https://sourceware.org/gdb/onlinedocs/gdb/JIT-Interface.html>`_; for registering JITed code with debuggers. LLDB implements it in the; JITLoaderGDB plugin. On the JIT side, LLVM MCJIT does implement the interface; for ELF object files. At a high level, whenever MCJIT generates new machine code, it does so in an; in-memory object file that contains the debug information in DWARF format.; MCJIT then adds this in-memory object file to a global list of dynamically; generated object files and calls a special function; ``__jit_debug_register_code`` that the debugger knows about. When the debugger; attaches to a process, it puts a breakpoint in this function and associates a; special handler with it. Once MCJIT calls the registration function, the; debugger catches the breakpoint signal, loads the new object file from the; inferior's memory and resumes execution. This way it can obtain debug; information for pure in-memory object files. GDB Version; ===========. In order to debug code JIT-ed by LLVM, you need GDB 7.0 or newer, which is; available on most modern distributions of Linux. The version of GDB that; Apple ships with Xcode has been frozen at 6.3 for a while. LLDB Version; ============. Due to a regression in release 6.0, LLDB didn't support JITed code debugging for; a while. The bug was fixed in mainline recently, so that debugging JITed ELF; objects should be possible again from the upcoming release 12.0 on. On macOS the; feature must be enabled explicitly using the ``plugin.jit-loader.gdb.enable``; setting. Debugging MCJIT-ed code; =======================. The emerging MCJIT comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst:380,interface,interface,380,interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,2,['interface'],['interface']
Integrability,"=====================; How To Use Attributes; =====================. .. contents::; :local:. Introduction; ============. Attributes in LLVM have changed in some fundamental ways. It was necessary to; do this to support expanding the attributes to encompass more than a handful of; attributes --- e.g. command line options. The old way of handling attributes; consisted of representing them as a bit mask of values. This bit mask was; stored in a ""list"" structure that was reference counted. The advantage of this; was that attributes could be manipulated with 'or's and 'and's. The; disadvantage of this was that there was limited room for expansion, and; virtually no support for attribute-value pairs other than alignment. In the new scheme, an ``Attribute`` object represents a single attribute that's; uniqued. You use the ``Attribute::get`` methods to create a new ``Attribute``; object. An attribute can be a single ""enum"" value (the enum being the; ``Attribute::AttrKind`` enum), a string representing a target-dependent; attribute, or an attribute-value pair. Some examples:. * Target-independent: ``noinline``, ``zext``; * Target-dependent: ``""no-sse""``, ``""thumb2""``; * Attribute-value pair: ``""cpu"" = ""cortex-a8""``, ``align = 4``. Note: for an attribute value pair, we expect a target-dependent attribute to; have a string for the value. ``Attribute``; =============; An ``Attribute`` object is designed to be passed around by value. Because attributes are no longer represented as a bit mask, you will need to; convert any code which does treat them as a bit mask to use the new query; methods on the Attribute class. ``AttributeList``; =================. The ``AttributeList`` stores a collection of Attribute objects for each kind of; object that may have an attribute associated with it: the function as a whole,; the return type, or the function's parameters. A function's attributes are at; index ``AttributeList::FunctionIndex``; the return type's attributes are at; index ``Attribut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst:1018,depend,dependent,1018,interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,1,['depend'],['dependent']
Integrability,"======================. .. role:: raw-html(raw); :format: html. .. raw:: html. <style>; .unknown { background-color: #C0C0C0; text-align: center; }; .unknown:before { content: ""?"" }; .no { background-color: #C11B17 }; .no:before { content: ""N"" }; .partial { background-color: #F88017 }; .yes { background-color: #0F0; }; .yes:before { content: ""Y"" }; .na { background-color: #6666FF; }; .na:before { content: ""N/A"" }; </style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:1062,interface,interfaces,1062,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability,"======================; Clang Offload Packager; ======================. .. contents::; :local:. .. _clang-offload-packager:. Introduction; ============. This tool bundles device files into a single image containing necessary; metadata. We use a custom binary format for bundling all the device images; together. The image format is a small header wrapping around a string map. This; tool creates bundled binaries so that they can be embedded into the host to; create a fat-binary. Binary Format; =============. The binary format is marked by the ``0x10FF10AD`` magic bytes, followed by a; version. Each created binary contains its own magic bytes. This allows us to; locate all the embedded offloading sections even after they may have been merged; by the linker, such as when using relocatable linking. Conceptually, this binary; format is a serialization of a string map and an image buffer. The binary header; is described in the following :ref:`table<table-binary_header>`. .. table:: Offloading Binary Header; :name: table-binary_header. +----------+--------------+----------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+====================================================+; | uint8_t | magic | The magic bytes for the binary format (0x10FF10AD) |; +----------+--------------+----------------------------------------------------+; | uint32_t | version | Version of this format (currently version 1) |; +----------+--------------+----------------------------------------------------+; | uint64_t | size | Size of this binary in bytes |; +----------+--------------+----------------------------------------------------+; | uint64_t | entry offset | Absolute offset of the offload entries in bytes |; +----------+--------------+----------------------------------------------------+; | uint64_t | entry size | Size of the offload entries in bytes |; +----------+--------------+----------------------------------------------------+. Once ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:347,wrap,wrapping,347,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['wrap'],['wrapping']
Integrability,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:821,interface,interface,821,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['interface'],['interface']
Integrability,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:383,integrat,integrate,383,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['integrat'],['integrate']
Integrability,"========================. > This document is meant for ROOT developers. It provides background information on the RNTuple code design and behavior. > The RNTuple code uses the nomenclature from the [RNTuple format specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/BinaryFormatSpecification.md) (e.g. ""field"", ""column"", ""anchor"", etc.). General Principles; ------------------. The RNTuple classes provide the functionality to read, write, and describe RNTuple datasets.; The core classes, such as `RNTupleReader` and `RNTupleWriter`, are part of the RNTuple library.; Additional tools, such as the `RNTupleImporter` and the `RNTupleInspector`, are part of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:1027,interface,interfaces,1027,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interfaces']
Integrability,"========================; LLVM Programmer's Manual; ========================. .. contents::; :local:. .. warning::; This is always a work in progress. .. _introduction:. Introduction; ============. This document is meant to highlight some of the important classes and interfaces; available in the LLVM source-base. This manual is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:268,interface,interfaces,268,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interfaces']
Integrability,"=========================; Clang Language Extensions; =========================. .. contents::; :local:; :depth: 1. .. toctree::; :hidden:. ObjectiveCLiterals; BlockLanguageSpec; Block-ABI-Apple; AutomaticReferenceCounting; MatrixTypes. Introduction; ============. This document describes the language extensions provided by Clang. In addition; to the language extensions listed here, Clang aims to support a broad range of; GCC extensions. Please see the `GCC manual; <https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:716,depend,depend,716,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depend']
Integrability,"=========================; Dependence Graphs in LLVM; =========================. .. contents::; :local:. Introduction; ============; Dependence graphs are useful tools in compilers for analyzing relationships; between various program elements to help guide optimizations. The ideas; behind these graphs are described in papers [1]_ and [2]_. The implementation of these ideas in LLVM may be slightly different than; what is mentioned in the papers. These differences are documented in; the `implementation details <implementation-details_>`_. .. _DataDependenceGraph:. Data Dependence Graph; =====================; In its simplest form the Data Dependence Graph (or DDG) represents data; dependencies between individual instructions. Each node in such a graph; represents a single instruction and is referred to as an ""atomic"" node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:688,depend,dependencies,688,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,2,['depend'],"['dependencies', 'dependency']"
Integrability,"=========================; Driver Design & Internals; =========================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver. The purpose of this document; is to describe both the motivation and design goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:509,interface,interface,509,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['interface'],['interface']
Integrability,"==========================; Symbolizer Markup Format; ==========================. .. contents::; :local:. Overview; ========. This document defines a text format for log messages that can be processed by a; symbolizing filter. The basic idea is that logging code emits text that contains; raw address values and so forth, without the logging code doing any real work to; convert those values to human-readable form. Instead, logging text uses the; markup format defined here to identify pieces of information that should be; converted to human-readable form after the fact. As with other markup formats,; the expectation is that most of the text will be displayed as is, while the; markup elements will be replaced with expanded text, or converted into active UI; elements, that present more details in symbolic form. This means there is no need for symbol tables, DWARF debugging sections, or; similar information to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:170,message,messages,170,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['message'],['messages']
Integrability,"=========================== ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Must be 0. 0; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_HS_TESSFACTOR 2 \- \- \-; MSG_DEALLOC_VGPRS 3 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst:1292,message,message,1292,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_msg_e37f7b.rst,1,['message'],['message']
Integrability,"===========================; Install the necessary dependencies:; - binutils // needed for libprotobuf-mutator; - liblzma-dev // needed for libprotobuf-mutator; - libz-dev // needed for libprotobuf-mutator; - docbook2x // needed for libprotobuf-mutator; - Recent version of protobuf [3.3.0 is known to work]. Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address; - CLANG_ENABLE_PROTO_FUZZER=ON. Then build the clang-proto-fuzzer and clang-proto-to-cxx targets. Optionally,; you may also build clang-fuzzer with this setup. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address \; -DCLANG_ENABLE_PROTO_FUZZER=ON; ninja clang-proto-fuzzer clang-proto-to-cxx. This directory also contains a Dockerfile which sets up all required; dependencies and builds the fuzzers. ============================; Running clang-proto-fuzzer; ============================; bin/clang-proto-fuzzer CORPUS_DIR. Arguments can be specified after -ignore_remaining_args=1 to modify the compiler; invocation. For example, the following command line will fuzz LLVM with a; custom optimization level and target triple:; bin/clang-proto-fuzzer CORPUS_DIR -ignore_remaining_args=1 -O3 -triple \; arm64apple-ios9. To translate a clang-proto-fuzzer corpus output to C++:; bin/clang-proto-to-cxx CORPUS_OUTPUT_FILE. ===================; llvm-proto-fuzzer; ===================; Like, clang-proto-fuzzer, llvm-proto-fuzzer is also a protobuf-mutator based; fuzzer. It receives as input a cxx_loop_proto which it then converts into a; string of valid LLVM IR: a function with either a single loop or two nested; loops. It then creates a new string of IR by running optimization passes over; the original IR. Currently, it only runs a loop-vectorize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:3542,depend,dependencies,3542,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['depend'],['dependencies']
Integrability,"===========================; LLVM Branch Weight Metadata; ===========================. .. contents::; :local:. Introduction; ============. Branch Weight Metadata represents branch weights as its likeliness to be taken; (see :doc:`BlockFrequencyTerminology`). Metadata is assigned to an; ``Instruction`` that is a terminator as a ``MDNode`` of the ``MD_prof`` kind.; The first operator is always a ``MDString`` node with the string; ""branch_weights"". Number of operators depends on the terminator type. Branch weights might be fetch from the profiling file, or generated based on; `__builtin_expect`_ and `__builtin_expect_with_probability`_ instruction. All weights are represented as an unsigned 32-bit values, where higher value; indicates greater chance to be taken. Supported Instructions; ======================. ``BranchInst``; ^^^^^^^^^^^^^^. Metadata is only assigned to the conditional branches. There are two extra; operands for the true and the false branch. .. code-block:: none. !0 = !{; !""branch_weights"",; i32 <TRUE_BRANCH_WEIGHT>,; i32 <FALSE_BRANCH_WEIGHT>; }. ``SwitchInst``; ^^^^^^^^^^^^^^. Branch weights are assigned to every case (including the ``default`` case which; is always case #0). .. code-block:: none. !0 = !{; !""branch_weights"",; i32 <DEFAULT_BRANCH_WEIGHT>; [ , i32 <CASE_BRANCH_WEIGHT> ... ]; }. ``IndirectBrInst``; ^^^^^^^^^^^^^^^^^^. Branch weights are assigned to every destination. .. code-block:: none. !0 = !{; !""branch_weights"",; i32 <LABEL_BRANCH_WEIGHT>; [ , i32 <LABEL_BRANCH_WEIGHT> ... ]; }. ``CallInst``; ^^^^^^^^^^^^^^^^^^. Calls may have branch weight metadata, containing the execution count of; the call. It is currently used in SamplePGO mode only, to augment the; block and entry counts which may not be accurate with sampling. .. code-block:: none. !0 = !{; !""branch_weights"",; i32 <CALL_BRANCH_WEIGHT>; }. ``InvokeInst``; ^^^^^^^^^^^^^^^^^^. Invoke instruction may have branch weight metadata with one or two weights.; The second weight is option",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst:470,depend,depends,470,interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BranchWeightMetadata.rst,1,['depend'],['depends']
Integrability,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:598,interface,interface,598,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['interface'],['interface']
Integrability,"============================= ===============; Bits Description Value Range; ============ =============================== ===============; 3:0 Message *type*. 0..15; 6:4 Optional *operation*. 0..7; 7:7 Unused. \-; 9:8 Optional *stream*. 0..3; 15:10 Unused. \-; ============ =============================== ===============. This operand may be specified as one of the following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A *sendmsg* value which is described below. ==================================== ====================================================; Sendmsg Value Syntax Description; ==================================== ====================================================; sendmsg(<*type*>) A message identified by its *type*.; sendmsg(<*type*>,<*op*>) A message identified by its *type* and *operation*.; sendmsg(<*type*>,<*op*>,<*stream*>) A message identified by its *type* and *operation*; with a stream *id*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst:1285,message,message,1285,interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx1030_msg.rst,7,['message'],['message']
Integrability,"============================= ====================== ====================. .. _amdgpu_synid_expression:. Expressions; ===========. An expression is evaluated to a 64-bit integer.; Note that floating-point expressions are not supported. There are two kinds of expressions:. * :ref:`Absolute<amdgpu_synid_absolute_expression>`.; * :ref:`Relocatable<amdgpu_synid_relocatable_expression>`. .. _amdgpu_synid_absolute_expression:. Absolute Expressions; --------------------. The value of an absolute expression does not change after program relocation.; Absolute expressions must not include unassigned and relocatable values; such as labels. Absolute expressions are evaluated to 64-bit integer values and converted to; :ref:`expected operand type<amdgpu_syn_instruction_type>`; as described :ref:`here<amdgpu_synid_int_conv>`. Examples:. .. parsed-literal::. x = -1; y = x + 10. .. _amdgpu_synid_relocatable_expression:. Relocatable Expressions; -----------------------. The value of a relocatable expression depends on program relocation. Note that use of relocatable expressions is limited to branch targets; and 32-bit integer operands. A relocatable expression is evaluated to a 64-bit integer value,; which depends on operand kind and; :ref:`relocation type<amdgpu-relocation-records>` of symbol(s); used in the expression. For example, if an instruction refers to a label,; this reference is evaluated to an offset from the address after; the instruction to the label address:. .. parsed-literal::. label:; v_add_co_u32_e32 v0, vcc, label, v1 // 'label' operand is evaluated to -4. Note that values of relocatable expressions are usually unknown; at assembly time; they are resolved later by a linker and converted to; :ref:`expected operand type<amdgpu_syn_instruction_type>`; as described :ref:`here<amdgpu_synid_rl_conv>`. Operands and Operations; -----------------------. Expressions are composed of 64-bit integer operands and operations.; Operands include :ref:`integer numbers<amdgpu_synid_in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:29788,depend,depends,29788,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['depend'],['depends']
Integrability,"=============================; LLVM Community Support Policy; =============================. As a compilation infrastructure, LLVM has multiple types of users, both; downstream and upstream, of many combinations of its projects, tools and; libraries. There is a core part of it that encompass the implementation of the compiler; (front/middle/back ends), run-time libraries (RT, C++, OpenMP, etc) and; associated tools (debugger, linker, object file manipulation, etc). These; components are present in the public release on our supported architectures; and operating systems and the whole community must maintain and care about. There are, however, other components within the main repository that either; cater to a specific sub-community of LLVM (upstream or downstream) or; help parts of the community to integrate LLVM into their own development tools; or external projects. Those parts of the main repository don't always have; rigorous testing like the core parts, nor are they validated and shipped with; our public upstream releases. Even not being a core part of the project, we have enough sub-communities; needing those changes with enough overlap that having them in the main; repository is beneficial to minimise the repetition of those changes in all; the external repositories that need them. But the maintenance costs of such diverse ecosystem is non trivial, so we divide; the level of support in two tiers: core and peripheral, with two; different levels of impact and responsibilities. Those tiers refer only to the; main repository (``llvm-project``) and not the other repositories in our git; project, unless explicitly stated. Regardless of the tier, all code must follow the existing policies on quality,; reviews, style, etc. Core Tier; =========. The core tier encompasses all of the code in the main repository that is; in production, is actively tested and released in a regular schedule, including; core LLVM APIs and infrastructure, front/middle/back-ends, run-time libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:809,integrat,integrate,809,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['integrat'],['integrate']
Integrability,"=============================; User Guide for RISC-V Target; =============================. .. contents::; :local:. Introduction; ============. The RISC-V target provides code generation for processors implementing; supported variations of the RISC-V specification. It lives in the; ``llvm/lib/Target/RISCV`` directory. Specification Documents; =======================. There have been a number of revisions to the RISC-V specifications. LLVM aims; to implement the most recent ratified version of the standard RISC-V base ISAs; and ISA extensions with pragmatic variances. The most recent specification can; be found at: https://github.com/riscv/riscv-isa-manual/releases/. `The official RISC-V International specification page; <https://riscv.org/technical/specifications/>`_. is also worth checking, but; tends to significantly lag the specifications linked above. Make sure to check; the `wiki for not yet integrated extensions; <https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions>`_ and note; that in addition, we sometimes carry support for extensions that have not yet; been ratified (these will be marked as experimental - see below) and support; various vendor-specific extensions (see below). The current known variances from the specification are:. * Unconditionally allowing instructions from zifencei, zicsr, zicntr, and; zihpm without gating them on the extensions being enabled. Previous; revisions of the specification included these instructions in the base; ISA, and we preserve this behavior to avoid breaking existing code. If; a future revision of the specification reuses these opcodes for other; extensions, we may need to reevaluate this choice, and thus recommend; users migrate build systems so as not to rely on this.; * Allowing CSRs to be named without gating on specific extensions. This; applies to all CSR names, not just those in zicsr, zicntr, and zihpm.; * The ordering of ``z*``, ``s*``, and ``x*`` prefixed extension names is not; enforced in user-sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:910,integrat,integrated,910,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['integrat'],['integrated']
Integrability,"==============================; Convergent Operation Semantics; ==============================. .. contents::; :local:; :depth: 4. Overview; ========. Some parallel execution environments execute threads in groups that allow; efficient communication within the group using special primitives called; *convergent* operations. The outcome of a convergent operation is sensitive to; the set of threads that executes it ""together"", i.e., convergently. When control; flow :ref:`diverges <convergence-and-uniformity>`, i.e. threads of the same; group follow different; paths through the CFG, not all threads of the group may be available to; participate in this communication. This is the defining characteristic that; distinguishes convergent operations from other inter-thread communication:. A convergent operation involves inter-thread communication or synchronization; that occurs outside of the memory model, where the set of threads which; participate in communication is implicitly affected by control flow. For example, in the following GPU compute kernel, communication during the; convergent operation is expected to occur precisely among those threads of an; implementation-defined execution scope (such as workgroup or subgroup) for; which ``condition`` is true:. .. code-block:: c++. void example_kernel() {; ...; if (condition); convergent_operation();; ...; }. In structured programming languages, there is often an intuitive and; unambiguous way of determining the threads that are expected to communicate.; However, this is not always the case even in structured programming languages,; and the intuition breaks down entirely in unstructured control flow. This; document describes the formal semantics in LLVM, i.e. how to determine the set; of communicating threads for convergent operations. The definitions in this document leave many details open, such as how groups of; threads are formed in the first place. It focuses on the questions that are; relevant for deciding the correctness",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:851,synchroniz,synchronization,851,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['synchroniz'],['synchronization']
Integrability,"===============================; lit - A Software Testing Tool; ===============================. About; =====. *lit* is a portable tool for executing LLVM and Clang style test suites,; summarizing their results, and providing indication of failures. *lit* is; designed to be a lightweight testing tool with as simple a user interface as; possible. Features; ========. * Portable!; * Flexible test discovery.; * Parallel test execution.; * Support for multiple test formats and test suite designs. Documentation; =============. The official *lit* documentation is in the man page, available online at the LLVM; Command Guide: http://llvm.org/cmds/lit.html. Source; ======. The *lit* source is available as part of LLVM, in the LLVM source repository:; https://github.com/llvm/llvm-project/tree/main/llvm/utils/lit. Contributing to lit; ===================. Please browse the issues labeled *tools:llvm-lit* in LLVM's issue tracker for; ideas on what to work on:; https://github.com/llvm/llvm-project/labels/tools%3Allvm-lit. Before submitting patches, run the test suite to ensure nothing has regressed::. # From within your LLVM source directory.; utils/lit/lit.py \; --path /path/to/your/llvm/build/bin \; utils/lit/tests. Note that lit's tests depend on ``not`` and ``FileCheck``, LLVM utilities.; You will need to have built LLVM tools in order to run lit's test suite; successfully. You'll also want to confirm that lit continues to work when testing LLVM.; Follow the instructions in http://llvm.org/docs/TestingGuide.html to run the; regression test suite:. make check-llvm. And be sure to run the llvm-lit wrapper script as well:. /path/to/your/llvm/build/bin/llvm-lit utils/lit/tests. Finally, make sure lit works when installed via setuptools:. python utils/lit/setup.py install; lit --path /path/to/your/llvm/build/bin utils/lit/tests. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst:324,interface,interface,324,interpreter/llvm-project/llvm/utils/lit/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst,3,"['depend', 'interface', 'wrap']","['depend', 'interface', 'wrapper']"
Integrability,"================================; LLVM Tutorial: Table of Contents; ================================. Kaleidoscope: Implementing a Language with LLVM; ===============================================. .. toctree::; :hidden:. MyFirstLanguageFrontend/index. :doc:`MyFirstLanguageFrontend/index`; This is the ""Kaleidoscope"" Language tutorial, showing how to implement a simple; language using LLVM components in C++. .. toctree::; :titlesonly:; :glob:; :numbered:. MyFirstLanguageFrontend/LangImpl*. Building a JIT in LLVM; ===============================================. .. toctree::; :titlesonly:; :glob:; :numbered:. BuildingAJIT*. External Tutorials; ==================. `Tutorial: Creating an LLVM Backend for the Cpu0 Architecture <http://jonathan2251.github.io/lbd/>`_; A step-by-step tutorial for developing an LLVM backend. Under; active development at `<https://github.com/Jonathan2251/lbd>`_ (please; contribute!). `Howto: Implementing LLVM Integrated Assembler`_; A simple guide for how to implement an LLVM integrated assembler for an; architecture. .. _`Howto: Implementing LLVM Integrated Assembler`: http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html. Advanced Topics; ===============. #. `Writing an Optimization for LLVM <https://llvm.org/pubs/2004-09-22-LCPCLLVMTutorial.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst:1017,integrat,integrated,1017,interpreter/llvm-project/llvm/docs/tutorial/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst,1,['integrat'],['integrated']
Integrability,"=================================; User Guide for the DirectX Target; =================================. .. warning::; Disclaimer: The DirectX backend is experimental and under active development.; It is not yet feature complete or ready to be used outside of experimental or; demonstration contexts. .. contents::; :local:. .. toctree::; :hidden:. Introduction; ============. The DirectX target implements the DirectX programmability interfaces. These; interfaces are documented in the `DirectX Specifications. <https://github.com/Microsoft/DirectX-Specs>`_. Initially the backend is aimed at supporting DirectX 12, and support for DirectX; 11 is planned at a later date. The DirectX backend is currently experimental and is not shipped with any; release builds of LLVM tools. To enable building the DirectX backend locally add; ``DirectX`` to the ``LLVM_EXPERIMENTAL_TARGETS_TO_BUILD`` CMake option. For more; information on building LLVM see the :doc:`CMake` documentation. .. _dx-target-triples:. Target Triples; ==============. At present the DirectX target only supports the ``dxil`` architecture, which; generates code for the; `DirectX Intermediate Language. <https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst>`_. In addition to target architecture, the DirectX backend also needs to know the; target runtime version and pipeline stage. These are expressed using the OS and; Environment triple component. Presently the DirectX backend requires targeting the ``shadermodel`` OS, and; supports versions 6.0+ (at time of writing the latest announced version is 6.7). .. table:: DirectX Environments. ================== ========================================================; Environment Description; ================== ========================================================; ``pixel`` Pixel shader; ``vertex`` Vertex shader; ``geometry`` Geometry shader; ``hull`` Hull shader (tesselation); ``domain`` Domain shader (tesselation); ``compute`` Compute kernel; ``librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DirectXUsage.rst:435,interface,interfaces,435,interpreter/llvm-project/llvm/docs/DirectXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DirectXUsage.rst,2,['interface'],['interfaces']
Integrability,"==================================; Benchmarking tips; ==================================. Introduction; ============. For benchmarking a patch we want to reduce all possible sources of; noise as much as possible. How to do that is very OS dependent. Note that low noise is required, but not sufficient. It does not; exclude measurement bias. See; https://www.cis.upenn.edu/~cis501/papers/producing-wrong-data.pdf for; example. General; ================================. * Use a high resolution timer, e.g. perf under linux. * Run the benchmark multiple times to be able to recognize noise. * Disable as many processes or services as possible on the target system. * Disable frequency scaling, turbo boost and address space; randomization (see OS specific section). * Static link if the OS supports it. That avoids any variation that; might be introduced by loading dynamic libraries. This can be done; by passing ``-DLLVM_BUILD_STATIC=ON`` to cmake. * Try to avoid storage. On some systems you can use tmpfs. Putting the; program, inputs and outputs on tmpfs avoids touching a real storage; system, which can have a pretty big variability. To mount it (on linux and freebsd at least)::. mount -t tmpfs -o size=<XX>g none dir_to_mount. Linux; =====. * Disable address space randomization::. echo 0 > /proc/sys/kernel/randomize_va_space. * Set scaling_governor to performance::. for i in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do; echo performance > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; done. * Use https://github.com/lpechacek/cpuset to reserve cpus for just the; program you are benchmarking. If using perf, leave at least 2 cores; so that perf runs in one and your program in another::. cset shield -c N1,N2 -k on. This will move all threads out of N1 and N2. The ``-k on`` means; that even kernel threads are moved out. * Disable the SMT pair of the cpus you will use for the benchmark. The; pair of cpu N can be found in; ``/sys/devices/system/cpu/cpuN/topology/t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Benchmarking.rst:240,depend,dependent,240,interpreter/llvm-project/llvm/docs/Benchmarking.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Benchmarking.rst,1,['depend'],['dependent']
Integrability,"==================================; LLVM Alias Analysis Infrastructure; ==================================. .. contents::; :local:. Introduction; ============. Alias Analysis (aka Pointer Analysis) is a class of techniques which attempt to; determine whether or not two pointers ever can point to the same object in; memory. There are many different algorithms for alias analysis and many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:934,interface,interface,934,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"=====================================. This document describes a format for specifying how to replay single; compilations independently of the build system. Background; ==========. Tools based on the C++ Abstract Syntax Tree need full information how to; parse a translation unit. Usually this information is implicitly; available in the build system, but running tools as part of the build; system is not necessarily the best solution:. - Build systems are inherently change driven, so running multiple tools; over the same code base without changing the code does not fit into; the architecture of many build systems.; - Figuring out whether things have changed is often an IO bound; process; this makes it hard to build low latency end user tools based; on the build system.; - Build systems are inherently sequential in the build graph, for; example due to generated source code. While tools that run; independently of the build still need the generated source code to; exist, running tools multiple times over unchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise resistant to Bear and other compiler-intercept; techniques. Clang's tooling interface supports reading c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:1205,depend,dependency,1205,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['depend'],['dependency']
Integrability,"=====================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:10534,interface,interface,10534,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"=====================================; Cross Translation Unit (CTU) Analysis; =====================================. Normally, static analysis works in the boundary of one translation unit (TU).; However, with additional steps and configuration we can enable the analysis to inline the definition of a function from; another TU. .. contents::; :local:. Overview; ________; CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH; files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static; analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options; of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This; process can be automated by other tools, like `CodeChecker <https://github.com/Ericsson/codechecker>`_ and scan-build-py; (preference for the former). PCH-based analysis; __________________; The analysis needs the PCH dumps of all the translations units used in the project.; These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.; The index, which maps symbols' USR names to PCH dumps containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index *must* have an `.ast` suffix if the goal; is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.; This tool uses a :doc:`compilation database <../../JSONCompilationDatabase>` to; determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the dumps and the mapping files. Manual CTU Analysis; ###################; Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:788,depend,dependencies,788,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['depend'],['dependencies']
Integrability,"=====================================; Garbage Collection with LLVM; =====================================. .. contents::; :local:. Abstract; ========. This document covers how to integrate LLVM into a compiler for a language which; supports garbage collection. **Note that LLVM itself does not provide a; garbage collector.** You must provide your own. Quick Start; ============. First, you should pick a collector strategy. LLVM includes a number of built; in ones, but you can also implement a loadable plugin with a custom definition.; Note that the collector strategy is a description of how LLVM should generate; code such that it interacts with your collector and runtime, not a description; of the collector itself. Next, mark your generated functions as using your chosen collector strategy.; From c++, you can call:. .. code-block:: c++. F.setGC(<collector description name>);. This will produce IR like the following fragment:. .. code-block:: llvm. define void @foo() gc ""<collector description name>"" { ... }. When generating LLVM IR for your functions, you will need to:. * Use ``@llvm.gcread`` and/or ``@llvm.gcwrite`` in place of standard load and; store instructions. These intrinsics are used to represent load and store; barriers. If you collector does not require such barriers, you can skip; this step. * Use the memory allocation routines provided by your garbage collector's; runtime library. * If your collector requires them, generate type maps according to your; runtime's binary interface. LLVM is not involved in the process. In; particular, the LLVM type system is not suitable for conveying such; information though the compiler. * Insert any coordination code required for interacting with your collector.; Many collectors require running application code to periodically check a; flag and conditionally call a runtime function. This is often referred to; as a safepoint poll. You will need to identify roots (i.e. references to heap objects your collector; needs to kno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:180,integrat,integrate,180,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['integrat'],['integrate']
Integrability,"=======================================. Reading an object with RNTuple should be seen as _overwriting_ its persistent data members.; Given a properly constructed and valid object, the object must ensure that it stays valid when overwriting its persistent data members.; However, the object should not rely on its transient state to remain unchanged during reading:; it may be destructed and constructed again when it is read as part of a collection (see below). An object that is being read from disk may have been constructed by `RField::CreateValue()`.; In this case, the deleter returned by `RField::GetDeleter()` releases the resources. When reading collections of type `T` (`std::vector<T>`, `ROOT::RVec<T>`, ...), RNTuple uses `RField::CreateValue()` to construct elements of the inner type `T`.; As the size of a collection changes from event to event, this has the following effect on its elements; - If the collection shrinks, cut-off elements are destructed; - If the collection grows, new elements are constructed before reading them; - If the array buffer of the collection is reallocated (may happen for both shrinking and growing depending on the collection), all elements are destructed first in the old buffer; and the new number of elements is constructed in the new buffer. So unless the collection buffer needs to be reallocated, RNTuple tries to avoid unnecessary destruction/construction but instead overwrites existing objects.; Note that RNTuple currently does not copy or move existing objects when the collection buffer is reallocated. Naming Conventions; ==================. For byte arrays and collections of things, the RNTuple code uses the following variable name suffixes:; - `XyzSize` denotes the size of Xyz in bytes on disk, i.e. after compression. Example: `fPageListSize`.; - `XyzLength` denotes the size of Xyz in bytes in memory, i.e. uncompressed. Example: `fPageListLength`.; - `NXyz` denotes the number of Xyz items in a collection. Example: `fNPageLists`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:31203,depend,depending,31203,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['depend'],['depending']
Integrability,"=============================================; SYCL Compiler and Runtime architecture design; =============================================. .. contents::; :local:. Introduction; ============. This document describes the architecture of the SYCL compiler and runtime; library. More details are provided in; `external document <https://github.com/intel/llvm/blob/sycl/sycl/doc/design/CompilerAndRuntimeDesign.md>`_\ ,; which are going to be added to clang documentation in the future. Address space handling; ======================. The SYCL specification represents pointers to disjoint memory regions using C++; wrapper classes on an accelerator to enable compilation with a standard C++; toolchain and a SYCL compiler toolchain. Section 3.8.2 of SYCL 2020; specification defines; `memory model <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_sycl_device_memory_model>`_\ ,; section 4.7.7 - `address space classes <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_classes>`_; and section 5.9 covers `address space deduction <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_deduction>`_.; The SYCL specification allows two modes of address space deduction: ""generic as; default address space"" (see section 5.9.3) and ""inferred address space"" (see; section 5.9.4). Current implementation supports only ""generic as default address; space"" mode. SYCL borrows its memory model from OpenCL however SYCL doesn't perform; the address space qualifier inference as detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:613,wrap,wrapper,613,interpreter/llvm-project/clang/docs/SYCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst,1,['wrap'],['wrapper']
Integrability,"==============================================; Control Flow Verification Tool Design Document; ==============================================. .. contents::; :local:. Objective; =========. This document provides an overview of an external tool to verify the protection; mechanisms implemented by Clang's *Control Flow Integrity* (CFI) schemes; (``-fsanitize=cfi``). This tool, provided a binary or DSO, should infer whether; indirect control flow operations are protected by CFI, and should output these; results in a human-readable form. This tool should also be added as part of Clang's continuous integration testing; framework, where modifications to the compiler ensure that CFI protection; schemes are still present in the final binary. Location; ========. This tool will be present as a part of the LLVM toolchain, and will reside in; the ""/llvm/tools/llvm-cfi-verify"" directory, relative to the LLVM trunk. It will; be tested in two methods:. - Unit tests to validate code sections, present in; ""/llvm/unittests/tools/llvm-cfi-verify"".; - Integration tests, present in ""/llvm/tools/clang/test/LLVMCFIVerify"". These; integration tests are part of clang as part of a continuous integration; framework, ensuring updates to the compiler that reduce CFI coverage on; indirect control flow instructions are identified. Background; ==========. This tool will continuously validate that CFI directives are properly; implemented around all indirect control flows by analysing the output machine; code. The analysis of machine code is important as it ensures that any bugs; present in linker or compiler do not subvert CFI protections in the final; shipped binary. Unprotected indirect control flow instructions will be flagged for manual; review. These unexpected control flows may simply have not been accounted for in; the compiler implementation of CFI (e.g. indirect jumps to facilitate switch; statements may not be fully protected). It may be possible in the future to extend this tool to flag u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst:601,integrat,integration,601,interpreter/llvm-project/llvm/docs/CFIVerify.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst,1,['integrat'],['integration']
Integrability,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:486,interface,interface,486,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,5,['interface'],"['interface', 'interfaces']"
Integrability,"=====================================================; Kaleidoscope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:700,interface,interface,700,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['interface'],['interface']
Integrability,"======================================================; LLVM Link Time Optimization: Design and Implementation; ======================================================. .. contents::; :local:. Description; ===========. LLVM features powerful intermodular optimizations which can be used at link; time. Link Time Optimization (LTO) is another name for intermodular; optimization when performed during the link stage. This document describes the; interface and design between the LTO optimizer and the linker. Design Philosophy; =================. The LLVM Link Time Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:444,interface,interface,444,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:577,interface,interface,577,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,2,['interface'],['interface']
Integrability,"===================================================================; How to Cross Compile Compiler-rt Builtins For Arm; ===================================================================. Introduction; ============. This document contains information about building and testing the builtins part; of compiler-rt for an Arm target, from an x86_64 Linux machine. While this document concentrates on Arm and Linux the general principles should; apply to other targets supported by compiler-rt. Further contributions for other; targets are welcome. The instructions in this document depend on libraries and programs external to; LLVM, there are many ways to install and configure these dependencies so you; may need to adapt the instructions here to fit your own local situation. Prerequisites; =============. In this use case we'll be using cmake on a Debian-based Linux system,; cross-compiling from an x86_64 host to a hard-float Armv7-A target. We'll be; using as many of the LLVM tools as we can, but it is possible to use GNU; equivalents. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:580,depend,depend,580,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,2,['depend'],"['depend', 'dependencies']"
Integrability,"==============================================================================; The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:; ==============================================================================. Apache License; Version 2.0, January 2004; http://www.apache.org/licenses/. TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION. 1. Definitions. ""License"" shall mean the terms and conditions for use, reproduction,; and distribution as defined by Sections 1 through 9 of this document. ""Licensor"" shall mean the copyright owner or entity authorized by; the copyright owner that is granting the License. ""Legal Entity"" shall mean the union of the acting entity and all; other entities that control, are controlled by, or are under common; control with that entity. For the purposes of this definition,; ""control"" means (i) the power, direct or indirect, to cause the; direction or management of such entity, whether by contract or; otherwise, or (ii) ownership of fifty percent (50%) or more of the; outstanding shares, or (iii) beneficial ownership of such entity. ""You"" (or ""Your"") shall mean an individual or Legal Entity; exercising permissions granted by this License. ""Source"" form shall mean the preferred form for making modifications,; including but not limited to software source code, documentation; source, and configuration files. ""Object"" form shall mean any form resulting from mechanical; transformation or translation of a Source form, including but; not limited to compiled object code, generated documentation,; and conversions to other media types. ""Work"" shall mean the work of authorship, whether in Source or; Object form, made available under the License, as indicated by a; copyright notice that is included in or attached to the work; (an example is provided in the Appendix below). ""Derivative Works"" shall mean any work, whether in Source or Object; form, that is based on (or derived from) the Work and for which the; editorial revi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:959,contract,contract,959,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,4,['contract'],['contract']
Integrability,"> <on_false>, i32 <pivot>). Overview:; """""""""""""""""". The '``llvm.vp.merge``' intrinsic is used to choose one value based on a; condition vector and an index operand, without IR-level branching. Arguments:; """""""""""""""""""". The first operand is a vector of ``i1`` and indicates the condition. The; second operand is the value that is merged where the condition vector is true.; The third operand is the value that is selected where the condition vector is; false or the lane position is greater equal than the pivot. The fourth operand; is the pivot. #. The optional ``fast-math flags`` marker indicates that the merge has one or; more :ref:`fast-math flags <fastmath>`. These are optimization hints to; enable otherwise unsafe floating-point optimizations. Fast-math flags are; only valid for merges that return a floating-point scalar or vector type,; or an array (nested to any depth) of floating-point scalar or vector types. Semantics:; """""""""""""""""""". The intrinsic selects lanes from the second and third operand depending on a; condition vector and pivot value. For all lanes where the condition vector is true and the lane position is less; than ``%pivot`` the lane is taken from the second operand. Otherwise, the lane; is taken from the third operand. Example:; """""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.merge.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %pivot). ;;; Expansion.; ;; Lanes at and above %pivot are taken from %on_false; %atfirst = insertelement <4 x i32> undef, i32 %pivot, i32 0; %splat = shufflevector <4 x i32> %atfirst, <4 x i32> poison, <4 x i32> zeroinitializer; %pivotmask = icmp ult <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> %splat; %mergemask = and <4 x i1> %cond, <4 x i1> %pivotmask; %also.r = select <4 x i1> %mergemask, <4 x i32> %on_true, <4 x i32> %on_false. .. _int_vp_add:. '``llvm.vp.add.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:696458,depend,depending,696458,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"> InnerMatcher; Matches the first method of a class or struct that satisfies InnerMatcher. Given:; class A { void func(); };; class B { void member(); };. cxxRecordDecl(hasMethod(hasName(""func""))) matches the declaration of; A but not B. Matcher<CXXRecordDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<CXXRecordDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<CXXRecordDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<CXXRewrittenBinaryOperator>hasEitherOperandMatcher<Expr> InnerMatcher; Matches if either the left",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:167770,interface,interface,167770,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"> and <string.h>; had to be added. TPRegexp. Modularized Match() and Substitute() functions so that the low-level work; is done by MatchInternal() and SubstituteInternal(). Added function TString GetModifiers() that translates from bit-flag; options back to perl-style option characters. For all functions that do actual matching replaced the default value; of 'Int_t nMatchMax' argument from 30 to 10. PCRE internals require; the index buffer to be 3-times the number of allowed matches. This; multiplication is now performed in individual functions and nMatchMax; is really the number of allowed matches. Two function calls in; TString passing this number explicitly have been updated. TPMERegexp. New sub-class of TPRegexp with API closer to PERL.; Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_each algorithm for ROOT; Containers/Iterators by making as few as possible changes, without rewriting; iterators at all. No",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:3043,interface,interface,3043,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['interface'],['interface']
Integrability,">. //===---------------------------------------------------------------------===//. In c99 mode, the preprocessor doesn't like assembly comments like #TRUNCATE. //===---------------------------------------------------------------------===//. This could be a single 16-bit load. int f(char *p) {; if ((p[0] == 1) & (p[1] == 2)) return 1;; return 0;; }. //===---------------------------------------------------------------------===//. We should inline lrintf and probably other libc functions. //===---------------------------------------------------------------------===//. This code:. void test(int X) {; if (X) abort();; }. is currently compiled to:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne LBB1_1; addl $12, %esp; ret; LBB1_1:; call L_abort$stub. It would be better to produce:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne L_abort$stub; addl $12, %esp; ret. This can be applied to any no-return function call that takes no arguments etc.; Alternatively, the stack save/restore logic could be shrink-wrapped, producing; something like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; subl $12, %esp; call L_abort$stub. Both are useful in different situations. Finally, it could be shrink-wrapped; and tail called, like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; pop %eax # realign stack.; call L_abort$stub. Though this probably isn't worth it. //===---------------------------------------------------------------------===//. Sometimes it is better to codegen subtractions from a constant (e.g. 7-x) with; a neg instead of a sub instruction. Consider:. int test(char X) { return 7-X; }. we currently produce:; _test:; movl $7, %eax; movsbl 4(%esp), %ecx; subl %ecx, %eax; ret. We would use one fewer register if codegen'd as:. movsbl 4(%esp), %eax; 	neg %eax; add $7, %eax; ret. Note that this isn't beneficial if the load can be folded into the sub. In; this case, we want a sub:. int test(int X) { return 7-X; }; _test:; movl $7, %eax; subl 4(%esp), %eax; ret. /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:12174,wrap,wrapped,12174,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['wrap'],['wrapped']
Integrability,">>> cppyy.gbl.callback(PyMyClass(1), 2) # calls Python-side override; 5; >>>. With a modern C++ compiler having its back, cppyy is future-proof.; Consider the following session using ``boost::any``, a capsule-type that; allows for heterogeneous containers in C++.; The `Boost`_ library is well known for its no holds barred use of modern C++; and heavy use of templates:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('boost/any.hpp') # assumes you have boost installed; >>> from cppyy.gbl import std, boost; >>> val = boost.any() # the capsule ; >>> val.__assign__(std.vector[int]()) # assign it a std::vector<int>; <cppyy.gbl.boost.any object at 0xf6a8a0>; >>> val.type() == cppyy.typeid(std.vector[int]) # verify type; True; >>> extract = boost.any_cast[int](std.move(val)) # wrong cast; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; cppyy.gbl.boost.bad_any_cast: Could not instantiate any_cast<int>:; int boost::any_cast(boost::any&& operand) =>; wrapexcept<boost::bad_any_cast>: boost::bad_any_cast: failed conversion using boost::any_cast; >>> extract = boost.any_cast[std.vector[int]](val) # correct cast; >>> type(extract) is std.vector[int]; True; >>> extract += xrange(100); >>> len(extract); 100; >>> val.__assign__(std.move(extract)) # move forced; <cppyy.gbl.boost.any object at 0xf6a8a0>; >>> len(extract) # now empty (or invalid); 0; >>> extract = boost.any_cast[std.vector[int]](val); >>> list(extract); [0, 1, 2, 3, 4, 5, 6, ..., 97, 98, 99]; >>>. Of course, there is no reason to use Boost from Python (in fact, this example; calls out for :doc:`pythonizations <pythonizations>`), but it shows that; cppyy seamlessly supports many advanced C++ features. cppyy is available for both `CPython`_ (v2 and v3) and `PyPy`_, reaching; C++-like performance with the latter.; It makes judicious use of precompiled headers, dynamic loading, and lazy; instantiation, to support C++ programs consisting of millions of lines of; code and many thousands of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:3527,wrap,wrapexcept,3527,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,1,['wrap'],['wrapexcept']
Integrability,">GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36113,interface,interface,36113,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,">`), which uses a; serialized representation of Clang's internal data structures, encoded with the; `LLVM bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_. The Frontend Library; ====================. The Frontend library contains functionality useful for building tools on top of; the Clang libraries, for example several methods for outputting diagnostics. Compiler Invocation; -------------------. One of the classes provided by the Frontend library is ``CompilerInvocation``,; which holds information that describe current invocation of the Clang ``-cc1``; frontend. The information typically comes from the command line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:27058,interface,interface,27058,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"@interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8277,interface,interface,8277,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['interface'],['interface']
Integrability,"ALL LICENSES; =====. This document includes several copyright licenses for different; aspects of the software. Not all licenses may apply depending; on the features chosen. Civetweb License; -----. ### Included with all features. > Copyright (c) 2013-2021 The CivetWeb developers ([CREDITS.md](https://github.com/civetweb/civetweb/blob/master/CREDITS.md)); >; > Copyright (c) 2004-2013 Sergey Lyubka; >; > Copyright (c) 2013 No Face Press, LLC (Thomas Davis); >; > Copyright (c) 2013 F-Secure Corporation; >; > Permission is hereby granted, free of charge, to any person obtaining a copy; > of this software and associated documentation files (the ""Software""), to deal; > in the Software without restriction, including without limitation the rights; > to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; > copies of the Software, and to permit persons to whom the Software is; > furnished to do so, subject to the following conditions:; >; > The above copyright notice and this permission notice shall be included in; > all copies or substantial portions of the Software.; >; > THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; > IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; > FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; > AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; > LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; > OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; > THE SOFTWARE. Lua License; ------. ### Included only if built with Lua support. http://www.lua.org/license.html. > Copyright (C) 1994-2020 Lua.org, PUC-Rio.; >; > Permission is hereby granted, free of charge, to any person obtaining a copy; > of this software and associated documentation files (the ""Software""), to deal; > in the Software without restriction, including without limitation the rights; > to use, copy, modify, merge, pu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md:138,depend,depending,138,net/http/civetweb/LICENSE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md,1,['depend'],['depending']
Integrability,"AMDHSA*; Local 3 group LDS 32 0xFFFFFFFF; Constant 4 constant *same as global* 64 0x0000000000000000; Private 5 private scratch 32 0xFFFFFFFF; Constant 32-bit 6 *TODO* 0x00000000; Buffer Fat Pointer (experimental) 7 *TODO*; Buffer Resource (experimental) 8 *TODO*; Buffer Strided Pointer (experimental) 9 *TODO*; Streamout Registers 128 N/A GS_REGS; ===================================== =============== =========== ================ ======= ============================. **Generic**; The generic address space is supported unless the *Target Properties* column; of :ref:`amdgpu-processor-table` specifies *Does not support generic address; space*. The generic address space uses the hardware flat address support for two fixed; ranges of virtual addresses (the private and local apertures), that are; outside the range of addressable global memory, to map from a flat address to; a private or local address. This uses FLAT instructions that can take a flat; address and access global, private (scratch), and group (LDS) memory depending; on if the address is within one of the aperture ranges. Flat access to scratch requires hardware aperture setup and setup in the; kernel prologue (see :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat; access to LDS requires hardware aperture setup and M0 (GFX7-GFX8) register; setup (see :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a private or group address space address (termed a segment; address) and a flat address the base address of the corresponding aperture; can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline; constant registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``.; In 64-bit address mode the aperture sizes are 2^32 bytes and the base is; aligned to 2^32 which makes it easie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:23491,depend,depending,23491,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depending']
Integrability,"ARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2462,interface,interface,2462,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ATH=""${library_output_dir}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); else(); set(modules_idx_cmd COMMAND ${ld_library_path}=${library_output_dir}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); endif(); add_custom_command(OUTPUT ${library_output_dir}/modules.idx; COMMAND ${CMAKE_COMMAND} -E remove -f modules.idx modules.timestamp; ${modules_idx_cmd}; WORKING_DIRECTORY ${library_output_dir}; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts; ${modules_idx_deps}); add_custom_target(modules_idx ALL DEPENDS ${library_output_dir}/modules.idx); add_dependencies(modules_idx ${modules_idx_deps}); set_property(TARGET modules_idx PROPERTY modules_idx_file ${library_output_dir}/modules.idx); set_directory_properties(PROPERTIES ADDITIONAL_CLEAN_FILES ""${library_output_dir}/modules.timestamp""); endif(). #---hsimple.root---------(use the executable for clearer dependencies and proper return code)---; add_custom_target(hsimple ALL DEPENDS tutorials/hsimple.root); add_dependencies(hsimple onepcm); if(WIN32); set(hsimple_cmd COMMAND ${CMAKE_COMMAND} -E env PATH=""${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); else(); set(hsimple_cmd COMMAND ${MODULES_ROOT_INCPATH} ${ld_library_path}=${CMAKE_LIBRARY_OUTPUT_DIRECTORY}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); endif(); add_custom_command(OUTPUT tutorials/hsimple.root; ${hsimple_cmd}; WORKING_DIRECTORY tutorials; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts); install(FILES ${CMAKE_BINARY_DIR}/tutorials/hsimple.root DESTINATION ${CMAKE_INSTALL_TUTDIR} COMPONENT tests). if(runtime_cxxmodules); add_dependencies(hsimple modules_idx); endif(). #---copy special headers required for building on Windows---------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:22985,depend,dependencies,22985,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"ATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${multithreaded}). #---Loop over all tutorials and define the corresponding test---------. #---Define the primordial tutorials-----------------------------------; ROOT_ADD_TEST(tutorial-hsimple COMMAND ${ROOT_root_CMD} -b -l -n -q ${CMAKE_CURRENT_SOURCE_DIR}/hsimple.C; PASSRC 255 FAILREGEX ""Error in"" ""error:"" ""warning: Failed to call"" LABELS tutorial ENVIRONMENT ${TUTORIAL_ENV}); if(ROOT_geom_FOUND); ROOT_ADD_TEST(tutorial-geom-geometry COMMAND ${ROOT_root_CMD} -b -l -n -q ${CMAKE_CURRENT_SOURCE_DIR}/geom/geometry.C; FAILREGEX ""Error in"" ""error:"" ""warning: Failed to call"" LABELS tutorial ENVIRONMENT ${TUTORIAL_ENV}); endif(); # define Python GNN parsing tutorial needed to run before; if (PY_SONNET_FOUND AND PY_GRAPH_NETS_FOUND); ROOT_ADD_TEST(tutorial-tmva-TMVA_SOFIE_GNN_Parser COMMAND ${Python3_EXECUTABLE}; ${CMAKE_CURRENT_SOURCE_DIR}/tmva/TMVA_SOFIE_GNN_Parser.py; PASSRC 0 FAILREGEX ""Error in"" "": error:"" LABELS tutorial ENVIRONMENT ${TUTORIAL_ENV}); set (tmva-TMVA_SOFIE_GNN_Application-depends tutorial-tmva-TMVA_SOFIE_GNN_Parser); endif(). #---Loop over all tutorials and define the corresponding test---------; foreach(t ${tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). set(labels tutorial); if(${t} IN_LIST long_running); list(APPEND labels longtest); endif(); if(${t} IN_LIST multithreaded); list(APPEND labels multithreaded); # If this is not a TMVA tutorial, we want to limit the size of the thread; # pool in case the tutorial invokes ROOT::EnableImplicitMT(), which by; # default creates a thread pool of the size of the total number of cores.; if(${t} IN_LIST multithreaded_all_cores); set(createThreadPool ""-e \""ROOT::EnableImplicitMT(${NProcessors})\""""); endif(); else(); unset(createThreadPool); endif(). if(${t} IN_LIST need_network); list(APPEND labels needs_network); endif(). # These tests on A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:23075,depend,depends,23075,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"AULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --per-test-coverage""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); set(LLVM_NATIVE_TOOL_DIR """" CACHE PATH ""Path to a directory containing prebuilt matching native tools (such as llvm-tblgen)""). set(LLVM_INTEGRATED_CRT_ALLOC """" CACHE PATH ""Replace the Windows CRT allocator with any of {rpmalloc|mimalloc|snmalloc}. Only works with CMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded.""); if(LLVM_INTEGRATED_CRT_ALLOC); if(NOT WIN32); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC is only supported on Windows.""); endif(); if(LLVM_USE_SANITIZER); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC cannot be used along with LLVM_USE_SANITIZER!""); endif(); if(CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE STREQUAL ""DEBUG""); message(FATAL_ERROR ""The Debug target isn't supported along with LLVM_INTEGRATED_CRT_ALLOC!""); endif(); endif(). # Define options to control the inclusion and default build behavior for; # components which may not strictly be necessary (tools, examples, and tests).; #; # This is primarily to support building smaller or faster project files.; option(LLVM_INCLUDE_TOOLS ""Generate build targets for the LLVM tools."" ON); option(LLVM_BUILD_TOOLS; ""Build the LLVM tools. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_UTILS ""Generate build targets for the LLVM utils."" ON); option(LLVM_BUILD_UTILS; ""Build LLVM utility binaries. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_RUNTIMES ""Generate build targets for the LLVM runtimes."" ON); option(LLVM_BUILD_RUNTIMES; ""Build the LLVM runtimes. If OFF, just generate build targets."" ON). option(LLVM_BUILD_RUNTIME; ""Build the LLVM runtime libraries."" ON); option(LLVM_BUILD_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:30234,message,message,30234,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,['message'],['message']
Integrability,"AVE_RLIMITS). # This check requires _GNU_SOURCE on linux; check_include_file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl); endif(); endif(). set(CLANG_RESOURCE_DIR """" CACHE STRING; ""Relative directory from the Clang binary to its resource files.""). set(C_INCLUDE_DIRS """" CACHE STRING; ""Colon separated list of directories clang will search for headers.""). set(GCC_INSTALL_PREFIX """" CACHE PATH ""Directory where gcc is installed."" ); set(DEFAULT_SYSROOT """" CACHE STRING; ""Default <path> to all compiler invocations for --sysroot=<path>."" ); if(GCC_INSTALL_PREFIX); message(WARNING ""GCC_INSTALL_PREFIX is deprecated and will be removed. Use ""; ""configuration files (https://clang.llvm.org/docs/UsersManual.html#configuration-files)""; ""to specify the default --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:6858,message,message,6858,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"A_SOFIE_RSofieReader.C`. ### TMVA Pythonizations. New Pythonizations are available for TMVA allowing to replace the option string passed to several `TMVA` functions such as the `TMVA::Factory` constructor, the `DataLoader::PrepareTrainingAndTestTree` and `Factory::BookMethod` using Python function arguments.; For example instead of writing an option string `""NTrees=500:BoostType=AdaBoost""` one can use in Python `NTrees=500,BoostType='AdaBoost'`.; The new tmva tutorials `TMVA_Higgs_Classification.py`, `TMVA_CNN_Classificaion.py` and `TMVA_RNN_Classificaton.py` provide examples of using these new pythonizations. ## 2D Graphics Libraries. - Implement the option ""File"": The current file name is painted on the bottom right of each plot; if the option `File` is set on via `gStyle->SetOptFile()`. - In matplolib one can use the ""Default X-Points"" feature to plot X/Y graphs: If one doesn't; specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; on the length of the y-points). The matplotlib script will be:; ```; import matplotlib.pyplot as plt; import numpy as np; points = np.array([3, 8, 1, 10, 5, 7]); plt.plot(ypoints); plt. show(); ```; It is now possible to do the same with the ROOT TGraph:; ```; double y[6] = {3, 8, 1, 10, 5, 7};; auto g = new TGraph(6,y);; g->Draw();; ```. So, if we take the same example as above, and leave out the x-points, the diagram will look like this:. ## 3D Graphics Libraries. ## Geometry Libraries. - Support with web geometry viewer image production in batch mode. Just do:; ```; ROOT::Experimental::RGeomViewer viewer(geom);; viewer.SaveImage(""rootgeom.jpeg"", 800, 600);; ```; This runs normal WebGL rendering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable director",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:30930,depend,depending,30930,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['depend'],['depending']
Integrability,"Acts as both an ``acquire`` and ``release`` operation on its; address. This corresponds to the C/C++ ``memory_order_acq_rel``.; ``seq_cst`` (sequentially consistent); In addition to the guarantees of ``acq_rel`` (``acquire`` for an; operation that only reads, ``release`` for an operation that only; writes), there is a global total order on all; sequentially-consistent operations on all addresses. Each; sequentially-consistent read sees the last preceding write to the; same address in this global order. This corresponds to the C/C++; ``memory_order_seq_cst`` and Java ``volatile``. Note: this global total order is *not* guaranteed to be fully; consistent with the *happens-before* partial order if; non-``seq_cst`` accesses are involved. See the C++ standard; `[atomics.order] <https://wg21.link/atomics.order>`_ section; for more details on the exact guarantees. .. _syncscope:. If an atomic operation is marked ``syncscope(""singlethread"")``, it only; *synchronizes with* and only participates in the seq\_cst total orderings of; other operations running in the same thread (for example, in signal handlers). If an atomic operation is marked ``syncscope(""<target-scope>"")``, where; ``<target-scope>`` is a target specific synchronization scope, then it is target; dependent if it *synchronizes with* and participates in the seq\_cst total; orderings of other operations. Otherwise, an atomic operation that is not marked ``syncscope(""singlethread"")``; or ``syncscope(""<target-scope>"")`` *synchronizes with* and participates in the; seq\_cst total orderings of other operations that are not marked; ``syncscope(""singlethread"")`` or ``syncscope(""<target-scope>"")``. .. _floatenv:. Floating-Point Environment; --------------------------. The default LLVM floating-point environment assumes that traps are disabled and; status flags are not observable. Therefore, floating-point math operations do; not have side effects and may be speculated freely. Results assume the; round-to-nearest rounding ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:156125,synchroniz,synchronizes,156125,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes']
Integrability,"Additional; functionality exists to work with multiple prototype p.d.f.s simultaneously. ; Improved infrastructure for caching p.d.f and functions. The infrastructure that exists for caching p.d.f.s, i.e. p.d.f that precalculate their value; for all observable values at one and cache those in a histogram that is returned as p.d.f shape; (with optional interpolation), has been expanded. This infrastructure comprises RooAbsCached; the base class for all caching p.d.fs, RooAbsSelfCachedPdf a base class for end-user; caching p.d.f implementations that simply cache the result of evaluate() and RooCachedPdf; that can wrap and cache any input p.d.f specified in its constructor. . By default a p.d.f is sampled and cached in all observables in any; given use context, with no need to specify what those are in advance.; The internal code has also been changed such that all cache; histograms now store pre-normalized p.d.f, which is more efficient; than 'raw' p.d.f histograms that are explicitly post-normalized; through integration. Multiple different use cases (e.g. definitions; of what are observables vs parameters) can be cached; simultaneously. Now it is also possible to specify that p.d.f.s; should be sampled and cached in one or more parameter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of handling negative entries. New PDF error handling structure. New infrastructure has been put into place to propagate and process p.d.f evaluation errors during fitting.; Previously evaluation errors were marked with a zero p.d.f value and propagated as a special condition; in RooAddPdf, RooProdPdf etc to result in a zero top-level p.d.f value that was caught by the RooFit minuit; interface as a special cond",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:14386,integrat,integration,14386,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist before (this doesn't make sense for a safe compiler transformation), so; this is the only way to introduce a new value. This method indicates that the; new value has exactly the same properties as the value being copied. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14472,interface,interfaces,14472,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interfaces']
Integrability,"Applications; ------------. 1. **C++ in Jupyter Notebook - Xeus Cling:**. The `Jupyter Notebook <https://jupyter.org/>`_ technology allows users to create; and share documents that contain live code, equations, visualizations and; narrative text. It enables data scientists to easily exchange ideas or; collaborate by sharing their analyses in a straight-forward and reproducible; way. Jupyter’s official C++ kernel(`Xeus-Cling; <https://github.com/jupyter-xeus/xeus-cling>`_) relies on Xeus, a C++; implementation of the kernel protocol, and Cling. Using C++ in the Jupyter; environment yields a different experience to C++ users. For example, Jupyter’s; visualization system can be used to render rich content such as images,; therefore bringing more interactivity into the Jupyter’s world. You can find; more information on `Xeus Cling's Read the Docs; <https://xeus-cling.readthedocs.io/en/latest/>`_ webpage. 2. **Interactive CUDA C++ with Cling:**. `CUDA <https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/>`_ is a platform; and Application Programming Interface (API) created by `NVIDIA; <https://www.nvidia.com/en-us/>`_. It controls `GPU; <https://en.wikipedia.org/wiki/Graphics_processing_unit>`_ (Graphical Processing; Unit) for parallel programming, enabling developers to harness the power of; graphic processing units (GPUs) to speed up applications. As an example,; `PIConGPU <https://github.com/ComputationalRadiationPhysics/picongpu>`_ is a; CUDA-based plasma physics application to solve the dynamics of a plasma by; computing the motion of electrons and ions in the plasma field. Interactive GPU; programming was made possible by extending Cling functionality to compile CUDA; C++ code. The new Cling-CUDA C++ can be used on Jupyter Notebook platform, and; enables big, interactive simulation with GPUs, easy GPU development and; debugging, and effective GPU programming learning. 3. **Clad:**. `Clad <https://compiler-research.org/clad/>`_ enables automatic differentiation; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:529,protocol,protocol,529,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['protocol'],['protocol']
Integrability,"Arch64 / ARMv8 64-bit - thanks, David Abdurachmanov!. ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3. #### Thread-Safety. A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!. #### std::string_view. Introduce a preview of C++17's std::string_view. To take advantage of this new; class use:; ```{.cpp}; #include ""RStringView.h""; ```; The documentation of this can be found at `http://en.cppreference.com/w/cpp/experimental/basic_string_view`; The implementation provided is extracted from libcxx. Whenever the current; compiler and standard library provide an implmentation, it is used. The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. This type is used throughout the ROOT code to avoid copying strings when a; sub-string is needed and to extent interfaces that uses to take a const char*; to take a std::string_view as thus be able to be directly directly passed a; TString, a std::string or a std::string_view. Usage example:. ``` {.cpp}; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; ```. ### Meta library. #### Backward Incompatibilities. TIsAProxy's constructor no longer take the optional and unused 2nd argument which was reserved for a 'context'. This context was unused in TIsAProxy itself and was not accessible from derived classes. #### Interpreter. The new interface `TInterpreter::Declare(const char* code)` will declare the; code to the interpreter with all interpreter extensions disabled, i.e. as; ""proper"" C++ code. No autoloading or synamic lookup will be performed. A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:. ``` {.cpp}; // ROOT ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:2131,interface,interfaces,2131,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['interface'],['interfaces']
Integrability,"At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3596,depend,dependent,3596,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['depend'],['dependent']
Integrability,"BEGIN_HTML. <center><h1>Gviz3d - Objects Data Structure visualisation in 3D space</h1></center>; <p><hr><p>. The Gviz3d module provides an interface for inspecting objects collections.; TStructViewer represents a class, a struct or any other type as an; object in 3D space.; At the top of the scene we can see objects depending on a pointer root. Under it we see; pointers and collection elements. Collections must inherit from TCollection; or be STL collections. We can change the number of visible levels or objects on the scene with the GUI or; methods. The Size of objects in the geometry scene is proportional to memory taken by this object; or to the number of objects inside this object. An easy way to find some class in the viewer is to change the color of a type.; We can connect for example TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigatiion in the viewer is very simple like in usual GLViewer. When you put mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operations are supported. END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt:139,interface,interface,139,graf3d/gviz3d/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"BEGIN_HTML; This directory contains classes that provide and interface to the libxml2; XML parser. Both DOM and SAX parser interfaces are provided.; See:; <ul>; <li><a href=""http://www.xmlsoft.org"">For more on libxml2</a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xmlparser/doc/index.txt:61,interface,interface,61,io/xmlparser/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xmlparser/doc/index.txt,2,['interface'],"['interface', 'interfaces']"
Integrability,"BEGIN_HTML; This directory contains the I/O interface classes for the <b>Dcache</b> system.; For more information about <b>Dcache</b>, see:; <ul>; <li><a href=""http://www-dcache.desy.de/"">the DESY Dcache site; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/doc/index.txt:44,interface,interface,44,io/dcache/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/doc/index.txt,1,['interface'],['interface']
Integrability,"BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-block:: c++. A(a*b);. will usually be interpreted as a call to a function A, and the; multiplication expression will be formatted as ``a * b``. If we specify the macro definition:. .. code-block:: yaml. Macros:; - A(x)=x. the code will now be parsed as a declaration of the variable b of type a*,; and formatted as ``a* b`` (depending on pointer-binding rules). Features and restrictions:; * Both function-like macros and object-like macros are supported.; * Macro arguments must be used exactly once in the expansion.; * No recursive expansion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:86122,depend,depending,86122,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['depend'],['depending']
Integrability,"BLE_BEGIN _Pragma(""clang attribute Unavailable.push (__attribute__((unavailable)), apply_to=function)""); #define ASSUME_UNAVAILABLE_END _Pragma(""clang attribute Unavailable.pop""). ASSUME_NORETURN_BEGIN; ASSUME_UNAVAILABLE_BEGIN; void function(); // function has [[noreturn]] and __attribute__((unavailable)); ASSUME_NORETURN_END; void other_function(); // function has __attribute__((unavailable)); ASSUME_UNAVAILABLE_END. Without the namespaces on the macros, ``other_function`` will be annotated with; ``[[noreturn]]`` instead of ``__attribute__((unavailable))``. This may seem like; a contrived example, but its very possible for this kind of situation to appear; in real code if the pragmas are spread out across a large file. You can test if; your version of clang supports namespaces on ``#pragma clang attribute`` with; ``__has_extension(pragma_clang_attribute_namespaces)``. Subject Match Rules; -------------------. The set of declarations that receive a single attribute from the attribute stack; depends on the subject match rules that were specified in the pragma. Subject; match rules are specified after the attribute. The compiler expects an; identifier that corresponds to the subject set specifier. The ``apply_to``; specifier is currently the only supported subject set specifier. It allows you; to specify match rules that form a subset of the attribute's allowed subject; set, i.e. the compiler doesn't require all of the attribute's subjects. For; example, an attribute like ``[[nodiscard]]`` whose subject set includes; ``enum``, ``record`` and ``hasType(functionType)``, requires the presence of at; least one of these rules after ``apply_to``:. .. code-block:: c++. #pragma clang attribute push([[nodiscard]], apply_to = enum). enum Enum1 { A1, B1 }; // The enum will receive [[nodiscard]]. struct Record1 { }; // The struct will *not* receive [[nodiscard]]. #pragma clang attribute pop. #pragma clang attribute push([[nodiscard]], apply_to = any(record, enum)). enum Enum2 { ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:180875,depend,depends,180875,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depends']
Integrability,"BUG`` option which implies it) is also unsupported. Send any questions or comments to the mailing list: libfuzzer(#)googlegroups.com. Q. When libFuzzer is not a good solution for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one test) the fuzzing results will be unreliable. Q. So, what exactly this Fuzzer is good for?; --------------------------------------------. This Fuzzer might be a good choice for testing libraries that have relatively; small inputs, each input takes < 10ms to run, and the library code is not expected; to crash on invalid inputs.; Examples: regular expression matchers, text or binary format parsers, compression,; network, crypto. Q. LibFuzzer crashes on my complicated fuzz target (but works fine for me on smaller targets).; ----------------------------------------------------------------------------------------------. Check if your fuzz target uses ``dlclose``.; Current",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:30165,interface,interface,30165,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['interface'],['interface']
Integrability,"BUILT_STANDALONE); umbrella_lit_testsuite_end(check-all); endif(); add_subdirectory(utils/perf-training); endif(). option(CLANG_INCLUDE_DOCS ""Generate build targets for the Clang docs.""; ${LLVM_INCLUDE_DOCS}); if( CLANG_INCLUDE_DOCS ); add_subdirectory(docs); endif(). # Custom target to install all clang libraries.; add_custom_target(clang-libraries); set_target_properties(clang-libraries PROPERTIES FOLDER ""Misc""). if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-libraries; DEPENDS clang-libraries; COMPONENT clang-libraries); endif(). get_property(CLANG_LIBS GLOBAL PROPERTY CLANG_LIBS); if(CLANG_LIBS); list(REMOVE_DUPLICATES CLANG_LIBS); foreach(lib ${CLANG_LIBS}); add_dependencies(clang-libraries ${lib}); if(NOT LLVM_ENABLE_IDE); add_dependencies(install-clang-libraries install-${lib}); add_dependencies(install-clang-libraries-stripped install-${lib}-stripped); endif(); endforeach(); endif(). add_subdirectory(cmake/modules). if(CLANG_STAGE); message(STATUS ""Setting current clang stage to: ${CLANG_STAGE}""); endif(). if (CLANG_ENABLE_BOOTSTRAP); include(ExternalProject). add_custom_target(clang-bootstrap-deps DEPENDS clang). if(NOT CLANG_STAGE); set(CLANG_STAGE stage1); endif(). string(REGEX MATCH ""stage([0-9]*)"" MATCHED_STAGE ""${CLANG_STAGE}""); if(MATCHED_STAGE); if(NOT LLVM_BUILD_INSTRUMENTED); math(EXPR STAGE_NUM ""${CMAKE_MATCH_1} + 1""); set(NEXT_CLANG_STAGE stage${STAGE_NUM}); else(); set(NEXT_CLANG_STAGE stage${CMAKE_MATCH_1}); endif(); else(); set(NEXT_CLANG_STAGE bootstrap); endif(). if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED); set(NEXT_CLANG_STAGE ${NEXT_CLANG_STAGE}-instrumented); endif(); message(STATUS ""Setting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error mes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:19974,message,message,19974,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"BoostBeta No 1 − The ADA boost parameter that sets the effect of every boost step on the events' weights. Boost_Transform No step step, linear, log, gauss Type of transform applied to every boosted method linear, log, step. Boost_RandomSeed No 0 − Seed for random number generator used for bagging. Configuration options for MVA method :. Configuration options reference for MVA method: RuleFit. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). GDTau No -1 − Gradient-directed (GD) path: default fit cut-off. GDTauPrec No 0.01 − GD path: precision of tau. GDStep No 0.01 − GD path: step size. GDNSteps No 10000 − GD path: number of steps. GDErrScale No 1.1 − Stop scan when error > scale*errmin. LinQuantile No 0.025 − Quantile of linear terms (removes outliers). GDPathEveFrac No 0.5 − Fraction of events used for the path search. GDValidEveFrac No 0.5 − Fraction of events used for the validation. fEventsMin No 0.1 − Minimum fraction of events in a splittable node. fEventsMax No 0.9 − Maximum fraction of events in a splittable node. nTrees No 20 − Number of trees in forest. ForestType No AdaBoost AdaBoost, Random Method to use for forest generation (AdaBoost or RandomForest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:18318,message,message,18318,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"By Chris:. LLVM has been designed with two primary goals in mind. First we strive to ; enable the best possible division of labor between static and dynamic ; compilers, and second, we need a flexible and powerful interface ; between these two complementary stages of compilation. We feel that ; providing a solution to these two goals will yield an excellent solution ; to the performance problem faced by modern architectures and programming ; languages. A key insight into current compiler and runtime systems is that a ; compiler may fall in anywhere in a ""continuum of compilation"" to do its ; job. On one side, scripting languages statically compile nothing and ; dynamically compile (or equivalently, interpret) everything. On the far ; other side, traditional static compilers process everything statically and ; nothing dynamically. These approaches have typically been seen as a ; tradeoff between performance and portability. On a deeper level, however, ; there are two reasons that optimal system performance may be obtained by a; system somewhere in between these two extremes: Dynamic application ; behavior and social constraints. From a technical perspective, pure static compilation cannot ever give ; optimal performance in all cases, because applications have varying dynamic; behavior that the static compiler cannot take into consideration. Even ; compilers that support profile guided optimization generate poor code in ; the real world, because using such optimization tunes that application ; to one particular usage pattern, whereas real programs (as opposed to ; benchmarks) often have several different usage patterns. On a social level, static compilation is a very shortsighted solution to ; the performance problem. Instruction set architectures (ISAs) continuously ; evolve, and each implementation of an ISA (a processor) must choose a set ; of tradeoffs that make sense in the market context that it is designed for. ; With every new processor introduced, the vendor f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt:214,interface,interface,214,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,1,['interface'],['interface']
Integrability,"C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been developed during this time, many of them exhibiting exotic and; culturally specific features that professional software developers are mostly; unaware of. In this framework, Cling has been used as the basis for a C++ based; live coding synthesiser (`TinySpec-Cling; <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_). In another example,; Cling has been installed on a BeagleBoard to bring live coding to the Bela; interactive audio platform (`Using the Cling C++ Interpreter on the Bela; Platform; <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_). These; two examples show the potential mutual benefits for increased engagement between; the Cling community and the artistic live coding community. 5. **Clion:** The `CLion <https://www.jetbrains.com/clion/>`_ platform is a; Integrating Development Environment (`IDE; <https://en.wikipedia.org/wiki/Integrated_development_environment>`_) for C and; C++ by `JetBrains <https://www.jetbrains.com/>`_. It was developed with the aim; to enhance developer's productivity with a smart editor, code quality assurance,; automated refactorings and deep integration with the CMake build system. CLion; integrates Cling, which can be found by clicking on Tool. Cling enables; prototyping and learning C++ in CLion. You can find more information on `CLion's; building instructions; <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:3923,integrat,integration,3923,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,3,['integrat'],"['integrates', 'integration']"
Integrability,"C++ toolchain, both compiler and standard library, in order to build LLVM. LLVM is written using the subset of C++ documented in :doc:`coding; standards<CodingStandards>`. To enforce this language version, we check the most; popular host toolchains for specific minimum versions in our build systems:. * Clang 5.0; * Apple Clang 10.0; * GCC 7.4; * Visual Studio 2019 16.7. Anything older than these toolchains *may* work, but will require forcing the; build system with a special option and is not really a supported host platform.; Also note that older versions of these compilers have often crashed or; miscompiled LLVM. For less widely used host toolchains such as ICC or xlC, be aware that a very; recent version may be required to support all of the C++ features used in LLVM. We track certain versions of software that are *known* to fail when used as; part of the host toolchain. These even include linkers at times. **GNU ld 2.16.X**. Some 2.16.X versions of the ld linker will produce very long; warning messages complaining that some ""``.gnu.linkonce.t.*``"" symbol was; defined in a discarded section. You can safely ignore these messages as they are; erroneous and the linkage is correct. These messages disappear using ld 2.17. **GNU binutils 2.17**: Binutils 2.17 contains `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=3111>`__ which causes huge link; times (minutes instead of seconds) when building LLVM. We recommend upgrading; to a newer version (2.17.50.0.4 or later). **GNU Binutils 2.19.1 Gold**: This version of Gold contained `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=9836>`__ which causes; intermittent failures when building LLVM with position independent code. The; symptom is an error about cyclic dependencies. We recommend upgrading to a; newer version of Gold. Getting a Modern Host C++ Toolchain; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:14050,message,messages,14050,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['messages']
Integrability,"C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this condition is found to be true, then ``Interp.SynthesizeExpr()`` will be; invoked. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. for (Decl *D : DGR); if (auto *TSD = llvm::dyn_cast<TopLevelStmtDecl>(D);; TSD && TSD->isSemiMissing()); TSD->setStmt(Interp.SynthesizeExpr(cast<Expr>(TSD->getStmt())));. return Consumer->HandleTopLevelDecl(DGR);. The synthesizer will then choose the relevant expression, based on its type. Communication between Compiled Code and Interpreted Code; --------------------------------------------------------. In Clang-Repl there is **interpreted code**, and this feature adds a 'value'; runtime that can talk to the **compiled code**. Following is an example where the compiled code interacts with the interpreter; code. The execution results of an expression are stored in the object 'V' of;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11955,wrap,wraps,11955,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['wrap'],['wraps']
Integrability,"CERN/EP-SFT,\; Alja Mrak Tadel, UCSD/CMS,\; Axel Naumann, CERN/EP-SFT,\; Dante Niewenhuis, VU Amsterdam\; Luis Antonio Obis Aparicio, University of Zaragoza,; Ianna Osborne, Princeton University,\; Vincenzo Eduardo Padulano, CERN/EP-SFT,\; Danilo Piparo, CERN/EP-SFT,\; Fons Rademakers, CERN/IT,\; Jonas Rembser, CERN/EP-SFT,\; Andrea Rizzi, University of Pisa,\; Andre Sailer, CERN/EP-SFT,\; Garima Singh, ETH,\; Juraj Smiesko, CERN/RCS-PRJ-FC,; Pavlo Svirin, National Technical University of Ukraine,\; Maciej Szymanski, Argonne,\; Christian Tacke, Darmstadt University,\; Matevz Tadel, UCSD/CMS,\; Alvaro Tolosa Delgado, CERN/RCS-PRJ-FC,\; Devajith Valaparambil Sreeramaswamy, CERN/EP-SFT,\; Peter Van Gemmeren, Argonne,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/ATLAS,; Stefan Wunsch. ## Deprecation and Removal; - The RooFit legacy iterators are deprecated and will be removed in ROOT 6.34 (see section ""RooFit libraries""); - Some memory-unsafe RooFit interfaces were removed; - Some redundant **RooDataSet** constructors are deprecated and will be removed in ROOT 6.34.; Please use the RooDataSet constructors that take RooFit command arguments instead; - ROOT does not longer support Python 2. The minimum required Python version to build ROOT is 3.8.; - Support for wildcard imports like `from ROOT import *` is dropped from PyROOT; - Support for external (ie. non-builtin) libAfterImage is now deprecated and it will be removed in next release 6.34.; - The `TList::TList(TObject*)` constructor is deprecated and will be removed in ROOT 6.34; - The deprecated `TProofOutputList::TProofOutputList(TObject *o)` constructor was removed. ## Core Libraries. The Cling interpreter now relies on LLVM version 16. ## I/O Libraries. ### hadd respects compression settings. Fixed a bug that was previously changing the compression settings to a single digit number instead of the full value; (by default 101). ## TTree Libraries; ### Add files from subdirectories with `TChain::Add` g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:2314,interface,interfaces,2314,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability,"CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:1402,message,message,1402,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['message'],['message']
Integrability,"CMake cache variable. This exists for; # several reasons:; #; # * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single; # source of truth for which projects to build. This means we will ignore user; # supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite; # them.; #; # * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a; # non-empty list but now the user wishes to disable building all other projects; # by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still; # need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable; # building all the projects that were previously enabled.; set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL """"); mark_as_advanced(LLVM_ENABLE_PROJECTS_USED). if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL """"); set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:9038,message,message,9038,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"CROSSCOMPILE_HOST); # Dummy use to avoid CMake Warning: Manually-specified variables were not used; # (this is a variable that CrossCompile sets on recursive invocations); endif(). if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ); # special hack for Solaris to handle crazy system sys/regset.h; include_directories(""${LLVM_MAIN_INCLUDE_DIR}/llvm/Support/Solaris""); endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS ). # Make sure we don't get -rdynamic in every binary. For those that need it,; # use export_executable_symbols(target).; set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS """"). include(AddLLVM); include(TableGen). include(LLVMDistributionSupport). if( MINGW AND NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang"" ); # People report that -O3 is unreliable on MinGW. The traditional; # build also uses -O2 for that reason:; llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE ""-O3"" ""-O2""); endif(). if(LLVM_INCLUDE_TESTS); umbrella_lit_testsuite_begin(check-all); endif(). # Put this before tblgen. Else we have a circular dependence.; add_subdirectory(lib/Demangle); add_subdirectory(lib/Support); add_subdirectory(lib/TableGen). add_subdirectory(utils/TableGen). add_subdirectory(include). add_subdirectory(lib). if( LLVM_INCLUDE_UTILS ); add_subdirectory(utils/FileCheck); add_subdirectory(utils/PerfectShuffle); add_subdirectory(utils/count); add_subdirectory(utils/not); add_subdirectory(utils/UnicodeData); add_subdirectory(utils/yaml-bench); add_subdirectory(utils/split-file); # add_subdirectory(utils/mlgo-utils); if( LLVM_INCLUDE_TESTS ); add_subdirectory(${LLVM_THIRD_PARTY_DIR}/unittest ${CMAKE_CURRENT_BINARY_DIR}/third-party/unittest); endif(); else(); if ( LLVM_INCLUDE_TESTS ); message(FATAL_ERROR ""Including tests when not building utils will not work.; Either set LLVM_INCLUDE_UTILS to On, or set LLVM_INCLUDE_TESTS to Off.""); endif(); endif(). # Use LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION instead of LLVM_INCLUDE_UTILS because it is not really a util; if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:48834,depend,dependence,48834,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependence']
Integrability,"CXXLiteralIdentifier()`` to retrieve the corresponding; ``IdentifierInfo*`` pointing to the identifier. ``CXXUsingDirective``. The name is a C++ using directive. Using directives are not really; NamedDecls, in that they all have the same name, but they are; implemented as such in order to store them in DeclContext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists within some *declaration context*, such; as a translation unit, namespace, class, or function. Declaration contexts in; Clang are represented by the ``DeclContext`` class, from which the various; declaration-context AST nodes (``Translatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72380,depend,depending,72380,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depending']
Integrability,"Chain Monte Carlo was added in this; release. The MCMCCalculator is a concrete implementation of the; IntervalCalculator interface. To use it one needs to specify the ProposalFunction.; There is a base class for ProposalFunctions and one concrete implementation: UniformProposal.; Support for other proposal functions will be added in the next release.; The MCMCCalculator scans the space of the parameters of interest and nuisance parameters and; produces a Bayesian posterior. In this version, the prior must be added to the model initially,; otherwise a flat prior is assumed. The MCMCCalculator returns an MCMCInterval, which produces; the smallest interval by taking a contour of the posterior. This first version only supports; 1,2, and 3 dimensional intervals, but will be generalized in the next release. In addition to the MCMC implementation in RooStats, one can export their model and dataset into a workspace,; and then use the Bayesian Analysis Toolkit (BAT) for the MCMC. There is a wrapper available. Redesigned SPlot class; The RooStats SPlot implementation works with any RooAbsPdf. The class has been redesigned for more; convenient use. It also adds some helper functions to check that the sum of sWeights over species is 1 for each event and; the sum over events for a given species equals the yield for that species. Plotting classes; We have added new plotting classes: SamplingDistPlot and LikelihoodIntervalPlot.; In 1-d LikelihoodIntervalPlot shows the profile likelihood ratio and the upper/lower limits; of the interval for the parameter of interest. In 2-d, the LikelihoodIntervalPlot shows; the contour of the profile likelihood ratio for the parameters of interest. Bernstein Correction. BernsteinCorrection is a utility in RooStats to augment a nominal PDF; with a polynomial�; correction term. �This is useful for incorporating systematic variations; to the nominal PDF. �; The Bernstein basis polynomails are particularly appropriate because they; are positive defini",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:30513,wrap,wrapper,30513,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['wrap'],['wrapper']
Integrability,"Changes:; * Change the casting code to be const correct. Now, doing this is invalid:; const Value *V = ...;; Instruction *I = dyn_cast<Instruction>(V);; instead, the second line should be:; const Instruction *I = dyn_cast<Instruction>(V);. * Change the casting code to allow casting a reference value thus:; const Value &V = ...;; Instruction &I = cast<Instruction>(V);. dyn_cast does not work with references, because it must return a null pointer; on failure. * Fundamentally change how instructions and other values are represented.; Before, every llvm container was an instance of the ValueHolder template,; instantiated for each container type. This ValueHolder was effectively a; wrapper around a vector of pointers to the sub-objects. Now, instead of having a vector to pointers of objects, the objects are; maintained in a doubly linked list of values (ie each Instruction now has; Next & Previous fields). The containers are now instances of ilist (intrusive; linked list class), which use the next and previous fields to chain them; together. The advantage of this implementation is that iterators can be; formed directly from pointers to the LLVM value, and invalidation is much; easier to handle. * As part of the above change, dereferencing an iterator (for example:; BasicBlock::iterator) now produces a reference to the underlying type (same; example: Instruction&) instead of a pointer to the underlying object. This; makes it much easier to write nested loops that iterator over things, changing; this:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = (*BI)->begin(); II != (*BI)->end(); ++II); (*II)->dump();. into:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = BI->begin(); II != BI->end(); ++II); II->dump();. which is much more natural and what users expect. * Simplification of #include's: Before, it was necessary for a .cpp file to; include every .h file that it used.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt:686,wrap,wrapper,686,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,1,['wrap'],['wrapper']
Integrability,"Clang as a compiler; for an end-user, documenting the supported features, command line; options, etc. If you are interested in using Clang to build a tool that; processes code, please see :doc:`InternalsManual`. If you are interested in the; `Clang Static Analyzer <https://clang-analyzer.llvm.org>`_, please see its web; page. Clang is one component in a complete toolchain for C family languages.; A separate document describes the other pieces necessary to; :doc:`assemble a complete toolchain <Toolchain>`. Clang is designed to support the C family of programming languages,; which includes :ref:`C <c>`, :ref:`Objective-C <objc>`, :ref:`C++ <cxx>`, and; :ref:`Objective-C++ <objcxx>` as well as many dialects of those. For; language-specific information, please see the corresponding language; specific section:. - :ref:`C Language <c>`: K&R C, ANSI C89, ISO C90, ISO C94 (C89+AMD1), ISO; C99 (+TC1, TC2, TC3).; - :ref:`Objective-C Language <objc>`: ObjC 1, ObjC 2, ObjC 2.1, plus; variants depending on base language.; - :ref:`C++ Language <cxx>`; - :ref:`Objective C++ Language <objcxx>`; - :ref:`OpenCL Kernel Language <opencl>`: OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0,; and C++ for OpenCL 1.0 and 2021. In addition to these base languages and their dialects, Clang supports a; broad variety of language extensions, which are documented in the; corresponding language section. These extensions are provided to be; compatible with the GCC, Microsoft, and other popular compilers as well; as to improve functionality through Clang-specific features. The Clang; driver and language features are intentionally designed to be as; compatible with the GNU GCC compiler as reasonably possible, easing; migration from GCC to Clang. In most cases, code ""just works"".; Clang also provides an alternative driver, :ref:`clang-cl`, that is designed; to be compatible with the Visual C++ compiler, cl.exe. In addition to language specific features, Clang has a variety of; features that depend on what CPU architec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:1660,depend,depending,1660,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depending']
Integrability,"Clang must be a superset of; # {--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16} for this multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9372,interface,interfaces,9372,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interfaces']
Integrability,"Cling interprets C++; ====================. .. figure:: images/fig1.jpeg. **Cling** is an interactive C++ interpreter built on top of `Clang; <https://clang.llvm.org/>`_ and `LLVM <https://llvm.org/>`_. It uses LLVM's; *Just-In-Time* (`JIT <https://en.wikipedia.org/wiki/Just-in-time_compilation>`_); compiler to provide a fast and optimized compilation pipeline. Cling uses the; `read-eval-print-loop; <https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>`_; (**REPL**) approach, making rapid application development in C++ possible,; avoiding the classic edit-compile-run-debug cycle approach. Cling's last release, download instructions, dependencies, and any other useful; information for developers can be found on `Cling's GitHub webpage; <https://github.com/vgvassilev/cling>`_. Find out more about **Interpreting C++** on the `Compiler Research Group; <https://compiler-research.org/>`_'s webpage.; . Table of Contents; -----------------. .. toctree::; :numbered:; ; chapters/background; chapters/interactivity; chapters/why_interpreting; chapters/implementation; chapters/REPL; chapters/grammar; chapters/applications; chapters/conclusion; chapters/references; . .. note::. This project is under active development.; Cling has its documentation hosted on Read the Docs. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/index.rst:656,depend,dependencies,656,interpreter/cling/docs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/index.rst,1,['depend'],['dependencies']
Integrability,"Command Line; ============. Cling has its own command line, which looks like any other Unix shell. The; emacs-like command line editor is what we call interactive command line or; interactive shell. Once we start Cling it automatically includes several header files and its own; runtime universe. Thus it creates the minimal environment for the user to start. Grammar; -------. Cling is capable to parse everything that `Clang <https://clang.llvm.org/>`_ can; do. In addition, Cling can parse some interpreter-specific C++ extensions. Metaprocessor; -------------. Cling Metaprocessor provides convenient and easy to use interface for changing; the interpreter’s internal state or for executing handy commands. Cling provides; the following metaprocessor commands:. **syntax: .(command)**, where command is:. .. code:: bash. x filename.cxx; ; loads filename and calls void filename() if defined;. .. code:: bash. L library | filename.cxx; ; loads library or filename.cxx;. .. code:: bash. printAST; ; (DEBUG ONLY) shows the abstract syntax tree after each processed entity;. .. code:: bash. I path; ; adds an include path;. .. code:: bash. .@ . Cancels the multiline input;. .. code:: bash. .dynamicExtensions. Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and; the late resolving of the identifier. With that option cling tries to heal the; compile-time failed lookups at runtime.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/grammar.rst:621,interface,interface,621,interpreter/cling/docs/chapters/grammar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/grammar.rst,1,['interface'],['interface']
Integrability,"Core.js provide central function, which handles different kinds; of XMLHttpRequest. Use only async requests, also when getting file header.; 4. Fully reorganize data management in file/tree/directory/collection hierarchical; display. Now complete description collected in HPainter class and decoupled from; visualization, performed with dTree.js.; 5. Remove all global variables from the code.; 6. Automatic scripts/style loading handled via JSROOT.loadScript() function.; One can specify arbitrary scripts list, which asynchronously loaded by browser.; 7. Method to build simple GUI changed and more simplified :). The example in index.htm.; While loadScript and AssertPrerequisites functions moved to JSROOT, one; can easily build many different kinds of GUIs, reusing provided JSRootCore.js functions.; 8. In example.htm also use AssertPrerequisites to load necessary scripts.; This helps to keep code up-to-date even by big changes in JavaScript code.; 9. Provide monitoring of online THttpServer with similar interface as for ROOT files.; 10. Fix several errors in TKey Streamer, use member names as in ROOT itself.; 11. Keep the only version identifier JSROOT.version for JS code; 12. One can specify in JSROOT.AssertPrerequisites functionality which is required.; One could specify '2d', 'io' (default) or '3d'.; 13. Use new AssertPrerequisites functionality to load only required functionality.; 14. When displaying single element, one could specify draw options and monitor property like:; <http://localhost:8080/Files/job1.root/hpxpy/draw.htm?opt=col&monitor=2000>; Such link is best possibility to integrate display into different HTML pages,; using `<iframe/>` tag like:; `<iframe src=""http://localhost:8080/Files/job1.root/hpx/draw.htm""`; `style=""width: 800px; height:600px""></iframe>`; 15. Remove 'JSROOTIO.' prefix from _typename. Now real class name is used.; 16. Use in all scripts JSROOT as central 'namespace'; 17. Introduce context menu in 3D, use it for switch between 2D/3D modes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:74990,interface,interface,74990,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['interface'],['interface']
Integrability,"Create Diff*.; * Select the review you want to from the *Attach To* dropdown and click; *Continue*.; * Leave the Repository field blank. (We previously filled out the Repository; for the review request.); * Add comments about the changes in the new diff. Click *Save*. Choosing reviewers: You typically pick one or two people as initial reviewers.; This choice is not crucial, because you are merely suggesting and not requiring; them to participate. Many people will see the email notification on cfe-commits; or llvm-commits, and if the subject line suggests the patch is something they; should look at, they will. .. _creating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:5479,interface,interface,5479,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"D"");; // The writer creates a page sink and connects the model's fields to it; auto writer = RNTupleWriter::Append(std::move(model), ""ntpl"", *file);; *ptrPt = 1.0;; // Append the model's default entry; writer->Fill();; // Commit the dataset by destructing the writer; writer.reset();; ```. The points on object type-safety and ownership apply in the same way as for reading data. Creation of the RNTuple model can use runtime type information:. ```c++; auto model = RNTupleModel::Create();; model->AddField(RFieldBase::Create(""pt"", ""float"").Unwrap());; ```. Main Classes; ------------. ### RNTuple; The RNTuple class contains the information of the RNTuple anchor in a ROOT file (see specification).; It has a dictionary and is streamed through the standard ROOT I/O.; An RNTuple object represents an RNTuple dataset but it is not the dataset itself.; It can be used like a token to open the actual RNTuple dataset with, e.g., RDF or an RNTupleReader,; and it provides the `Merge(...)` interface for the `TFileMerger`. ### RPageSource / Sink; The page source and sink can read and write pages and clusters from and to a storage backend.; There are concrete class implementations for an RNTuple stored in a ROOT file (local or remote), and for an RNTuple stored in a DAOS object store.; There is a virtual page sink for buffered writes, which also groups pages of the same column before flushing them to disk.; There is a virtual page source for aligned friend datasets (horizontal data combination). Page sources and sinks do not operate entry-based but based on pages/indices of columns.; For instance, there is no API in the page sink to write an entry, but only to write pages of columns.; The higher-level APIs, e.g. `RField`, `REntry`, `RNTupleWriter`, take care of presenting the available data as entries where necessary. The page source also gives access to an `RNTupleDescriptor` through a read/write lock guard.; The `RNTupleDescriptor` owned by the page source changes only when new cluster",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:5679,interface,interface,5679,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"D**:STRING; Semicolon-separated list of targets to build, or *all* for building all; targets. Case-sensitive. Defaults to *all*. Example:; ``-DLLVM_TARGETS_TO_BUILD=""X86;PowerPC""``.; The full list, as of March 2023, is:; ``AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;LoongArch;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;VE;WebAssembly;X86;XCore``. **LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler version check will only warn when using a toolchain; which is about to be deprecated, instead of emitting an error. **LLVM_UBSAN_FLAGS**:STRING; Defines the set of compile flags used to enable UBSan. Only used if; ``LLVM_USE_SANITIZER`` contains ``Undefined``. This can be used to override; the default set of UBSan flags. **LLVM_USE_INTEL_JITEVENTS**:BOOL; Enable building support for Intel JIT Events API. Defaults to OFF. **LLVM_USE_LINKER**:STRING; Add ``-fuse-ld={name}`` to the link invocation. The possible value depend on; your compiler, for clang the value can be an absolute path to your custom; linker, otherwise clang will prefix the name with ``ld.`` and apply its usual; search. For example to link LLVM with the Gold linker, cmake can be invoked; with ``-DLLVM_USE_LINKER=gold``. **LLVM_USE_OPROFILE**:BOOL; Enable building OProfile JIT support. Defaults to OFF. **LLVM_USE_PERF**:BOOL; Enable building support for Perf (linux profiling tool) JIT support. Defaults to OFF. **LLVM_USE_RELATIVE_PATHS_IN_FILES**:BOOL; Rewrite absolute source paths in sources and debug info to relative ones. The; source prefix can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_RELATIVE_PATHS_IN_DEBUG_INFO**:BOOL; Rewrite absolute source paths in debug info to relative ones. The source prefix; can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_SANITIZER**:STRING; Define the sanitizer used to build LLVM binaries and tests. Possible values; are ``Address``, ``Memory``, ``MemoryWithOrigins``, ``Undefined``, ``Thread``,; ``DataFlow``, and ``Address;Undefi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:35403,depend,depend,35403,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['depend']
Integrability,"D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1; [12] .llvm.offloading PROGBITS 0000000000000000 000260 030950 00 E 0 0 8. Compiling this file again will invoke the ``clang-linker-wrapper`` utility to; extract and link the device code stored at the section named; ``.llvm.offloading`` and then use entries stored in; the section named ``omp_offloading_entries`` to create the symbols necessary for; ``libomptarget`` to register the device image and call the entry function. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 zaxpy.o -o zaxpy; $ ./zaxpy. We can see the steps created by clang to generate the offloading code using the; ``-ccc-print-phases`` option in Clang. This matches the description in; :ref:`Offloading Overview`. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -ccc-print-phases zaxpy.cpp; # ""x86_64-unknown-linux-gnu"" - ""clang"", inputs: [""zaxpy.cpp""], output: ""/tmp/zaxpy-host.bc""; # ""nvptx64-nvidia-cuda"" - ""clang"", inputs: [""zaxpy.cpp"", ""/tmp/zaxpy-e6a41b.bc""], output: ""/tmp/zaxpy-07f434.s""; # ""nvptx64-nvidia-cuda"" - ""NVPTX::Assembler"", inputs: [""/tmp/zaxpy-07f434.s""], output: ""/tmp/zaxpy-0af7b7.o""; # ""x86_64-unknown-linux-gnu""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:22978,wrap,wrapper,22978,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapper']
Integrability,D; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163193,contract,contract-attribute-specifiers,163193,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['contract'],['contract-attribute-specifiers']
Integrability,"DD_GTEST(testTFormula test_TFormula.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTKDE test_tkde.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTH1FindFirstBinAbove test_TH1_FindFirstBinAbove.cxx LIBRARIES Hist); ROOT_ADD_GTEST(test_TEfficiency test_TEfficiency.cxx LIBRARIES Hist); ROOT_ADD_GTEST(TGraphMultiErrorsTests TGraphMultiErrorsTests.cxx LIBRARIES Hist RIO); ROOT_ADD_GTEST(test_TF123_Moments test_TF123_Moments.cxx LIBRARIES Hist); ROOT_ADD_GTEST(test_THBinIterator test_THBinIterator.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTMultiGraphGetHistogram test_TMultiGraph_GetHistogram.cxx LIBRARIES Hist Gpad); ROOT_ADD_GTEST(testMapCppName test_MapCppName.cxx LIBRARIES Hist Gpad); ROOT_ADD_GTEST(testTGraphSorting test_TGraph_sorting.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testSpline test_spline.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTF1Simple test_tf1_simple.cxx LIBRARIES Hist RIO). if(fftw3); ROOT_ADD_GTEST(testTF1 test_tf1.cxx LIBRARIES Hist); endif(). ROOT_ADD_GTEST(testTF2 test_tf2.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTF3 test_tf3.cxx LIBRARIES Hist). ROOT_ADD_GTEST(testTH1sa test_TH1_SaveAs.cxx LIBRARIES Hist). if(clad); ROOT_ADD_GTEST(TFormulaGradientTests TFormulaGradientTests.cxx LIBRARIES Core MathCore Hist); ROOT_ADD_GTEST(TFormulaHessianTests TFormulaHessianTests.cxx LIBRARIES Core MathCore Hist); endif(). # Regression test for https://github.com/root-project/root/issues/13691; # The test needs the following to be actually useful:; # - It must be compiled and run as a standalone executable, as it depends on; # gROOT not being initialized yet.; # - It must link to any library that is not in `core`. See the linked issue; # for details.; ROOT_EXECUTABLE(tdirectoryfile_destructor_segfault tdirectoryfile_destructor_segfault.cxx LIBRARIES RIO Hist); ROOT_ADD_TEST(test-tdirectoryfile_destructor_segfault COMMAND tdirectoryfile_destructor_segfault). # Test for https://github.com/root-project/root/issues/6658; ROOT_ADD_GTEST(test_projections test_projections.cxx LIBRARIES Hist); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/CMakeLists.txt:2366,depend,depends,2366,hist/hist/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/CMakeLists.txt,1,['depend'],['depends']
Integrability,"DG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation. .. image:: uml_builder_pattern.png. Notice that the common code for building the two types of graphs are; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``Depende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:2876,depend,dependencies,2876,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependencies']
Integrability,"DIR}); set(CLANG_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}). if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed. ""; ""Please create a directory and run cmake ""; ""from there, passing the path to this source directory as the last argument. ""; ""This process created the file `CMakeCache.txt' and the directory ""; ""`CMakeFiles'. Please delete them.""); endif(). # If CLANG_VERSION_* is specified, use it, if not use LLVM_VERSION_*.; if(NOT DEFINED CLANG_VERSION_MAJOR); set(CLANG_VERSION_MAJOR ${LLVM_VERSION_MAJOR}); endif(); if(NOT DEFINED CLANG_VERSION_MINOR); set(CLANG_VERSION_MINOR ${LLVM_VERSION_MINOR}); endif(); if(NOT DEFINED CLANG_VERSION_PATCHLEVEL); set(CLANG_VERSION_PATCHLEVEL ${LLVM_VERSION_PATCH}); endif(); if(NOT DEFINED CLANG_VERSION_SUFFIX); set(CLANG_VERSION_SUFFIX ${LLVM_VERSION_SUFFIX}); endif(); set(CLANG_VERSION ""${CLANG_VERSION_MAJOR}.${CLANG_VERSION_MINOR}.${CLANG_VERSION_PATCHLEVEL}${CLANG_VERSION_SUFFIX}""); message(STATUS ""Clang version: ${CLANG_VERSION}""). # Configure the Version.inc file.; configure_file(; ${CMAKE_CURRENT_SOURCE_DIR}/include/clang/Basic/Version.inc.in; ${CMAKE_CURRENT_BINARY_DIR}/include/clang/Basic/Version.inc). # Add appropriate flags for GCC; if (LLVM_COMPILER_IS_GCC_COMPATIBLE); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-common -Woverloaded-virtual""); if (NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-strict-aliasing""); endif (). # Enable -pedantic for Clang even if it's not enabled for LLVM.; if (NOT LLVM_ENABLE_PEDANTIC); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pedantic -Wno-long-long""); endif (). check_cxx_compiler_flag(""-Werror -Wnested-anon-types"" CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG); if( CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG ); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-nested-anon-types"" ); endif(); endif (). # Determine HOST_LINK_VERSION on Darwin.; set(HOST_LINK_VERSION); if (APPLE AND NOT CMAKE_LINK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:11941,message,message,11941,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"DLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via github): Fix file corruption in `TTeXDump::DrawPolyMarker`; The current implementation of `TTeXDump` uses `TVirtualPS::PrintFast` based methods; to output TeX markup with automatic line-wraps. Yet these methods are optimized for; PostScript format where there are a lot of space characters that are used for newline; placement. Current `TTeXDump::DrawPolyMarker` would often produce a long contiguous lines; that trigger a forceful linewrap that can happen in the middle of real number constant; (ignored by latex) or even in the middle of latex command (producing incorrect file).; One solution would be to rewrite TTeXDump using only `PrintRaw` (that you can't mix; with `PrintStr/PrintFast/WriteReal`). The other would be to fix `PrintFast` to not; introduce forced newline. The third option is less intrusive and just adds additional; spaces to provide clues for the proper line wrapping (this is the one implemented in; this change). ### TLatex. Make sure the line width used to draw `#sqrt` is always >= 1. When a global text alignment was set the `TLatex`characters `#minus`, `#plus`,; `#mp`, `#hbar`, and `#backslash` were mis-aligned. The following macro demonstrate; the problem:. ``` {.cpp}; {; gStyle->SetTextAlign(22);; TLatex t(.5,.5,""#minus100 #mp100 #plus100 #hbar #backslash"");; t.Draw();; }; ```. The angle of a `TLatex` object was set to 0 if the `GetYsize` method was called. ### TColor. New palette `kViridis`. It was presented at SciPy2015 by Stéfan van der Walt and; Nathaniel Smith. It is now matplotlib's current default color map. ![Viridis](palette_112.png). ### TMultiGraph. Ignore empty graphs when computing the multi-graph range at painting time. ### TASImage. A left click on a image produced a one pixel zoom. ### TCreatePrimitives. The ending of a polyline creation is based on the closeness of the two last; entered points.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:16007,wrap,wrapping,16007,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['wrap'],['wrapping']
Integrability,"D_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88470,message,message,88470,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['message']
Integrability,"Data pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Result;; }. int main() {; std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8635,depend,dependent,8635,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"Date: Sat, 18 Nov 2000 09:19:35 -0600 (CST); From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: a few thoughts. I've been mulling over the virtual machine problem and I had some; thoughts about some things for us to think about discuss:. 1. We need to be clear on our goals for the VM. Do we want to emphasize; portability and safety like the Java VM? Or shall we focus on the; architecture interface first (i.e., consider the code generation and; processor issues), since the architecture interface question is also; important for portable Java-type VMs?. This is important because the audiences for these two goals are very; different. Architects and many compiler people care much more about; the second question. The Java compiler and OS community care much more; about the first one. Also, while the architecture interface question is important for; Java-type VMs, the design constraints are very different. 2. Design issues to consider (an initial list that we should continue; to modify). Note that I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:429,interface,interface,429,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,3,['interface'],['interface']
Integrability,"Date: Sun, 19 Nov 2000 16:23:57 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram Adve <vadve@cs.uiuc.edu>; Subject: Re: a few thoughts. Okay... here are a few of my thoughts on this (it's good to know that we; think so alike!):. > 1. We need to be clear on our goals for the VM. Do we want to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:403,interface,interface,403,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,2,['interface'],['interface']
Integrability,"Date: Tue, 13 Feb 2001 13:29:52 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: LLVM Concerns... I've updated the documentation to include load store and allocation; instructions (please take a look and let me know if I'm on the right; track):. file:/home/vadve/lattner/llvm/docs/LangRef.html#memoryops. I have a couple of concerns I would like to bring up:. 1. Reference types; Right now, I've spec'd out the language to have a pointer type, which; works fine for lots of stuff... except that Java really has; references: constrained pointers that cannot be manipulated: added and; subtracted, moved, etc... Do we want to have a type like this? It; could be very nice for analysis (pointer always points to the start of; an object, etc...) and more closely matches Java semantics. The; pointer type would be kept for C++ like semantics. Through analysis,; C++ pointers could be promoted to references in the LLVM; representation. 2. Our ""implicit"" memory references in assembly language:; After thinking about it, this model has two problems:; A. If you do pointer analysis and realize that two stores are; independent and can share the same memory source object, there is; no way to represent this in either the bytecode or assembly.; B. When parsing assembly/bytecode, we effectively have to do a full; SSA generation/PHI node insertion pass to build the dependencies; when we don't want the ""pinned"" representation. This is not; cool.; I'm tempted to make memory references explicit in both the assembly and; bytecode to get around this... what do you think?. -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-Memory.txt:1412,depend,dependencies,1412,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-Memory.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-Memory.txt,1,['depend'],['dependencies']
Integrability,"Date: Wed, 31 Jan 2001 12:04:33 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:798,depend,dependent,798,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['depend'],['dependent']
Integrability,"Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34.; They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. - `RooAbsArg::clientIterator()`: use `clients()` and `begin()`, `end()` or range-based loops instead; - `RooAbsArg::valueClientIterator()`: use `valueClients()`; - `RooAbsArg::shapeClientIterator()`: use `shapeClients()`; - `RooAbsArg::serverIterator()`: use `servers()`; - `RooAbsArg::valueClientMIterator()`: use `valueClients()`; - `RooAbsArg::shapeClientMIterator()`: use `shapeClients()`; - `RooAbsArg::serverMIterator()`: use `servers()`. - `RooAbsCollection::createIterator()`: use `begin()`, `end()` and range-based for loops; - `RooAbsCollection::iterator()`: same; - `RooAbsCollection::fwdIterator()`: same. - `RooWorkspace::componentIterator()`: use `RooWorkspace::components()` with range-based loop. ### Deprecation of legacy test statistics classes in public interface. Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. * RooAbsTestStatistic; * RooAbsOptTestStatistic; * RooNLLVar; * RooChi2Var; * RooXYChi2Var. Please use the higher-level functions `RooAbsPdf::createNLL()` and `RooAbsPdf::createChi2()` if you want to create objects that represent test statistics. ### Change of RooParamHistFunc. The `RooParamHistFunc` didn't take any observable `RooRealVar` as constructor; argument. It assumes as observable the internal variables in the passed; RooDataHist. This means it was in most contexts unusable, because the input; can't be changed, other than loading a different bin in the dataset. Furthermore, there was actually a constructor that took a `RooAbsArg x`, but it; was simply ignored. To fix all these problems, the existing constructors were replaced by a new one; that takes the observable explicitly. Since the old constructors resu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:12751,interface,interface,12751,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interface']
Integrability,"DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21751,interface,interface,21751,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"E ""${CLANG_VENDOR} clang""); else(); set(TOOL_INFO_NAME ""clang""); endif(). set(TOOL_INFO_UTI ""${CLANG_VENDOR_UTI}""); set(TOOL_INFO_VERSION ""${CLANG_VERSION}""); set(TOOL_INFO_BUILD_VERSION ""${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}""). set(TOOL_INFO_PLIST_OUT ""${CMAKE_CURRENT_BINARY_DIR}/${TOOL_INFO_PLIST}""). if(LLVM_TOOL_LLVM_DRIVER_BUILD AND clang IN_LIST LLVM_DRIVER_TOOLS); set(TARGET_NAME llvm-driver); else(); set(TARGET_NAME clang); endif(). target_link_libraries(${TARGET_NAME}; PRIVATE; ""-Wl,-sectcreate,__TEXT,__info_plist,\""${TOOL_INFO_PLIST_OUT}\""""); configure_file(""${TOOL_INFO_PLIST}.in"" ""${TOOL_INFO_PLIST_OUT}"" @ONLY). set(TOOL_INFO_UTI); set(TOOL_INFO_NAME); set(TOOL_INFO_VERSION); set(TOOL_INFO_BUILD_VERSION); endif(). if(CLANG_ORDER_FILE AND; (LLVM_LINKER_IS_APPLE OR LLVM_LINKER_IS_GOLD OR LLVM_LINKER_IS_LLD)); include(LLVMCheckLinkerFlag). if (LLVM_LINKER_IS_APPLE OR (LLVM_LINKER_IS_LLD AND APPLE)); set(LINKER_ORDER_FILE_OPTION ""-Wl,-order_file,${CLANG_ORDER_FILE}""); elseif (LLVM_LINKER_IS_GOLD); set(LINKER_ORDER_FILE_OPTION ""-Wl,--section-ordering-file,${CLANG_ORDER_FILE}""); elseif (LLVM_LINKER_IS_LLD); set(LINKER_ORDER_FILE_OPTION ""-Wl,--symbol-ordering-file,${CLANG_ORDER_FILE}""); endif(). # This is a test to ensure the actual order file works with the linker.; llvm_check_linker_flag(CXX ${LINKER_ORDER_FILE_OPTION} LINKER_ORDER_FILE_WORKS). # Passing an empty order file disables some linker layout optimizations.; # To work around this and enable workflows for re-linking when the order file; # changes we check during configuration if the file is empty, and make it a; # configuration dependency.; file(READ ${CLANG_ORDER_FILE} ORDER_FILE LIMIT 20); if(""${ORDER_FILE}"" STREQUAL ""\n""); set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS ${CLANG_ORDER_FILE}); elseif(LINKER_ORDER_FILE_WORKS); target_link_libraries(clang PRIVATE ${LINKER_ORDER_FILE_OPTION}); set_target_properties(clang PROPERTIES LINK_DEPENDS ${CLANG_ORDER_FILE}); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/CMakeLists.txt:2985,depend,dependency,2985,interpreter/llvm-project/clang/tools/driver/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"E OWNER_READ; GROUP_EXECUTE GROUP_READ; WORLD_EXECUTE WORLD_READ; COMPONENT applications); endforeach(). install(FILES python/cmdLineUtils.py DESTINATION ${runtimedir}); if(IS_ABSOLUTE ${runtimedir}); set(absruntimedir ${runtimedir}); else(); set(absruntimedir \${CMAKE_INSTALL_PREFIX}/${runtimedir}); endif(); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -m py_compile \$ENV{DESTDIR}${absruntimedir}/cmdLineUtils.py)""); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -O -m py_compile \$ENV{DESTDIR}${absruntimedir}/cmdLineUtils.py)""); configure_file(python/cmdLineUtils.py ${localruntimedir}/cmdLineUtils.py @ONLY). set_source_files_properties(src/rootcling.cxx PROPERTIES; COMPILE_FLAGS ""${CLING_CXXFLAGS}""; VISIBILITY_INLINES_HIDDEN ""ON""; ). ROOT_EXECUTABLE(rootcling src/rootcling.cxx LIBRARIES RIO Cling Core Rint). # rootcling includes the ROOT complex header which would build the complex; # dictionary with modules. To make sure that rootcling_stage1 builds this; # dict before we use it, we add a dependency here.; add_dependencies(rootcling complexDict). target_include_directories(rootcling PRIVATE; ${CMAKE_SOURCE_DIR}/core/metacling/res; ${CMAKE_SOURCE_DIR}/core/dictgen/res; ${CMAKE_SOURCE_DIR}/io/rootpcm/res); set_property(TARGET rootcling PROPERTY ENABLE_EXPORTS 1); if(WIN32); set_target_properties(rootcling PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1); set_property(TARGET rootcling APPEND_STRING PROPERTY LINK_FLAGS "" -STACK:4000000""); endif(). # Create aliases: rootcint, genreflex.; if(WIN32); add_custom_command(TARGET rootcling POST_BUILD; COMMAND copy /y rootcling.exe rootcint.exe; COMMAND copy /y rootcling.exe genreflex.exe; WORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}); else(); add_custom_command(TARGET rootcling POST_BUILD; COMMAND ln -f rootcling rootcint; COMMAND ln -f rootcling genreflex; WORKING_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}); endif(); set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES; ""${CMAKE_RUNTIME",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/CMakeLists.txt:3939,depend,dependency,3939,main/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/CMakeLists.txt,1,['depend'],['dependency']
Integrability,ECUTABLE(testPyAdaBoostMulticlass testPyAdaBoostMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Multiclass COMMAND testPyAdaBoostMulticlass DEPENDS PyMVA-GTB-Multiclass). endif(PY_SKLEARN_FOUND). # Enable tests based on available python modules; if(PY_TORCH_FOUND); configure_file(generatePyTorchModelClassification.py generatePyTorchModelClassification.py COPYONLY); configure_file(generatePyTorchModelMulticlass.py generatePyTorchModelMulticlass.py COPYONLY); configure_file(generatePyTorchModelRegression.py generatePyTorchModelRegression.py COPYONLY); configure_file(generatePyTorchModels.py generatePyTorchModels.py COPYONLY); # Test PyTorch: Binary classification. if (PY_SKLEARN_FOUND); set(PyMVA-Torch-Classification-depends PyMVA-AdaBoost-Classification); set(PyMVA-Torch-Multiclass-depends PyMVA-AdaBoost-Multiclass); endif(). ROOT_EXECUTABLE(testPyTorchClassification testPyTorchClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Classification COMMAND testPyTorchClassification DEPENDS ${PyMVA-Torch-Classification-depends}). # Test PyTorch: Regression; ROOT_EXECUTABLE(testPyTorchRegression testPyTorchRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Regression COMMAND testPyTorchRegression). # Test PyTorch: Multi-class classification; ROOT_EXECUTABLE(testPyTorchMulticlass testPyTorchMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Torch-Multiclass COMMAND testPyTorchMulticlass DEPENDS ${PyMVA-Torch-Multiclass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:3044,depend,depends,3044,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,1,['depend'],['depends']
Integrability,"ERAGE_LINK_FLAGS ""-fprofile-arcs""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHAREDLINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS ""${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); endif(). #--- Enable build timing -----------------------------------------------------------------------; if (build_timing); # FIXME: This currently will override the use of ccache if -Dbuild_timing=On -Dccache=On is passed.; set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""${CMAKE_COMMAND} -E time""); set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ""${CMAKE_COMMAND} -E time""); #set_property(GLOBAL PROPERTY RULE_LAUNCH_CUSTOM ""${CMAKE_COMMAND} -E time""); endif(). #--- Set up address sanitizer builds ----------------------------------------------------------; if(asan); if(NOT CMAKE_COMPILER_IS_GNUCXX AND NOT CMAKE_CXX_COMPILER_ID MATCHES Clang); message(WARNING ""Address sanitizer builds only tested with gcc and Clang""); endif(). if(NOT MSVC); set(ASAN_EXTRA_LD_PRELOAD ""${CMAKE_BINARY_DIR}/lib/${CMAKE_SHARED_LIBRARY_PREFIX}ROOTSanitizerConfig${CMAKE_SHARED_LIBRARY_SUFFIX}:${ASAN_RUNTIME_LIBRARY}""); endif(). foreach(item IN LISTS ASAN_EXTRA_CXX_FLAGS); add_compile_options($<$<COMPILE_LANGUAGE:CXX>:${item}>); endforeach(); #add_link_options() not available in our CMake version:; set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} ${ASAN_EXTRA_SHARED_LINKER_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${ASAN_EXTRA_EXE_LINKER_FLAGS}""); endif(). #---Enable CTest package -----------------------------------------------------------------------; #include(CTest); if(testing); enable_testing(); endif(). #---Here we look for installed software and switch on and of the different build options--------; include(SearchInstalledSoftware). #---Here we add tcmalloc to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:11465,message,message,11465,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"ETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_returns_retained); #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained)); #else; #define NS_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSString*) returnsRetained NS_RETURNS_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:4537,interface,interface,4537,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['interface'],['interface']
Integrability,"ET_TRIPLE DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGET_TRIPLE); #---Get back the potentially updated LLVM_TARGETS_TO_BUILD (expanding all/host/Native)---------------; get_directory_property(LLVM_TARGETS_TO_BUILD DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGETS_TO_BUILD). if(MSVC); if(CMAKE_GENERATOR MATCHES Ninja); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen.exe""); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/$<CONFIG>/bin/llvm-tblgen.exe""); endif(); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen""); endif(); else(); # Rely on llvm-config.; set(CONFIG_OUTPUT); find_program(LLVM_CONFIG NAMES ""llvm-config-${ROOT_LLVM_VERSION_REQUIRED_MAJOR}"" ""llvm-config""); if(LLVM_CONFIG); message(STATUS ""Found LLVM_CONFIG as ${LLVM_CONFIG}""); set(CONFIG_COMMAND ${LLVM_CONFIG}; ""--assertion-mode""; ""--bindir""; ""--libdir""; ""--includedir""; ""--prefix""; ""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:12654,message,message,12654,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,4,['message'],['message']
Integrability,"Eduardo Padulano, CERN/SFT and UPV,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Jonas Rembser, CERN/SFT,\; Andrea Sciandra, SCIPP-UCSC/Atlas, \; Oksana Shadura, UNL/CMS,\; Enric Tejedor Saavedra, CERN/SFT,\; Christian Tacke, GSI, \; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Stefan Wunsch, CERN/SFT,\; Anirudh Dagar, CERN-HSF/GSoC. ## Deprecation and Removal. - [`RooAbsReal::evaluateBatch()`](https://root.cern/doc/v624/classRooAbsReal.html#a261580dfe94f2b107f9b9a77cad78a62) has been removed in favour of the faster evaluateSpan(). See section ""RooFit Libraries"" for instructions on how to use [`RooAbsReal::evaluateSpan()`](https://root.cern/doc/v624/classRooAbsReal.html#a1e5129ffbc63bfd04c01511fd354b1b8).; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` has been deprecated in favour of `TTreeProcessorMT::SetTasksPerWorkerHint`. ## Core Libraries. Due to internal changes required to comply with the deprecation of Intel TBB's `task_scheduler_init` and related; interfaces in recent TBB versions, as of v6.24 ROOT will not honor a maximum concurrency level set with; `tbb::task_scheduler_init` but will require instead the usage of `tbb::global_control`:. ```cpp; //tbb::task_scheduler_init init(2); // does not affect the number of threads ROOT will use anymore. tbb::global_control c(tbb::global_control::max_allowed_parallelism, 2);; ROOT::TThreadExecutor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; ```. Note that the preferred way to steer ROOT's concurrency level is still through; [`ROOT::EnableImplicitMT`](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f); or by passing the appropriate parameter to executors' constructors, as in; [`TThreadExecutor::TThreadExecutor`](https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html#ac7783d52c56cc7875d3954cf212247bb). See the discussion at [ROOT-11014](https://sft.its.cern.ch/jira",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:1913,interface,interfaces,1913,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['interface'],['interfaces']
Integrability,"Eigen` |; +------------------------------+-----------+------------------------------------+. Below, usage of the eigenvalue class is shown in an example where it is; checked that the square of the singular values of a matrix; $c$ are identical to the eigenvalues; of $c^{T}$. $c$:. ``` {.cpp}; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:49966,depend,dependence,49966,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['depend'],['dependence']
Integrability,"Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:12058,protocol,protocols,12058,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['protocol'],['protocols']
Integrability,"FIG_FILE}); endif(); if (NOT CLANG_INCLUDE_DIRS); set (CLANG_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/tools/clang/include""); if (NOT EXISTS ${CLANG_INCLUDE_DIRS}); # Otherwise assume the monorepo layout.; set (CLANG_INCLUDE_DIRS ${LLVM_MAIN_SRC_DIR}/../clang/include ); endif(); set (CLANG_INCLUDE_DIRS ""${CLANG_INCLUDE_DIRS}""; ""${LLVM_BINARY_DIR}/tools/clang/include""); endif(); if (NOT LLVM_INCLUDE_DIRS); set (LLVM_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/include"" ""${LLVM_BINARY_DIR}/include""); endif(); endif(). if( NOT ""NVPTX"" IN_LIST LLVM_TARGETS_TO_BUILD); message(FATAL_ERROR ""NVPTX backend is not activated\n""; ""Please enable it via -DLLVM_TARGETS_TO_BUILD=\""host;NVPTX\""""); endif(). set(CLING_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}); set(CLING_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}); set(LLVM_TOOLS_BINARY_DIR ""${LLVM_BINARY_DIR}/bin""); if(DEFINED CLING_ROOT_BUILD); set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ""${LLVM_TOOLS_BINARY_DIR}""); endif(). if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed. CMake would overwrite ""; ""the makefiles distributed with LLVM. Please create a directory and run cmake ""; ""from there, passing the path to this source directory as the last argument. ""; ""This process created the file `CMakeCache.txt' and the directory ""; ""`CMakeFiles'. Please delete them.""); endif(). # From ROOT:; function(cling_add_cxx_flag var flag); string(REGEX REPLACE ""[-.+/:= ]"" ""_"" flag_esc ""${flag}""); CHECK_CXX_COMPILER_FLAG(""${flag}"" CXX_HAS${flag_esc}); if(CXX_HAS${flag_esc}); set(${var} ""${${var}} ${flag}"" PARENT_SCOPE); endif(); endfunction(). if(CLING_ENABLE_WARNINGS AND NOT LLVM_ENABLE_WARNINGS AND (LLVM_COMPILER_IS_GCC_COMPATIBLE OR CLANG_CL)); # from HandleLLCMOptions.cmake:; append(""-Wall -W -Wno-unused-parameter -Wwrite-strings"" CMAKE_C_FLAGS CMAKE_CXX_FLAGS); append(""-Wcast-qual"" CMAKE_CXX_FLAGS). # Turn off missing field initializer warnings for gcc to avoid noise from; # false positives with empty {}. Tu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:5156,message,message,5156,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['message'],['message']
Integrability,"FIx; a few issues in libXrdProofd.so with handling of connection used for; admin operation: this should solve some cases where the daemon was not; responding. ; Fix a few memory leaks showing up when; running several queries in the same session; Fix a few issues affecting the new sub-merging option; Fix an issue preventing proper real-time notification; during VerifyDataSet; Fix an issue with TQueryResult ordering (was causing; random 'stressProof' failures); Fix; an issue with TProof::AskStatistics (fBytesRead, fRealTime and fCpuTime; were not correctly filled on the client; the values on the master,; displayed by TProof::Print were correct).; Fix several small issues affecting the handling of global; package directories; Fix an issue with socket handling in the main event-loop; while sendign or receiving files via TProofMgr.; Fix; a problem counting valid nodes in sequential or 'masteronly' mode,; generating the fake error message ""GoParallel: attaching to candidate!""; Fix a few issues with the length of Unix socket paths; affecting PROOF-Lite and xproofd on MacOsX ; Fix an issue with the release of file descriptors when; recovering sessions .; Fix an issue with a fake error message (""Error in; <TROOT::cd>: No such file root:/"") in PROOF-Lite when; issuing TProof::SetParallel().; Fix a problem with negative values for 'workers still; sending' in PROOF-Lite .; Fix locking issue while building packages locally.; Fix issue setting permission and ownership of the dataset; user directories.Fix; a subtle bug affecting the (possibly rare) case when not all entries; are required and # entries does not correspond to an complete subset of; files (e.g. # entries = 1001000 with files of 100000 entries each). The; effect was uncomplete processing (skipped events, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:10492,message,message,10492,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['message'],['message']
Integrability,"Fail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32277,wrap,wrapping,32277,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapping']
Integrability,"File (#208); 3. Fix TGraph tooltips handling; 4. Fix TH2Poly tooltips handling. ## Changes in 6.0.0; 1. Major release with:; - incompatible changes in API; - heavy use of Promise class; - upgrade all used packages; 2. Use generic naming convention - all class names always starts from; capital letter like ""ObjectPainter"", all function names starts from small; letter like ""painter.getObjectHint()""; 3. Rename JSRootCore.js -> JSRoot.core.js, eliminate all URL parameters.; Loading of extra JSROOT functionality should be done via JSROOT.require() method; All other scripts uses similar naming convention.; 4. JSROOT.draw()/JSROOT.redraw() functions returns Promise, deprecate callback parameter; 5. Introduce JSROOT.httpRequest() function which returns Promise instance, deprecate; JSROOT.NewHttpRequest() function; 6. JSROOT.openFile() returns Promise with file instance, deprecate callback parameter; 7. Provide new code loader via JSROOT.require(); - introduces clean dependencies in JSROOT code; - by default uses plain script loading emulating require.js behavior; - can use require.js when available; - uses require() method when running inside node.js; - supports openui5 sap.ui.require loader if available before JSRoot.core.js; - deprecates old JSROOT.AssertPrerequisites() function; 8. Upgrade d3.js to v6.1.1, skip support of older versions; 9. Upgrade three.js to r121:; - SoftwareRenderer deprecated and removed; - let use WebGL for browser, batch and node.js (via headless-gl); - support r3d_gl, r3d_img, r3d_svg rendering options for TGeo and histograms; - keep support of SVGRendered as backup solution; 10. Upgrade MathJax.js to version 3.1.1; - reliably works in browser and node.js!; - all latex/mathjax related methods moved to special JSRoot.latex.js script, loaded on demand; 11. Update jquery to 3.5.1, openui5 to 1.82.2; 12. Use JS classes only in few places - performance is not good enough compared to Object.prototype; 13. Deprecate IE support; 14. Deprecate bower package",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:25471,depend,dependencies,25471,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['depend'],['dependencies']
Integrability,"File`, and `TNetXNGFile`.; In either case, the `RRawFile` owns its own file descriptor and does not interfere with `TFile` objects concurrently reading the file.; For anchors from files of other dynamic type, including all other `TFile` subclasses, the file is wrapped in a `RRawFileTFile` and access is shared. On-Disk Encoding; ----------------. ### Writing Case; The following steps are taken to write RNTuple data to disk:. 1. On creation of the RNTupleWriter, the header is written to disk; 2. Upon `RNTupleWriter::Fill()`, the RField<T> class _serializes_ the object into its column representation.; To this end, it uses the `RColumn` class to append elements to the columns page buffer (`RPage`); 3. When a page buffer is full (cf. tuning.md), it is sent to the page sink for writing it to disk.; Note that page boundaries do _not_ need to align with entry boundaries,; e.g. information from a single entry can span multiple pages.; 1. The page is _packed_:; depending on the type of the page, a light encoding is applied to facilitate compression, e.g., byte splitting (`RColumnElement`).; Big-endian / little-endian conversion takes place here.; 2. The packed page is _compressed_ according to the user-provided compression settings (default: zstd).; A packed and compressed page is _sealed_.; 3. The sealed page is written to the storage backend.; 4. When the target cluster size is reached (cf. tuning.md), the `Fill()` method automatically commits the cluster.; The user can also manually commit a cluster.; 5. When the dataset is committed (e.g., on destruction of the RNTupleWriter), the page list, the footer, and the anchor are written to disk. The header, footer, and page list are compressed. If the buffered sink is used (default), the pages of a cluster are buffered until the cluster is committed.; On committing the cluster, all pages are sealed and sent to a _persistent sink_ in one go (vector write).; Pages are also reordered to ensure locality of pages of the same column. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:19770,depend,depending,19770,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['depend'],['depending']
Integrability,"Fit are 10 - 20% faster. #### Legacy iterators; The (three kinds) of legacy iterators in RooFit are still supported, such that old code will not break, but they are slower than `begin(), end()` and range-based for loops. **Important caveat**:; The old RooFit collections could be modified while iterating. The STL-like iterators do not support this (as for a *e.g.* std::vector)! Using the legacy iterators with the new collections (*i.e.* in existing code), mutating the collection is still possible in the following cases:; - Inserting/deleting elements **after** the current iterator.; - Changing an element at a position **other than** the current iterator; - **But not** inserting/deleting before/at the current iterator position. With a debug build (with assertions), the legacy iterators will check that the collection is not mutated. In a release build, elements might be skipped or be iterated twice. #### Moving away from the slower iterators; The legacy iterators have been flagged with a special deprecation macro that can be used help the user use the recommended ROOT interface. Defining one of the [deprecation macros](#preprocessor-deprecation-macros) (either in a single translation unit or in the build system), and creating a legacy iterator will trigger a compiler warning such as:; ```; <path>/RooChebychev.cxx:66:34: warning: 'createIterator' is deprecated: There is a superior alternative: begin(), end() and range-based for loops. [-Wdeprecated-declarations]; TIterator* coefIter = coefList.createIterator() ;; ^; 1 warning generated.; ```. ## TMVA. This release provides a consolidation and several fixes of the new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:16687,interface,interface,16687,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interface']
Integrability,"Fitter: Minuit; ```. ### Behavior change of `TMath::AreEqualAbs()`. The `TMath::AreEqualAbs()` compares two numbers for equality within a certain absolute range.; So far, it would tell you that `inf != inf` if you define `inf` as `std::numeric_limits<double>::infinity()`, which is inconsistent with the regular `==` operator. This is unexpected, because one would expect that if two numbers are considered exactly equal, they would also be considered equal within any range.; Therefore, the behavior of `TMath::AreEqualAbs()` was changed to return always `true` if the `==` comparison would return `true`. ## RooFit Libraries. ### Changes in RooFormulaVar and RooGenericPdf. The TFormula-based RooFit classes `RooFormulaVar` and `RooGenericPdf` change a bit their behavior to be more consistent:. 1. No matter which variables you pass to the constructor, only the variables that the formula depends on are registered as value servers.; 2. Similarly, the `dependents()` method of RooFormulaVar and RooGenericPdf will only return the list of actual value servers. ### Removal of the RooGenFunction and RooMultiGenFunction classes. The `RooGenFunction` was only a lightweight adaptor that exports a RooAbsReal as a `ROOT::Math::IGenFunction`.; The same can be easily achieved with the generic `ROOT::Math::Functor1D`, so in the spirit of not duplicating interfaces, the `RooGenFunction` is removed in this release. Here is an example that shows how to replace it in the unlikely case you were using it:. ```C++; RooArgSet normSet{x}; // normalization set. // Old way 1: create a RooGenFunction:; RooGenFunction func1{pdf, x, {}, normSet};. // Old way 2: use `RooAbsReal::iGenFunction()`:; std::unique_ptr<ROOT::Math::IGenFunction> func2{; pdf.iGenFunction(x, normSet); };. // How to do it now:; RooFunctor functor{pdf, x, {}, normSet};; ROOT::Math::Functor1D func3{functor};; // Functor1D takes by reference, so the RooFunctor also needs to stay alive.; ```. For the same reason, the `RooMultiGenFunctio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:11486,depend,dependents,11486,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['depend'],['dependents']
Integrability,"Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:46157,wrap,wrap,46157,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrap']
Integrability,"For GFX6-GFX9:. * Each agent has multiple shader arrays (SA).; * Each SA has multiple compute units (CU).; * Each CU has multiple SIMDs that execute wavefronts.; * The wavefronts for a single work-group are executed in the same CU but may be; executed by different SIMDs.; * Each CU has a single LDS memory shared by the wavefronts of the work-groups; executing on it.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that for GFX7-GFX9 ``flat_load/store/atomic`` instructions can report out of; vector memory order if they access LDS memory, and out of LDS operation order; if they access global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore, no special action is required for coherence between the; lanes of a single wavefront, or for coherence between wavefronts in the same; work-group. A ``buffer_wbinvl1_vol`` is required for coherence between; wavefronts executing in different work-groups as they may be executing on; different CUs.; * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coheren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:207178,synchroniz,synchronization,207178,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:36059,message,message,36059,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"For more information on passes and how they are run, see the; `How to Write a Pass <../../WritingAnLLVMPass.html>`_ document and the; `List of LLVM Passes <../../Passes.html>`_. For Kaleidoscope, we are currently generating functions on the fly, one; at a time, as the user types them in. We aren't shooting for the; ultimate optimization experience in this setting, but we also want to; catch the easy and quick stuff where possible. As such, we will choose; to run a few per-function optimizations as the user types the function; in. If we wanted to make a ""static Kaleidoscope compiler"", we would use; exactly the code we have now, except that we would defer running the; optimizer until the entire file has been parsed. In addition to the distinction between function and module passes, passes can be; divided into transform and analysis passes. Transform passes mutate the IR, and; analysis passes compute information that other passes can use. In order to add; a transform pass, all analysis passes it depends upon must be registered in; advance. In order to get per-function optimizations going, we need to set up a; `FunctionPassManager <../../WritingAnLLVMPass.html#what-passmanager-doesr>`_ to hold; and organize the LLVM optimizations that we want to run. Once we have; that, we can add a set of optimizations to run. We'll need a new; FunctionPassManager for each module that we want to optimize, so we'll; add to a function created in the previous chapter (``InitializeModule()``):. .. code-block:: c++. void InitializeModuleAndManagers(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""KaleidoscopeJIT"", *TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create new pass and analysis managers.; TheFPM = std::make_unique<FunctionPassManager>();; TheLAM = std::make_unique<LoopAnalysisManager>(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:5104,depend,depends,5104,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['depend'],['depends']
Integrability,"G-ATTR]_.; ""amdgpu-num-vgpr""=""n"" Specifies the number of VGPRs to use. Generated by the; ``amdgpu_num_vgpr`` CLANG attribute [CLANG-ATTR]_.; ""amdgpu-waves-per-eu""=""m,n"" Specify the minimum and maximum number of waves per; execution unit. Generated by the ``amdgpu_waves_per_eu``; CLANG attribute [CLANG-ATTR]_. This is an optimization hint,; and the backend may not be able to satisfy the request. If; the specified range is incompatible with the function's; ""amdgpu-flat-work-group-size"" value, the implied occupancy; bounds by the workgroup size takes precedence. ""amdgpu-ieee"" true/false. GFX6-GFX11 Only; Specify whether the function expects the IEEE field of the; mode register to be set on entry. Overrides the default for; the calling convention.; ""amdgpu-dx10-clamp"" true/false. GFX6-GFX11 Only; Specify whether the function expects the DX10_CLAMP field of; the mode register to be set on entry. Overrides the default; for the calling convention. ""amdgpu-no-workitem-id-x"" Indicates the function does not depend on the value of the; llvm.amdgcn.workitem.id.x intrinsic. If a function is marked with this; attribute, or reached through a call site marked with this attribute,; the value returned by the intrinsic is undefined. The backend can; generally infer this during code generation, so typically there is no; benefit to frontends marking functions with this. ""amdgpu-no-workitem-id-y"" The same as amdgpu-no-workitem-id-x, except for the; llvm.amdgcn.workitem.id.y intrinsic. ""amdgpu-no-workitem-id-z"" The same as amdgpu-no-workitem-id-x, except for the; llvm.amdgcn.workitem.id.z intrinsic. ""amdgpu-no-workgroup-id-x"" The same as amdgpu-no-workitem-id-x, except for the; llvm.amdgcn.workgroup.id.x intrinsic. ""amdgpu-no-workgroup-id-y"" The same as amdgpu-no-workitem-id-x, except for the; llvm.amdgcn.workgroup.id.y intrinsic. ""amdgpu-no-workgroup-id-z"" The same as amdgpu-no-workitem-id-x, except for the; llvm.amdgcn.workgroup.id.z intrinsic. ""amdgpu-no-dispatch-ptr"" The same as amdgp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:48296,depend,depend,48296,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depend']
Integrability,"GOAL:. Provide http interface to arbitrary ROOT application. USAGE:. At any place of the code create http server:. root [0] serv = new THttpServer. By default, civetweb web server with port number 8080 will be started.; It gets access to files, canvases and trees, registered in gROOT.; One additionally could register other objects to the server:. root [1] serv->Register(""abc/fold1"", hpx);; root [2] serv->Register(""abc/fold2"", hpxpy);; root [3] serv->Register(""extra"", c1);. Once server running, just open in any browser page: http://yourhost:8080. Example macro: $ROOTSYS/tutorials/http/httpserver.C. FAST CGI:. Instead of running http server, one could use fast cgi interface; to normal web server like Apache or lighttpd or any other.; When creating server, one could specify:. root [0] serv = new THttpServer(""fastcgi:9000"");. This opens port 9000, which should be specified in web server configuration.; For instance, lighttpd.conf file could contain path like this:. fastcgi.server = (; ""/remote_scripts/"" =>; (( ""host"" => ""192.168.1.10"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ). In this case one should be able to access root application via address. http://your_lighttpd_host/remote_scripts/root.cgi/. AUTHOR:. Sergey Linev, S.Linev@gsi.de. CHANGES:. January 2015; - Provide exe.json request to execute arbitrary object method and return; result in JSON format. Server should run in non-readonly mode. Fall 2014; - Implement gzip for result of any submitted requests, automatically done ; when .gz extension is provided; - Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetwe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:20,interface,interface,20,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,2,['interface'],['interface']
Integrability,"GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::Wrap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47136,wrap,wrap,47136,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['interface', 'wrap']","['interfaces', 'wrap']"
Integrability,"How to read and write custom classes in TTree; =============================================. This example shows how to use ROOT as a toolkit to write and read a TTree containing custom classes. # Starting steps. 1. Build the project, it requires ROOT. ```; cmake -B build -S . ; cmake --build build ; ```. 2. Run the executable. ```; ./build/treeExample; ```. 3. Inspect the output rootfile, and the source code. . # Files. This example shows how to use ROOT as a library in a C++ project. The C++ main function is defined in the file main.cpp. The code that writes the TTree onto disk is contained in the file writeTree.cxx. The files readTree.cxx and readTreeDF.cxx show two different ROOT interfaces to read a TTree. The files data2tree.* contain the code for the custom class that fills the TTree. ## Definition of custom class. The TTree can be seen as a collection of objects (branches), with a number of attributes (leaves). The name of the branch corresponds to the name of the instantiated object. The name of the leaves corresponds to the name of the attributes. The class that is present in the TTree is declared in the file data2tree.hpp, and the methods defined in the file data2tree.cpp. . To be able to read and write objects of a particular user-defined type, ROOT I/O needs to know some information about the class/struct, e.g. the class members and their types, offset of each data member, etc. This information is contained in a ROOT dictionary; see [I/O of custom classes](https://root.cern/manual/io_custom_classes/#generating-dictionaries) for more information. The linkdef file contains some instructions for ROOT, to specify which classes will require a dictionary:. ```; #pragma link C++ class myFancyClass+;; ```. If for example `std::vector` of such class is also used in the TTree as well, it should be notified to ROOT as another separated instruction:. ```; #pragma link C++ class std::vector<myFancyClass>+;; ```. # Links: ; * ROOT documentation: https://root.cern/manu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/README.md:693,interface,interfaces,693,tutorials/tree/dictionary/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/README.md,1,['interface'],['interfaces']
Integrability,"However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library (e.g.; libxml) it needs to be modularized. As part of our ongoing efforts to move; CMSSW to use C++ Modules [[6]] we have implemented a helper tool [[7]]. The; tool detects (based on the include paths of the compiler) dependencies and; tries to generate the relevant vfs file. ## State of the union. Preloading all modules at start up time turn our motivating example into:. ```cpp; // ROOT prompt; root [] S *s; // #1: does not require a definition.; root [] foo::bar *baz1; // #2: does not require a definition.; root [] foo::bar baz2; // #3: requires a definition.; root [] TCanvas* c = new TCanvas(); // #4 requires a definition. ```. becomes equivalent to. ```cpp; // ROOT prompt; root [] import ROOT.*;; root [] ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:15098,depend,dependencies,15098,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['dependencies']
Integrability,"Html.OutputDir: htmldoc/; ```. Address of the package's home page (default: <http://root.cern.ch>):. ``` {.cpp}; Root.Html.HomePage:; ```. Location of user defined header and footer files, see; <http://root.cern.ch/root/html/THtml#conf:header> (defaults are `""""`,; example: `../header.txt`, `../footer.txt`):. ``` {.cpp}; Root.Html.Header:; Root.Html.Footer:; ```. Tag for detecting class description comments (default value is set; below). ``` {.cpp}; Root.Html.Description: //____________________; ```. Tag for detecting ""Author"" comment (default value is set below). ``` {.cpp}; Root.Html.Author: // Author:; ```. Tag for detecting ""last updated"" comment. **`THtml`** uses the current; date if this tag is not found in a class source file (default value is; set below). ``` {.cpp}; Root.Html.LastUpdate: // @(#); ```. Tag for detecting ""Copyright"" comment (default value is set below). ``` {.cpp}; Root.Html.Copyright: * Copyright; ```. ### GUI Specific Settings. Set the ""`native`"" ROOT GUI interface to be used in a ROOT session. ``` {.cpp}; Gui.Backend: native; Gui.Factory: native; ```. GUI default fonts in use:. ``` {.cpp}; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; ```. Regular background and foreground colors in use:. ``` {.cpp}; Gui.BackgroundColor: #c0c0c0; Gui.ForegroundColor: black; ```. Selection background and foreground colors in use:. ``` {.cpp}; Gui.SelectBackgroundColor: #000080; Gui.SelectForegroundColor: white; ```. Document background and foreground colors in use:. ``` {.cpp}; Gui.DocumentBackgroundColor: white; Gui.DocumentF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:10006,interface,interface,10006,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['interface'],['interface']
Integrability,"HttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new interface, implemented in the class TProcPool, provides the possibility to perform in parallel a very generic set of tasks, described by macros, functions or lambdas. This illustrates the usage of lambdas:. ``` {.cpp}; {; TProcPool pool;; auto ten = pool.MapReduce([]() { return 1; }, 10, [](std::vector<int> v) { return std::accumulate(v.begin(), v.end(), 0); }); }; ```. And this how it can be used to generate ten histos and merge them:. ``` {.cpp}; {; TObject *CreateAndFillHists(); {. TH1F *h = new TH1F(""h"", """", 100, -3., 3.);; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; ```. Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore. ## Language Bindings. ### Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:21218,interface,interface,21218,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interface']
Integrability,"I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A ""thread-id"" field on every instruction that allows the static; compiler to generate a set of parallel threads, and then have; the runtime compiler and hardware do what they please with it.; This has very powerful uses, but thread-id on every instruction; is expensive in terms of instruction size and code size.; We would need to compactly encode it somehow. Also, this will require some reading on at least two other; projects:; -- Multiscalar architecture from Wisconsin; -- Simultaneous multithreading architecture from Washington. o Or forget all this and stick to a traditional instruction set?. BTW, on an unrelated note, after the meeting yesterday, I did remember; that you had suggested doing instruction scheduling on SSA form instead; of a dependence DAG earlier in the semester. When we talked about; it yesterday, I didn't remember where the idea had come from but I; remembered later. Just giving credit where its due... Perhaps you can save the above as a file under RCS so you and I can; continue to expand on this. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:2753,depend,dependence,2753,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,1,['depend'],['dependence']
Integrability,"INCLUDE_TESTS ); add_subdirectory(${LLVM_THIRD_PARTY_DIR}/unittest ${CMAKE_CURRENT_BINARY_DIR}/third-party/unittest); endif(); else(); if ( LLVM_INCLUDE_TESTS ); message(FATAL_ERROR ""Including tests when not building utils will not work.; Either set LLVM_INCLUDE_UTILS to On, or set LLVM_INCLUDE_TESTS to Off.""); endif(); endif(). # Use LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION instead of LLVM_INCLUDE_UTILS because it is not really a util; if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION); add_subdirectory(utils/LLVMVisualizers); endif(). foreach( binding ${LLVM_BINDINGS_LIST} ); if( EXISTS ""${LLVM_MAIN_SRC_DIR}/bindings/${binding}/CMakeLists.txt"" ); add_subdirectory(bindings/${binding}); endif(); endforeach(). add_subdirectory(projects). if( LLVM_INCLUDE_TOOLS ); add_subdirectory(tools); endif(). if( LLVM_INCLUDE_RUNTIMES ); add_subdirectory(runtimes); endif(). if( LLVM_INCLUDE_EXAMPLES ); add_subdirectory(examples); endif(). if( LLVM_INCLUDE_TESTS ); set(LLVM_GTEST_RUN_UNDER; """" CACHE STRING; ""Define the wrapper program that LLVM unit tests should be run under.""); if(EXISTS ${LLVM_MAIN_SRC_DIR}/projects/test-suite AND TARGET clang); include(LLVMExternalProjectUtils); llvm_ExternalProject_Add(test-suite ${LLVM_MAIN_SRC_DIR}/projects/test-suite; USE_TOOLCHAIN; EXCLUDE_FROM_ALL; NO_INSTALL; ALWAYS_CLEAN); endif(); add_subdirectory(utils/lit); add_subdirectory(test); add_subdirectory(unittests). if (WIN32); # This utility is used to prevent crashing tests from calling Dr. Watson on; # Windows.; add_subdirectory(utils/KillTheDoctor); endif(). umbrella_lit_testsuite_end(check-all); get_property(LLVM_ALL_LIT_DEPENDS GLOBAL PROPERTY LLVM_ALL_LIT_DEPENDS); get_property(LLVM_ALL_ADDITIONAL_TEST_DEPENDS; GLOBAL PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS); add_custom_target(test-depends; DEPENDS ${LLVM_ALL_LIT_DEPENDS} ${LLVM_ALL_ADDITIONAL_TEST_DEPENDS}); set_target_properties(test-depends PROPERTIES FOLDER ""Tests""); add_dependencies(check-all test-depends); endif(). if (LLVM_INCLUDE_D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:50356,wrap,wrapper,50356,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['wrap'],['wrapper']
Integrability,"ING=${LIBXML2_INCLUDE_DIRS}; -DLIBXML2_LIBRARY:PATH=${LIBXML2_LIBRARY}; -DLIBXML2_LIBRARIES:STRING=${LIBXML2_LIBRARIES}; CMAKE_ARGS; -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DENABLE_HTML_DOCS=OFF; -DENABLE_IPV6=OFF; -DSTATIC_LIBRARY=ON; -DSHARED_LIBRARY=OFF; -DENABLE_TOOLS=OFF; -DDAVIX_TESTS=OFF; -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}; -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}; -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}; -DCMAKE_CXX_FLAGS=${DAVIX_CXX_FLAGS}\ -fPIC; -DCMAKE_OSX_SYSROOT=${CMAKE_OSX_SYSROOT}; -DCMAKE_OSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}; -DLIB_SUFFIX=; PATCH_COMMAND sed -i """" -e ""s|sed -i '| sed -i \""\"" '|g"" -e ""s/gcc/cc/g"" patch-curl-clock-gettime.sh; LOG_BUILD 1 LOG_CONFIGURE 1 LOG_DOWNLOAD 1 LOG_INSTALL 1; BUILD_BYPRODUCTS ${DAVIX_LIBRARIES}; TIMEOUT 600). if(builtin_openssl); add_dependencies(DAVIX OPENSSL); endif(). if(APPLE); find_library(FOUND_CoreFoundation CoreFoundation); if(NOT FOUND_CoreFoundation); message(FATAL_ERROR ""Missing macOS CoreFoundation framework!""); endif(); list(APPEND DAVIX_LIBRARIES ${FOUND_CoreFoundation}). find_library(FOUND_Security Security); if(NOT FOUND_Security); message(FATAL_ERROR ""Missing macOS Security framework!""); endif(); list(APPEND DAVIX_LIBRARIES ${FOUND_Security}); endif(). list(APPEND DAVIX_LIBRARIES uuid::uuid OpenSSL::SSL ZLIB::ZLIB ${LIBXML2_LIBRARIES} ${CMAKE_DL_LIBS}). check_cxx_symbol_exists(""clock_gettime"" ""time.h"" _have_clock_gettime). if(NOT _have_clock_gettime); check_library_exists(rt clock_gettime """" _have_rt_library); if(_have_rt_library); list(APPEND DAVIX_LIBRARIES rt); endif(); endif(). unset(DAVIX_FOUND CACHE); unset(DAVIX_FOUND PARENT_SCOPE); set(DAVIX_FOUND TRUE CACHE BOOL """" FORCE). set(DAVIX_INCLUDE_DIR ${DAVIX_PREFIX}/include/davix CACHE INTERNAL """" FORCE); set(DAVIX_INCLUDE_DIRS ${DAVIX_PREFIX}/include/davix CACHE INTERNAL """" FORCE); set(DAVIX_LIBRARY ${DAVIX_PREFIX}/lib/${DAVIX_LIBNAME} CACHE INTERNAL """" FORCE); set(DAVIX_LIBRARIES ${DAVIX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/davix/CMakeLists.txt:2314,message,message,2314,builtins/davix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/davix/CMakeLists.txt,1,['message'],['message']
Integrability,"IST LLVM_ENABLE_PROJECTS); if (NOT ""mlir"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling MLIR as a dependency to flang""); list(APPEND LLVM_ENABLE_PROJECTS ""mlir""); endif(). if (NOT ""clang"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""Clang is not enabled, but is required for the Flang driver""); endif(); endif(). # Select the runtimes to build; #; # As we migrate runtimes to using the bootstrapping build, the set of default runtimes; # should grow as we remove those runtimes from LLVM_ENABLE_PROJECTS above.; set(LLVM_DEFAULT_RUNTIMES ""libcxx;libcxxabi;libunwind""); set(LLVM_SUPPORTED_RUNTIMES ""libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp;llvm-libgcc""); set(LLVM_ENABLE_RUNTIMES """" CACHE STRING; ""Semicolon-separated list of runtimes to build, or \""all\"" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.""); if(LLVM_ENABLE_RUNTIMES STREQUAL ""all""); set(LLVM_ENABLE_RUNTIMES ${LLVM_DEFAULT_RUNTIMES}); endif(); foreach(proj IN LISTS LLVM_ENABLE_RUNTIMES); if (NOT ""${proj}"" IN_LIST LLVM_SUPPORTED_RUNTIMES); message(FATAL_ERROR ""Runtime \""${proj}\"" is not a supported runtime. Supported runtimes are: ${LLVM_SUPPORTED_RUNTIMES}""); endif(); endforeach(). if (""libc"" IN_LIST LLVM_ENABLE_RUNTIMES); # To build the libc runtime, we need to be able to build few libc build; # tools from the ""libc"" project. So, we add it to the list of enabled; # projects.; if (NOT ""libc"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling libc project to build libc build tools""); list(APPEND LLVM_ENABLE_PROJECTS ""libc""); endif(); endif(). # LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the; # `LLVM_ENABLE_PROJECTS` CMake cache variable. This exists for; # several reasons:; #; # * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single; # source of truth for which projects to build. This means we will ignore user; # supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite; # them.; #; # * The case where",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:7323,message,message,7323,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"IT); compiler. Example applications of the patchpoint intrinsics are; implementing an inline call cache for polymorphic method dispatch or; optimizing the retrieval of properties in dynamically typed languages; such as JavaScript. The intrinsics documented here are currently used by the JavaScript; compiler within the open source WebKit project, see the `FTL JIT; <https://trac.webkit.org/wiki/FTLJIT>`_, but they are designed to be; used whenever stack maps or code patching are needed. Because the; intrinsics have experimental status, compatibility across LLVM; releases is not guaranteed. The stack map functionality described in this document is separate; from the functionality described in; :ref:`stack-map`. `GCFunctionMetadata` provides the location of; pointers into a collected heap captured by the `GCRoot` intrinsic,; which can also be considered a ""stack map"". Unlike the stack maps; defined above, the `GCFunctionMetadata` stack map interface does not; provide a way to associate live register values of arbitrary type with; an instruction address, nor does it specify a format for the resulting; stack map. The stack maps described here could potentially provide; richer information to a garbage collecting runtime, but that usage; will not be discussed in this document. Intrinsics; ==========. The following two kinds of intrinsics can be used to implement stack; maps and patch points: ``llvm.experimental.stackmap`` and; ``llvm.experimental.patchpoint``. Both kinds of intrinsics generate a; stack map record, and they both allow some form of code patching. They; can be used independently (i.e. ``llvm.experimental.patchpoint``; implicitly generates a stack map without the need for an additional; call to ``llvm.experimental.stackmap``). The choice of which to use; depends on whether it is necessary to reserve space for code patching; and whether any of the intrinsic arguments should be lowered according; to calling conventions. ``llvm.experimental.stackmap`` does not; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:2610,interface,interface,2610,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['interface'],['interface']
Integrability,"Integral()` function, simply; return the output using the `buildCall()` function. ``` {.cpp}; std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; ```. \note The implementation of the `RooAbsReal::buildCallToAnalyticIntegral()`; function is quite similar to the `translate()` function, except that in; `translate()`, you have to add to the result (using `addResult()`), while for; `buildCallToAnalyticIntegral()`, you only have to return the string (using; `buildCall()`). **Consolidated Code changes in RooFoo example**. Final RooFoo code:. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; // int doFoo() { return a* b + a + b; }; // int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return EvaluateFunc::doFoo(a, b);; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return EvaluateFunc::integralFoo(a, b);; }. //// ************************** functions for AD Support ***********************; void translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; std::string res = ctx.buildCall(""EvaluateFunc::doFoo"", a, b);; ctx.addResult(this, res);; }. std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; //// ************************** functions for AD Support ***********************; };. ```. Mathematical code moved to `MathFuncs.h` file. ``` {.cpp}; int doFoo(int a, int b) { return a* b + a + b; }; ```. Integrals moved to the 'MathFuncs.h' file. ``` {.cpp}; int integralFoo(int a, int b) { return /* whatever */;}; ```. > Remember, as long as your code is supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:24792,integrat,integration,24792,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['integrat'],['integration']
Integrability,"Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:1032,rout,routines,1032,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,['rout'],['routines']
Integrability,"Invalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderTe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59102,protocol,protocol,59102,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['protocol'],['protocol']
Integrability,"It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` has a richer command line interface than ``rootcling`` as can; be seen from the full help message. .. _selection-files:. Selection/exclusion is driven through a `selection file`_ using an XML format; that allows both exact and pattern matching to namespace, class, enum,; function, and variable names. .. _`selection file`: https://linux.die.net/man/1/genreflex. Example; """""""""""""". Consider the following basic example code, living in a header ""MyClass.h"":. .. code-block:: C++. class MyClass {; public:; MyClass(int i) : fInt(i) {}; int get_int() { return fInt; }. private:; int fInt;; };. and a corresponding ""Linkdef.h"" file, selecting only ``MyClass``::. #ifdef __ROOTCLING__; #pragma link off all classes;; #pragma link off all functions;; #pragma link off all globals;; #pragma link off all typedef;. #pragma ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:4645,interface,interface,4645,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['interface'],['interface']
Integrability,"Itanium Name Demangler Library; ==============================. Introduction; ------------. This directory contains the generic itanium name demangler; library. The main purpose of the library is to demangle C++ symbols,; i.e. convert the string ""_Z1fv"" into ""f()"". You can also use the CRTP; base ManglingParser to perform some simple analysis on the mangled; name, or (in LLVM) use the opaque ItaniumPartialDemangler to query the; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:833,depend,depend,833,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,1,['depend'],['depend']
Integrability,"Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. ; A new class for Delauney triangulator and interpolation has been added in the MathCore library ( `ROOT::Math::Delauney2D` ). ### Fitting. * Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:13528,interface,interfaces,13528,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interfaces']
Integrability,"KE_SYSTEM_NAME MATCHES ""Windows"" AND NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR; ""Intel JIT API support is available on Linux and Windows only.""); endif(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:27942,interface,interface,27942,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['interface'],['interface']
Integrability,"KING_CHECKS ""WITH_ASSERTS"" CACHE STRING; ""Enable abi-breaking checks. Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF.""). option(LLVM_FORCE_USE_OLD_TOOLCHAIN; ""Set to ON to force using an old, unsupported host toolchain."" OFF). set(LLVM_LOCAL_RPATH """" CACHE FILEPATH; ""If set, an absolute path added as rpath on binaries that do not already contain an executable-relative rpath.""). option(LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN; ""Set to ON to only warn when using a toolchain which is about to be deprecated, instead of emitting an error."" OFF). option(LLVM_USE_INTEL_JITEVENTS; ""Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code""; OFF). if( LLVM_USE_INTEL_JITEVENTS ); # Verify we are on a supported platform; if( NOT CMAKE_SYSTEM_NAME MATCHES ""Windows"" AND NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR; ""Intel JIT API support is available on Linux and Windows only.""); endif(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:27198,interface,interface,27198,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['interface'],['interface']
Integrability,"K_Square), SideLength(S) {}; double computeArea() override;; +; + static bool classof(const Shape *S) {; + return S->getKind() == SK_Square;; + }; };. class Circle : public Shape {; double Radius;; public:; Circle(double R) : Shape(SK_Circle), Radius(R) {}; double computeArea() override;; +; + static bool classof(const Shape *S) {; + return S->getKind() == SK_Circle;; + }; };. The job of ``classof`` is to dynamically determine whether an object of; a base class is in fact of a particular derived class. In order to; downcast a type ``Base`` to a type ``Derived``, there needs to be a; ``classof`` in ``Derived`` which will accept an object of type ``Base``. To be concrete, consider the following code:. .. code-block:: c++. Shape *S = ...;; if (isa<Circle>(S)) {; /* do something ... */; }. The code of the ``isa<>`` test in this code will eventually boil; down---after template instantiation and some other machinery---to a; check roughly like ``Circle::classof(S)``. For more information, see; :ref:`classof-contract`. The argument to ``classof`` should always be an *ancestor* class because; the implementation has logic to allow and optimize away; upcasts/up-``isa<>``'s automatically. It is as though every class; ``Foo`` automatically has a ``classof`` like:. .. code-block:: c++. class Foo {; [...]; template <class T>; static bool classof(const T *,; ::std::enable_if<; ::std::is_base_of<Foo, T>::value; >::type* = 0) { return true; }; [...]; };. Note that this is the reason that we did not need to introduce a; ``classof`` into ``Shape``: all relevant classes derive from ``Shape``,; and ``Shape`` itself is abstract (has no entry in the ``Kind`` enum),; so this notional inferred ``classof`` is all we need. See `Concrete; Bases and Deeper Hierarchies`_ for more information about how to extend; this example to more general hierarchies. Although for this small example setting up LLVM-style RTTI seems like a lot; of ""boilerplate"", if your classes are doing anything interesting the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:6155,contract,contract,6155,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['contract'],['contract']
Integrability,L and function templates that are not visible; P0846R0; Clang 9. const mismatch with defaulted copy constructor; P0641R2; Clang 8. Consistent comparison (operator<=>); P0515R3; Clang 10. ; P0905R1. ; P1120R0. ; P1185R2. ; P1186R3. P1630R1. ; P1946R0. P1959R0. ; P2002R1; Clang 17. P2085R0; Clang 14. Access checking on specializations; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macros; P0941R2; (see below). explicit(bool); P0892R2; Clang 9. Signed integers are two's complement; P1236R1; Clang 9. char8_t; P0482R6; Clang 7 (11). Immediate functions (consteval); P1073R3; Clang 17. ; P1937R2; Clang 14. std::is_constant_evaluated; P0595R2; Clang 9. Nested inline namespaces; P1094R2; Clang 8. Structured binding extensions; P1091R3; Clang 16. P1381R1. Stronger Unicode requirements; P1041R4; Yes. P1139R2. Parenthesized initialization of aggregates; P0960R3; Clang 16. ; P1975R0. Modules; P1103R3; Clang 15. ; P1766R1 (DR); Clang 11. P1811R0; No. P1703R1; Subsumed by P1857. ; P1874R1; Clang 15. ; P1979R0; No. ; P1779R3; Clang 15. P1857R3; No. P2115R0; Pa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:7774,depend,dependent,7774,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['depend'],['dependent']
Integrability,"LANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)""); if (NOT(CLANG_DEFAULT_RTLIB STREQUAL """" OR; CLANG_DEFAULT_RTLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_RTLIB STREQUAL ""compiler-rt"")); message(WARNING ""Resetting default rtlib to use platform default""); set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)"" FORCE); endif(). set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)""); if (CLANG_DEFAULT_UNWINDLIB STREQUAL """"); if (CLANG_DEFAULT_RTLIB STREQUAL ""libgcc""); set (CLANG_DEFAULT_UNWINDLIB ""libgcc"" CACHE STRING """" FORCE); endif(); endif(). if (NOT(CLANG_DEFAULT_UNWINDLIB STREQUAL """" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""none"" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_UNWINDLIB STREQUAL ""libunwind"")); message(WARNING ""Resetting default unwindlib to use platform default""); set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)"" FORCE); endif(). set(CLANG_DEFAULT_OBJCOPY ""objcopy"" CACHE STRING; ""Default objcopy executable to use.""). set(CLANG_DEFAULT_OPENMP_RUNTIME ""libomp"" CACHE STRING; ""Default OpenMP runtime used by -fopenmp.""). set(CLANG_SYSTEMZ_DEFAULT_ARCH ""z10"" CACHE STRING ""SystemZ Default Arch""). set(CLANG_VENDOR ${PACKAGE_VENDOR} CACHE STRING; ""Vendor-specific text for showing with version information.""). set(CLANG_REPOSITORY_STRING """" CACHE STRING; ""Vendor-specific text for showing the repository the source is taken from.""). if(CLANG_REPOSITORY_STRING); add_definitions(-DCLANG_REPOSITORY_STRING=""${CLANG_REPOSITORY_STRING}""); endif(). set(CLANG_VENDOR_UTI ""org.llvm.clang"" CACHE STRING; ""Vendor-specific uti.""). set(CLANG_PYTHON_BINDINGS_VERSIONS """" CACHE STRING; ""Python versions to install libclang p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:9285,message,message,9285,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"LE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6553,interface,interface,6553,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['interface'],['interface']
Integrability,LIBRARIES; ROOTTMVASofie; ${BLAS_LINKER_FLAGS}; ${BLAS_LIBRARIES}; INCLUDE_DIRS; ${CMAKE_CURRENT_BINARY_DIR}; ). add_dependencies(TestCustomModelsFromONNX SofieCompileModels_ONNX); endif(). #For testing serialisation of RModel object. add_executable(emitFromROOT; EmitFromRoot_all.cxx; ); target_include_directories(emitFromROOT PRIVATE; ${CMAKE_SOURCE_DIR}/tmva/sofie/inc; ${SOFIE_PARSERS_DIR}/inc; ${CMAKE_SOURCE_DIR}/tmva/inc; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(emitFromROOT protobuf::libprotobuf ROOTTMVASofie ROOTTMVASofieParser); set_target_properties(emitFromROOT PROPERTIES POSITION_INDEPENDENT_CODE TRUE); ## silence protobuf warnings seen in version 3.0 and 3.6. Not needed from protobuf version 3.17; target_compile_options(emitFromROOT PRIVATE -Wno-unused-parameter -Wno-array-bounds). # Automatic compilation of headers from root files; add_custom_target(SofieCompileModels_ROOT); # onepcm or modules dependency is needed for using ROOT I/O when converting a model in a ROOT file; if (runtime_cxxmodules); add_dependencies(SofieCompileModels_ROOT emitFromROOT modules_idx); else(); add_dependencies(SofieCompileModels_ROOT emitFromROOT onepcm); endif(). add_custom_command(TARGET SofieCompileModels_ROOT POST_BUILD; COMMAND ${CMAKE_COMMAND} -E env ROOTIGNOREPREFIX=1 ./emitFromROOT; 		USES_TERMINAL ). # Creating a Google Test for Serialisation of RModel; if (tmva-cpu); ROOT_ADD_GTEST(TestCustomModelsFromROOT TestCustomModelsFromROOT.cxx; LIBRARIES; ROOTTMVASofie; ${BLAS_LINKER_FLAGS}; ${BLAS_LIBRARIES}; INCLUDE_DIRS; ${CMAKE_CURRENT_BINARY_DIR}; ); add_dependencies(TestCustomModelsFromROOT SofieCompileModels_ROOT); endif(). # gtest; # Look for needed python modules; find_python_module(torch QUIET); if(PY_TORCH_FOUND); configure_file(Conv1dModelGenerator.py Conv1dModelGenerator.py COPYONLY); configure_file(Conv2dModelGenerator.py Conv2dModelGenerator.py COPYONLY); configure_file(Conv3dModelGenerator.py Conv3dModelGenerator.py COPYONLY); configure_file(ConvT,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/CMakeLists.txt:3530,depend,dependency,3530,tmva/sofie/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"LT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:53571,rout,routine,53571,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['rout'],['routine']
Integrability,"LVM_NATIVE_TOOL_DIR`` option - pointing; at a directory with prebuilt LLVM tools (``llvm-tblgen``, ``clang-tblgen``; etc) for the build host, allowing you to them reuse them if available.; E.g. ``-DLLVM_NATIVE_TOOL_DIR=<path-to-native-llvm-build>/bin``.; If the option isn't set (or the directory doesn't contain all needed tools),; the LLVM cross build will automatically launch a nested build to build the; tools that are required. The CXX flags define the target, cpu (which in this case; defaults to ``fpu=VFP3`` with NEON), and forcing the hard-float ABI. If you're; using Clang as a cross-compiler, you will *also* have to set ``--sysroot``; to make sure it picks the correct linker. When using Clang, it's important that you choose the triple to be *identical*; to the GCC triple and the sysroot. This will make it easier for Clang to; find the correct tools and include headers. But that won't mean all headers and; libraries will be found. You'll still need to use ``-I`` and ``-L`` to locate; those extra ones, depending on your distribution. Most of the time, what you want is to have a native compiler to the; platform itself, but not others. So there's rarely a point in compiling; all back-ends. For that reason, you should also set the; ``TARGETS_TO_BUILD`` to only build the back-end you're targeting to. You must set the ``CMAKE_INSTALL_PREFIX``, otherwise a ``ninja install``; will copy ARM binaries to your root filesystem, which is not what you; want. Hacks; -----. There are some bugs in current LLVM, which require some fiddling before; running CMake:. #. If you're using Clang as the cross-compiler, there is a problem in; the LLVM ARM back-end that is producing absolute relocations on; position-independent code (``R_ARM_THM_MOVW_ABS_NC``), so for now, you; should disable PIC:. .. code-block:: bash. -DLLVM_ENABLE_PIC=False. This is not a problem, since Clang/LLVM libraries are statically; linked anyway, it shouldn't affect much. #. The ARM libraries won't be installed in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:3733,depend,depending,3733,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['depend'],['depending']
Integrability,"Low-level code; ==============. .. toctree::; :hidden:. C code and older C++ code sometimes makes use of low-level features such as; pointers to builtin types, some of which do not have any Python equivalent; (e.g. ``unsigned short*``).; Furthermore, such codes tend to be ambiguous: the information from header; file is not sufficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:597,integrat,integration,597,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['integrat'],['integration']
Integrability,"M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4967,interface,interfaces,4967,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interfaces']
Integrability,"M) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23090,interface,interface,23090,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"M;; FPM.addPass(FunctionPass1());; FPM.addPass(FunctionPass2());. MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));. will run ``FunctionPass1`` and ``FunctionPass2`` on the first function in a; module, then run both passes on the second function in the module, and so on.; This is better for cache locality around LLVM data structures. This similarly; applies for the other IR types, and in some cases can even affect the quality; of optimization. For example, running all loop passes on a loop may cause a; later loop to be able to be optimized more than if each loop pass were run; separately. Inserting Passes into Default Pipelines; =======================================. Rather than manually adding passes to a pass manager, the typical way of; creating a pass manager is to use a ``PassBuilder`` and call something like; ``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical; pipeline for a given optimization level. Sometimes either frontends or backends will want to inject passes into the; pipeline. For example, frontends may want to add instrumentation, and target; backends may want to add passes that lower custom intrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipelin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:5344,inject,inject,5344,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['inject'],['inject']
Integrability,"MCJIT engine,; including the selection of MCJIT as the engine type to be created.; Of particular interest is the EngineBuilder::setMCJITMemoryManager; function. If the client does not explicitly create a memory manager at; this time, a default memory manager (specifically SectionMemoryManager); will be created when the MCJIT engine is instantiated. Once the options have been set, a client calls EngineBuilder::create to; create an instance of the MCJIT engine. If the client does not use the; form of this function that takes a TargetMachine as a parameter, a new; TargetMachine will be created based on the target triple associated with; the Module that was used to create the EngineBuilder. .. image:: MCJIT-engine-builder.png. EngineBuilder::create will call the static MCJIT::createJIT function,; passing in its pointers to the module, memory manager and target machine; objects, all of which will subsequently be owned by the MCJIT object. The MCJIT class has a member variable, Dyld, which contains an instance of; the RuntimeDyld wrapper class. This member will be used for; communications between MCJIT and the actual RuntimeDyldImpl object that; gets created when an object is loaded. .. image:: MCJIT-creation.png. Upon creation, MCJIT holds a pointer to the Module object that it received; from EngineBuilder but it does not immediately generate code for this; module. Code generation is deferred until either the; MCJIT::finalizeObject method is called explicitly or a function such as; MCJIT::getPointerToFunction is called which requires the code to have been; generated. Code Generation; ===============. When code generation is triggered, as described above, MCJIT will first; attempt to retrieve an object image from its ObjectCache member, if one; has been set. If a cached object image cannot be retrieved, MCJIT will; call its emitObject method. MCJIT::emitObject uses a local PassManager; instance and creates a new ObjectBufferStream instance, both of which it; passes to Targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst:1753,wrap,wrapper,1753,interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,1,['wrap'],['wrapper']
Integrability,"ME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}; -DCMAKE_C_COMPILER_WORKS=ON; -DCMAKE_CXX_COMPILER_WORKS=ON; -DCMAKE_ASM_COMPILER_WORKS=ON; -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON; -DLLVM_RUNTIMES_TARGET=${name}; ${COMMON_CMAKE_ARGS}; ${${name}_extra_args}; EXTRA_TARGETS ${${name}_extra_targets}; ${${name}_test_targets}; USE_TOOLCHAIN; ${EXTRA_ARGS} ${ARG_EXTRA_ARGS}). add_dependencies(runtimes runtimes-${name}); add_dependencies(runtimes-configure runtimes-${name}-configure); add_dependencies(install-runtimes install-runtimes-${name}); add_dependencies(install-runtimes-stripped install-runtimes-${name}-stripped); if(LLVM_INCLUDE_TESTS); add_dependencies(check-runtimes check-runtimes-${name}); add_dependencies(runtimes-test-depends runtimes-test-depends-${name}); endif(); foreach(runtime_name ${runtime_names}); if(NOT TARGET ${runtime_name}); add_custom_target(${runtime_name}); endif(); add_dependencies(${runtime_name} ${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}); add_custom_target(install-${runtime_name}); endif(); add_dependencies(install-${runtime_name} install-${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}-stripped); add_custom_target(install-${runtime_name}-stripped); endif(); add_dependencies(install-${runtime_name}-stripped install-${runtime_name}-${name}-stripped); endforeach(); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_dependencies(${component} ${component}-${name}); add_dependencies(install-${component} install-${component}-${name}); add_dependencies(install-${component}-stripped install-${component}-${name}-stripped); endforeach(); endfunction(). if(runtimes); # Create a runtimes target that uses this file as its top-level CMake file.; # The runtimes target is a configuration of all the runtime libraries; # together in a single CMake invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:14276,depend,depends,14276,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,['depend'],['depends']
Integrability,"MI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is faster since; it saves time for file lookup. Remember that module units still have an object counterpart to the BMI; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12914,interface,interface,12914,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"MINGW AND NOT LLVM_LINKER_IS_SOLARISLD_ILLUMOS); # Optimize function calls for default visibility definitions to avoid PLT and; # reduce dynamic relocations.; # Note: for -fno-pic default, the address of a function may be different from; # inside and outside libLLVM.so.; target_link_options(LLVM PRIVATE LINKER:-Bsymbolic-functions); endif(); endif(). target_link_libraries(LLVM PRIVATE ${LIB_NAMES}). if(LLVM_ENABLE_THREADS AND NOT HAVE_CXX_ATOMICS64_WITHOUT_LIB); target_link_libraries(LLVM PUBLIC atomic); endif(). if (APPLE); set_property(TARGET LLVM APPEND_STRING PROPERTY; LINK_FLAGS; "" -compatibility_version 1 -current_version ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}""); endif(). if(TARGET libLLVMExports); add_dependencies(LLVM libLLVMExports); endif(); endif(). if(LLVM_BUILD_LLVM_C_DYLIB AND NOT MSVC); if(NOT APPLE); message(FATAL_ERROR ""Generating libLLVM-c is only supported on Darwin""); endif(). if(NOT LLVM_BUILD_LLVM_DYLIB); message(FATAL_ERROR ""Generating libLLVM-c requires LLVM_BUILD_LLVM_C_DYLIB on Darwin""); endif(). # To get the export list for a single llvm library:; # nm ${LIB_PATH} | awk ""/T _LLVM/ { print $3 }"" | sort -u | sed -e ""s/^_//g"" > ${LIB_PATH}.exports. set(LLVM_EXPORTED_SYMBOL_FILE ${LLVM_BINARY_DIR}/libllvm-c.exports). set(LIB_DIR ${LLVM_LIBRARY_DIR}); set(LIB_NAME ${LIB_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}LLVM); set(LIB_PATH ${LIB_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}); set(LIB_EXPORTS_PATH ${LIB_NAME}.exports); list(APPEND LLVM_DYLIB_REQUIRED_EXPORTS ${LIB_EXPORTS_PATH}). add_custom_command(OUTPUT ${LLVM_EXPORTED_SYMBOL_FILE}; COMMAND nm ${LIB_PATH} | awk ""/T _LLVM/ || /T LLVM/ { print $3 }"" | sort -u | sed -e ""s/^_//g"" > ${LLVM_EXPORTED_SYMBOL_FILE}; WORKING_DIRECTORY ${LIB_DIR}; DEPENDS LLVM; COMMENT ""Generating Export list for LLVM...""; VERBATIM ). add_custom_target(libLLVMCExports DEPENDS ${LLVM_EXPORTED_SYMBOL_FILE}). add_llvm_library(LLVM-C SHARED ${SOURCES} INSTALL_WITH_TOOLCHAIN). target_link_libraries(LLVM-C PU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt:3270,message,message,3270,interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,1,['message'],['message']
Integrability,"MIPS Relocation Principles. In LLVM, there are several elements of the llvm::ISD::NodeType enum; that deal with addresses and/or relocations. These are defined in; include/llvm/Target/TargetSelectionDAG.td, namely:; GlobalAddress, GlobalTLSAddress, JumpTable, ConstantPool,; ExternalSymbol, BlockAddress; The MIPS backend uses several principles to handle these. 1. Code for lowering addresses references to machine dependent code is; factored into common code for generating different address forms and; is called by the relocation model specific lowering function, using; templated functions. For example:. // lib/Target/Mips/MipsISelLowering.cpp; SDValue MipsTargetLowering::; lowerJumpTable(SDValue Op, SelectionDAG &DAG) const. calls. template <class NodeTy> // lib/Target/Mips/MipsISelLowering.h; SDValue getAddrLocal(NodeTy *N, const SDLoc &DL, EVT Ty,; SelectionDAG &DAG, bool IsN32OrN64) const. which calls the overloaded function:. // lib/Target/Mips/MipsISelLowering.h; SDValue getTargetNode(JumpTableSDNode *N, EVT Ty, SelectionDAG &DAG,; unsigned Flag) const;. 2. Generic address nodes are lowered to some combination of target; independent and machine specific SDNodes (for example:; MipsISD::{Highest, Higher, Hi, Lo}) depending upon relocation model,; ABI, and compilation options. The choice of specific instructions that are to be used is delegated; to ISel which in turn relies on TableGen patterns to choose subtarget; specific instructions. For example, in getAddrLocal, the pseudo-code; generated is:. (add (load (wrapper $gp, %got(sym)), %lo(sym)). where ""%lo"" represents an instance of an SDNode with opcode; ""MipsISD::Lo"", ""wrapper"" indicates one with opcode ""MipsISD::Wrapper"",; and ""%got"" the global table pointer ""getGlobalReg(...)"". The ""add"" is; ""ISD::ADD"", not a target dependent one. 3. A TableGen multiclass pattern ""MipsHiLoRelocs"" is used to define a; template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:416,depend,dependent,416,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['depend'],['dependent']
Integrability,"MODIFICATION. 0. This License applies to any program or other work which contains; a notice placed by the copyright holder saying it may be distributed; under the terms of this General Public License. The ""Program"", below,; refers to any such program or work, and a ""work based on the Program""; means either the Program or any derivative work under copyright law:; that is to say, a work containing the Program or a portion of it,; either verbatim or with modifications and/or translated into another; language. (Hereinafter, translation is included without limitation in; the term ""modification"".) Each licensee is addressed as ""you"". Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running the Program is not restricted, and the output from the Program; is covered only if its contents constitute a work based on the; Program (independent of having been made by running the Program).; Whether that is true depends on what the Program does. 1. You may copy and distribute verbatim copies of the Program's; source code as you receive it, in any medium, provided that you; conspicuously and appropriately publish on each copy an appropriate; copyright notice and disclaimer of warranty; keep intact all the; notices that refer to this License and to the absence of any warranty;; and give any other recipients of the Program a copy of this License; along with the Program. You may charge a fee for the physical act of transferring a copy, and; you may at your option offer warranty protection in exchange for a fee. 2. You may modify your copy or copies of the Program or any portion; of it, thus forming a work based on the Program, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) You must cause the modified files to carry prominent notices; stating that you changed the files and the date of any change. b) You mu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:3893,depend,depends,3893,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['depend'],['depends']
Integrability,"MPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have any questions or need any help creating an LLVM project, the LLVM; team would be more than happy to help. You can always post your questions to; the `Discourse forums; <https://discourse.llvm.org>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8562,depend,depend,8562,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['depend'],['depend']
Integrability,"MT). Option Array Default value Predefined values Description. ErrorLevel No 1 − TMinuit: error level: 0.5=logL fit, 1=chi-squared fit. PrintLevel No -1 − TMinuit: output level: -1=least, 0, +1=all garbage. FitStrategy No 2 − TMinuit: fit strategy: 2=best. PrintWarnings No False − TMinuit: suppress warnings. UseImprove No True − TMinuit: use IMPROVE. UseMinos No True − TMinuit: use MINOS. SetBatch No False − TMinuit: use batch mode. MaxCalls No 1000 − TMinuit: approximate maximum number of function calls. Tolerance No 0.1 − TMinuit: tolerance to the function value at the minimum. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Genetic Algorithm (GA). Option Array Default value Predefined values Description. PopSize No 300 − Population size for GA. Steps No 40 − Number of steps for convergence. Cycles No 3 − Independent cycles of GA fitting. SC_steps No 10 − Spread control, steps. SC_rate No 5 − Spread control, rate: factor is changed depending on the rate. SC_factor No 0.95 − Spread control, factor. ConvCrit No 0.001 − Convergence criteria. SaveBestGen No 1 − Saves the best n results from each generation. They are included in the last cycle. SaveBestCycle No 10 − Saves the best n results from each cycle. They are included in the last cycle. The value should be set to at least 1.0. Trim No False − Trim the population to PopSize after assessing the fitness of each individual. Seed No 100 − Set seed of random generator (0 gives random seeds). Configuration options given in the ""PrepareForTrainingAndTesting"" call; these options define the creation of the data sets used for training and expert validation by TMVA :. Configuration options reference for class: DataSetFactory. Option Array Default value Predefined values Description. SplitMode No Random Random, Alternate, Block Method of picking training and testing events (default: random). MixMode No SameAsSplitMode SameAsSplitMode, Random, Alternate, Blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:31507,depend,depending,31507,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['depend'],['depending']
Integrability,"Mac (multiply-accumulate instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemIdx``; LLVM implements `the THeadMemIdx (indexed memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadMemPair``; LLVM implements `the THeadMemPair (two-GPR memory operations) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadSync``; LLVM implements `the THeadSync (multi-core synchronization instructions) vendor-defined instructions specified in <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.2/xthead-2023-01-30-2.2.2.pdf>`_ by T-HEAD of Alibaba. Instructions are prefixed with `th.` as described in the specification. ``XTHeadVdot``; LLVM implements `version 1.0.0 of the THeadV-family custom instructions specification <https://github.com/T-head-Semi/thead-extension-spec/releases/download/2.2.0/xthead-2022-12-04-2.2.0.pdf>`_ by T-HEAD of Alibaba. All instructions are prefixed with `th.` as described in the specification, and the riscv-toolchain-convention document linked above. ``XVentanaCondOps``; LLVM implements `version 1.0.0 of the VTx-family custom instructions specification <https://github.com/ventanamicro/ventana-custom-extensions/releases/download/v1.0.0/ventana-custom-extensions-v1.0.0.pdf>`_ by Ventana Micro Systems. All instructions are prefixed with `vt.` as described in the specification, and the riscv-toolchain-convention document l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:16260,synchroniz,synchronization,16260,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"Make. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory where ``LLVMConfig.cmake`` is found or allows the user to specify the; directory (e.g. by pass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41389,message,message,41389,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,['message'],['message']
Integrability,"Manual Data Model Evolution Capabilities - the user documentation. 1. Overview. The automatic data model schema evolution implemented in ROOT makes it possible; to read back the serialized data object in the situation when the definition of; the classes those objects represent changed slightly (some of the data members were; removed or some new ones added). It is also possible to manually specify the rules; for more sophisticated data transformations done while reading to load the serialized; objects into data structures that changed quite significantly. ROOT provides two interface enabling users to specify the conversion rules. The; first way is to define a rule in the dictionary file and the second way is to insert; it to the TClass object using the C++ API. There are two types of conversion rules. The first of them, the normal rules, are; the ones that should be used in the most of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no other option. 2. The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in CINT's LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. * For CINT dictionaries:. #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:579,interface,interface,579,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,1,['interface'],['interface']
Integrability,"Many useful optimizations that might theoretically decrease the lifetime of; an object would be rendered impossible. Essentially, it promises too much. A local variable of retainable object owner type and automatic storage duration; may be annotated with the ``objc_precise_lifetime`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:. Special methods; ---------------. .. _arc.misc.special_methods.retain:. Memory management methods; ^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it contains a method definition, message send, or; ``@selector`` expression for any of the following selectors:. * ``autorelease``; * ``release``; * ``retain``; * ``retainCount``. .. admonition:: Rationale. ``retainCount`` is banned because ARC robs it of consistent semantics. The; others were banned after weighing three options for how to deal with message; sends:. **Honoring** them would work out very poorly if a programmer naively or; accidentally tried to incorporate code written for manual retain/release code; into an ARC program. At best, such code would do twice as much work as; necessary; quite frequently, however, ARC and the explicit code would both; try to balance the same retain, leading to crashes. The cost is losing the; ability to perform ""unrooted"" retains, i.e. retains not logically; corresponding to a strong reference in the object graph. **Ignoring** them would badly violate user expectations about their code.; While it *would* make it easier to develop code simultaneously for ARC and; non-ARC, there is very",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:85175,message,message,85175,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132835,inject,injected,132835,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inject'],['injected']
Integrability,"Meeting</td></tr>; <tr><td>llvm-foundation</td><td>Community/LLVM Foundation</td></tr>; <tr><td>Mlir-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-dev</td><td>Runtimes/OpenMP</td></tr>; <tr><td>Parallel_libs-commits</td><td>no migration at the moment</td></tr>; <tr><td>Parallel_libs-dev</td><td>Runtimes/C++</td></tr>; <tr><td>Release-testers</td><td>Project Infrastructure/Release Testers</td></tr>; <tr><td>Test-list</td><td>Obsolete</td></tr>; <tr><td>vmkit-commits</td><td>Obsolete</td></tr>; <tr><td>WiCT</td><td>Community/Women in Compilers and Tools</td></tr>; <tr><td>www-scripts</td><td>Obsolete</td></tr> ; </table>. ## FAQ. ### I don't want to use a web UI. You can do most of the communication with your email client (see section on; Setting up email interactions above). You only need to set up your account once; and then configure which categories you want to subscribe to. ### How do I send a private message?. On the mailing list you have the opportunity to reply only to the sender of; the email, not to the entire list. That is not supported when replying via; email on Discourse. However you can send someone a private message via the; Web UI: Click on the user's name above a post and then on `Message`. Also Discourse does not expose users' email addresses , so your private; replies have to go through their platform (unless you happen to know the; email address of the user.). ### How can my script/tool send automatic messages?**. In case you want to [create a new; post/topic](https://docs.discourse.org/#tag/Posts/paths/~1posts.json/post); automatically from a script or tool, you can use the; [Discourse API](https://docs.discourse.org/). ### Who are the admins for Discourse?. See https://llvm.discourse.group/about. ### What is the reason for the migration?. See; [this email](https://lists.llvm.org/pipermail/llvm-dev/2021-June/150823.html). ### How do I set up a private mail",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:10240,message,message,10240,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['message'],['message']
Integrability,"Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Up",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:42392,rout,routines,42392,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['rout'],['routines']
Integrability,"Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` or `TGraph::Fit`.; The list of the current option values can be inspected by using `MinimizerOptions::Print`.; ```{.cpp}; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; ```. In addition it is possible to provide extra options which might apply for a particular minimizer `MinimizerOptions::SetExtraOptions(const IOptions & )`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:45556,depend,depending,45556,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['depending']
Integrability,"ModRule, ModRuleLinear, ModLinear Model to be used. RuleFitModule No RFTMVA RFTMVA, RFFriedman Which RuleFit module to use. RFWorkDir No ./rulefit − Friedman's RuleFit module (RFF): working dir. RFNrules No 2000 − RFF: Mximum number of rules. RFNendnodes No 4 − RFF: Average number of end nodes. Configuration options for MVA method :. Configuration options reference for MVA method: Likelihood. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TransformOutput No False − Transform likelihood output by inverse sigmoid function. Configuration options for MVA method :. Configuration options reference for MVA method: MLP. Option Array Default value Predefined values Description. NCycles No 500 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. NeuronType No sigmoid − Neuron activation function type. RandomSeed No 1 − Random seed for initial synapse weights (0 means unique seed for each run; default value '1'). EstimatorType No MSE MSE, CE, linear, sigmoid, tanh, radial MSE (Mean Square Estimator) for Gaussian Likelihood or CE(Cross-Entropy) for Bernoulli Likelihood. NeuronInputType No sum sum, sqsum, abssum Neuron input funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:20451,message,message,20451,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"MultiRootFinder::kHybridJ with name ""HybridJ"": unscaled version of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kNewton with name ""Newton"": Newton method ; ROOT::Math::GSLMultiRootFinder::kGNewton with name ""GNewton"": modified Newton method . The algorithms without derivatives (see also the GSL; documentation ); are the followings:; ; ROOT::Math::GSLMultiRootFinder::kHybridS with name ""HybridS"": same as HybridSJ but using; finate difference approximation for the derivatives; ROOT::Math::GSLMultiRootFinder::kHybrid with name ""Hybrid"": unscaled version of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kDNewton with name ""DNewton"": discrete Newton algorithm ; ROOT::Math::GSLMultiRootFinder::kBroyden with name ""Broyden"": Broyden algorithm . Minuit2. Improve Printing of information and Error messages. Use the class ROOT::Minuit2::MnPrint to store a; static print level, which can be set by using the static function MnPrint::SetLevel(int ). Add new information messages in the VariableMetricBuilder (i.e. Migrad), to print some messages; during the minimization.The new printing level is now also controlled by the Minuit2Minimizer class. ; Print now in the messages the parameter names instead of the parameter indices.; fix the update of the number of function calls in Minuit2 after calling Hess after Migrad. The number is now not; reset in MnHesse; Fix a problem, when, after calling Hesse ,the edm was correct to values below the required tolerance.; Now do not flag these cases as failed minimizations but as good ones.; Correct tolerance by 2E-3 instead 2E-4 to ve conistent with what is done in F77 Minuit or TMinuit; Avoid when using the CombinedMinimumBuilder (i.e. the Minimize algorithm) to call two times; ModularFunctionMinimize::Minimum. Since this last function correct the tolerance by the Up value, a; double correction was applied in this case. ; Implement the methods Minuit2Minimizer::GetHessianMatrix(double * mat) and; Minuit2Minimizer::GetCovMatr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:4866,message,messages,4866,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,1,['message'],['messages']
Integrability,"N expected, iN desired); iN __sync_lock_test_and_set_N(iN *ptr, iN val); iN __sync_fetch_and_add_N(iN *ptr, iN val); iN __sync_fetch_and_sub_N(iN *ptr, iN val); iN __sync_fetch_and_and_N(iN *ptr, iN val); iN __sync_fetch_and_or_N(iN *ptr, iN val); iN __sync_fetch_and_xor_N(iN *ptr, iN val); iN __sync_fetch_and_nand_N(iN *ptr, iN val); iN __sync_fetch_and_max_N(iN *ptr, iN val); iN __sync_fetch_and_umax_N(iN *ptr, iN val); iN __sync_fetch_and_min_N(iN *ptr, iN val); iN __sync_fetch_and_umin_N(iN *ptr, iN val). This list doesn't include any function for atomic load or store; all known; architectures support atomic loads and stores directly (possibly by emitting a; fence on either side of a normal load or store.). There's also, somewhat separately, the possibility to lower ``ATOMIC_FENCE`` to; ``__sync_synchronize()``. This may happen or not happen independent of all the; above, controlled purely by ``setOperationAction(ISD::ATOMIC_FENCE, ...)``. On AArch64, a variant of the __sync_* routines is used which contain the memory; order as part of the function name. These routines may determine at runtime; whether the single-instruction atomic operations which were introduced as part; of AArch64 Large System Extensions ""LSE"" instruction set are available, or if; it needs to fall back to an LL/SC loop. The following helper functions are; implemented in both ``compiler-rt`` and ``libgcc`` libraries; (``N`` is one of 1, 2, 4, 8, and ``M`` is one of 1, 2, 4, 8 and 16, and; ``ORDER`` is one of 'relax', 'acq', 'rel', 'acq_rel')::. iM __aarch64_casM_ORDER(iM expected, iM desired, iM *ptr); iN __aarch64_swpN_ORDER(iN val, iN *ptr); iN __aarch64_ldaddN_ORDER(iN val, iN *ptr); iN __aarch64_ldclrN_ORDER(iN val, iN *ptr); iN __aarch64_ldeorN_ORDER(iN val, iN *ptr); iN __aarch64_ldsetN_ORDER(iN val, iN *ptr). Please note, if LSE instruction set is specified for AArch64 target then; out-of-line atomics calls are not generated and single-instruction atomic; operations are used in place.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:30275,rout,routines,30275,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,2,['rout'],['routines']
Integrability,"NABLE_THREADS ""Use threads if available."" OFF); else(); option(LLVM_ENABLE_THREADS ""Use threads if available."" ON); endif(). set(LLVM_ENABLE_ZLIB ""ON"" CACHE STRING ""Use zlib for compression/decompression if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_ENABLE_ZSTD ""ON"" CACHE STRING ""Use zstd for compression/decompression if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_USE_STATIC_ZSTD FALSE CACHE BOOL ""Use static version of zstd. Can be TRUE, FALSE""). set(LLVM_ENABLE_CURL ""OFF"" CACHE STRING ""Use libcurl for the HTTP client if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_ENABLE_HTTPLIB ""OFF"" CACHE STRING ""Use cpp-httplib HTTP server library if available. Can be ON, OFF, or FORCE_ON""). set(LLVM_Z3_INSTALL_DIR """" CACHE STRING ""Install directory of the Z3 solver.""). option(LLVM_ENABLE_Z3_SOLVER; ""Enable Support for the Z3 constraint solver in LLVM.""; ${LLVM_ENABLE_Z3_SOLVER_DEFAULT}; ). if (LLVM_ENABLE_Z3_SOLVER); find_package(Z3 4.7.1). if (LLVM_Z3_INSTALL_DIR); if (NOT Z3_FOUND); message(FATAL_ERROR ""Z3 >= 4.7.1 has not been found in LLVM_Z3_INSTALL_DIR: ${LLVM_Z3_INSTALL_DIR}.""); endif(); endif(). if (NOT Z3_FOUND); message(FATAL_ERROR ""LLVM_ENABLE_Z3_SOLVER cannot be enabled when Z3 is not available.""); endif(). set(LLVM_WITH_Z3 1); endif(). set(LLVM_ENABLE_Z3_SOLVER_DEFAULT ""${Z3_FOUND}""). if( LLVM_TARGETS_TO_BUILD STREQUAL ""all"" ); set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} ); endif(). if(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD STREQUAL ""all""); set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${LLVM_ALL_EXPERIMENTAL_TARGETS}); endif(). set(LLVM_TARGETS_TO_BUILD; ${LLVM_TARGETS_TO_BUILD}; ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD}); list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD). if (NOT CMAKE_SYSTEM_NAME MATCHES ""OS390""); option(LLVM_ENABLE_PIC ""Build Position-Independent Code"" ON); endif(); option(LLVM_ENABLE_MODULES ""Compile with C++ modules enabled."" OFF); if(${CMAKE_SYSTEM_NAME} MATCHES ""Darwin""); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" ON)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:23344,message,message,23344,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"NG_LIBS); list(REMOVE_DUPLICATES CLANG_LIBS); foreach(lib ${CLANG_LIBS}); add_dependencies(clang-libraries ${lib}); if(NOT LLVM_ENABLE_IDE); add_dependencies(install-clang-libraries install-${lib}); add_dependencies(install-clang-libraries-stripped install-${lib}-stripped); endif(); endforeach(); endif(). add_subdirectory(cmake/modules). if(CLANG_STAGE); message(STATUS ""Setting current clang stage to: ${CLANG_STAGE}""); endif(). if (CLANG_ENABLE_BOOTSTRAP); include(ExternalProject). add_custom_target(clang-bootstrap-deps DEPENDS clang). if(NOT CLANG_STAGE); set(CLANG_STAGE stage1); endif(). string(REGEX MATCH ""stage([0-9]*)"" MATCHED_STAGE ""${CLANG_STAGE}""); if(MATCHED_STAGE); if(NOT LLVM_BUILD_INSTRUMENTED); math(EXPR STAGE_NUM ""${CMAKE_MATCH_1} + 1""); set(NEXT_CLANG_STAGE stage${STAGE_NUM}); else(); set(NEXT_CLANG_STAGE stage${CMAKE_MATCH_1}); endif(); else(); set(NEXT_CLANG_STAGE bootstrap); endif(). if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED); set(NEXT_CLANG_STAGE ${NEXT_CLANG_STAGE}-instrumented); endif(); message(STATUS ""Setting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:20636,message,message,20636,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"NTEL_JITEVENTS; ""Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code""; OFF). if( LLVM_USE_INTEL_JITEVENTS ); # Verify we are on a supported platform; if( NOT CMAKE_SYSTEM_NAME MATCHES ""Windows"" AND NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR; ""Intel JIT API support is available on Linux and Windows only.""); endif(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:27761,message,message,27761,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"No N,N-1 − Specification of hidden layer architecture. NeuronType No sigmoid − Neuron activation function type. RandomSeed No 1 − Random seed for initial synapse weights (0 means unique seed for each run; default value '1'). EstimatorType No MSE MSE, CE, linear, sigmoid, tanh, radial MSE (Mean Square Estimator) for Gaussian Likelihood or CE(Cross-Entropy) for Bernoulli Likelihood. NeuronInputType No sum sum, sqsum, abssum Neuron input function type. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TrainingMethod No BP BP, GA, BFGS Train with Back-Propagation (BP), BFGS Algorithm (BFGS), or Genetic Algorithm (GA - slower and worse). LearningRate No 0.02 − ANN learning rate parameter. DecayRate No 0.01 − Decay rate for learning parameter. TestRate No 10 − Test for overtraining performed at each #th epochs. EpochMonitoring No False − Provide epoch-wise monitoring plots according to TestRate (caution: causes big ROOT output file!). Sampling No 1 − Only 'Sampling' (randomly selected) events are trained each epoch. SamplingEpoch No 1 − Sampling is used for the first 'SamplingEpoch' epochs, afterwards, all events are taken for training. SamplingImportance No 1 − The sampling weights of events in epochs which successful (worse ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:22008,message,message,22008,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"NoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:41163,interface,interface,41163,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"OC only works with CMAKE_MSVC_RUNTIME_LIBRARY set to MultiThreaded or MultiThreadedDebug.""); endif(). string(REGEX REPLACE ""(/|\\\\)$"" """" LLVM_INTEGRATED_CRT_ALLOC ""${LLVM_INTEGRATED_CRT_ALLOC}""). if(NOT EXISTS ""${LLVM_INTEGRATED_CRT_ALLOC}""); message(FATAL_ERROR ""Cannot find the path to `git clone` for the CRT allocator! (${LLVM_INTEGRATED_CRT_ALLOC}). Currently, rpmalloc, snmalloc and mimalloc are supported.""); endif(). if(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""rpmalloc$""); add_compile_definitions(ENABLE_OVERRIDE ENABLE_PRELOAD); set(ALLOCATOR_FILES ""${LLVM_INTEGRATED_CRT_ALLOC}/rpmalloc/rpmalloc.c""); elseif(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""snmalloc$""); set(ALLOCATOR_FILES ""${LLVM_INTEGRATED_CRT_ALLOC}/src/snmalloc/override/new.cc""); set(system_libs ${system_libs} ""mincore.lib"" ""-INCLUDE:malloc""); elseif(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""mimalloc$""); set(MIMALLOC_LIB ""${LLVM_INTEGRATED_CRT_ALLOC}/out/msvc-x64/Release/mimalloc-static.lib""); if(NOT EXISTS ""${MIMALLOC_LIB}""); 	 message(FATAL_ERROR ""Cannot find the mimalloc static library. To build it, first apply the patch from https://github.com/microsoft/mimalloc/issues/268 then build the Release x64 target through ${LLVM_INTEGRATED_CRT_ALLOC}\\ide\\vs2019\\mimalloc.sln""); endif(); set(system_libs ${system_libs} ""${MIMALLOC_LIB}"" ""-INCLUDE:malloc""); endif(); endif(). # FIXME: We are currently guarding AIX headers with _XOPEN_SOURCE=700.; # See llvm/CMakeLists.txt. However, we need _SC_NPROCESSORS_ONLN in; # unistd.h and it is guarded by _ALL_SOURCE, so we remove the _XOPEN_SOURCE; # guard here. We should remove the guards all together once AIX cleans up; # the system headers.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""AIX""); remove_definitions(""-D_XOPEN_SOURCE=700""); endif(). add_subdirectory(BLAKE3). add_llvm_component_library(LLVMSupport; ABIBreak.cpp; AMDGPUMetadata.cpp; APFixedPoint.cpp; APFloat.cpp; APInt.cpp; APSInt.cpp; ARMBuildAttrs.cpp; ARMAttributeParser.cpp; ARMWinEH.cpp; Allocator.cpp; AutoConvert.cpp; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:4751,message,message,4751,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['message'],['message']
Integrability,"OJECTS ""flang""); # List of all known projects in the mono repo; set(LLVM_KNOWN_PROJECTS ""${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}""); set(LLVM_ENABLE_PROJECTS """" CACHE STRING; ""Semicolon-separated list of projects to build (${LLVM_KNOWN_PROJECTS}), or \""all\"".""); # Make sure expansion happens first to not handle ""all"" in rest of the checks.; if( LLVM_ENABLE_PROJECTS STREQUAL ""all"" ); set( LLVM_ENABLE_PROJECTS ${LLVM_ALL_PROJECTS}); endif(); foreach(proj ${LLVM_ENABLE_PROJECTS}); if (NOT proj STREQUAL ""llvm"" AND NOT ""${proj}"" IN_LIST LLVM_KNOWN_PROJECTS); MESSAGE(FATAL_ERROR ""${proj} isn't a known project: ${LLVM_KNOWN_PROJECTS}. Did you mean to enable it as a runtime in LLVM_ENABLE_RUNTIMES?""); endif(); endforeach(). if (""flang"" IN_LIST LLVM_ENABLE_PROJECTS); if (NOT ""mlir"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling MLIR as a dependency to flang""); list(APPEND LLVM_ENABLE_PROJECTS ""mlir""); endif(). if (NOT ""clang"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""Clang is not enabled, but is required for the Flang driver""); endif(); endif(). # Select the runtimes to build; #; # As we migrate runtimes to using the bootstrapping build, the set of default runtimes; # should grow as we remove those runtimes from LLVM_ENABLE_PROJECTS above.; set(LLVM_DEFAULT_RUNTIMES ""libcxx;libcxxabi;libunwind""); set(LLVM_SUPPORTED_RUNTIMES ""libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp;llvm-libgcc""); set(LLVM_ENABLE_RUNTIMES """" CACHE STRING; ""Semicolon-separated list of runtimes to build, or \""all\"" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.""); if(LLVM_ENABLE_RUNTIMES STREQUAL ""all""); set(LLVM_ENABLE_RUNTIMES ${LLVM_DEFAULT_RUNTIMES}); endif(); foreach(proj IN LISTS LLVM_ENABLE_RUNTIMES); if (NOT ""${proj}"" IN_LIST LLVM_SUPPORTED_RUNTIMES); message(FATAL_ERROR ""Runtime \""${proj}\"" is not a supported runtime. Supported runtimes are: ${LLVM_SUPPORTED_RUNTIMES}""); endif(); endforeach(). if (""libc"" IN_LIST LLVM_ENABLE_RUNTIMES);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:6484,message,message,6484,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"OO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. IndentWidth: 3. void f() {; someFunction();; if (true, false) {; f();; }; }. .. _IndentWrappedFunctionNames:. **IndentWrappedFunctionNames** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWrappedFunctionNames>`; Indent if a function definition or declaration is wrapped after the; type. .. code-block:: c++. true:; LoooooooooooooooooooooooooooooooooooooooongReturnType; LoooooooooooooooooooooooooooooooongFunctionDeclaration();. false:; LoooooooooooooooooooooooooooooooooooooooongReturnType; LoooooooooooooooooooooooooooooooongFunctionDeclaration();. .. _InsertBraces:. **InsertBraces** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <InsertBraces>`; Insert braces after control statements (``if``, ``else``, ``for``, ``do``,; and ``while``) in C++ unless the control statements are inside macro; definitions or the braces would enclose preprocessor directives. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) vs. if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D); handleFunctio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:74632,wrap,wrapped,74632,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"OOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage` is the image manipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:13651,interface,interface,13651,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"OOL literals.; NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES]; NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO]. #ifdef __cplusplus; NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Objective-C++ also supports ``@true`` and ``@false`` expressions, which; are equivalent to ``@YES`` and ``@NO``. Boxed Expressions; =================. Objective-C provides a new syntax for boxing C expressions:. .. code-block:: objc. @( <expression> ). Expressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3314,wrap,wrapping,3314,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['wrap'],['wrapping']
Integrability,"OOT 6.36. If you want to fit the model as well instead of just exporting it to a RooWorkspace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAsConstDataSet(); mcIntParams = mcInt.GetParameters(). chainDataset = mkcData.reduce(SelectVars=mcIntParams, EventRange=(mcInt.GetNumBurnInSteps(), mkc.Size())); chainDataHist = chainDataset.binnedClone(); ```. * The following methods related to the RooAbsArg interface are deprecated and will be removed in ROOT 6.36.; They should be replaced with the suitable alternatives interfaces:. - `RooAbsArg::getDependents()`: use `getObservables()`; - `RooAbsArg::dependentOverlaps()`: use `observableOverlaps()`; - `RooAbsArg::checkDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:6341,interface,interface,6341,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['interface'],['interface']
Integrability,"ORY ${CMAKE_CURRENT_BINARY_DIR}/include/cling; DESTINATION include; FILES_MATCHING; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""*.inc""; PATTERN ""*.h""; PATTERN ""*.modulemap""; ); endif(). add_definitions( -D_GNU_SOURCE -DCLING_VERSION=${CLING_VERSION}). option(CLING_INCLUDE_TESTS; ""Generate build targets for the Cling unit tests.""; ${LLVM_INCLUDE_TESTS}). if (NOT WIN32); set(cling_path_delim "":""); else(); set(cling_path_delim "";""); endif(). if( CLING_INCLUDE_TESTS ); set(cling_include_deflt ${CMAKE_INSTALL_PREFIX}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ${CLANG_INCLUDE_DIRS}; ${LLVM_INCLUDE_DIRS}; ). # CLANG_INCLUDE_DIRS and LLVM_INCLUDE_DIRS can be a semicolon separated lists.; string(REPLACE "";"" ""${cling_path_delim}"" cling_include_deflt ""${cling_include_deflt}""); endif(). if(NOT CLING_INCLUDE_PATHS); set(CLING_INCLUDE_PATHS ""${cling_include_deflt}""); else(); set(CLING_INCLUDE_PATHS ""${CLING_INCLUDE_PATHS}${cling_path_delim}${cling_include_deflt}""); endif(). # All targets below may depend on all tablegen'd files.; get_property(CLANG_TABLEGEN_TARGETS GLOBAL PROPERTY CLANG_TABLEGEN_TARGETS); list(APPEND LLVM_COMMON_DEPENDS ${CLANG_TABLEGEN_TARGETS}). # And llvm-intrinsics.; if (TARGET intrinsics_gen); list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen); endif(); if (TARGET clang-headers); list(APPEND LLVM_COMMON_DEPENDS clang-headers); endif(). add_subdirectory(include/cling/Interpreter); add_subdirectory(lib). if( CLING_INCLUDE_TESTS ); add_subdirectory(test). if(CLING_BUILT_STANDALONE); # Add a global check rule now that all subdirectories have been traversed; # and we know the total set of lit testsuites.; get_property(LLVM_LIT_TESTSUITES GLOBAL PROPERTY LLVM_LIT_TESTSUITES); get_property(LLVM_LIT_PARAMS GLOBAL PROPERTY LLVM_LIT_PARAMS); get_property(LLVM_LIT_DEPENDS GLOBAL PROPERTY LLVM_LIT_DEPENDS); get_property(LLVM_LIT_EXTRA_ARGS GLOBAL PROPERTY LLVM_LIT_EXTRA_ARGS); add_lit_target(check-all; ""Running all regression tests""; ${LLVM_LIT_TESTSUITES}; PARAMS ${LLVM_LIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:16535,depend,depend,16535,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['depend'],['depend']
Integrability,"OT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration phase FOAM object; including distribution function will be written to disk. #### foam_demopers.C; demonstrates persistency of FOAM classes.; To run this macro type:. ```; root [0] .x foam_demopers.C; ```. Program reads the FOAM object from disk, checks its; consistency and prints geometry of cells. Next starts the; the generation. It can be interpreted directly by CLING; because compiled TFDISTR class is already available in; `foam_demo_C.so` library. @}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:1574,interface,interface,1574,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,1,['interface'],['interface']
Integrability,"OT6; - Implement box and hbox draw options for TH1 class; - Significant (factor 4) I/O performance improvement; - New 'flex' layout:; - create frames like in Multi Document Interface; - one could move/resize/minimize/maximize such frames. For more details, like the complete change log, the documentation, and very detailed examples, see the [JSROOT home page](https://root.cern.ch/js) and the [JSROOT project github page](https://github.com/linev/jsroot) . ## Tutorials; * New tutorial `treegetval.C` illustrating how to retrieve `TTree` variables in arrays.; * Add script to automatically translate tutorials into notebooks; * Embed it into the documentation generation; * Make the notebooks available in the [tutorials section of the class documentation](https://root.cern/doc/master/group__Tutorials.html). ## Build, Configuration and Testing Infrastructure; - `root-config` does not suppress deprecation warnings (-Wno-deprecated-declarations) anymore. This means compilers will now diagnose the use of deprecated interfaces in user code.; - Added new 'builtin_vc' option to bundle a version of Vc within ROOT.; The default is OFF, however if the Vc package is not found in the system the option is switched to; ON if the option 'vc' option is ON.; - Many improvements (provided by Mattias Ellert):; - Build RFIO using dpm libraries if castor libraries are not available; - Add missing glib header path in GFAL module for version > 2; - Search also for globus libraries wouthout the flavour in the name; - Add missing io/hdfs/CMakeLists.txt; - net/globusauth has no installed headers - remove ROOT_INSTALL_HEADERS(); - Add missing pieces to the cmake config that are built by configure: bin/pq2, bin/rootd, bin/xpdtest, initd and xinitd start-up scripts; - Only link to libgfortranbegin.a when it is provided by the compiler; - Don't remove -Wall without also removing -Werror=*; - Don't overwrite the initial value of CMAKE_Fortran_FLAGS. Inconsistent case variant of CMAKE_Fortran_FLAGS; - Use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:28375,interface,interfaces,28375,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['interface'],['interfaces']
Integrability,"OT::Math::beta_inc.; TMath::GammaDist is implemented using ROOT::Math::gamma_pdf.; TMath::LogNormal is implemented using ROOT::Math::lognormal_pdf.; TMath::PoissonI: fixed a problem for large values and is implemented using directly TMath::Poisson with integer values. Fit; Mathcore include now new classes for performing fits and minimization of multi-dimensional functions. The aim of these classes is to extend and improve the fitting functionality provided in ROOT via the TVirtualFitter classes and the fitting methods present in many data analysis object, such as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinDat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:4770,interface,interface,4770,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"O_TRAINING_DATA_SOURCE_DIR OFF CACHE STRING ""Path to source directory containing cmake project with source files to use for generating pgo data""); set(CLANG_PGO_TRAINING_DEPS """" CACHE STRING ""Extra dependencies needed to build the PGO training data.""). if(LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/lit.site.cfg; ). add_lit_testsuite(generate-profraw ""Generating clang PGO data""; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang clear-profraw ${CLANG_PGO_TRAINING_DEPS}; ). add_custom_target(clear-profraw; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/ profraw; COMMENT ""Clearing old profraw data""). if(NOT LLVM_PROFDATA); find_program(LLVM_PROFDATA llvm-profdata); endif(). if(NOT LLVM_PROFDATA); message(STATUS ""To enable merging PGO data LLVM_PROFDATA has to point to llvm-profdata""); else(); add_custom_target(generate-profdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:1113,message,message,1113,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['message'],['message']
Integrability,"Obsolete</td></tr>; <tr><td>vmkit-commits</td><td>Obsolete</td></tr>; <tr><td>WiCT</td><td>Community/Women in Compilers and Tools</td></tr>; <tr><td>www-scripts</td><td>Obsolete</td></tr> ; </table>. ## FAQ. ### I don't want to use a web UI. You can do most of the communication with your email client (see section on; Setting up email interactions above). You only need to set up your account once; and then configure which categories you want to subscribe to. ### How do I send a private message?. On the mailing list you have the opportunity to reply only to the sender of; the email, not to the entire list. That is not supported when replying via; email on Discourse. However you can send someone a private message via the; Web UI: Click on the user's name above a post and then on `Message`. Also Discourse does not expose users' email addresses , so your private; replies have to go through their platform (unless you happen to know the; email address of the user.). ### How can my script/tool send automatic messages?**. In case you want to [create a new; post/topic](https://docs.discourse.org/#tag/Posts/paths/~1posts.json/post); automatically from a script or tool, you can use the; [Discourse API](https://docs.discourse.org/). ### Who are the admins for Discourse?. See https://llvm.discourse.group/about. ### What is the reason for the migration?. See; [this email](https://lists.llvm.org/pipermail/llvm-dev/2021-June/150823.html). ### How do I set up a private mailing list?. If needed categories can have individual [security; settings](https://meta.discourse.org/t/how-to-use-category-security-settings-to-create-private-categories/87678); to limit visibility and write permissions. Contact the; [admins](https://llvm.discourse.group/about) if you need such a category. ### What will happen to our email archives?. The Mailman archives will remain on the web server for now. ### What are advantages of Discourse over the current mailing lists?. * Users can post to any category, also ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:10766,message,messages,10766,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['message'],['messages']
Integrability,"Offloading entry information (see :ref:`table-tgt_offload_entry_structure`) |; +----------------------------------+------------------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14077,wrap,wrapped,14077,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapped']
Integrability,"Ok, here are my comments and suggestions about the LLVM instruction set.; We should discuss some now, but can discuss many of them later, when we; revisit synchronization, type inference, and other issues.; (We have discussed some of the comments already.). o We should consider eliminating the type annotation in cases where it is; essentially obvious from the instruction type, e.g., in br, it is obvious; that the first arg. should be a bool and the other args should be labels:. 	br bool <cond>, label <iftrue>, label <iffalse>. I think your point was that making all types explicit improves clarity; and readability. I agree to some extent, but it also comes at the cost; of verbosity. And when the types are obvious from people's experience; (e.g., in the br instruction), it doesn't seem to help as much. o On reflection, I really like your idea of having the two different switch; types (even though they encode implementation techniques rather than; semantics). It should simplify building the CFG and my guess is it could; enable some significant optimizations, though we should think about which. o In the lookup-indirect form of the switch, is there a reason not to make; the val-type uint? Most HLL switch statements (including Java and C++); require that anyway. And it would also make the val-type uniform ; in the two forms of the switch. I did see the switch-on-bool examples and, while cute, we can just use; the branch instructions in that particular case. o I agree with your comment that we don't need 'neg'. o There's a trade-off with the cast instruction:; + it avoids having to define all the upcasts and downcasts that are; valid for the operands of each instruction (you probably have thought; of other benefits also); - it could make the bytecode significantly larger because there could; be a lot of cast operations. o Making the second arg. to 'shl' a ubyte seems good enough to me.; 255 positions seems adequate for several generations of machines; and is more compact th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt:155,synchroniz,synchronization,155,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveComments.txt,1,['synchroniz'],['synchronization']
Integrability,"OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``. The emit operation takes a ``MaterializationResponsibility`` object and an; instance of your program representation and materializes it, usually by compiling it and handing; the resulting object off to an ``ObjectLinkingLayer``. Your custom ``MaterializationUnit`` will have two operations: ``materialize`` and ``discard``. The; ``materialize`` function will be called for you when any symbol provided by the unit is looked up,; and it should just call the ``emit`` function on your layer, passing in the given; ``MaterializationResponsibility`` and the wrapped program representation. The ``discard`` function; will be called if some weak symbol provided by your unit is not needed (because the JIT found an; overriding definition). You can use this to drop your definition early, or just ignore it and let; the linker drops the definition later. Here is an example of an ASTLayer:. .. code-block:: c++. // ... In you JIT class; AstLayer astLayer;; // ... class AstMaterializationUnit : public orc::MaterializationUnit {; public:; AstMaterializationUnit(AstLayer &l, Ast &ast); : llvm::orc::MaterializationUnit(l.getInterface(ast)), astLayer(l),; ast(ast) {};. llvm::StringRef getName() const override {; return ""AstMaterializationUnit"";; }. void materialize(std::unique_ptr<orc::MaterializationResponsibility> r) override {; astLayer.emit(std::move(r), ast);; };. private:; void discard(const llvm::orc::JITDylib &jd, const llvm::orc::SymbolStringPtr &",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:25633,wrap,wrapped,25633,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrapped']
Integrability,"P). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values instead. NaNs will be converted to zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54925,depend,depends,54925,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depends']
Integrability,"PEND RUNTIME_NAMES ${name}); endforeach(). function(runtime_default_target); cmake_parse_arguments(ARG """" """" ""DEPENDS;CMAKE_ARGS;PREFIXES"" ${ARGN}). include(${LLVM_BINARY_DIR}/runtimes/Components.cmake OPTIONAL); set(SUB_CHECK_TARGETS ${SUB_CHECK_TARGETS} PARENT_SCOPE); set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS ${LLVM_BINARY_DIR}/runtimes/Components.cmake). foreach(runtime_name ${RUNTIME_NAMES}); list(APPEND extra_targets; ${runtime_name}; install-${runtime_name}; install-${runtime_name}-stripped); if(LLVM_INCLUDE_TESTS); list(APPEND test_targets check-${runtime_name}); endif(); endforeach(); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); if(NOT ${component} IN_LIST SUB_COMPONENTS); list(APPEND extra_targets install-${component} install-${component}-stripped); endif(); endforeach(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_LIT_TESTSUITES ""@${LLVM_BINARY_DIR}/runtimes/runtimes-bins/lit.tests""); list(APPEND test_targets runtimes-test-depends check-runtimes); endif(). set_enable_per_target_runtime_dir(). llvm_ExternalProject_Add(runtimes; ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes; DEPENDS ${ARG_DEPENDS}; # Builtins were built separately above; CMAKE_ARGS -DCOMPILER_RT_BUILD_BUILTINS=Off; -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}; -DLLVM_DEFAULT_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}; -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}; -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}; -DLLVM_BUILD_TOOLS=${LLVM_BUILD_TOOLS}; -DCMAKE_C_COMPILER_WORKS=ON; -DCMAKE_CXX_COMPILER_WORKS=ON; -DCMAKE_ASM_COMPILER_WORKS=ON; ${COMMON_CMAKE_ARGS}; ${RUNTIMES_CMAKE_ARGS}; ${ARG_CMAKE_ARGS}; PASSTHROUGH_PREFIXES LLVM_ENABLE_RUNTIMES; LLVM_USE_LINKER; ${ARG_PREFIXES}; EXTRA_TARGETS ${extra_targets}; ${test_targets}; ${SUB_COMPONENTS}; ${SUB_CHECK_TARGETS}; ${SUB_INSTALL_TARGETS}; USE_TOOLCHAIN; TARGET_TRIPLE ${LLVM_TARGET_TRIPLE}; ${EXTRA_ARGS}); endfunction(). # runtime_register_target(name); #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:8361,depend,depends,8361,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['depend'],['depends']
Integrability,"PEND dataframe_veto dataframe/df036_missingBranches.C); list(APPEND dataframe_veto dataframe/df036_missingBranches.py); list(APPEND dataframe_veto dataframe/df037_TTreeEventMatching.C); list(APPEND dataframe_veto dataframe/df037_TTreeEventMatching.py); # The RooFit SBI tutorials fail on Windows for unknown reasons; list(APPEND roofit_veto roofit/rf617_simulation_based_inference_multidimensional.py); endif(). # TODO: fix the problem and re-enable the tutorial test. The rf615 tutorial; # occasionally fails on cleanup on different platforms, hinting to a PyROOT; # issue. We disable the rf617 tutorial for now. as the covered RooFit; # functionality is also covered by rf617 (the multidimensional case).; list(APPEND roofit_veto roofit/rf615_simulation_based_inference.py). if (NOT dataframe); # RDataFrame; list(APPEND dataframe_veto dataframe/*.C dataframe/*.py); # RDataFrame tutorial in graphs; list(APPEND dataframe_veto graphs/timeSeriesFromCSV_TDF.C); # TMVA tutorials dependent on RDataFrame; list(APPEND dataframe_veto tmva/tmva*.C); list(APPEND dataframe_veto tmva/TMVA_SOFIE_RDataFrame*.C); list(APPEND dataframe_veto tmva/TMVA_SOFIE_RDataFrame*.py); list(APPEND dataframe_veto tmva/TMVA_SOFIE_Inference.py); list(APPEND dataframe_veto tmva/RBatchGenerator_NumPy.py); list(APPEND dataframe_veto tmva/RBatchGenerator_TensorFlow.py); list(APPEND dataframe_veto tmva/RBatchGenerator_PyTorch.py); list(APPEND dataframe_veto tmva/RBatchGenerator_filters_vectors.py); # RooFit tutorial depending on RDataFrame; list(APPEND dataframe_veto roofit/rf408*); endif(). if(NOT sqlite); # RDF+SQlite tutorials; list(APPEND dataframe_veto dataframe/*SQlite*); endif(); if(NOT davix); list(APPEND dataframe_veto dataframe/df027_SQliteDependencyOverVersion.C); list(APPEND dataframe_veto dataframe/df028_SQliteIPLocation.C); list(APPEND dataframe_veto dataframe/df029_SQlitePlatformDistribution.C); list(APPEND dataframe_veto dataframe/df030_SQliteVersionsOfROOT.C); endif(). if(MACOSX_VERSION VERSION_E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:4496,depend,dependent,4496,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['dependent']
Integrability,"PIs directly for doing so. To do this, you'll need to include the; ``xray_log_interface.h`` from the compiler-rt ``xray`` directory. The important API; functions we list below:. - ``__xray_log_register_mode(...)``: Register a logging implementation against; a string Mode identifier. The implementation is an instance of; ``XRayLogImpl`` defined in ``xray/xray_log_interface.h``.; - ``__xray_log_select_mode(...)``: Select the mode to install, associated with; a string Mode identifier. Only implementations registered with; ``__xray_log_register_mode(...)`` can be chosen with this function.; - ``__xray_log_init_mode(...)``: This function allows for initializing and; re-initializing an installed logging implementation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:7561,rout,routine,7561,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['rout'],['routine']
Integrability,"PR [#6979](https://github.com/root-project/root/pull/6979)). Refer to the `RNTupleReader::OpenFriends()` function.; - Cluster and page sizes in `RNTupleWriteOptions` now refer to their target size in bytes (as opposed to the number of entries). Defaults are 64 kB for the page size and 50 MB for the cluster size (PR [#8703](https://github.com/root-project/root/pull/8703)).; - Storing objects of user-defined classes via `TClass` now also includes members inherited from all the base classes (PR [#8552](https://github.com/root-project/root/pull/8552)).; - Support for RFields whose type is a typedef to some other type. ## RDataFrame. ### New features. - Add [`Redefine`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a4e882a949c8a1022a38ec6936c2ff29c) to the `RDataFrame` interface, which allows to overwrite the value of an existing column.; - Add [`Describe`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a53f3e3d81e041a804481df228fe0081c) to the `RDataFrame` interface, which allows to get useful information, e.g. the columns and their types.; - Add [`DescribeDataset`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a1bc5b86a2a834bb06711fb535451146d) to the `RDataFrame` interface, which allows to get information about the dataset (subset of the output of Describe()).; - Add [`DefinePerSample`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a29d77593e95c0f84e359a802e6836a0e), a method which makes it possible to define columns based on the sample and entry range being processed. It is also a useful way to register callbacks that should only be called when the input dataset/TTree changes.; - Add [`HistoND`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#a0c9956a0f48c26f8e4294e17376c7fea) action that fills a N-dimensional histogram.; - `Book` now supports just-in-time compilation, i.e. it can be called without passing the column types as template parameters (with some performance penalty, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:7521,interface,interface,7521,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability,"Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:48463,depend,dependent,48463,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61755,integrat,integration,61755,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"PtrIdx %masked, %intptr; %result = getelementptr i8, ptr %ptr, iPtrIdx %diff. If the pointer index type size is smaller than the pointer type size, this; implies that pointer bits beyond the index size are not affected by this; intrinsic. For integral pointers, it behaves as if the mask were extended with; 1 bits to the pointer type size. Both the returned pointer(s) and the first argument are based on the same; underlying object (for more information on the *based on* terminology see; :ref:`the pointer aliasing rules <pointeraliasing>`). The intrinsic only captures the pointer argument through the return value. .. _int_threadlocal_address:. '``llvm.threadlocal.address``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.threadlocal.address(ptr) nounwind willreturn memory(none). Arguments:; """""""""""""""""""". The first argument is a pointer, which refers to a thread local global. Semantics:; """""""""""""""""""". The address of a thread local global is not a constant, since it depends on; the calling thread. The `llvm.threadlocal.address` intrinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.i32(); declare i64 llvm.vscale.i64(). Overview:; """""""""""""""""". The ``llvm.vscale`` intrinsic returns the value for ``vscale`` in scalable; vectors such as ``<vscale x 16 x i8>``. Semantics:; """""""""""""""""""". ``vscale`` is a positive value that is constant throughout program; execution, but is unknown at compile time.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. Stack Map Intrinsics; --------------------. LLVM provides experimental intrinsics to support runtime patching; mechanisms commonly desired in dynamic language JITs. These intrinsics; are described in :doc:`StackMaps`. Element Wise Atomic Memory Intrinsics; --------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:955852,depend,depends,955852,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,R0. P2092R0; Clang 16. P2113R0; Clang 16. Range-based for statements with initializer; P0614R1; Clang 8. ADL and function templates that are not visible; P0846R0; Clang 9. const mismatch with defaulted copy constructor; P0641R2; Clang 8. Consistent comparison (operator<=>); P0515R3; Clang 10. ; P0905R1. ; P1120R0. ; P1185R2. ; P1186R3. P1630R1. ; P1946R0. P1959R0. ; P2002R1; Clang 17. P2085R0; Clang 14. Access checking on specializations; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macros; P0941R2; (see below). explicit(bool); P0892R2; Clang 9. Signed integers are two's complement; P1236R1; Clang 9. char8_t; P0482R6; Clang 7 (11). Immediate functions (consteval); P1073R3; Clang 17. ; P1937R2; Clang 14. std::is_constant_evaluated; P0595R2; Clang 9. Nested inline namespaces; P1094R2; Clang 8. Structured binding extensions; P1091R3; Clang 16. P1381R1. Stronger Unicode requirements; P1041R4; Yes. P1139R2. Parenthesized initialization of aggregates; P0960R3; Clang 16. ; P1975R0. Modules; P1103R3; Clang 15. ; P1766R1 (DR); Clang 11. P1811R0; No. P17,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:7679,depend,dependent,7679,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['depend'],['dependent']
Integrability,"RC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99880,message,message,99880,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; ```. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all RDataFrame operations currently work with this package. The subset that is currently available is:. - AsNumpy; - Count; - Define; - Fill; - Filter; - Graph; - Histo[1,2,3]D; - Max; - Mean; - Min; - Profile[1,2,3]D; - Snapshot; - Sum. with support for more operations coming in the future. Any distributed RDataFrame backend inherits the dependencies of the underlying software needed to distribute the applications. The Spark backend for example has the following runtime dependencies (ROOT will build just fine without, but the feature will be unavailable without these packages):. - [pyspark](https://spark.apache.org/docs/latest/api/python/index.html), that in turn has its own set of dependencies:; - [Java](https://www.java.com/en/); - [py4j](https://www.py4j.org/). Tests for the Spark backend can be turned ON/OFF with the new build option `test_distrdf_pyspark` (OFF by default). ## Histogram Libraries. ## Math Libraries. - Update the definitions of the physical constants using the recommended 2018 values from NIST.; - Use also the new SI definition of base units from 2019, where the Planck constant, the Boltzmann constant, the elementary electric charge and the Avogadro constant are exact numerical values. See <https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units>. Note that with this new definition the functions `TMath::HUncertainty()`, `TMath::KUncertainty()`, `TMath::QeUncertainty()` and `TMath::NaUncertainty()` all return a `0.0` value.; - Due to some planned major improvements to `RVec`, the layout of `RVec` objects will change in a backward-incompatible way between v6.24 and v6.26.; Because of this, we now print a warning if an application i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:11894,depend,dependencies,11894,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['depend'],['dependencies']
Integrability,"RENT_SCOPE); endif(); endfunction(). #---Enable asserts------------------------------------------------------------------------------; if(asserts); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}}""); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}}""); endif(). #---Enable CCache ------------------------------------------------------------------------------; if(ccache); find_program(CCACHE_COMMAND NAMES ccache ccache-swig); mark_as_advanced(CCACHE_COMMAND ${CCACHE_COMMAND}). if(EXISTS ${CCACHE_COMMAND}); message(STATUS ""Found ccache: ${CCACHE_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_COMMAND}); execute_process(COMMAND ${CCACHE_COMMAND} ""-V"" OUTPUT_VARIABLE CCACHE_VERSION); string(REGEX REPLACE ""ccache version ([0-9\\.]+).*"" ""\\1"" CCACHE_VERSION ${CCACHE_VERSION}); else(); message(STATUS ""Could NOT find ccache""); set(ccache OFF CACHE BOOL ""Use ccache (disabled since ccache was not found)"" FORCE); endif(); endif(). #---Enable distcc ------------------------------------------------------------------------------; if(distcc); find_program(DISTCC_COMMAND NAMES distcc); mark_as_advanced(DISTCC_COMMAND ${DISTCC_COMMAND}); if(EXISTS ${DISTCC_COMMAND}); message(STATUS ""Found distcc: ${DISTCC_COMMAND}""); if (ccache); # If ccache is enabled, use distcc as CCACHE_PREFIX; message(STATUS ""Because ccache is enabled, CCACHE_PREFIX is set to ${DISTCC_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""CCACHE_PREFIX=${DISTCC_COMMAND} ${CCACHE_COMMAND}""); else(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${DISTCC_COMMAND}); endif(); execute_process(COMMAND ${DISTCC_COMMAND} ""--version"" OUTPUT_VARIABLE DISTCC_VERSION); string(REGEX REPLACE ""distcc ([0-9\\.]+).*"" ""\\1"" DISTCC_VERSION ${DISTCC_VERSION}); else(); message(STATUS ""Could NOT find distcc""); set(distcc OFF CACHE BOOL ""Use distcc (disabled sinc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:9128,message,message,9128,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"RNTuple Code Architecture; =========================. > This document is meant for ROOT developers. It provides background information on the RNTuple code design and behavior. > The RNTuple code uses the nomenclature from the [RNTuple format specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/BinaryFormatSpecification.md) (e.g. ""field"", ""column"", ""anchor"", etc.). General Principles; ------------------. The RNTuple classes provide the functionality to read, write, and describe RNTuple datasets.; The core classes, such as `RNTupleReader` and `RNTupleWriter`, are part of the RNTuple library.; Additional tools, such as the `RNTupleImporter` and the `RNTupleInspector`, are part of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:749,depend,depends,749,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['depend'],['depends']
Integrability,"RNTuple Introduction; ====================. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:169,interface,interfaces,169,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,2,['interface'],['interfaces']
Integrability,"ROOT::Math::negative_binomial_cdf_c.; ; New special functions: sine and cosine integral, translated by; B. List from CERNLIB:; ROOT::Math::sinint and ROOT::Math::cosint. New classes ROOT::Math::IOptions and; ROOT::Math::GenAlgoOptions for dealing in general with the; options for the numerical algorithm. The first one is the interface; for the second and defines the setting and retrieval of generic pair; of (name,value) options.; They are used for defining possible extra; options for the minimizer, integration and sampler options.; ; Integration classes:; ; Fix a bug in the templated method setting the integrand; function; Use now IntegrationOneDim::kADAPTIVESINGULAR as default method for the 1D; integration; Add the method IntegrationOneDim::kLEGENDRE based on; the GaussLegendreIntegrator class. ; Implement also for the GaussIntegrator and; GaussLegendreIntegrator the undefined and semi-undefined integral; using a function transformation as it is done in the GSLIntegrator; Fix a bug in IntegratorOneDim::SetAbsTolerance; New class ROOT::Math::IntegratorOptions which can be passed to; all integrator allowing the user to give options to the class and in; particular default value. Via the support for extra options (with; the class ROOT::Math::IOptions generic (string,value); options can be used in the base class to define specific options for; the implementations. For example for the MCIntegrator class,; specific options can now be passed to VEGAS or MISER.; . Improve the root finder and 1D minimization classes (BrentRootFinder; and BrentMinimizer1D) by fixing a bug in the Brent method (see rev. 32544); and adding possibility to pass the tolerance and max number of; iterations; Change also the interface classes,; ROOT::Math::RootFinder and; ROOT::Math::IMinimizer1D to have methods consistent with; the other numerical algorithm classes (e.g. return bool and not; int from RootFinder::Solve and add a; RootFinder::Status() function. In addition, use the same default; toleran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:5764,integrat,integrator,5764,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['integrat'],['integrator']
Integrability,"ROOTQL; ======. This is a Quick Look plugin that allows quick inspection of the content; of ROOT files. Quick Look is available on MacOS X since version 10.5 (Leopard). To use QL; select a file icon in the Finder and hit the space bar. For all file types; supported by QL you will get a window showing the file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file and number of keys, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the; ROOTQL.qlgenerator icon to either /Library/QuickLook or to ~/Library/QuickLook.; You may have to create that folder if it does not exist. Once installed; you may have to refresh the QL plugin cache by executing:; /usr/bin/qlmanage -r. To build from source, get it from git using:. git clone http://root.cern/git/root.git root; cd root/misc/rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set to ""Release""). A command line short cut to open; the Xcode project is to type ""open ROOTQL.xcodeproj"" in the Terminal app.; Move the resulting plugin from the build/Release directory to either; the /Library/QuickLook or ~/Library/QuickLook directory. Cheers, Fons.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/ReadMe.txt:543,depend,depends,543,misc/rootql/ReadMe.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/ReadMe.txt,1,['depend'],['depends']
Integrability,"RT_ALL_SYMBOLS: the auto-generated exports; # are now updated only when the object files providing the symbols are updated; cmake_minimum_required(VERSION 3.16 FATAL_ERROR); # Set CMP0091 (MSVC runtime library flags are selected by an abstraction) to OLD; # to keep the old way of selecting the runtime library with the -MD/-MDd compiler flag; cmake_policy(SET CMP0091 OLD); else(); cmake_minimum_required(VERSION 3.10 FATAL_ERROR); endif(). SET(LIB_NAME libAfterImage). # Microsoft Visual Studio:; IF(MSVC); # Define; ADD_DEFINITIONS(-D_CRT_SECURE_NO_DEPRECATE); SET(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} /DNO_DEBUG_OUTPUT /D_MBCS /D_LIB /wd4996 /wd4267 /wd4018 /wd4244""); ENDIF(). set(FREETYPE_INCLUDE_DIR """" CACHE PATH ""Path to Freetype include dir""); set(ZLIB_INCLUDE_DIR """" CACHE PATH ""Path to zlib include dir""). if(NOT EXISTS ""${FREETYPE_INCLUDE_DIR}/ft2build.h""); message(ERROR ""Can't find ft2build.h in ${FREETYPE_INCLUDE_DIR}""); endif(). if(NOT EXISTS ""${ZLIB_INCLUDE_DIR}/zlib.h""); message(ERROR ""Can't find zlib.h in ${ZLIB_INCLUDE_DIR}""); endif(). INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIR} ${ZLIB_INCLUDE_DIR}). set (LIB_DESTINATION ""${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}""). FILE(GLOB H_FILES ""*.h""). SET(SRC_FILES; libpng/png.c libpng/pngmem.c libpng/pngrio.c libpng/pngset.c libpng/pngwio.c libpng/pngwutil.c; libpng/pngerror.c libpng/pngpread.c libpng/pngrtran.c libpng/pngtest.c libpng/pngwrite.c; libpng/pngget.c libpng/pngread.c libpng/pngrutil.c libpng/pngtrans.c libpng/pngwtran.c; libjpeg/jcapimin.c libjpeg/jcapistd.c libjpeg/jccoefct.c libjpeg/jccolor.c libjpeg/jcdctmgr.c libjpeg/jchuff.c libjpeg/jcinit.c; libjpeg/jcmainct.c libjpeg/jcmarker.c libjpeg/jcmaster.c libjpeg/jcomapi.c libjpeg/jcparam.c libjpeg/jcphuff.c libjpeg/jcprepct.c; libjpeg/jcsample.c libjpeg/jctrans.c libjpeg/jdapimin.c libjpeg/jdapistd.c libjpeg/jdatadst.c libjpeg/jdatasrc.c libjpeg/jdcoefct.c; libjpeg/jdcolor.c libjpeg/transupp.c libjpeg/jaricom.c libjpeg/jdarith.c libjpeg/jcarith.c libjpeg/jddctm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/CMakeLists.txt:1200,message,message,1200,graf2d/asimage/src/libAfterImage/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/CMakeLists.txt,1,['message'],['message']
Integrability,"R__WRITE_LOCKGUARD``` to take advantage of the new lock. The legacy ```TLockGuard``` and ```R__LOCKGUARD``` use the write lock.; - Improved scaling of TROOT::RecursiveRemove in the case of large collection.; - Added a thread safe mode for the following ROOT collections: THashList, THashTable, TList and TObjArray. When ROOT's thread safe mode is enabled and the collection is set to use internal locks by calling:; ```; collection->UseRWLock();; ```; all operations on the collection will take the read or write lock when needed, currently they shared the global lock (ROOT::gCoreMutex). ### Interpreter. - cling's LLVM is upgraded to version 5.0; - All of cling's patches to llvm have been upstreamed.; - The interpreter-related lock is now locking only the compilation step, not the execution step. This reduces the scope for lock contention. Most significantly, it enables the use of concurrency on the prompt!. ## I/O Libraries. - Introduce TKey::ReadObject<typeName>. This is a user friendly wrapper around ReadObjectAny. For example; ```; auto h1 = key->ReadObject<TH1>; ```; after which h1 will either be null if the key contains something that is not a TH1 (or derived class); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer << arr;; }; ```; which would only really stream the array at the first iteration because it will be detected has having the same address and thus assumed to be the same object. We can now do:; ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer.WriteObject(&arr, kFALSE);; }; ```; where the last argument of WriteObject tells the buffer do *not* remember this object's address and to always stream it. This feature is also available via WriteObjectAny. - Added a new mechanism for providing clean forward-compatibility breaks",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:6443,wrap,wrapper,6443,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['wrap'],['wrapper']
Integrability,"Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Reference Manual <MIRLangRef>`; A reference manual for the MIR serialization format, which is used to test; LLVM's code generation passes. :doc:`GlobalISel/index`; This describes the prototype instruction selection replacement, GlobalISel. :doc:`ConvergentOperations`; Description of ``convergent`` o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1830,interface,interfaces,1830,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['interface'],['interfaces']
Integrability,"Region will be; automatically ended, and a new InstrumentRegion will begin. If there are comments containing the different `INSTRUMENT_TYPE`,; then both data sets remain available. In contrast with an AnalysisRegion,; an InstrumentRegion does not need a comment to end the region. Comments that are prefixed with `LLVM-MCA-` but do not correspond to; a valid `INSTRUMENT_TYPE` for the target cause an error, except for; `BEGIN` and `END`, since those correspond to AnalysisRegions. Comments; that do not start with `LLVM-MCA-` are ignored by :program `llvm-mca`. An instruction (a MCInst) is added to an InstrumentRegion R only; if its location is in range [R.RangeStart, R.RangeEnd]. On RISCV targets, vector instructions have different behaviour depending; on the LMUL. Code can be instrumented with a comment that takes the; following form:. .. code-block:: none. # LLVM-MCA-RISCV-LMUL <M1|M2|M4|M8|MF2|MF4|MF8>. The RISCV InstrumentManager will override the schedule class for vector; instructions to use the scheduling behaviour of its pseudo-instruction; which is LMUL dependent. It makes sense to place RISCV instrument; comments directly after `vset{i}vl{i}` instructions, although; they can be placed anywhere in the program. Example of program with no call to `vset{i}vl{i}`:. .. code-block:: none. # LLVM-MCA-RISCV-LMUL M2; vadd.vv v2, v2, v2. Example of program with call to `vset{i}vl{i}`:. .. code-block:: none. vsetvli zero, a0, e8, m1, tu, mu; # LLVM-MCA-RISCV-LMUL M1; vadd.vv v2, v2, v2. Example of program with multiple calls to `vset{i}vl{i}`:. .. code-block:: none. vsetvli zero, a0, e8, m1, tu, mu; # LLVM-MCA-RISCV-LMUL M1; vadd.vv v2, v2, v2; vsetvli zero, a0, e8, m8, tu, mu; # LLVM-MCA-RISCV-LMUL M8; vadd.vv v2, v2, v2. Example of program with call to `vsetvl`:. .. code-block:: none. vsetvl rd, rs1, rs2; # LLVM-MCA-RISCV-LMUL M1; vadd.vv v12, v12, v12; vsetvl rd, rs1, rs2; # LLVM-MCA-RISCV-LMUL M4; vadd.vv v12, v12, v12. HOW LLVM-MCA WORKS; ------------------. :program",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:12392,depend,dependent,12392,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependent']
Integrability,"ResourceTrackerSP &rt, Ast &ast) {; return rt->getJITDylib().define(std::make_unique<AstMaterializationUnit>(*this, ast), rt);; }. void emit(std::unique_ptr<orc::MaterializationResponsibility> mr, Ast &ast) {; // compileAst is just function that compiles the given AST and returns; // a `llvm::orc::ThreadSafeModule`; baseLayer.emit(std::move(mr), compileAst(ast));; }. llvm::orc::MaterializationUnit::Interface getInterface(Ast &ast) {; SymbolFlagsMap Symbols;; // Find all the symbols in the AST and for each of them; // add it to the Symbols map.; Symbols[mangler(someNameFromAST)] =; JITSymbolFlags(JITSymbolFlags::Exported | JITSymbolFlags::Callable);; return MaterializationUnit::Interface(std::move(Symbols), nullptr);; }; };. Take look at the source code of `Building A JIT's Chapter 4 <tutorial/BuildingAJIT4.html>`_ for a complete example. How to use ThreadSafeModule and ThreadSafeContext; -------------------------------------------------. ThreadSafeModule and ThreadSafeContext are wrappers around Modules and; LLVMContexts respectively. A ThreadSafeModule is a pair of a; std::unique_ptr<Module> and a (possibly shared) ThreadSafeContext value. A; ThreadSafeContext is a pair of a std::unique_ptr<LLVMContext> and a lock.; This design serves two purposes: providing a locking scheme and lifetime; management for LLVMContexts. The ThreadSafeContext may be locked to prevent; accidental concurrent access by two Modules that use the same LLVMContext.; The underlying LLVMContext is freed once all ThreadSafeContext values pointing; to it are destroyed, allowing the context memory to be reclaimed as soon as; the Modules referring to it are destroyed. ThreadSafeContexts can be explicitly constructed from a; std::unique_ptr<LLVMContext>:. .. code-block:: c++. ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());. ThreadSafeModules can be constructed from a pair of a std::unique_ptr<Module>; and a ThreadSafeContext value. ThreadSafeContext values may be shared between; multiple Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:27889,wrap,wrappers,27889,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrappers']
Integrability,"RooAbsPdf::fitTo` or `RooAbsPdf::createNLL` interfaces could take in a set of optional parameters as `RooCmdArg` objects.; In `TestStatistics::buildLikelihood`, we have implemented 4 of these options as separate types while an additional one is supported as a simple string:; - `RooAbsL::Extended`: an enum class used to set extended term calculation `on`, `off` or use `Extended::Auto` to determine automatically based on the pdf whether to activate or not.; - `ConstrainedParameters`: Initialized with a `RooArgSet` of parameters that are constrained. Pdf components dependent on these alone are added to a subsidiary likelihood term.; - `ExternalConstraints`: Initialized with a `RooArgSet` of external constraint pdfs, i.e. constraints not necessarily in the pdf itself. These are always added to the subsidiary likelihood.; - `GlobalObservables`: Initialized with a `RooArgSet` of observables that have a constant value, independent of the dataset events. Pdf components dependent on these alone are added to the subsidiary likelihood. \note This overrides all other likelihood parameters (like those in the `ConstrainedParameters` argument) if present.; - Finally, a string argument `global_observables_tag` can be given, which should be set as attribute in any pdf component to indicate that it is a global observable. Can be used instead of or in addition to a `GlobalObservables` argument. Using these parameters, creating a likelihood of a simultaneous pdf (i.e. a `RooSimultaneous`) with constrained terms and global observables can be done with:. ``` {.cpp}; auto likelihood = RooFit::TestStatistics::buildLikelihood(; simultaneous_pdf, data,; RooFit::TestStatistics::ConstrainedParameters(RooArgSet(/*YOUR CONSTRAINED PARAMETERS*/)),; RooFit::TestStatistics::GlobalObservables(RooArgSet(/*YOUR GLOBAL OBSERVABLES*/)));; ```. The resulting object will be a `RooSumL` containing a `RooSubsidiaryL` with the constrained parameters and `RooBinnedL` or `RooUnbinnedL` components for each simu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:4426,depend,dependent,4426,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['depend'],['dependent']
Integrability,"RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from now on. ### RooBrowser: a graphical user interface for workspace exploration, visualization, and analysis. This experimental new feature utilises the technology from ROOT's familiar `TBrowser` in order to create an interface for graphically exploring and visualizing the content of a workspace, as well as perform basic fitting operations with the models and datasets. ![Demonstration of RooBrowser using json workspace from the roofit tutorials directory](RooBrowser.png). ### Removal of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statistics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:22013,interface,interface,22013,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:4218,protocol,protocols,4218,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['protocol'],['protocols']
Integrability,"S --noIncludePaths; DEPENDENCIES Core); target_include_directories(${dict}Dict PRIVATE ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint); endforeach(). set(CLANG_RESOURCE_DIR_STEM); if (builtin_clang); set(CLANG_RESOURCE_DIR_STEM ${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm/${CMAKE_CFG_INTDIR}/lib/clang); set(CLANG_RESOURCE_DIR_VERSION ${LLVM_VERSION_MAJOR}); else (); set(CLANG_RESOURCE_DIR_STEM ${LLVM_LIBRARY_DIR}/clang); # A user can define a clang version to use, otherwise find it (but will error if more than one version is present); if (NOT DEFINED CLANG_RESOURCE_DIR_VERSION); if (NOT EXISTS ${CLANG_RESOURCE_DIR_STEM}); message(FATAL_ERROR ""${CLANG_RESOURCE_DIR_STEM} does not exist. Please install clang.""); endif(); # There is no reasonable way to get the version of clang under which is its resource directory.; # For example, lib/clang/5.0.0/include. Deduce it.; file(GLOB CHILDREN RELATIVE ${CLANG_RESOURCE_DIR_STEM} ${CLANG_RESOURCE_DIR_STEM}/*); list(LENGTH CHILDREN CHILDREN_LENGTH); if (${CHILDREN_LENGTH} GREATER 1); message(FATAL_ERROR ""Found more than one version of clang. CLANG_RESOURCE_DIR_VERSION contains: '${CHILDREN}'."" ); endif(). list(GET CHILDREN 0 CLANG_RESOURCE_DIR_VERSION); endif(); endif(). set(CLANG_RESOURCE_DIR ${CLANG_RESOURCE_DIR_STEM}/${CLANG_RESOURCE_DIR_VERSION}/include). #---Deal with clang resource here----------------------------------------------; install(DIRECTORY ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include/; DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include USE_SOURCE_PERMISSIONS). #---Install a bunch of files to /etc/cling------------------------------------; set(clinginclude ${CMAKE_SOURCE_DIR}/interpreter/cling/include). set(custom_modulemaps); if (runtime_cxxmodules); set(custom_modulemaps boost.modulemap tinyxml2.modulemap cuda.modulemap module.modulemap.build); # FIXME: We should install vc.modulemap only when Vc is found (Vc_FOUND) but; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:3364,message,message,3364,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,1,['message'],['message']
Integrability,"S bits is retrieved from the location storage LS specified by; one of the single location descriptions SL of L. *If L, or the location description of any composite location description; part that is a subcomponent of L, has more than one single location; description, then any one of them can be selected as they are required to; all have the same value. For any single location description SL, bits are; retrieved from the associated storage location starting at the bit offset; specified by SL. For a composite location description, the retrieved bits; are the concatenation of the N bits from each composite location part PL,; where N is limited to the size of PL.*. V is pushed on the stack with the type T. .. note::. This definition makes it an evaluation error if L is a register location; description that has less than TS bits remaining in the register storage.; Particularly since these extensions extend location descriptions to have; a bit offset, it would be odd to define this as performing sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This definition allows the base type to be a bit size since there seems no; reason to restrict it. It is an evaluation error if any bit of the value is retrieved from the; undefined location storage or the offset o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:91910,depend,dependent,91910,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['depend'],['dependent']
Integrability,"S); set(builtins_dep_name ""${builtins_dep}-${name}""); else(); set(builtins_dep_name ${builtins_dep}); endif(); endif(). check_apple_target(${name} runtime). runtime_register_target(${name}; DEPENDS ${builtins_dep_name} ${hdrgen_deps}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name} ${libc_cmake_args}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(). foreach(multilib ${LLVM_RUNTIME_MULTILIBS}); foreach(name ${LLVM_RUNTIME_MULTILIB_${multilib}_TARGETS}); runtime_register_target(${name}+${multilib}; DEPENDS runtimes-${name}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name}; -DLLVM_RUNTIMES_PREFIX=${name}/; -DLLVM_RUNTIMES_LIBDIR_SUBDIR=${multilib}; BASE_NAME ${name}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(); endforeach(); endif(). if(NOT LLVM_BUILD_INSTRUMENTED AND CLANG_ENABLE_BOOTSTRAP); # TODO: This is a hack needed because the libcxx headers are copied into the; # build directory during configuration. Without that step the clang in the; # build directory cannot find the C++ headers in certain configurations.; # I need to build a mechanism for runtime projects to provide CMake code; # that executes at LLVM configuration time to handle this case.; add_dependencies(clang-bootstrap-deps runtimes-configure); # We need to add the runtimes as a dependency because compiler-rt can be; # built as part of runtimes and we need the profile runtime for PGO; add_dependencies(clang-bootstrap-deps runtimes); endif(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS runtimes-test-depends). set(RUNTIMES_TEST_DEPENDS; FileCheck; count; llvm-cov; llvm-lto; llvm-nm; llvm-objdump; llvm-profdata; llvm-size; llvm-xray; not; obj2yaml; opt; sancov; sanstats; llvm_gtest_main; llvm_gtest; split-file; ); foreach(target ${test_targets} ${SUB_CHECK_TARGETS}); add_dependencies(${target} ${RUNTIMES_TEST_DEPENDS}); endforeach(). set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_TARGETS runtimes ${RUNTIMES_TEST_DEPENDS}); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:18709,depend,dependency,18709,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,['depend'],"['dependency', 'depends']"
Integrability,"SANITIZER=Address -DLLVM_USE_SANITIZE_COVERAGE=On``. .. note:: If you have ``compiler-rt`` checked out in an LLVM tree when building; with sanitizers, you'll want to specify ``-DLLVM_BUILD_RUNTIME=Off``; to avoid building the sanitizers themselves with sanitizers enabled. .. note:: You may run into issues if you build with BFD ld, which is the; default linker on many unix systems. These issues are being tracked; in https://llvm.org/PR34636. Continuously Running and Finding Bugs; -------------------------------------. There used to be a public buildbot running LLVM fuzzers continuously, and while; this did find issues, it didn't have a very good way to report problems in an; actionable way. Because of this, we're moving towards using `OSS Fuzz`_ more; instead. You can browse the `LLVM project issue list`_ for the bugs found by; `LLVM on OSS Fuzz`_. These are also mailed to the `llvm-bugs mailing; list`_. .. _OSS Fuzz: https://github.com/google/oss-fuzz; .. _LLVM project issue list:; https://bugs.chromium.org/p/oss-fuzz/issues/list?q=Proj-llvm; .. _LLVM on OSS Fuzz:; https://github.com/google/oss-fuzz/blob/master/projects/llvm; .. _llvm-bugs mailing list:; http://lists.llvm.org/cgi-bin/mailman/listinfo/llvm-bugs. Utilities for Writing Fuzzers; =============================. There are some utilities available for writing fuzzers in LLVM. Some helpers for handling the command line interface are available in; ``include/llvm/FuzzMutate/FuzzerCLI.h``, including functions to parse command; line options in a consistent way and to implement standalone main functions so; your fuzzer can be built and tested when not built against libFuzzer. There is also some handling of the CMake config for fuzzers, where you should; use the ``add_llvm_fuzzer`` to set up fuzzer targets. This function works; similarly to functions such as ``add_llvm_tool``, but they take care of linking; to LibFuzzer when appropriate and can be passed the ``DUMMY_MAIN`` argument to; enable standalone testing.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:9739,interface,interface,9739,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['interface'],['interface']
Integrability,"SObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220280,message,message,220280,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,"SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should process the; command-line options ``-mcpu=`` and ``-mattr=``. TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to; generate code in ``SparcGenSubtarget.inc``. In ``Target.td``, shown below, the; ``SubtargetFeature`` interface is defined. The first 4 string parameters of; the ``SubtargetFeature`` interface are a feature name, a XXXSubtarget field set; by the feature, the value of the XXXSubtarget field, and a description of the; feature. (The fifth parameter is a list of features whose presence is implied,; and its default value is an empty array.). If the value for the field is the string ""true"" or ""false"", the field; is assumed to be a bool and only one SubtargetFeature should refer to it.; Otherwise, it is assumed to be an integer. The integer value may be the name; of an enum constant. If multiple features use the same integer field, the; field will be set to the maximum value of all enabled features that share; the field. .. code-block:: text. class SubtargetFeature<string n, string f, string v, string d,; list<SubtargetFeature> i = []> {; string Name = n;; string FieldName = f;; string Value = v;; string Desc = d;; list<SubtargetFeature> Implies = i;; }. In the ``Sparc.td`` file, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:72411,interface,interface,72411,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interface']
Integrability,"SRC_DIR}); set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR}); set(LLVM_CPPFLAGS ""${LLVM_DEFINITIONS}""); set(LLVM_CFLAGS ""${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}""); # The language standard potentially affects the ABI/API of LLVM, so we want; # to make sure it is reported by llvm-config.; set(LLVM_CXXFLAGS ""${CMAKE_CXX${CMAKE_CXX_STANDARD}_STANDARD_COMPILE_OPTION} ${LLVM_CXX_STDLIB_FLAG} ${COMPILE_FLAGS} ${LLVM_DEFINITIONS}""); set(LLVM_BUILD_SYSTEM cmake); set(LLVM_HAS_RTTI ${LLVM_CONFIG_HAS_RTTI}); set(LLVM_DYLIB_VERSION ""${LLVM_VERSION_MAJOR}${LLVM_VERSION_SUFFIX}""). # Use the C++ link flags, since they should be a superset of C link flags.; set(LLVM_LDFLAGS ""${CMAKE_CXX_LINK_FLAGS}""); set(LLVM_BUILDMODE ${CMAKE_BUILD_TYPE}); set(LLVM_SYSTEM_LIBS ${SYSTEM_LIBS}); string(REPLACE "";"" "" "" LLVM_TARGETS_BUILT ""${LLVM_TARGETS_TO_BUILD}""); llvm_canonicalize_cmake_booleans(; LLVM_BUILD_LLVM_DYLIB; LLVM_LINK_LLVM_DYLIB; LLVM_HAS_RTTI; BUILD_SHARED_LIBS); llvm_expand_pseudo_components(LLVM_DYLIB_COMPONENTS_expanded ""${LLVM_DYLIB_COMPONENTS}""); configure_file(${BUILDVARIABLES_SRCPATH} ${BUILDVARIABLES_OBJPATH} @ONLY). # Set build-time environment(s).; add_compile_definitions(CMAKE_CFG_INTDIR=""$<CONFIG>""). if(LLVM_ENABLE_MODULES); target_compile_options(llvm-config PUBLIC; ""-fmodules-ignore-macro=CMAKE_CFG_INTDIR""; ); endif(). # Add the dependency on the generation step.; add_file_dependencies(${CMAKE_CURRENT_SOURCE_DIR}/llvm-config.cpp ${BUILDVARIABLES_OBJPATH}). if(CMAKE_CROSSCOMPILING); if (LLVM_NATIVE_TOOL_DIR AND NOT LLVM_CONFIG_PATH); if (EXISTS ""${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}""); set(LLVM_CONFIG_PATH ""${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}""); endif(); endif(). if (NOT LLVM_CONFIG_PATH); build_native_tool(llvm-config LLVM_CONFIG_PATH); set(LLVM_CONFIG_PATH ""${LLVM_CONFIG_PATH}"" CACHE STRING """"). add_custom_target(NativeLLVMConfig DEPENDS ${LLVM_CONFIG_PATH}); add_dependencies(llvm-config NativeLLVMConfig); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:3376,depend,dependency,3376,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,1,['depend'],['dependency']
Integrability,SX/CFString.cpp; lldb/tools/debugserver/source/MacOSX/CFString.h; lldb/tools/debugserver/source/MacOSX/CFUtils.h; lldb/tools/debugserver/source/MacOSX/Genealogy.cpp; lldb/tools/debugserver/source/MacOSX/Genealogy.h; lldb/tools/debugserver/source/MacOSX/GenealogySPI.h; lldb/tools/debugserver/source/MacOSX/MachException.h; lldb/tools/debugserver/source/MacOSX/MachThread.cpp; lldb/tools/debugserver/source/MacOSX/MachThread.h; lldb/tools/debugserver/source/MacOSX/MachThreadList.h; lldb/tools/debugserver/source/MacOSX/MachVMMemory.h; lldb/tools/debugserver/source/MacOSX/MachVMRegion.cpp; lldb/tools/debugserver/source/MacOSX/MachVMRegion.h; lldb/tools/debugserver/source/MacOSX/OsLogger.h; lldb/tools/debugserver/source/MacOSX/arm/DNBArchImpl.h; lldb/tools/debugserver/source/MacOSX/arm64/DNBArchImplARM64.h; lldb/tools/driver/Driver.cpp; lldb/tools/driver/Driver.h; lldb/tools/driver/Platform.cpp; lldb/tools/driver/Platform.h; lldb/tools/intel-features/cli-wrapper.cpp; lldb/tools/intel-features/intel-mpx/cli-wrapper-mpxtable.h; lldb/tools/lldb-instr/Instrument.cpp; lldb/tools/lldb-server/Acceptor.h; lldb/tools/lldb-server/LLDBServerUtilities.cpp; lldb/tools/lldb-server/SystemInitializerLLGS.cpp; lldb/tools/lldb-server/SystemInitializerLLGS.h; lldb/tools/lldb-test/SystemInitializerTest.cpp; lldb/tools/lldb-test/SystemInitializerTest.h; lldb/tools/lldb-vscode/BreakpointBase.cpp; lldb/tools/lldb-vscode/BreakpointBase.h; lldb/tools/lldb-vscode/ExceptionBreakpoint.cpp; lldb/tools/lldb-vscode/ExceptionBreakpoint.h; lldb/tools/lldb-vscode/FifoFiles.cpp; lldb/tools/lldb-vscode/FifoFiles.h; lldb/tools/lldb-vscode/FunctionBreakpoint.cpp; lldb/tools/lldb-vscode/FunctionBreakpoint.h; lldb/tools/lldb-vscode/IOStream.cpp; lldb/tools/lldb-vscode/IOStream.h; lldb/tools/lldb-vscode/JSONUtils.cpp; lldb/tools/lldb-vscode/JSONUtils.h; lldb/tools/lldb-vscode/lldb-vscode.cpp; lldb/tools/lldb-vscode/LLDBUtils.cpp; lldb/tools/lldb-vscode/LLDBUtils.h; lldb/tools/lldb-vscode/OutputRedirector.cpp; lldb,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:226715,wrap,wrapper-mpxtable,226715,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['wrap'],['wrapper-mpxtable']
Integrability,"Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo versio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:6066,depend,depending,6066,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['depend'],['depending']
Integrability,"See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.; - `RDataFrame` now supports reading friend `TTree`s with a `TTreeIndex`, aka ""indexed friends"". More details at [ROOT-9559](https://sft.its.cern.ch/jira/browse/ROOT-9559).; - Experimental logging capabilities have been added to `RDataFrame`. To activate logging, define the following variable before creating the `RDataFrame` object: `auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel.kInfo);`.; - With [ROOT-10023](https://sft.its.cern.ch/jira/browse/ROOT-10023) fixed, `RDataFrame` can now read and write certain branches containing unsplit objects, i.e. `TBranchObjects`. More information is available at [ROOT-10022](https://sft.its.cern.ch/jira/browse/ROOT-10022).; - CSV files can now be opened and processed from remote HTTP(S) locations; - `RDataFrame` results produced by the same action in different computation graphs can now be merged thanks to the new interface provided by `ROOT::Detail::RDF::RMergeableValue`, introduced in [#5552](https://github.com/root-project/root/pull/5552). A feature originally requested with [ROOT-9869](https://sft.its.cern.ch/jira/browse/ROOT-9869), it helps streamline `RDataFrame` workflows in a distributed environment. Currently only a subset of `RDataFrame` actions have their corresponding mergeable class, but in the future it will be possible to extend it to any action through the creation of a new `RMergeableValue` derived class. ### Behavior changes. - `Snapshot` now respects the basket size and split level of the original branch when copying branches to a new `TTree`.; - `Snapshot` now writes branches coming from friend `TTree`s even if they have the same name as branches in the main tree (`friendname_` is prepended to the name of the output branches). More details at [#7181](https://github.com/root-project/root/issues/7181).; - Just-in-time compilation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:7171,interface,interface,7171,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['interface'],['interface']
Integrability,"SelLowering.h; SDValue getAddrLocal(NodeTy *N, const SDLoc &DL, EVT Ty,; SelectionDAG &DAG, bool IsN32OrN64) const. which calls the overloaded function:. // lib/Target/Mips/MipsISelLowering.h; SDValue getTargetNode(JumpTableSDNode *N, EVT Ty, SelectionDAG &DAG,; unsigned Flag) const;. 2. Generic address nodes are lowered to some combination of target; independent and machine specific SDNodes (for example:; MipsISD::{Highest, Higher, Hi, Lo}) depending upon relocation model,; ABI, and compilation options. The choice of specific instructions that are to be used is delegated; to ISel which in turn relies on TableGen patterns to choose subtarget; specific instructions. For example, in getAddrLocal, the pseudo-code; generated is:. (add (load (wrapper $gp, %got(sym)), %lo(sym)). where ""%lo"" represents an instance of an SDNode with opcode; ""MipsISD::Lo"", ""wrapper"" indicates one with opcode ""MipsISD::Wrapper"",; and ""%got"" the global table pointer ""getGlobalReg(...)"". The ""add"" is; ""ISD::ADD"", not a target dependent one. 3. A TableGen multiclass pattern ""MipsHiLoRelocs"" is used to define a; template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td; multiclass MipsHiLoRelocs<Instruction Lui, Instruction Addiu,; Register ZeroReg, RegisterOperand GPROpnd> {; def : MipsPat<(MipsHi tglobaladdr:$in), (Lui tglobaladdr:$in)>;; ...; def : MipsPat<(MipsLo tglobaladdr:$in), (Addiu ZeroReg, tglobaladdr:$in)>;; ...; def : MipsPat<(add GPROpnd:$hi, (MipsLo tglobaladdr:$lo)),; (Addiu GPROpnd:$hi, tglobaladdr:$lo)>;; ...; }; defm : MipsHiLoRelocs<LUi, ADDiu, ZERO, GPR32Opnd>;. // lib/Target/Mips/Mips64InstrInfo.td; defm : MipsHiLoRelocs<LUi64, DADDiu, ZERO_64, GPR64Opnd>, SYM_32;. The instantiation in Mips64InstrInfo.td is used for MIPS64 in ILP32; mode",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:1801,depend,dependent,1801,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['depend'],['dependent']
Integrability,"Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1606,message,message,1606,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['message'],['message']
Integrability,"Server.C: update to follow the change in interfaces; Introduce the tutorials parallelMergerClient.C and the temporary tutorials parallelMergerServer.C; to demonstrate the parallel merging (with parallelMergerServer.C being the prototype of the upcoming; parallel merger server executable). Other. Introduce the new function TFileMerger::PartialMerge(Int_t) which; will Merge the list of file _with_ the content of the output; file (if any). This allows make several successive Merge; into the same TFile object.; Yhe argument defines the type of merge as define by the bit values in EPartialMergeType:; ; kRegular : normal merge, overwritting the output file.; kIncremental : merge the input file with the content of the output file (if already exising) (default).; kAll : merge all type of objects (default).; kResetable : merge only the objects with a MergeAfterReset member function. ; kNonResetable : merge only the objects without a MergeAfterReset member function. . Removed TFileMerger::RecursiveMerge from the interface. Prevent TFileMerger (and hadd) from trying to open too many files.; Add a new member function TFileMerger::SetMaxOpenedFiles and; new command line option to hadd ( -n requested_max ) to allow; the user to reduce the number of files opened even further. Update hadd and TFileMerger so that they prefix all their information message; with their names (when running hadd, the TFileMerger message are prefixed by hadd):. $ hadd -v 0 -f output.root input1.root input2.root; $ hadd -v 1 -f output.root input1.root input2.root; hadd merged 2 input files in output.root.; $ hadd -v 2 -f output.root input1.root input2.root; hadd target file: output.root; hadd Source file 1: input1.root; hadd Source file 2: input2.root; hadd Target path: output.root:/. Introduce non-static version of TFile::Cp allows the copy of; an existing TFile object. Introduce new explicit interface for providing reseting; capability after a merge. If a class has a method with; the name and signature:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:7521,interface,interface,7521,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['interface'],['interface']
Integrability,"Size()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; ```. The state information about a child frame can be obtained from the; methods `GetState(TGframe *f)`, `IsArranged(TGFrame *f)`, and; `IsVisible(TGFrame *f)`. The method `Cleanup()` deletes all objects of the composite frame added; via `AddFrame()`. All **`TGFrameElement`** objects (frames and layout; hints) must be unique, i.e. cannot be shared. We already mentioned that **`TGMainFrame`** class defines top level; windows interacting with the system window manager. It handles; applications with a menu bar, toolbar, text entry fields and other; widgets surrounding a central area (e.g. a canvas widget). It lays out a; set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:31426,interface,interface,31426,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interface']
Integrability,"Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue cas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4030,interface,interfaces,4030,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['interface'],['interfaces']
Integrability,"Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3017,depend,dependent,3017,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"Support single- and multi-dimensional arrays -- works for arrays with constant; size like `double A[] = {1, 2, 3};`, `double A[3];` or `double A[1][2][3][4];`. ## RooFit Libraries; ### RooJohnson PDF; The Johnson SU PDF has been added to RooFit. It comes with an analytical integral and a generator function,; which make it superior (faster and more accurate) than implementing it manually with an interpreted/compiled formula. ### HistFactory; hist2workspace performance optimisations. For a large, ATLAS-style Higgs-->bb workspace with > 100 systematic uncertainties and more than 10 channels, the run time for converting histograms to a fit model decreases by a factor 11 to 12. ### Faster, STL-like Collections in RooFit; RooFit's collections `RooArgSet` and `RooArgList` have been made more STL-like. The underlying implementation used to be the `RooLinkedList`, but now both collections work with `std::vector`. The collections have an STL-like interface concerning iterators such that iterations over the two collections that looked like; ```; TIterator* depIter = intDepList.createIterator() ;; RooAbsArg* arg;; while((arg=(RooAbsArg*)depIter->Next())) {; ...; }; delete depIter;; ```; now look like:; ```; for (auto arg : intDepList) {; ...; }; ```; Depending on how many elements are iterated, RooFit will be between 10 and 20% faster if the new iterators are used. Heavily using old iterators might slow it down by 5 to 10%. Iterators in key classes have been updated, such that many workflows in RooFit are 10 - 20% faster. #### Legacy iterators; The (three kinds) of legacy iterators in RooFit are still supported, such that old code will not break, but they are slower than `begin(), end()` and range-based for loops. **Important caveat**:; The old RooFit collections could be modified while iterating. The STL-like iterators do not support this (as for a *e.g.* std::vector)! Using the legacy iterators with the new collections (*i.e.* in existing code), mutating the collection is sti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:15045,interface,interface,15045,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interface']
Integrability,"T. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3808,depend,dependent,3808,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['depend'],['dependent']
Integrability,"T::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:6703,integrat,integration,6703,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"T>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:6633,rout,routines,6633,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,2,['rout'],['routines']
Integrability,"TF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49028,integrat,integrating,49028,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integrating']
Integrability,"TIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/bin); set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/lib). if(WIN32 OR CYGWIN); # DLL platform -- put DLLs into bin.; set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR}); else(); set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR}); endif(). option(LLVM_INSTALL_TOOLCHAIN_ONLY; ""Only include toolchain files in the 'install' target."" OFF). option(LLVM_FORCE_USE_OLD_HOST_TOOLCHAIN; ""Set to ON to force using an old, unsupported host toolchain."" OFF); option(CLANG_ENABLE_BOOTSTRAP ""Generate the clang bootstrap target"" OFF). include(AddLLVM); include(TableGen); include(HandleLLVMOptions); include(VersionFromVCS). set(PACKAGE_VERSION ""${LLVM_PACKAGE_VERSION}""); if (${PACKAGE_VERSION} MATCHES ""${ROOT_LLVM_VERSION_REQUIRED_MAJOR}\\.1(|\\.[0-9]+)""); message(STATUS ""Using LLVM external library - ${PACKAGE_VERSION}""); else(); message(FATAL_ERROR ""LLVM version ${LLVM_PACKAGE_VERSION} different from ROOT supported, please try ${ROOT_LLVM_VERSION_REQUIRED_MAJOR}.1.x""); endif(). if (NOT DEFINED LLVM_INCLUDE_TESTS); set(LLVM_INCLUDE_TESTS ON); endif(). include_directories(""${LLVM_BINARY_DIR}/include"" ""${LLVM_MAIN_INCLUDE_DIR}""); link_directories(""${LLVM_LIBRARY_DIR}""). # set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin ); # set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ); # set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ). if(LLVM_INCLUDE_TESTS OR clingtest); find_package(Python3 3.8 REQUIRED COMPONENTS Interpreter). # Check prebuilt llvm/utils.; if(EXISTS ${LLVM_TOOLS_BINARY_DIR}/FileCheck${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/count${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/not${CMAKE_EXECUTABLE_SUFFIX}); set(LLVM_UTILS_PROVIDED ON); endif(); set(ROOT_LLVM_MAIN_SRC_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/llvm-project/l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:16081,message,message,16081,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,2,['message'],['message']
Integrability,"TP, do _not_ require `TFile`.; For these cases, RNTuple depends on the `RRawFile` class and its XRootD and Davix plugins. For user-defined classes as well as sets and maps, RNTuple uses `TClass`.; Simple types and other stdlib classes are natively supported and do not require dictionaries.; See the format specification for an exhaustive list of types supported in RNTuple.; The streamer field uses the standard ROOT streaming machinery. Integration to RDataFrame is provided through an RNTuple data source.; A universal RDataFrame constructor can create a data frame from either a TTree or an RNTuple with the same syntax. The RBrowser uses RNTuple classes to display RNTuple dataset information. Future Features; ---------------. The following features are planned for after the first RNTuple production version:; - RNTupleProcessor: advanced RNTupleReader that allows for free combination of chains and (indexed/unaligned) friends; - Horizontal merging: persistified friends, analogous to a classical merge being a persistified chain; - An interface for bulk writing; - Meta-data: RNTuple-specific and user-provided meta-data storage, such as file provenance, scale factors, or varied columns; - C library interface; - S3 storage backend (page source / page sink). Semantics of Reading Non-Trivial Objects; ========================================. Reading an object with RNTuple should be seen as _overwriting_ its persistent data members.; Given a properly constructed and valid object, the object must ensure that it stays valid when overwriting its persistent data members.; However, the object should not rely on its transient state to remain unchanged during reading:; it may be destructed and constructed again when it is read as part of a collection (see below). An object that is being read from disk may have been constructed by `RField::CreateValue()`.; In this case, the deleter returned by `RField::GetDeleter()` releases the resources. When reading collections of type `T` (`std::ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:29790,interface,interface,29790,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,2,['interface'],['interface']
Integrability,"TSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of X, it can be; displayed by a profile histogram with much better precision than by a; scatter-plot. Profile histograms display the mean value of Y and its; RMS for each bin in X. The following shows the contents; [capital letters] and the values shown in the graphics [small letters]; of the elements for bin j. When you fill a profile histogram with; **`TProfile`**`.Fill(x,y)` :. - `H[j]` will contain for each bin `j` the sum of the y values for; this bin. - `L[j]` contains the number of entries in the bin `j`. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; ```. In the special case where `s[j]` is zero, when there is only one entry; per bin, `e[j]` is computed from the average of the `s[j]` for all; bins. This approximation is used to keep the bin during a fit; operation. The **`TProfile`** constructor takes up to eight arguments.; The first five parameters are similar to **`TH1D`** constructor. ``` {.cpp}; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:62232,depend,depending,62232,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['depend'],['depending']
Integrability,"The Dataset Stager; ==================. Overview; --------. The [Dataset Stager (afdsmgrd)](http://afdsmgrd.googlecode.com/) is; a daemon that coordinates the transfer of data from a remote storage; to your local storage. For each file to transfer, a script is called. The script can be; customized to support your source and destination protocol. Staging requests are issued from the ROOT console, where you can also; control the progress of your staging. Installation; ------------. The Dataset Stager is distributed both on a repository on its own and as; part of ROOT. The easiest way to compile it is to do it inside ROOT. Installing from ROOT; --------------------. When configuring the ROOT source, enable the Dataset Stager by adding; `--enable-afdsmgrd`. Check in the list of enabled features if you have; ""afdsmgrd"". After running `make` (and, optionally, `make install`) you'll find the; daemon in the same directory of `root.exe`. The configuration file and init.d startup script will be in; `$ROOTSYS/etc/proof`. The daemon can and **must** run as unprivileged; user. Configuration; -------------. The Dataset Stager can share its configuration file with PROOF, as; some directives are the same and unknown directives are just ignored. Directives are one per line and lines beginning with a pound sign (`#`); are used for comments. > The configuration file is automatically checked at each loop: this; > means you can change configuration without restarting the daemon or; > stopping your current transfers. A detailed description of each directive follows. set *VARIABLE=value*; : This statement will substitute every occurrence of `$VARIABLE` with; its *value* in the rest of the configuration file. You can have; multiple `set` statements. xpd.stagereqrepo [dir:]*directory*; : This directive is shared with PROOF: *directory* is the full path to; the dataset repository. **Defaults to empty:** without this; directive the daemon is not operative. The `dir:` prefix is optional. dsmgrd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:338,protocol,protocol,338,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['protocol'],['protocol']
Integrability,"The TextInput library is used by ROOT (TRint, specifically) to read input on the prompt. It does e.g. syntax highlighting and history management, understands all supported terminals and all of that as a stand-alone package, without dependency on the (old, big, non-Windows) [n]curses library.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/doc/index.html:232,depend,dependency,232,core/textinput/doc/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/doc/index.html,1,['depend'],['dependency']
Integrability,"The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and its pdf which will be marginalized by the calculator. The HypoTestCalculator interface provides also the possibility of setting the model via a Rooworkspace class and names of the pdf. This possibility is not yet supported for the HybridCalculator class. ; ; . Additional classes or functions provided by RooStats are: ; ; NumberCountingUtils: a collection of number counting statistical utilities; 	NumberCountingPdfFactory: a factory for building ; 	the PDF and the data for a number counting combination and adding them in a RooWorkspace. ; 	SPlot: implementa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:11329,interface,interface,11329,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interface']
Integrability,"The interactive mode lets you get the R's command line within ROOT's command line to run R code with tab completion support.; The variables created in the interactive mode can be passed to ROOT with TRObjectProxy and the method ParseEval?.; To initialize the interactive mode just call Interactive() method and type "".q"" to exit from R's prompt and to go to the ROOT's prompt again. ~~~{.cxx}; [omazapa] [tuxhome] [~]$ root -l; root [0] #include<TRInterface.h>; root [1] ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; root [2] r.Interactive(); [r]:a=seq; seq seq_along seq.Date seq.default seq.int seq_len seq.POSIXt sequence; [r]:a=seq(1,5,0.5); [r]:.q; root [3] TVectorD v=r.ParseEval(""a"");; root [4] v.Print(). Vector (9) is as follows. | 1 |; ------------------; 0 |1; 1 |1.5; 2 |2; 3 |2.5; 4 |3; 5 |3.5; 6 |4; 7 |4.5; 8 |5. root [4]; ~~~. ## Examples; The examples can also be found in `$ROOTSYS/tutorials/r`. ## Creating a Functor; A functor is a class which wraps a function, very useful when states and properties; associated to that function are needed.; In this example I show how to give support to a custom class to be used in R's environment,; which at the same time is a functor. ~~~{.cxx}; #include<TRInterface.h>; #include<TMath.h>. typedef Double_t (*Function)(Double_t);. //Functor class with the function inside; class MyFunctor{; public:; MyFunctor(){; status=false;; f=TMath::BesselY1;; }; void setFunction(Function fun); {; f=fun;; status=true;; }; Bool_t getStatus(){return status;}; Double_t doEval(Double_t x) {; return f(x);; }; private:; Function f;; Bool_t status;; };; //this macro exposes the class into R's environment; // and lets you pass objects directly.; ROOTR_EXPOSED_CLASS(MyFunctor). //Macro to create a module; ROOTR_MODULE(MyFunctorModule) {; ROOT::R::class_<MyFunctor>( ""MyFunctor"" ); //creating a default constructor; .constructor(); //adding the method doEval to evaluate the internal function; .method( ""doEval"", &MyFunctor::doEval ); .method(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:12080,wrap,wraps,12080,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['wrap'],['wraps']
Integrability,"These headers, providing routines to construct and navigate; bounding volume hierarchies, have been copied from https://github.com/madmann91/bvh; commit 66e445b92f68801a6dd8ef94. Minor changes have been subsequently been applied to achieve compilation with C++17:. - inclusion of alternative span, when std::span is not found; - replacement of C++20 defaulted comparison operators with actual implementation; - old-style struct construction for objects of type ""Reinsertion""; - use of std::inner_product instead of std::transform_reduce (gcc 8.5 had problems). This is needed since ROOT should compile with C++17.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/README.md:25,rout,routines,25,geom/geom/inc/bvh/v2/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/README.md,1,['rout'],['routines']
Integrability,This directory contains all the hbook interface classes. See:. - [How to convert Hbook/PAW files to ROOT](https://root-forum.cern.ch/t/how-to-convert-hbook-paw-files-to-root/); - [The Chapter about the Histogram classes in the Users Guide](ftp://root.cern.ch/root/doc/3Histograms.pdf); - [The Chapter about Fitting Histogram in the Users Guide](ftp://root.cern.ch/root/doc/5FittingHistograms.pdf); - [How to use the Histogram classes](https://root.cern/manual/histograms/); - [How to Merge files with histograms and Trees](https://root.cern/manual/storing_root_objects/#merging-root-files-with-hadd); - [How to Fit Histograms](https://root.cern/manual/fitting/); - [How to Fit find peaks in histograms](https://root.cern/doc/master/peaks_8C.html); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/doc/index.md:38,interface,interface,38,hist/hbook/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/doc/index.md,1,['interface'],['interface']
Integrability,"This directory contains the Dictionary classes (interface to CINT); BEGIN_HTML; See:; <ul>; <li><a href=""http://root.cern.ch/root/Dictionary.html"">The ROOT Dictionary; </a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/doc/index.txt:48,interface,interface,48,core/meta/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/doc/index.txt,1,['interface'],['interface']
Integrability,"This directory contains the ROOT::Math::GeneticMinimizer class; BEGIN_HTML; The GeneticMinimizer class is used to implement a genetic minimizer algorithm.; The algorithm is based on an algorithm implemented in the TMVA package; (TMVA::GeneticAlgorithm class).; <p>; The ROOT::Math:GeneticMinimizer class implements the; ROOT::Math::Minimizer interface, as a new plugin with name ""Genetic"".; The class can be used when fitting histograms or graph by selecting it; as default minimizer. This can be done via:; <pre>; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Genetic"");; </pre>; Via the MinimizerOptions, one can control the possible options for the; class. These are described in the TMVA user guide, Option Table 7.; A list of the default options can be obtained by doing:; <pre>; ROOT::Math::Minimizer * min =ROOT::Math::Factory::CreateMinimizer(""Genetic"");; min->Options().Print();; </pre>; The user can change a default option, like the population size to 500; and the steps to 60 by doing:; <pre>; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""PopSize"",500);; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""Steps"",60);; </pre>. END_HTML. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt:342,interface,interface,342,math/genetic/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt,1,['interface'],['interface']
Integrability,"This file lists the most important contributors to the Cling interpreter.; It is sorted by name and formatted to allow easy grepping and beautification; by scripts. The fields are: name (N), email (E), description (D). Please let us know if you are not on this list while you should be, or if; something in your entry is incorrect. -------------------. N: Jerome Beclin; E: jerome.beclin@cern.ch; D: Contributions to unload verification. N: Bertrand Bellenot; E: bertrand.bellenot@cern.ch; D: Windows ports: MS Visual Studio; cygwin.; D: File system interaction: search paths, shared libraries. N: Philippe Canal; E: pcanal@fnal.gov; D: Core developer of cling. N: Cristina Cristescu; E: bianca-cristina.cristescu@cern.ch; D: Output redirection.; D: Contributions to unloading. N: Baozeng Ding; E: sploving1@gmail.com; D: Null-pointer deref protection. N: Lukasz Janyst; E: ljanyst@cern.ch; D: Initial prototype of cling. N: Javier Lopez-Gomez; E: javier.lopez.gomez@cern.ch; D: Support for entity redefinition (shadowing), general improvements, bug fixes. N: Roman Zulak (aka Frederich Munch); E: machtyrtle@gmail.com; D: Various contributions. N: Axel Naumann; E: axel@cern.ch; D: Core developer of cling. N: Timur Pocheptsov; E: Timur.Pocheptsov@cern.ch; D: .class, .typedef prompt interfaces. N: Fons Rademakers; E: Fons.Rademakers@cern.ch; D: Contributions to libc++ support. N: Paul Russo; E: russo@fnal.gov; D: Lookup routines.; D: Function call interfaces. N: Vassil Vassilev; E: vvasilev@cern.ch; D: Main developer of cling. N: Simeon Ehrig; E: s.ehrig@hzdr.de; D: cling CUDA runtime support; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CREDITS.txt:1285,interface,interfaces,1285,interpreter/cling/CREDITS.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CREDITS.txt,3,"['interface', 'rout']","['interfaces', 'routines']"
Integrability,"This just shows a class ``FancyAA`` that uses the ``INITIALIZE_AG_PASS`` macro; both to register and to ""join"" the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ analysis group.; Every implementation of an analysis group should join using this macro. .. code-block:: c++. namespace {; // Declare that we implement the AliasAnalysis interface; INITIALIZE_AG_PASS(BasicAA, AliasAnalysis, ""basic-aa"",; ""Basic Alias Analysis (default AA impl)"",; false, // Is CFG Only?; true, // Is Analysis?; true); // Is default Analysis Group implementation?; }. Here we show how the default implementation is specified (using the final; argument to the ``INITIALIZE_AG_PASS`` template). There must be exactly one; default implementation available at all times for an Analysis Group to be used.; Only default implementation can derive from ``ImmutablePass``. Here we declare; that the `BasicAliasAnalysis; <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass is the default; implementation for the interface. Pass Statistics; ===============. The `Statistic <https://llvm.org/doxygen/Statistic_8h_source.html>`_ class is; designed to be an easy way to expose various success metrics from passes.; These statistics are printed at the end of a run, when the :option:`-stats`; command line option is enabled on the command line. See the :ref:`Statistics; section <Statistic>` in the Programmer's Manual for details. .. _writing-an-llvm-pass-passmanager:. What PassManager does; ---------------------. The `PassManager <https://llvm.org/doxygen/PassManager_8h_source.html>`_ `class; <https://llvm.org/doxygen/classllvm_1_1PassManager.html>`_ takes a list of; passes, ensures their :ref:`prerequisites <writing-an-llvm-pass-interaction>`; are set up correctly, and then schedules passes to run efficiently. All of the; LLVM tools that run passes use the PassManager for execution of these passes. The PassManager does two main things to try to reduce the execution time of a; series",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:40203,interface,interface,40203,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:982,message,messages,982,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['message'],['messages']
Integrability,"To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In general, this is not a problem. If any object will outlive the; compound statement in which it was created then a more permanent; pointer will point to it, which frequently is part of another heap; object. See Resetting the Interpreter Environment in the chapter; ""Cling the C++ Interpreter"".; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:14047,message,message,14047,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['message'],['message']
Integrability,"Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());. Putting it together --- the first tool; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now we combine the two previous steps into our first real tool. A more advanced; version of this example tool is also checked into the clang tree at; ``tools/clang-check/ClangCheck.cpp``. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MAC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:4864,message,message,4864,interpreter/llvm-project/clang/docs/LibTooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst,1,['message'],['message']
Integrability,"Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""Volumes"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""General"" category and select the newly created volume; as the top one (you can do it also from the volume category). This is; just for starting. To create some hierarchy, one has to create several; other volumes and the matrices to position them. Once this is done, use; the volume editor interface to:; - add/remove daughters, change shape, edit position of daughters; - change visualization settings; - divide the volume (only if there are no daughters yet). 7. Close the geometry from the ""General"" category. \defgroup Geometry_classes Geometry classes; \ingroup Geometry; \brief The Geometry related classes. Several documents describing these classes are listed below:. - The main geometry class is documented in class TGeoManager.; - [Presentation/article at CHEP'03](http://www.slac.stanford.edu/econf/C0303241/proc/papers/THMT001.PDF); - [Presentation at ROOT 2004](http://www.slac.stanford.edu/BFROOT/www/Computing/Distributed/ROOT2004/files/gheata.ppt); - [Presentation at ROOT 2005](http://indico.cern.ch/getFile.py/access?contribId=s1t14&sessionId=1&resId=1&materialId=0&confId=a055638); - [Presentation at ROOT 2007](http://indico.cern.ch/materialDisplay.py?contribId=35&materialId=slides&confId=13356). See also [the use of the geometry classes in AliROOT package of ALICE](https://alice-offline.web.cern.ch/AliRoot/Manual.html). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:135570,interface,interface,135570,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"Tuple:; they link the in-memory representation of data types to their on-disk representation.; All field classes inherit from `RFieldBase`. Every type with RNTuple I/O supported has a corresponding RField<T> template specialization.; Complex types are composed of fields and sub fields.; E.g., a `struct` is represented by a parent field for the `struct` itself and a subfield for every member of the `struct`.; Fields of complex types have type-erased versions in addition to the templated ones (e.g., `RVectorField`, `RClassField`).; In this way, fields can be constructed even if the type information is only available at runtime.; To this end, `RFieldBase::Create()` creates an `RField` object from a type string. On the ""in-memory"" side, fields can construct and destroy objects of their wrapped type; (cf. `CreateValue()`, `CreateObject()`, `GetDeleter()` methods).; Existing objects in memory can be bound to fields (cf. `BindValue()` method). On the ""on-disk"" side, fields know about the possible column representations of their wrapped type.; Upon connecting a field to a page source or page sink,; fields create `RColumn` objects and register them with the page source/sink.; When reading and writing data, the field maps the in-memory information of an object to read/write calls on its columns.; For instance, when writing a `std::vector<float>`,; the field writes to an index column (storing information about the size of the vector).; Its subfield writes the actual values to a float column. During its lifetime, a field undergoes the following possible state transitions:; ```; [*] --> Unconnected --> ConnectedToSink ----; | | |; | --> ConnectedToSource ---> [*]; | |; -------------------------------; ```. The RField class hierarchy is fixed and not meant to be extended by user classes. ### RField::RValue; The `RValue` class makes the connection between an object in memory and the corresponding field used for I/O.; It contains a shared pointer of the object, i.e. RNTuple and the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:8768,wrap,wrapped,8768,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['wrap'],['wrapped']
Integrability,"ULT_PATH). # We need to consider not just the direct link dependencies, but also the; # transitive link dependencies. Do this by starting with the set of direct; # dependencies, then the dependencies of those dependencies, and so on.; set(new_libs ""clingMetaProcessor""); set(link_libs ${new_libs}); while(NOT ""${new_libs}"" STREQUAL """"); foreach(lib ${new_libs}); if(TARGET ${lib}); get_target_property(lib_type ${lib} TYPE); if(""${lib_type}"" STREQUAL ""STATIC_LIBRARY""); list(APPEND static_libs ${lib}); else(); list(APPEND other_libs ${lib}); endif(); get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES); if (NOT transitive_libs); continue(); endif(); foreach(transitive_lib ${transitive_libs}); list(FIND link_libs ${transitive_lib} idx); #if(TARGET ${transitive_lib} AND idx EQUAL -1); if(idx EQUAL -1); list(APPEND newer_libs ${transitive_lib}); list(APPEND link_libs ${transitive_lib}); endif(); endforeach(transitive_lib); endif(); endforeach(lib); set(new_libs ${newer_libs}); set(newer_libs """"); endwhile(); set(CLING_DEPEND_LIBS ${link_libs} CACHE STRING """"); endif(builtin_cling). #---Avoid to dependencies to system (e.g. atomic) libraries without modifying the LLVM code----------; if(CMAKE_SYSTEM_NAME STREQUAL Darwin); get_target_property(__libs LLVMSupport INTERFACE_LINK_LIBRARIES); list(REMOVE_ITEM __libs atomic); set_target_properties(LLVMSupport PROPERTIES INTERFACE_LINK_LIBRARIES ""${__libs}""); endif(). #---Mark the LLVM/CLANG variables as advanced--------------------------------------------------------; get_cmake_property(variables CACHE_VARIABLES); foreach(var ${variables}); if(var MATCHES ""^(CLANG|LLVM|CLING)_""); mark_as_advanced(FORCE ${var}); endif(); endforeach(); mark_as_advanced(FORCE BUG_REPORT_URL BUILD_CLANG_FORMAT_VS_PLUGIN BUILD_SHARED_LIBS BUILD_TESTING; C_INCLUDE_DIRS DEFAULT_SYSROOT FFI_INCLUDE_DIR FFI_LIBRARY_DIR; GCC_INSTALL_PREFIX LIBCLANG_BUILD_STATIC TOOL_INFO_PLIST); mark_as_advanced(CLEAR LLVM_ENABLE_ASSERTIONS LLVM_BUILD_TYPE); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:24207,depend,dependencies,24207,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"UM(gaus , expo)"", xmin, xmax)` will create a function composed of a normalized sum of a gaussian and an exponential.; - `TF1(""voigt"", ""CONV(breitwigner, gausn) , -15, 15)` will create a TF1 object made of a convolution between a Breit-Wigner and a Gaussian. ; - `TFormula` supports vectorization. All the `TF1` objected created with a formula expression can have a vectorized signature using `ROOT::Double_v`: `TF1::EvalPar( ROOT::Double_v * x,; double * p)`. The vectorization can then be used to speed-up fitting. It is not enabled by default, but it can be enabled by callig `TF1::SetVectorized(true)` or using the `""VEC""` option in the; constructor of TF1, when ROOT has been built with VecCore and one vectorization library such as Vc. ; - Added new auto-binning algorithm, referred to as `power-2`, which uses power of 2 bin widths to create bins; that are mergeable. The target use-case is support for auto-binning in multi-process or multi-thread execution,; e.g. `TDataFrame`, without the need of a synchronization point.; The new `power-2` algorithm is activated by setting the new `TH1::kAutoBinPTwo` status bit on the histogram.; The tutorial `tutorials/multicore/mt304_fillHistos.C` gives an example of how to use the functionality with; `TThreadedObject<TH1D>` . The `power-2` binning is currently available only for 1D histograms. ## Math Libraries; - The Fitting functions now support vectorization and parallelization.; - Added padding in the fit data classes for correct loading of SIMD arrays. ## RooFit Libraries. - Apply several fixes from the ATLAS Higgs combination branch of RooFit. These fixes include; - fix for computing the contraint normalization. This requires now the option GlobalObservables when creating the NLL.; - All the `RooAbsPdf::createNLL` used in The RooStats classes have been updated to include the `GlobalObservables` option.; - Remove the `Roo1DMomentMorphFunction` and replace it with `RooMomentMorphFunction` and `RooMomentMorphFunctionND`. ## TMVA Libr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:17874,synchroniz,synchronization,17874,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['synchroniz'],['synchronization']
Integrability,"USS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58177,integrat,integration,58177,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"V# is eliminated. This is more efficient and; avoids the problem that the second register allocation may perform; spilling which will fail as there is no longer a scratch V#. When the kernel prolog code is being emitted it is known whether the scratch V#; described above is actually used. If it is, the prolog code must set it up by; copying the Private Segment Buffer to the scratch V# registers and then adding; the Private Segment Wavefront Offset to the queue base address in the V#. The; result is a V# with a base address pointing to the beginning of the wavefront; scratch backing memory. The Private Segment Buffer is always requested, but the Private Segment; Wavefront Offset is only requested if it is used (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). .. _amdgpu-amdhsa-memory-model:. Memory Model; ~~~~~~~~~~~~. This section describes the mapping of the LLVM memory model onto AMDGPU machine; code (see :ref:`memmodel`). The AMDGPU backend supports the memory synchronization scopes specified in; :ref:`amdgpu-memory-scopes`. The code sequences used to implement the memory model specify the order of; instructions that a single thread must execute. The ``s_waitcnt`` and cache; management instructions such as ``buffer_wbinvl1_vol`` are defined with respect; to other memory instructions executed by the same thread. This allows them to be; moved earlier or later which can allow them to be combined with other instances; of the same instruction, or hoisted/sunk out of loops to improve performance.; Only the instructions related to the memory model are given; additional; ``s_waitcnt`` instructions are required to ensure registers are defined before; being used. These may be able to be combined with the memory model ``s_waitcnt``; instructions as described above. The AMDGPU backend supports the following memory models:. HSA Memory Model [HSA]_; The HSA memory model uses a single happens-before relation for all address; spaces (see :ref:`amdgpu-address-spaces`).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:200966,synchroniz,synchronization,200966,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,VAClassification); set (tmva-TMVAClassificationCategoryApplication-depends tutorial-tmva-TMVAClassificationCategory); set (tmva-TMVAMulticlass-depends tutorial-tmva-TMVAMultipleBackgroundExample); set (tmva-TMVAMulticlassApplication-depends tutorial-tmva-TMVAMulticlass); set (tmva-TMVARegressionApplication-depends tutorial-tmva-TMVARegression); set (tmva-TMVACrossValidationRegression-depends tutorial-tmva-TMVARegressionApplication); set (tmva-TMVACrossValidationApplication-depends tutorial-tmva-TMVACrossValidation); set (tmva-tmva101_Training-depends tutorial-tmva-tmva100_DataPreparation-py); set (tmva-tmva102_Testing-depends tutorial-tmva-tmva101_Training-py); set (tmva-tmva003_RReader-depends tutorial-tmva-TMVAClassification); set (tmva-tmva004_RStandardScaler-depends tutorial-tmva-tmva003_RReader); if (PY_TORCH_FOUND); set (tmva-pytorch-ApplicationClassificationPyTorch-depends tutorial-tmva-pytorch-ClassificationPyTorch-py); set (tmva-pytorch-RegressionPyTorch-depends tutorial-tmva-pytorch-ApplicationClassificationPyTorch-py); set (tmva-pytorch-ApplicationRegressionPyTorch-depends tutorial-tmva-pytorch-RegressionPyTorch-py); endif(); if (PY_KERAS_FOUND); set (tmva-TMVA_SOFIE_RSofieReader-depends tutorial-tmva-TMVA_Higgs_Classification); set (tmva-TMVA_SOFIE_RDataFrame_JIT-depends tutorial-tmva-TMVA_SOFIE_RSofieReader); set (tmva-TMVA_SOFIE_Keras_HiggsModel-depends tutorial-tmva-TMVA_SOFIE_RDataFrame_JIT); set (tmva-TMVA_SOFIE_RDataFrame-depends tutorial-tmva-TMVA_SOFIE_Keras_HiggsModel); set (tmva-TMVA_SOFIE_Inference-depends tutorial-tmva-TMVA_SOFIE_RDataFrame); if (PY_TORCH_FOUND); set (tmva-keras-RegressionKeras-depends tutorial-tmva-pytorch-RegressionPyTorch-py); set (tmva-keras-ClassificationKeras-depends tutorial-tmva-pytorch-ClassificationPyTorch-py); endif(); set (tmva-keras-ApplicationRegressionKeras-depends tutorial-tmva-keras-RegressionKeras-py); set (tmva-keras-ApplicationClassificationKeras-depends tutorial-tmva-keras-ClassificationKeras-py); endif().,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:20369,depend,depends,20369,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,10,['depend'],['depends']
Integrability,"VIRONMENT ${CLINGTEST_EXECUTABLE}); else(); #---Build LLVM/Clang with symbol visibility=hidden--------------------------------------------------; set(CMAKE_CXX_VISIBILITY_PRESET hidden); set(CMAKE_C_VISIBILITY_PRESET hidden); endif(); if (NOT MSVC AND NOT APPLE); # Requires the linker to resolve the symbol internally and prevents; # conflicts when linked with another software using also LLVM like in; # the problem reported for Julia in; # https://github.com/JuliaHEP/ROOT.jl/issues/17#issuecomment-882719292; # Only needed for Linux: Mac uses linker namespaces and Windows explicit export/import; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -Wl,-Bsymbolic""); ROOT_ADD_CXX_FLAG(CMAKE_CXX_FLAGS ""-fno-semantic-interposition""); endif(); set(CMAKE_VISIBILITY_INLINES_HIDDEN ""ON""). #--- Build LLVM/Clang with modules -----------------------------------------------------------------; if(cxxmodules); # LLVM knows how to configure its modules builds. We cannot just add the flags; # because the cxxmodules builds in llvm have different build dependency order.; string(REPLACE ""${ROOT_CXXMODULES_CXXFLAGS}"" """" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS}); string(REPLACE ""${ROOT_CXXMODULES_CFLAGS}"" """" CMAKE_C_FLAGS ${CMAKE_C_FLAGS}); if(libcxx); # FIXME: We cannot build LLVM/clang with modules on with libstdc++, yet.; # FIXME: We cannot build LLVM/clang with modules on with libc++, too.; #set (LLVM_ENABLE_MODULES ON CACHE BOOL ""Override the default LLVM_ENABLE_MODULES option value."" ); endif(libcxx); endif(cxxmodules). if(gcctoolchain); ROOT_ADD_CXX_FLAG(CMAKE_CXX_FLAGS --gcc-toolchain=${gcctoolchain}); endif(). # We will not fix llvm or clang.; string(REPLACE ""-Werror "" """" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ""); # Turn off coverage - we don't need this for llvm.; string(REPLACE ""${GCC_COVERAGE_COMPILE_FLAGS}"" """" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""). if(LLVM_SHARED_LINKER_FLAGS); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} ${LLVM_SHARED_LINKER_FLAGS}""); endif(); if(LLVM_EXE_LINKER_F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:8032,depend,dependency,8032,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"VM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; -----------------. Implementations of the Support Library interface are separated by their general; class of operating system. Currently only Unix and Win32 classes are defined; but more could be added for other operating system classifications. To; distinguish which implementation to compile, the code in ``lib/Support`` uses; the ``LLVM_ON_UNIX`` and ``_WIN32`` ``#defines``. Each source file in; ``lib/Support``, after implementing the generic (operating system independent); functionality needs to include the correct implementation using a set of; ``#if defined(LLVM_ON_XYZ)`` directives. For example, if we had; ``lib/Support/Path.cpp``, we'd expect to see in that file:. .. code-block:: c++. #if defined(LLVM_ON_UNIX); #include ""Unix/Path.inc""; #endif; #if defined(_WIN32); #include ""Windows/Path.inc""; #endif. The implementation in ``lib/Support/Unix/Path.inc`` should handle all Unix; variants. The implementation in ``lib/Support/Windows/Path.inc`` should handle; all Windows variants. What this does is quickly inc the basic class; of operating system that wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:9946,interface,interface,9946,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"VM_CCACHE_DIR} ${CCACHE_PROGRAM}""); endif(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM}); else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ""Dependency debugging is only currently supported on Darwin hosts.""); endif(); if(LLVM_CCACHE_BUILD); message(FATAL_ERROR ""Cannot enable dependency debugging while using ccache.""); endif(); endif(). option(LLVM_ENABLE_DAGISEL_COV ""Debug: Prints tablegen patterns that were used for selecting"" OFF); option(LLVM_ENABLE_GISEL_COV ""Enable collection of GlobalISel rule coverage"" OFF); if(LLVM_ENABLE_GISEL_COV); set(LLVM_GISEL_COV_PREFIX ""${CMAKE_BINARY_DIR}/gisel-coverage-"" CACHE STRING ""Provide a filename prefix to collect the GlobalISel rule coverage""); endif(). # Add path for custom modules; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:12160,depend,dependencies,12160,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"WAYS 1; ). get_ext_project_build_command(run_clean_compiler_rt clean); ExternalProject_Add_Step(compiler-rt clean; COMMAND ${run_clean_compiler_rt}; COMMENT ""Cleaning compiler-rt...""; DEPENDEES configure; DEPENDERS build; DEPENDS clang; WORKING_DIRECTORY ${BINARY_DIR}; ). install(CODE ""execute_process\(COMMAND \${CMAKE_COMMAND} -DCMAKE_INSTALL_PREFIX=\${CMAKE_INSTALL_PREFIX} -P ${BINARY_DIR}/cmake_install.cmake \)""; COMPONENT compiler-rt). add_llvm_install_targets(install-compiler-rt; DEPENDS compiler-rt; COMPONENT compiler-rt). # Add top-level targets that build specific compiler-rt runtimes.; set(COMPILER_RT_RUNTIMES fuzzer asan builtins dfsan lsan msan profile tsan ubsan ubsan-minimal); foreach(runtime ${COMPILER_RT_RUNTIMES}); get_ext_project_build_command(build_runtime_cmd ${runtime}); add_custom_target(${runtime}; COMMAND ${build_runtime_cmd}; DEPENDS compiler-rt-configure; WORKING_DIRECTORY ${BINARY_DIR}; VERBATIM USES_TERMINAL); endforeach(). if(LLVM_INCLUDE_TESTS); # Add binaries that compiler-rt tests depend on.; set(COMPILER_RT_TEST_DEPENDENCIES; FileCheck count not llvm-nm llvm-objdump llvm-symbolizer llvm-jitlink lli split-file). # Add top-level targets for various compiler-rt test suites.; set(COMPILER_RT_TEST_SUITES; check-asan; check-asan-dynamic; check-cfi; check-cfi-and-supported; check-dfsan; check-fuzzer; check-gwp_asan; check-hwasan; check-lsan; check-msan; check-profile; check-safestack; check-sanitizer; check-tsan; check-ubsan; check-ubsan-minimal; ); foreach(test_suite ${COMPILER_RT_TEST_SUITES}); get_ext_project_build_command(run_test_suite ${test_suite}); add_custom_target(${test_suite}; COMMAND ${run_test_suite}; DEPENDS compiler-rt-build ${COMPILER_RT_TEST_DEPENDENCIES}; WORKING_DIRECTORY ${BINARY_DIR}; VERBATIM; USES_TERMINAL; ); endforeach(). # Add special target to run all compiler-rt test suites.; get_ext_project_build_command(run_check_compiler_rt check-all); add_custom_target(check-compiler-rt; COMMAND ${run_check_compiler_rt}; DEPEN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:4831,depend,depend,4831,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,1,['depend'],['depend']
Integrability,"When and why was Cling developed?; ---------------------------------. Cling was first released in 2014 as the interactive, C++ interpreter in; ROOT. `ROOT <https://root.cern/>`_ is an open-source program written primarily; in C++, developed by research groups in high-energy physics including `CERN; <https://home.cern/>`_, `FERMILAB <https://www.fnal.gov/>`_ and `Princeton; <https://www.princeton.edu/>`_. ROOT is nowadays used by most high-energy; physics experiments. CERN is an European research organization that operates the; largest particle physics laboratory in the world. Its experiments collect; petabytes of data per year to be serialized, analyzed, and visualized as C++; objects. In this framework, Cling was developed with the aim to facilitate the; processing of scientific data in the field of high-energy physics . Cling is a; core component of ROOT: it provides essential functionality for the analysis of; vast amounts of very complex data produced by the experimental high-energy; physics community by enabling (1) interactive exploration in C++, (2) dynamic; interoperability (see `cppyy <https://cppyy.readthedocs.io/en/latest/>`_, an; automatic, runtime Python/C++ binder), and (3) rapid prototyping capabilities.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/background.rst:1082,interoperab,interoperability,1082,interpreter/cling/docs/chapters/background.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/background.rst,1,['interoperab'],['interoperability']
Integrability,"Why interpreting C++ with Cling?; -----------------------------------. 1. **Learning C++:**; ; One use case of Cling is to aid the C++ learning process. Offering imediate; feedback the user can easily get familiar with the structures and spelling of; the language. 2. **Creating scripts:**; ; The power of an interpreter lays as well in the compactness and ease of; repeatedly running a small snippet of code - aka a script. This can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:920,interface,interface,920,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,1,['interface'],['interface']
Integrability,"X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220589,interface,interface,220589,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return typeNameParameters. Matcher<*>binaryOperationMatcher<*>...Matcher<*>; Matches nodes which can be used with binary operators. The code; var1 != var2;; might be represented in the clang AST as a binaryOperator, a; cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on. * whether the types of var1 and var2 are fundamental (binaryOperator) or at; least one is a class type (cxxOperatorCallExpr); * whether the code appears in a template declaration, if at least one of the; vars is a dependent-type (binaryOperator); * whether the code relies on a rewritten binary operator, such as a; spaceship operator or an inverted equality operator; (cxxRewrittenBinaryOperator). This matcher elides details in places where the matchers for the nodes are; compatible. Given; binaryOperation(; hasOperatorName(""!=""),; hasLHS(expr().bind(""lhs"")),; hasRHS(expr().bind(""rhs"")); ); matches each use of ""!="" in:; struct S{; bool operator!=(const S&) const;; };. void foo(); {; 1 != 2;; S() != S();; }. template<typename T>; void templ(); {; 1 != 2;; T() != S();; }; struct HasOpEq; {; bool operator==(const HasOpEq &) const;; };. void inverse(); {; HasOpEq s1;; HasOpEq s2;; if (s1 != s2); return;; }. struct HasSpaceship; {; bool operator<=>(const HasOpEq &) const;; };. void use_spaceship(); {; HasSpaceship s1;; HasSpaceship s2;; if (s1 != s2); return;; }. Matcher<*>eachOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Unlike anyOf, eachOf will generate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:130411,depend,dependent-type,130411,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent-type']
