quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoSphere (const TGeoSphere &)=delete;  ; TGeoSp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:18181,Safe,SafetySeg,18181,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoTorus (const TGeoTorus &)=delete;  ; TGeoToru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:18063,Safe,SafetySeg,18063,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoTrd1 (const TGeoTrd1 &)=delete;  ; TGeoTrd1 &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:17629,Safe,SafetySeg,17629,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoTrd2 (const TGeoTrd2 &)=delete;  ; TGeoTrd2 &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:17689,Safe,SafetySeg,17689,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoTube (const TGeoTube &)=delete;  ; TGeoTube &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:18155,Safe,SafetySeg,18155,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoXtru (const TGeoXtru &)=delete;  mutex for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:17903,Safe,SafetySeg,17903,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EGeoArb8Type { kArb8Trap = (1ULL << ( 27 )); , kArb8Tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:20390,Safe,SafetySeg,20390,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['Safe'],['SafetySeg']
Safety,"i1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; static Bool_t DO NOT USE !The overlap detection does not wo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:16844,Safe,SafetySeg,16844,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['Safe'],['SafetySeg']
Safety,"iDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:106; TGeoTrap::fAlpha2Double_t fAlpha2Definition TGeoArb8.h:108; TGeoTrap::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTrap::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTrap::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTrap::fBl1Double_t fBl1Definition TGeoArb8.h:102; TGeoTrap::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::fH1Double_t fH1Definition TGeoArb8.h:101; TGeoTrap::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTrap::fPhiDouble_t fPhiDefinition TGeoArb8.h:100; TGeoTrap::GetAlpha2Double_t GetAlpha2() constDefinition TGeoArb8.h:139; TGeoTrap::GetThetaDouble_t GetTheta() constDefinition TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:18633,safe,safe,18633,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"iability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002361,avoid,avoid,1002361,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"ialize(nPoints,1, type);; 594 ; 595#ifdef DEBUG; 596 std::cout << ""DoFillData: graph npoints = "" << nPoints << "" type "" << type << std::endl;; 597 if (func) {; 598 double a1,a2; func->GetRange(a1,a2); std::cout << ""func range "" << a1 << "" "" << a2 << std::endl;; 599 }; 600#endif; 601 ; 602 double x[1];; 603 for ( int i = 0; i < nPoints; ++i) {; 604 ; 605 x[0] = gx[i];; 606 ; 607 ; 608 if (useRange && ( x[0] < xmin || x[0] > xmax) ) continue;; 609 ; 610 // need to evaluate function to know about rejected points; 611 // hugly but no other solutions; 612 if (func) {; 613 TF1::RejectPoint(false);; 614 (*func)( x ); // evaluate using stored function parameters; 615 if (TF1::RejectedPoint() ) continue;; 616 }; 617 ; 618 ; 619 if (fitOpt.fErrors1); 620 dv.Add( gx[i], gy[i] );; 621 ; 622 // for the errors use the getters by index to avoid cases when the arrays are zero; 623 // (like in a case of a graph); 624 else if (type == BinData::kValueError) {; 625 double errorY = gr->GetErrorY(i);; 626 // should consider error = 0 as 1 ? Decide to skip points with zero errors; 627 // in case want to keep points with error = 0 as errrors=1 need to set the option UseEmpty; 628 if (!HFitInterface::AdjustError(fitOpt,errorY) ) continue;; 629 dv.Add( gx[i], gy[i], errorY );; 630 ; 631#ifdef DEBUG; 632 std::cout << ""Point "" << i << "" "" << gx[i] << "" "" << gy[i] << "" "" << errorY << std::endl;; 633#endif; 634 ; 635 ; 636 }; 637 else { // case use error in x or asym errors; 638 double errorX = 0;; 639 if (fitOpt.fCoordErrors); 640 // shoulkd take combined average (sqrt(0.5(e1^2+e2^2)) or math average ?; 641 // gr->GetErrorX(i) returns combined average; 642 // use math average for same behaviour as before; 643 errorX = std::max( 0.5 * ( gr->GetErrorXlow(i) + gr->GetErrorXhigh(i) ) , 0. ) ;; 644 ; 645 ; 646 // adjust error in y according to option; 647 double errorY = std::max(gr->GetErrorY(i), 0.);; 648 // we do not check the return value since we check later if error in X and Y is zero for skip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:19808,avoid,avoid,19808,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Double_t GetMaximumStored() const; {return fMaximum;}. Double_t GetMinimumStored() const; {return fMinimum;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF1.html:64070,safe,safe,64070,root/html534/TF1.html,https://root.cern,https://root.cern/root/html534/TF1.html,1,['safe'],['safe']
Safety,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return fXmax;}. void SetChisquare(Double_t chi2); {fChisquare = chi2;}. void SetNumberFitPoints(Int_t npfits); {fNpfit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:63525,safe,safe,63525,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,3,['safe'],['safe']
Safety,"ible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441510,recover,recovery,441510,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovery']
Safety,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoUnion.html:8850,safe,safe,8850,root/html528/TGeoUnion.html,https://root.cern,https://root.cern/root/html528/TGeoUnion.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoUnion.html:8950,safe,safe,8950,root/html530/TGeoUnion.html,https://root.cern,https://root.cern/root/html530/TGeoUnion.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"ic 3D buffer and returns a reference. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  in case shape has some negative parameters, these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; TGeoScale * GetScale () const;  ; TGeoShape * GetShape () const;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () const override;  ; Bool_t IsAssembly () const override;  Returns true if the scaled shape is an assembly. ;  ; Bool_t IsCylType () const override;  ; Bool_t IsReflected () const override;  Check if the scale transformation is a reflection. ;  ; TBuffer3D * MakeBuffer3D () const override;  Creates a TBuffer3D describing this shape. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  computes the closest distance from given point to this shape, according to option. ;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  Compute safe distance from each of the points in the input array. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetPoints (Double_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetPoints (Float_t *points) const override;  Mesh points for scaled shapes. ;  ; void SetScale (TGeoScale *scale);  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  Fill TBuffer3D structure for segments and polygons. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:3846,Safe,Safety,3846,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:3065,safe,safe,3065,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,2,['safe'],['safe']
Safety,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:3044,safe,safe,3044,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,2,['safe'],['safe']
Safety,"ic TMVA::Tools::ECitationkPlainText; static TMVA::Tools::EWelcomeMessagekSmall1WelcomeMsg; static TMVA::Tools::EWelcomeMessagekSmall2WelcomeMsg; static TMVA::Tools::EWelcomeMessagekStandardWelcomeMsg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(). void DestroyInstance(); NOTE: there is no thread safe way to do this so; one must only call this method ones in an executable. Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Tools.html:6610,sanity check,sanity check,6610,root/html602/TMVA__Tools.html,https://root.cern,https://root.cern/root/html602/TMVA__Tools.html,2,['sanity check'],['sanity check']
Safety,"ic TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_AsIs; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Fill; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Line; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Int_tfBoxSkipNumber of boxes to skip for each drawn box during scene rotation.; TEveBoxSet::EBoxType_efBoxTypeType of rendered box.; UChar_tTEveElement::fCSCBits; TEveDigitSet::Callback_fooTEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefDepthBreadth assigned to third coordinate (C).; Float_tfDefHeightBreadth assigned to second coordinate (B).; Float_tfDefWid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBoxSet.html:25477,avoid,avoid,25477,root/html602/TEveBoxSet.html,https://root.cern,https://root.cern/root/html602/TEveBoxSet.html,2,['avoid'],['avoid']
Safety,"ic TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. atomic<TApplication*>fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; TROOT::AListOfEnums_tfEnumsList of enum types; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TListOfFunctionTemplates*fFuncTemplateList of global function templates; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TStringfGitBranchGit branch; TStringfGitCommitGit commit SHA1 of built; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:18061,detect,detected,18061,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['detect'],['detected']
Safety,"ic const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19131,timeout,timeout,19131,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3417,avoid,avoid,3417,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['avoid'],['avoid']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3417,avoid,avoid,3417,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['avoid'],['avoid']
Safety,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3417,avoid,avoid,3417,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['avoid'],['avoid']
Safety,"ic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ;  . Private Attributes; std::string fAddr;  ! HTTP address of the server ;  ; std::unique_ptr< TExec > fAssgnExec;  ! special exec to assign thread id via ProcessEvents ;  ; WebWindowDeleteCallback_t fDeleteCallback;  ! function called when RWebWindow is destroyed ;  ; bool fExternalProcessEvents {false};  ! indicate that there are external process events engine ;  ; unsigned fIdCnt {0};  ! counter for identifiers ;  ; float fLaunchTmout {30.};  ! timeout in seconds to start browser process, default 30s ;  ; std::recursive_mutex fMutex;  ! main mutex, used for window creations ;  ; std::unique_ptr< THttpServer > fServer;  ! central communication with the all used displays ;  ; std::string fSessionKey;  ! secret session key used on client to code connections keys ;  ; WebWindowShowCallback_t fShowCallback;  ! function called for each RWebWindow::Show call ;  ; bool fUseHttpThrd {false};  ! use special thread for THttpServer ;  ; bool fUseSenderThreads {false};  ! use extra threads for sending data from RWebWindow to clients ;  ; bool fUseSessionKey {false};  ! is session key has to be used for data signing ;  . Friends; class RWebWindow;  . #include <ROOT/RWebWindowsManager.hxx>; Constructor & Destructor Documentation. ◆ RWebWindowsManager(). RWebWindowsManager::RWebWindowsManager ; (; ). window manager constructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 273 of file RWebWindowsManager.cxx. ◆ ~RWebWindowsManager(). RWebWindowsManager::~RWebWindowsManager ; (; ). window manager destructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 287 of file RWebWindowsManager.cxx. Member Function Documentation. ◆ AddServerLocation(). void RWebWindowsManager::AddServerLocation ; (; const std::string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:6418,timeout,timeout,6418,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety,"ic std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooDirItem; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; double correlation (Int_t row, Int_t col) const;  Return a correlation matrix element addressed with numeric indices. ;  ; double covariance (Int_t row, Int_t col) const;  Return the covariance matrix element addressed with numeric indices. ;  ; void fillCorrMatrix ();  Internal utility method to extract the correlation matrix and the global correlation coefficients from the MINUIT memory buffer and fill the internal arrays. ;  ; void fillLegacyCorrMatrix () const;  Sanity check. ;  ; void fillPrefitCorrMatrix ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from RooDirItem; void appendToDir (TObject *obj, bool forceMemoryResident=false);  Append object to directory. ;  ; void removeFromDir (TObject *obj);  Remove object from directory it was added to. ;  . Protected Attributes; TMatrixDSym * _CM = nullptr;  Correlation matrix. ;  ; RooArgList * _constPars = nullptr;  List of constant parameters. ;  ; TList _corrMatrix;  ! Correlation matrix (list of RooArgLists) ;  ; Int_t _covQual;  MINUIT quality code of covariance matrix. ;  ; double _edm;  Estimated distance to minimum. ;  ; RooArgList * _finalPars = nullptr;  List of floating parameters with final values. ;  ; TVectorD * _GC = nullptr;  Global correlation coefficients. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:18521,Sanity check,Sanity check,18521,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['Sanity check'],['Sanity check']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buffer) const; voidTGeoShape::SetShapeBit(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:9307,Safe,SafetyPhi,9307,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:8317,Safe,SafetyPhi,8317,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:9190,Safe,SafetyPhi,9190,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:8092,Safe,SafetyPhi,8092,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:7874,Safe,SafetyPhi,7874,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd1.html:7762,Safe,SafetyPhi,7762,root/html528/TGeoTrd1.html,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2.html:7828,Safe,SafetyPhi,7828,root/html528/TGeoTrd2.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:8448,Safe,SafetyPhi,8448,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,1,['Safe'],['SafetyPhi']
Safety,"ic voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:8891,Safe,SafetySeg,8891,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,1,['Safe'],['SafetySeg']
Safety,"ic voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:5845,timeout,timeout,5845,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['timeout'],['timeout']
Safety,"ically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid problems; using AsString multiple times in a single statement. void Copy(TTimeStamp& ts) const; Copy this to ts. UInt_t GetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Return date in form of 19971224 (i.e. 24/12/1997),; if non-zero pointers supplied for year, month, day fill those as well. UInt_t GetTime(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* hour = 0, UInt_t* min = 0, UInt_t* sec = 0) const; Return time in form of 123623 (i.e. 12:36:23),; if non-zero pointers supplied for hour, min, sec fill those as well. Int_t GetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Get the day of the year represented by this time stamp value.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetMonth(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:5904,avoid,avoid,5904,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,6,['avoid'],['avoid']
Safety,"ices () const;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; virtual Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const =0;  ; virtual void InspectShape () const =0;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () const;  ; virtual Bool_t IsCylType () const =0;  ; virtual Bool_t IsReflected () const;  ; Bool_t IsRunTimeShape () const;  ; Bool_t IsValid () const;  ; virtual Bool_t IsValidBox () const =0;  ; virtual Bool_t IsVecGeom () const;  ; virtual TBuffer3D * MakeBuffer3D () const;  ; void Paint (Option_t *option="""") override;  Paint this shape. ;  ; void ResetShapeBit (UInt_t f);  ; virtual Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const =0;  ; virtual void Safety_v (const Double_t *, const Bool_t *, Double_t *, Int_t) const;  ; virtual void SetDimensions (Double_t *param)=0;  ; void SetId (Int_t id);  ; virtual void SetPoints (Double_t *points) const =0;  ; virtual void SetPoints (Float_t *points) const =0;  ; void SetRuntime (Bool_t flag=kTRUE);  ; virtual void SetSegsAndPols (TBuffer3D &buff) const =0;  ; void SetShapeBit (UInt_t f);  ; void SetShapeBit (UInt_t f, Bool_t set);  Equivalent of TObject::SetBit. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numpoints, Int_t px, Int_t py) const;  Returns distance to shape primitive mesh. ;  ; virtual void Sizeof3D () const =0;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t TestShapeBit (UInt_t f) const;  ; Int_t TestShapeBits (UInt_t f) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:12500,Safe,Safety,12500,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['Safety']
Safety,"ices; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Tra; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Trap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:18016,safe,safe,18016,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety,"ich threads will process the batches of entries. In particular, note that this means that, for multi-thread event loops, there is no guarantee on the order in which Snapshot() will write entries: they could be scrambled with respect to the input dataset. The values of the special rdfentry_ column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46574,safe,safe,46574,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"iciency is then the combined efficiency. The weights to be used in the combination should be the probability that an electron comes from the corresponding process. \[; p_{1} = \frac{\sigma_{1}}{\sigma_{1} + \sigma_{2}} = \frac{N_{1}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\; p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}; \]. VI. Further operations. VI.1 Information about the internal histograms; The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram return a constant pointer to the internal histograms. They can be used to obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...). One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto. The returned histograms are completely independent from the current TEfficiency object. By default, they are not attached to a directory to avoid the duplication of data and the user is responsible for deleting them.; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; ; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; ; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; ; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directory and write the file; //clone->SetDirectory(gDirectory);; //pFile->Write();; ; //delete histogram object; delete clone;; clone = 0;; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TEfficiency::GetCopyTotalHistoTH1 * GetCopyTotalHisto() constReturns a cloned version of fTotalHistogram.Definition TEfficiency.cxx:2647; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; It is also possible to set the internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:24350,avoid,avoid,24350,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['avoid'],['avoid']
Safety,"ict(var=y, Binning=50)); hh_model_1.SetLineColor(ROOT.kBlue); hh_model_2.SetLineColor(ROOT.kBlue); hh_model_3.SetLineColor(ROOT.kBlue); hh_model_4.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; Author",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:3577,safe,safe,3577,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['safe'],['safe']
Safety,"icy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBuffer.html:18325,avoid,avoid,18325,root/html534/TBuffer.html,https://root.cern,https://root.cern/root/html534/TBuffer.html,3,['avoid'],['avoid']
Safety,"id * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TThread.h 41086 2011-09-30 21:27:53Z pcanal $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TThread.html:14972,avoid,avoid,14972,root/html532/TThread.html,https://root.cern,https://root.cern/root/html532/TThread.html,1,['avoid'],['avoid']
Safety,"id 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:1990,detect,detects,1990,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,6,['detect'],['detects']
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:19184,safe,safe,19184,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTorus.html:20938,safe,safe,20938,root/html604/TGeoTorus.html,https://root.cern,https://root.cern/root/html604/TGeoTorus.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:20938,safe,safe,20938,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"id DefineColors() constDefine 100 colors with increasing light intensities for each basic color (1-7) Register these colors ...Definition TGeoPainter.cxx:279; TGeoPainter::SetExplodedViewvoid SetExplodedView(Int_t iopt=0) overrideSet type of exploding view.Definition TGeoPainter.cxx:1962; TGeoPainter::ExecuteManagerEventvoid ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1074; TGeoPainter::SetTopVolumevoid SetTopVolume(TGeoVolume *vol) overrideDefinition TGeoPainter.h:173; TGeoPainter::SetRaytracingvoid SetRaytracing(Bool_t flag=kTRUE) overrideDefinition TGeoPainter.h:171; TGeoPainter::fLastVolumeTGeoVolume * fLastVolumeDefinition TGeoPainter.h:67; TGeoPainter::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints) overrideSet number of points to be generated on the shape outline when checking for overlaps.Definition TGeoPainter.cxx:2007; TGeoPainter::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideCheck current point in the geometry.Definition TGeoPainter.cxx:242; TGeoPainter::DistanceToPrimitiveVolInt_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) overrideCompute the closest distance of approach from point px,py to a volume.Definition TGeoPainter.cxx:348; TGeoPainter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:17403,safe,safety,17403,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['safe'],['safety']
Safety,"id Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSubtraction.html:9580,safe,safe,9580,root/html534/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"id TGeoBoolNode::CreateThreadData ; (; Int_t ; nthreads). Create thread data for n threads max. ; Definition at line 100 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoBoolNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). virtual Int_t TGeoBoolNode::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromInside(). virtual Double_t TGeoBoolNode::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromOutside(). virtual Double_t TGeoBoolNode::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetBooleanOperator(). virtual EGeoBoolType TGeoBoolNode::GetBooleanOperator ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetLeftMatrix(). TGeoMatrix * TGeoBoolNode::GetLeftMatrix ; (; ); const. inline . Definition at line 76 of file TGeoBoolNode.h. ◆ GetLeftShape(). TGeoShape * TGeoBoolNode::GetLeftShape ; (; ); const. inline . Definition at line 78 of file TGeoBoolNode.h. ◆ GetNpoints(). virtual Int_t TGeoBoolNode::GetNpoints ; (; ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetRightMatrix(). TGeoMatrix * TGeoBoolNode::GetRightMatrix ; (; ); const. inline . Definition at line 77 of file TGeoBoolNode.h. ◆ GetRightShape(). TGeoShape * TGeoBoolNode::GetRightShape ; (; ); const. inline . Definition at line 79 of file TGeoBoolNode.h. ◆ GetThreadData(). TGeoBoolNode::ThreadData_t & TGeoBoolNode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:17437,safe,safe,17437,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['safe'],['safe']
Safety,"id);  only for use by root streamer or derived classes ;  ;  ~TUnfold (void) override;  ; virtual Double_t DoUnfold (Double_t tau);  perform the unfolding for a given regularisation parameter tau ;  ; Double_t DoUnfold (Double_t tau, const TH1 *hist_y, Double_t scaleBias=0.0);  perform the unfolding for a given input and regularisation ;  ; void GetBias (TH1 *bias, const Int_t *binMap=nullptr) const;  get bias vector including bias scale ;  ; Double_t GetChi2A (void) const;  get χ2A contribution determined in recent unfolding ;  ; Double_t GetChi2L (void) const;  get χ2L contribution determined in recent unfolding ;  ; double GetDF (void) const;  return the effecive number of degrees of freedom See e.g. ;  ; void GetDXDY (TH2 *dxdy) const;  get matrix connecting input and output changes ;  ; void GetEmatrix (TH2 *ematrix, const Int_t *binMap=nullptr) const;  get output covariance matrix, possibly cumulated over several bins ;  ; Double_t GetEpsMatrix (void) const;  get numerical accuracy for Eigenvalue analysis when inverting matrices with rank problems ;  ; void GetFoldedOutput (TH1 *folded, const Int_t *binMap=nullptr) const;  get unfolding result on detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:5039,detect,detector,5039,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,3,['detect'],['detector']
Safety,"id* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPSocket.html:5979,timeout,timeout,5979,root/html528/TPSocket.html,https://root.cern,https://root.cern/root/html528/TPSocket.html,1,['timeout'],['timeout']
Safety,"id; TReffLastTrackreference pointer to last track; Double32_tfMatrix[4][4]; Int_tfMeasures[10]; TRefArray*fMuonsarray of Muon tracks only; Int_tfNsegNumber of track segments; Int_tfNtrackNumber of tracks; Int_tfNvertex; Double32_tfTemperature; TClonesArray*fTracks->array with all tracks; TBitsfTriggerBitsBits triggered by this event.; charfType[20]event type; TReffWebHistogramEXEC:GetWebHistogram reference to an histogram in a TWebFile; static TH1F*fgHist; static TClonesArray*fgTracks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). void Build(Int_t ev, Int_t arg5 = 600, Float_t ptmin = 1). Track * AddTrack(Float_t random, Float_t ptmin = 1); Add a new track to the list of tracks for this event.; To avoid calling the very time consuming operator new for each track,; the standard but not well know C++ operator ""new with placement""; is called. If tracks[i] is 0, a new Track object will be created; otherwise the previous Track[i] will be overwritten. void Clear(Option_t* option = """"). void Reset(Option_t* option = """"); Static function to reset all static objects for this event; fgTracks->Delete(option);. void SetHeader(Int_t i, Int_t run, Int_t date, Float_t random). void SetMeasure(UChar_t which, Int_t what). void SetRandomVertex(); This delete is to test the relocation of variable length array. TBits& GetTriggerBits(); { return fTriggerBits; }. Event(). Bool_t IsValid() const; { return fIsValid; }. void ResetHistogramPointer(); {fH=0;}. void SetNseg(Int_t n); { fNseg = n; }. void SetNtrack(Int_t n); { fNtrack = n; }. void SetNvertex(Int_t n); { fNvertex = n; SetRandomVertex(); }. void SetFlag(UInt_t f); { fFlag = f; }. void SetTemperature(Double32_t t); { fTemperature = t; }. void SetType(char* type); {strcpy(fType,type);}. void SetMatrix(UChar_t x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Event.html:9934,avoid,avoid,9934,root/html528/Event.html,https://root.cern,https://root.cern/root/html528/Event.html,1,['avoid'],['avoid']
Safety,"idIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line 916 of file TGeoParallelWorld.cxx. ◆ IsA(). TClass * TGeoParallelWorld::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 184 of file TGeoParallelWorld.h. ◆ IsClosed(). Bool_t TGeoParallelWorld::IsClosed ; (; ); const. inline . Definition at line 143 of file TGeoParallelWorld.h. ◆ IsUsingOverlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. ◆ operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld & ; ). protecteddelete . ◆ PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. ◆ PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. ◆ RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25179,detect,detected,25179,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['detect'],['detected']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:2454,safe,safe,2454,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:2240,safe,safe,2240,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,1,['safe'],['safe']
Safety,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:7932,safe,safe,7932,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"idTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:8463,safe,safe,8463,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,1,['safe'],['safe']
Safety,"idTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:10465,timeout,timeout,10465,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,1,['timeout'],['timeout']
Safety,"idTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonitor&operator=(const TMonitor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:7320,timeout,timeout,7320,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['timeout'],['timeout']
Safety,"ide EACH volume and calling FindNextBoundary() + Safety() for each call. The timing is normalized by the number of crossings computed at stage 2 and presented as percentage. One can get a picture on which are the most ""burned"" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced. ; Definition at line 3811 of file TGeoManager.cxx. ◆ CheckOverlaps(). void TGeoManager::CheckOverlaps ; (; Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ). Check all geometry for illegal overlaps within a limit OVLP. ; Definition at line 3869 of file TGeoManager.cxx. ◆ CheckPath(). Bool_t TGeoManager::CheckPath ; (; const char * ; path); const. Check if a geometry path is valid without changing the state of the current navigator. ; Definition at line 1715 of file TGeoManager.cxx. ◆ CheckPoint(). void TGeoManager::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Classify a given point. See TGeoChecker::CheckPoint(). ; Definition at line 3770 of file TGeoManager.cxx. ◆ CheckShape(). void TGeoManager::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2) . Definition at line 3783 of file TGeoManager.cxx. ◆ Class(). static TClass * TGeoManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 605 of file TGeoManager.h. ◆ CleanGarb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:76425,safe,safety,76425,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"ide alternative; scan methods or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ProduceXml(const char* path, const char* options, TString& res); produce XML data for specified item; For object conversion TBufferXML is used. TString DecodeUrlOptionValue(const char* value, Bool_t remove_quotes = kTRUE); method replaces all kind of special symbols, which could appear in URL options. Bool_t ProduceExe(const char* path, const char* options, TString& res, Bool_t astxt = kFALSE); execute co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSniffer.html:10480,detect,detect,10480,root/html602/TRootSniffer.html,https://root.cern,https://root.cern/root/html602/TRootSniffer.html,1,['detect'],['detect']
Safety,"ide(). Double_t TGeoGtra::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoGtra::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoGtra::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetTwistAngle(). Double_t TGeoGtra::GetTwistAngle ; (; ); const. inline . Definition at line 171 of file TGeoArb8.h. ◆ IsA(). TClass * TGeoGtra::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 177 of file TGeoArb8.h. ◆ Safety(). Double_t TGeoGtra::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Safety_v(). void TGeoGtra::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ SavePrimitive(). void TGeoGtra::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoArb8. ◆ SetDimensions(). void TGeoGtra::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoArb8. ◆ Streamer(). void TGeoGtra::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoArb8. ◆ StreamerNVirtual(). void TGeoGtra::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 177 of file TGeoArb8.h. Member Data Documentation. ◆ fTwistAngle. Double_t TGeoGt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:29968,Safe,Safety,29968,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['Safe'],['Safety']
Safety,"ide(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside); compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.; Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside); returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a different array. Dividing shapes; Shapes can generally be divided along a given axis. Supported axis are X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:5780,safe,safe,5780,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"ide(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 18.3.5 Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923271,safe,safe,923271,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"idevirtual . Reimplemented from TGeoBBox.; Definition at line 55 of file TGeoHalfSpace.h. ◆ GetNorm(). virtual Double_t * TGeoHalfSpace::GetNorm ; (; ). inlinevirtual . Definition at line 51 of file TGeoHalfSpace.h. ◆ GetPoint(). virtual Double_t * TGeoHalfSpace::GetPoint ; (; ). inlinevirtual . Definition at line 50 of file TGeoHalfSpace.h. ◆ InspectShape(). void TGeoHalfSpace::InspectShape ; (; ); const. overridevirtual . print shape parameters ; Reimplemented from TGeoBBox.; Definition at line 191 of file TGeoHalfSpace.cxx. ◆ IsA(). TClass * TGeoHalfSpace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoHalfSpace.h. ◆ IsCylType(). Bool_t TGeoHalfSpace::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoHalfSpace.h. ◆ operator=(). TGeoHalfSpace & TGeoHalfSpace::operator= ; (; const TGeoHalfSpace & ; ). privatedelete . ◆ Safety(). Double_t TGeoHalfSpace::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 202 of file TGeoHalfSpace.cxx. ◆ Safety_v(). void TGeoHalfSpace::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 291 of file TGeoHalfSpace.cxx. ◆ SavePrimitive(). void TGeoHalfSpace::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:30751,Safe,Safety,30751,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['Safe'],['Safety']
Safety,"idevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. ◆ IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone & ; ). protecteddelete . ◆ Safety(). Double_t TGeoCone::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ Safety_v(). void TGeoCone::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ SetDimensions(). void TGeoCone::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetPoints() [1/2]. void TGeoCone::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetPoints() [2/2]. void TGeoCone::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31830,Safe,SafetyS,31830,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['Safe'],['SafetyS']
Safety,"idevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 91 of file TGeoTube.h. ◆ IsCylType(). Bool_t TGeoTube::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 77 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTube::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ operator=(). TGeoTube & TGeoTube::operator= ; (; const TGeoTube & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTube::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Safety_v(). void TGeoTube::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SafetyS(). static Double_t TGeoTube::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTube::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetDimensions(). void TGeoTube::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [1/2]. void TGeoTube::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [2/2]. void TGeoTube::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetSegsAndPols(). void TGeoTube::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:30902,Safe,SafetyS,30902,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['Safe'],['SafetyS']
Safety,"idth; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. private:. static intfgCoinFlagno coin viewer;; static intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. Int_t InitWindow(ULong_t window); -; *-* if window == 0 InitWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:22767,safe,safely,22767,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,3,['safe'],['safely']
Safety,"id DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; ROOT::R::TRFunctionImport asfactor;  ; ROOT::R::TRFunctionImport asmatrix;  ; Double_t fEta;  ; std::vector< UInt_t > fFactorNumeric;  ; UInt_t fMaxDepth;  ; ROOT::R::TRObject * fModel;  ; UInt_t fNRounds;  ; ROOT::R::TRFunctionImport predict;  ; ROOT::R::TRFunctionImport xgbdmatrix;  ; ROOT::R::TRFunctionImport xgbload;  ; ROOT::R::TRFunctionImport xgbsave;  ; ROOT::R::TRFunctionImport xgbtrain;  ;  Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrame fDfSpectators;  ; ROOT::R::TRDataFrame fDfTest;  ; ROOT::R::TRDataFrame fDfTrain;  ; std::vector< std::string > fFactorTest;  ; std::vector< std::string > fFactorTrain;  ; TVectorD fWeightTest;  ; TVectorD fWeightTrain;  ; ROOT::R::TRInterface & r;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Bool_t IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""xgboost"");  . Private Attributes; DataSetMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html:24391,predict,predict,24391,doc/master/classTMVA_1_1MethodRXGB.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRXGB.html,1,['predict'],['predict']
Safety,"id Init (TTree *tree) override;  ; TClass * IsA () const override;  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; Bool_t Process (Long64_t entry) override;  The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; void Reset ();  ; void SetInputList (TList *input) override;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; void SlaveBegin (TTree *tree) override;  ; void SlaveTerminate () override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysis.html:1469,Abort,Abort,1469,doc/master/classh1analysis.html,https://root.cern,https://root.cern/doc/master/classh1analysis.html,2,['Abort'],['Abort']
Safety,"ied, ""A"" is ignored. ""F"" show all details available about queries ""H"" print help menu Default """" ; Definition at line 2165 of file TProof.cxx. ◆ ShowStagingStatusDataSet(). void TProof::ShowStagingStatusDataSet ; (; const char * ; dataset, . const char * ; optStr = ""filter:SsCc"" . ). virtual . Like GetStagingStatusDataSet, but displays results immediately. ; Definition at line 11116 of file TProof.cxx. ◆ SlaveStartupThread(). static void * TProof::SlaveStartupThread ; (; void * ; arg). staticprotected . ◆ StartSlaves(). Bool_t TProof::StartSlaves ; (; Bool_t ; attach = kFALSE). protectedvirtual . Start up PROOF slaves. ; Reimplemented in TProofCondor, and TProofSuperMaster.; Definition at line 1660 of file TProof.cxx. ◆ StartupMessage(). void TProof::StartupMessage ; (; const char * ; msg, . Bool_t ; status, . Int_t ; done, . Int_t ; total . ). Send startup message. ; Definition at line 9312 of file TProof.cxx. ◆ StopProcess(). void TProof::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). Send STOPPROCESS message to master and workers. ; Definition at line 6224 of file TProof.cxx. ◆ Streamer(). void TProof::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed.; Reimplemented in TProofCondor, TProofLite, and TProofSuperMaster. ◆ StreamerNVirtual(). void TProof::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 1073 of file TProof.h. ◆ SystemCmd(). void TProof::SystemCmd ; (; const char * ; cmd, . Int_t ; fdout . ). staticprotected . Exec system command 'cmd'. If fdout > -1, append the output to fdout. ; Definition at line 7735 of file TProof.cxx. ◆ TerminateWorker() [1/2]. void TProof::TerminateWorker ; (; const char * ; ord). private . Ask an active worker 'ord' to terminate, i.e. to shutdown. ; Definition at line 4720 of file TProof.cxx. ◆ TerminateWorker() [2/2]. void TProof::TerminateWorker ; (; TSlave * ; wrk). private . Ask an active worker 'wrk' to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:152754,timeout,timeout,152754,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset = 0, const char* rangeName = 0) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:47042,unsafe,unsafe,47042,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,3,['unsafe'],['unsafe']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:50430,unsafe,unsafe,50430,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,3,['unsafe'],['unsafe']
Safety,"ient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const char* rangeName); Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:46566,unsafe,unsafe,46566,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['unsafe'],['unsafe']
Safety,"ient vector ; Definition at line 1375 of file RuleFitParams.cxx. ◆ MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16637,Risk,Risk,16637,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['Risk']
Safety,"iew name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:7068,safe,safe,7068,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,1,['safe'],['safe']
Safety,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:175055,timeout,timeout,175055,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:175087,timeout,timeout,175087,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorderSurfaces) {; 596 fBorderSurfaces->Delete();; 597 SafeDelete(fBorderSurfaces);; 598 }; 599 ClearNavigators();; 600 CleanGarbage();; 601 SafeDelete(fPainter);; 602 SafeDelete(fGLMatrix);; 603 if (fSizePNEId) {; 604 delete[] fKeyPNEId;; 605 delete[] fValuePNEId;; 606 }; 607 delete fParallelWorld;; 608 fIsGeomCleaning = kFALSE;; 609 gGeoIdentity = nullptr;; 610 gGeoManager = nullptr;; 611}; 612 ; 613//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22485,Safe,SafeDelete,22485,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"if (mom); 545 result = mom->GetDirectory(slash+1,printError,funcname);; 546 delete [] path; return result;; 547 }; 548 GetObject(subdir,obj);; 549 if (!obj) {; 550 if (printError) Error(funcname,""Unknown directory %s"", subdir.Data());; 551 delete [] path; return nullptr;; 552 }; 553 ; 554 result = ((TDirectory*)obj)->GetDirectory(slash+1,printError,funcname);; 555 delete [] path; return result;; 556}; 557 ; 558////////////////////////////////////////////////////////////////////////////////; 559/// Delete all objects from memory and directory structure itself.; 560 ; 561void TDirectoryFile::Close(Option_t *option); 562{; 563 if (!fList || !fSeekDir) {; 564 return;; 565 }; 566 ; 567 // Save the directory key list and header; 568 Save();; 569 ; 570 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 571 ; 572 if (!nodelete) {; 573 Bool_t fast = kTRUE;; 574 TObjLink *lnk = fList->FirstLink();; 575 while (lnk) {; 576 if (lnk->GetObject()->IsA() == TDirectoryFile::Class()) {fast = kFALSE;break;}; 577 lnk = lnk->Next();; 578 }; 579 // Delete objects from directory list, this in turn, recursively closes all; 580 // sub-directories (that were allocated on the heap); 581 // if this dir contains subdirs, we must use the slow option for Delete!; 582 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 583 // with a large number of objects (eg >10^5) would take for ever.; 584 {; 585 if (fast) fList->Delete();; 586 else fList->Delete(""slow"");; 587 }; 588 }; 589 ; 590 // Delete keys from key list (but don't delete the list header); 591 if (fKeys) {; 592 fKeys->Delete(""slow"");; 593 }; 594 ; 595 TDirectoryFile::CleanTargets();; 596}; 597 ; 598////////////////////////////////////////////////////////////////////////////////; 599/// Delete Objects or/and keys in a directory; 600///; 601/// Properties of the namecycle string:; 602/// - namecycle has the format name;cycle; 603/// - namecycle = """" is same as namecycle =""T*""; 604/// - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:19065,avoid,avoid,19065,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:34084,avoid,avoid,34084,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"if the vertices are defined; clockwise or anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoArb8.html:14372,safe,safe,14372,root/html528/TGeoArb8.html,https://root.cern,https://root.cern/root/html528/TGeoArb8.html,3,['safe'],['safe']
Safety,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:7437,avoid,avoid,7437,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['avoid'],['avoid']
Safety,"ific readv config params. ;  ; virtual Bool_t IsUseable () const;  Check the file is open and isn't a zombie. ;  ; TNetXNGFile & operator= (const TNetXNGFile &other);  ; virtual void SetEnv ();  Map ROOT and xrootd environment variables. ;  . Private Attributes; XrdCl::File * fFile;  ; XrdSysCondVar * fInitCondVar;  ; int fMode;  ; TString fNewUrl;  ; Int_t fQueryReadVParams;  ; Int_t fReadvIorMax;  ; Int_t fReadvIovMax;  ; XrdCl::URL * fUrl;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:30287,timeout,timeout,30287,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['timeout'],['timeout']
Safety,"ified by index, if non-NULL. w, h – Filled with the width and height of the bounding box for the character specified by index, if non-NULL. ; Definition at line 1109 of file TGFont.cxx. ◆ Class(). static TClass * TGTextLayout::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGTextLayout::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGTextLayout::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 134 of file TGFont.h. ◆ DeclFileName(). static const char * TGTextLayout::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 134 of file TGFont.h. ◆ DistanceToText(). Int_t TGTextLayout::DistanceToText ; (; Int_t ; x, . Int_t ; y . ); const. Computes the distance in pixels from the given point to the given text layout. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for hit detection purposes.; The return value is 0 if the point (x, y) is inside the text layout. If the point isn't inside the text layout then the return value is the distance in pixels from the point to the text item.; x, y – Coordinates of point to check, with respect to the upper-left corner of the text layout (in pixels). ; Definition at line 1191 of file TGFont.cxx. ◆ DrawText(). void TGTextLayout::DrawText ; (; Drawable_t ; dst, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . Int_t ; firstChar, . Int_t ; lastChar . ); const. Use the information in the TGTextLayout object to display a multi-line, justified string of text. ; This procedure is useful for simple widgets that need to display single-font, multi-line text and want TGFont to handle the details.; dst – Window or pixmap in which to draw. gc – Graphics context to use for drawing text. x, y – Upper-left hand corner of rectangle in which to draw (pixels). firstChar – The index of the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextLayout.html:14684,detect,detection,14684,doc/master/classTGTextLayout.html,https://root.cern,https://root.cern/doc/master/classTGTextLayout.html,1,['detect'],['detection']
Safety,"ig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCompositeShape.html:7916,safe,safe,7916,root/html532/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html,1,['safe'],['safe']
Safety,"ight use more memory.; 283/// (For the currently supported algorithms, the maximum level is 9); 284/// If compress is negative it indicates the compression level is not set yet.; 285/// The enumeration ROOT::RCompressionSetting::EAlgorithm associates each; 286/// algorithm with a number. There is a utility function to help; 287/// to set the value of compress. For example,; 288/// ROOT::CompressionSettings(ROOT::kLZMA, 1); 289/// will build an integer which will set the compression to use; 290/// the LZMA algorithm and compression level 1. These are defined; 291/// in the header file <em>Compression.h</em>.; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:12468,detect,detect,12468,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['detect'],['detect']
Safety,"ight, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoUnion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoUnion.html:2339,safe,safe,2339,root/html528/TGeoUnion.html,https://root.cern,https://root.cern/root/html528/TGeoUnion.html,2,['safe'],['safe']
Safety,"ignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TSysEvtHandler.h>. Inheritance diagram for TStdExceptionHandler:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatus. enum TStdExceptionHandler::EStatus. EnumeratorkSEProceed ; kSEHandled ; kSEAbort . Definition at line 175 of file TSysEvtHandler.h. Constructor & Destructor Documentation. ◆ TStdExceptionHandler(). TStdExceptionHandler::TStdExceptionHandler ; (; ). Handle standard C++ exceptions intercepted by the TSystem::Run(). ; Virtual method EStatus Handle(std::exception& exc) is called on the collection of handlers registered to TSystem. The return value of each handler influences the continuation of handling procedure:; kSEProceed - Proceed with passing of the exception to other handlers, the exception has not been handled.; kSEHandled - The exception has been handled, do not pass it to other handlers.; kSEAbort - Abort application. If all handlers return kSEProceed TSystem::Run() rethrows the exception, possibly resulting in process abortion. . Definition at line 202 of file TSysEvtHandler.cxx. ◆ ~TStdExceptionHandler(). virtual TStdExceptionHandler::~TStdExceptionHandler ; (; ). inlinevirtual . Definition at line 178 of file TSysEvtHandler.h. Member Function Documentation. ◆ Add(). void TStdExceptionHandler::Add ; (; ). overridevirtual . Add std::exception handler to system handler list. ; Implements TSysEvtHandler.; Definition at line 209 of file TSysEvtHandler.cxx. ◆ Class(). static TClass * TStdExceptionHandler::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TStdExceptionHandler::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TStdExceptionHandler::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 186 of file TSysEvtHandler.h. ◆ DeclFileName(). s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStdExceptionHandler.html:16316,Abort,Abort,16316,doc/master/classTStdExceptionHandler.html,https://root.cern,https://root.cern/doc/master/classTStdExceptionHandler.html,1,['Abort'],['Abort']
Safety,"ignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStylePreview. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad). » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStylePreview.html:23386,avoid,avoid,23386,root/html602/TStylePreview.html,https://root.cern,https://root.cern/root/html602/TStylePreview.html,2,['avoid'],['avoid']
Safety,"ihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:3943,avoid,avoided,3943,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['avoid'],['avoided']
Safety,"ij, . const Int_t * ; binMap = nullptr . ); const. get correlation coefficiencts, possibly cumulated over several bins ; Parameters. [out]rhoijhistogram to store the correlation coefficiencts. The bin contents are overwritten. ; [in]binMap(default=nullptr) array for mapping truth bins to histogram bins. The use of binMap is explained with the documentation of the GetOutput() method ; Definition at line 3461 of file TUnfold.cxx. ◆ GetRhoMax(). Double_t TUnfold::GetRhoMax ; (; void ; ); const. inline . get maximum global correlation determined in recent unfolding ; Definition at line 325 of file TUnfold.h. ◆ GetRowFromBin(). Int_t TUnfold::GetRowFromBin ; (; int ; ix); const. inlineprotected . converts truth histogram bin number to matrix row ; Definition at line 234 of file TUnfold.h. ◆ GetSqrtEvEmatrix(). TVectorD TUnfold::GetSqrtEvEmatrix ; (; void ; ); const. Definition at line 2509 of file TUnfold.cxx. ◆ GetSURE(). double TUnfold::GetSURE ; (; void ; ); const. return Stein's unbiased risk estimator See e.g. ; arXiv:1612.09415; A minimum in the SURE variable is a good choice of regularisation strength; NOTE: the calculation of SURE depends on the calculation of DF. See the method GetDF() for caveats with Poisson-distributed data. ; Definition at line 3732 of file TUnfold.cxx. ◆ GetTau(). Double_t TUnfold::GetTau ; (; void ; ); const. return regularisation parameter ; Definition at line 3223 of file TUnfold.cxx. ◆ GetTUnfoldVersion(). const char * TUnfold::GetTUnfoldVersion ; (; void ; ). static . return a string describing the TUnfold version ; The version is reported in the form Vmajor.minor Changes of the minor version number typically correspond to bug-fixes. Changes of the major version may result in adding or removing data attributes, such that the streamer methods are not compatible between different major versions. ; Definition at line 3717 of file TUnfold.cxx. ◆ GetVxx(). const TMatrixDSparse * TUnfold::GetVxx ; (; void ; ); const. inlineprotected . covari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:45011,risk,risk,45011,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['risk'],['risk']
Safety,"il(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:182605,timeout,timeout,182605,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"il(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:182637,timeout,timeout,182637,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ile TFractionFitter.h. ◆ fIntegralData. Double_t TFractionFitter::fIntegralData. protected . ""data"" histogram content integral over allowed fit range ; Definition at line 103 of file TFractionFitter.h. ◆ fIntegralMCs. Double_t* TFractionFitter::fIntegralMCs. protected . Same for template histograms (weights not taken into account) ; Definition at line 104 of file TFractionFitter.h. ◆ fLowLimitX. Int_t TFractionFitter::fLowLimitX. protected . First bin in X dimension. ; Definition at line 84 of file TFractionFitter.h. ◆ fLowLimitY. Int_t TFractionFitter::fLowLimitY. protected . First bin in Y dimension. ; Definition at line 86 of file TFractionFitter.h. ◆ fLowLimitZ. Int_t TFractionFitter::fLowLimitZ. protected . First bin in Z dimension. ; Definition at line 88 of file TFractionFitter.h. ◆ fMCs. TObjArray TFractionFitter::fMCs. protected . Array of pointers to template histograms. ; Definition at line 101 of file TFractionFitter.h. ◆ fNDF. Int_t TFractionFitter::fNDF. protected . Number of degrees of freedom in the fit. ; Definition at line 93 of file TFractionFitter.h. ◆ fNpar. Int_t TFractionFitter::fNpar. protected . number of fit parameters ; Definition at line 110 of file TFractionFitter.h. ◆ fNpfits. Int_t TFractionFitter::fNpfits. protected . Number of points used in the fit. ; Definition at line 92 of file TFractionFitter.h. ◆ fPlot. TH1* TFractionFitter::fPlot. protected . Pointer to histogram containing summed template predictions. ; Definition at line 106 of file TFractionFitter.h. ◆ fWeights. TObjArray TFractionFitter::fWeights. protected . Array of pointers to corresponding weight factors (may be null) ; Definition at line 102 of file TFractionFitter.h. Libraries for TFractionFitter:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/TFractionFitter.h; hist/hist/src/TFractionFitter.cxx. TFractionFitter. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:53 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:36494,predict,predictions,36494,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['predictions']
Safety,"ile TGeoArb8.h. ◆ IsCylType(). Bool_t TGeoArb8::IsCylType ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Definition at line 73 of file TGeoArb8.h. ◆ IsSamePoint(). static Bool_t TGeoArb8::IsSamePoint ; (; const Double_t * ; p1, . const Double_t * ; p2 . ). inlinestatic . Definition at line 74 of file TGeoArb8.h. ◆ IsTwisted(). Bool_t TGeoArb8::IsTwisted ; (; ); const. inline . Definition at line 80 of file TGeoArb8.h. ◆ operator=(). TGeoArb8 & TGeoArb8::operator= ; (; const TGeoArb8 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoArb8::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ Safety_v(). void TGeoArb8::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SafetyToFace(). Double_t TGeoArb8::SafetyToFace ; (; const Double_t * ; point, . Int_t ; iseg, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoArb8::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDimensions(). void TGeoArb8::SetDimensions ; (; Double_t * ; param). overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDz(). void TGeoArb8::SetDz ; (; Double_t ; dz). inline . Definition at line 88 of file TGeoArb8.h. ◆ SetPlaneVertices(). void TGeoArb8::SetPlaneVertices ; (; Double_t ; zpl, . Double_t * ; vertices . ); const. ◆ SetPoints() [1/2]. void TGeoArb8::SetPoints ; (; Double_t * ; points); const. overridevirtual . Implements TGeoShape. ◆ SetPoints() [2/2]. void TGeoArb8::SetPoints ; (; Float_t * ; points); const. overridevirtual . Implements TGeoShape. ◆ SetVertex(). virtual void TGeoArb8::SetVertex ; (; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:31993,Safe,SafetyToFace,31993,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['Safe'],['SafetyToFace']
Safety,"ile and libraries); [#6509] - [ROOT I/O] Warning: writing 1 byte into a region of size 0; [#6597] - pytest shipped in roottest is not compatible with py3.9; [#6677] - [bug] Clang builds ROOT libraries that emit FPEs; [#6784] - external nlohmann/json.hpp is not forwarded as dependency or should be linked PRIVATE?; [#6523] - TBufferMerger cannot handle TTree spanning over multiple files; [#6743] - ROOT crashes with no helpful error messages if a TApplication is not present and tree->StartViewer() is called; [#6840] - TClass for pair sometimes have the wrong offset/size; [#6839] - Compilation fails on macosx 11.0 with arm processor; [#6838] - build/unix/compiledata.sh assumes macOS will always have major version 10; [#6817] - macOS packaging broken in master; [#6856] - error when creating a python class inheriting from a ROOT class, 6.22/02; [#6797] - TCling::UpdateListOfLoadedSharedLibraries() Linux thread safety; [#6483] - [GUI] Crashes when creating TGClient in a standalone application; [#6563] - Test failures on MacOS with Xcode 12; [#6624] - TRandom: signature mismatch between getter and setter; [#6815] - PowerShell version of thisroot.bat; [#6853] - [DF] SaveGraph can be confused by shared upstream Defines; [#6731] - Compilation error on CentOS 7 of root V6.22.02 c++17; [#6974] - pyROOT doesn’t work with ipyparallel; [#6964] - [TTree] GetLeaf ignores the branchname arg if friend trees are present; [#6944] - RDataFrame misidentifies vector<XYZTVector> type of a friend tree with identical branch name to another friend tree; [#6345] - 6.22.00 pyroot regression: Can’t derive from TProfile.; [#6903] - Builtin TBB is broken on MacOS M1; [#7016] - Memory leak during schema evolution of some classes; [#6993] - [TTreeReader] Segfault when reading branch of “automatically loaded” friend; [#6741] - [DF] When dataset is specified as treename/filename, the TTree is read without its friends; [#6470] - PyROOT: virtual C++ method overriden in python ignored with further inherita",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:42083,safe,safety,42083,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['safe'],['safety']
Safety,"ile.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In particular, if 'output' is nullptr or empty, reset the internal list. On return, the content of 'output' is cleared to avoid double deletion issues. (The caller is responsible of 'output' as container: its content is transferred under the selector ownership). ; Definition at line 270 of file TSelector.cxx. ◆ Init(). virtual void TSelector::Init ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelVerifyDataSet, TSelHandleDataSet, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, h1analysisTreeReader, TSelEvent, TSelEventGen, TProofDrawGraph, TProofDrawPolyMarker3D, RooProofDriverSelector, TSelectorEntries, and h1analysis.; Definition at line 53 of file TSelector.h. ◆ IsA(). TClass * TSelector::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSelVerifyDataSet, TSelEvent, TSelEventGen, TSelHandleDataSet, TSelHist, TSelectorDraw, and TSelectorEntries.; Definition at line 79 of file TSelector.h. ◆ IsStandardDraw(). bool TSelector::IsStandardDraw ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:19067,avoid,avoid,19067,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['avoid'],['avoid']
Safety,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:25503,avoid,avoid,25503,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['avoid'],['avoid']
Safety,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:25843,avoid,avoid,25843,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['avoid'],['avoid']
Safety,"iled; 2973 /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; 2974 ///; 2975 /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; 2976 ///; 2977 /// ### Examples; 2978 /// See [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html) for an example implementation of an action helper.; 2979 ///; 2980 /// It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx.; 2981 ///; 2982 // clang-format on; 2983 template <typename FirstColumn = RDFDetail::RInferredType, typename... OtherColumns, typename Helper>; 2984 RResultPtr<typename std::decay_t<Helper>::Result_t> Book(Helper &&helper, const ColumnNames_t &columns = {}); 2985 {; 2986 using HelperT = std::decay_t<Helper>;; 2987 // TODO add more static sanity checks on Helper; 2988 using AH = RDFDetail::RActionImpl<HelperT>;; 2989 static_assert(std::is_base_of<AH, HelperT>::value && std::is_convertible<HelperT *, AH *>::value,; 2990 ""Action helper of type T must publicly inherit from ROOT::Detail::RDF::RActionImpl<T>"");; 2991 ; 2992 auto hPtr = std::make_shared<HelperT>(std::forward<Helper>(helper));; 2993 auto resPtr = hPtr->GetResultPtr();; 2994 ; 2995 if (std::is_same<FirstColumn, RDFDetail::RInferredType>::value && columns.empty()) {; 2996 return CallCreateActionWithoutColsIfPossible<HelperT>(resPtr, hPtr, TTraits::TypeList<FirstColumn>{});; 2997 } else {; 2998 return CreateAction<RDFInternal::ActionTags::Book, FirstColumn, OtherColumns...>(columns, resPtr, hPtr,; 2999 fProxiedPtr, columns.size());; 3000 }; 3001 }; 3002 ; 3003 ////////////////////////////////////////////////////////////////////////////; 3004 /// \brief Provides a representation of the columns in the dataset.; 3005 /// \tparam ColumnTypes variadic list of branch/column types.; 3006 /// \param[in] columnList Names of the columns to be displayed.; 3007 /// \param[in] nRows Number of events f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:169762,sanity check,sanity checks,169762,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['sanity check'],['sanity checks']
Safety,"ilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:12695,safe,safely,12695,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,4,['safe'],['safely']
Safety,"ill provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMarker(TGCompositeFrame* f); Add the 'Marker' group frame to the 'General' tab. void CreateTabCanvas(TGCompositeFrame* tab); Add the tab 'Canvas' to the editor. void AddCanvasFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'Canvas' tab. void AddCanvasGeome",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:50929,avoid,avoid,50929,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['avoid'],['avoid']
Safety,"illed from the buffer. When the histogram is filled from the; 1406/// buffer the value fBuffer[0] is set to a negative number (= - number of entries); 1407/// When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0; 1408/// While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if; 1409/// the histogram was filled before. This is needed when drawing the histogram; 1410/// - action = 1 histogram is filled and buffer is deleted; 1411/// The buffer is automatically deleted when filling the histogram and the entries is; 1412/// larger than the buffer size; 1413 ; 1414Int_t TH1::BufferEmpty(Int_t action); 1415{; 1416 // do we need to compute the bin size?; 1417 if (!fBuffer) return 0;; 1418 Int_t nbentries = (Int_t)fBuffer[0];; 1419 ; 1420 // nbentries correspond to the number of entries of histogram; 1421 ; 1422 if (nbentries == 0) {; 1423 // if action is 1 we delete the buffer; 1424 // this will avoid infinite recursion; 1425 if (action > 0) {; 1426 delete [] fBuffer;; 1427 fBuffer = nullptr;; 1428 fBufferSize = 0;; 1429 }; 1430 return 0;; 1431 }; 1432 if (nbentries < 0 && action == 0) return 0; // case histogram has been already filled from the buffer; 1433 ; 1434 Double_t *buffer = fBuffer;; 1435 if (nbentries < 0) {; 1436 nbentries = -nbentries;; 1437 // a reset might call BufferEmpty() giving an infinite recursion; 1438 // Protect it by setting fBuffer = nullptr; 1439 fBuffer = nullptr;; 1440 //do not reset the list of functions; 1441 Reset(""ICES"");; 1442 fBuffer = buffer;; 1443 }; 1444 if (CanExtendAllAxes() || (fXaxis.GetXmax() <= fXaxis.GetXmin())) {; 1445 //find min, max of entries in buffer; 1446 Double_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:55964,avoid,avoid,55964,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11475,avoid,avoid,11475,root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,6,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:11475,avoid,avoid,11475,root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,9,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11258,avoid,avoid,11258,root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,5,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:11151,avoid,avoid,11151,root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,10,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11475,avoid,avoid,11475,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,8,['avoid'],['avoid']
Safety,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:11475,avoid,avoid,11475,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,7,['avoid'],['avoid']
Safety,"ilure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:243518,avoid,avoid,243518,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"imental::EIOUnsupportedFeatures ; input_bits). Clear a specific IO feature from this set. ; Parameters. [in]input_bitsThe specific feature to disable. Removes a feature from the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT. ; Definition at line 69 of file TIOFeatures.cxx. ◆ GetFeatures(). UChar_t TIOFeatures::GetFeatures ; (; ); const. private . Definition at line 250 of file TIOFeatures.cxx. ◆ Print(). void TIOFeatures::Print ; (; ); const. Print a human-readable representation of the TIOFeatures to stdout. ; Prints a string with the names of all enabled IO features. ; Definition at line 197 of file TIOFeatures.cxx. ◆ Set() [1/4]. bool TIOFeatures::Set ; (; const std::string & ; value). Given a IO feature string, set the corresponding feature. ; Parameters. [in]valueFeature name to test. This allows one to set a feature given a specific string from the TBasket::EIOBits enum.; NOTE this function is quite slow and users are strongly encouraged to use the type-safe Set version instead. This has been added for better CLI interfaces.; Returns true only if a new feature was set; otherwise emits an error message and returns false. ; Definition at line 172 of file TIOFeatures.cxx. ◆ Set() [2/4]. bool TIOFeatures::Set ; (; EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 139 of file TIOFeatures.cxx. ◆ Set() [3/4]. bool TIOFeatures::Set ; (; Experimental::EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html:4980,safe,safe,4980,doc/v632/classROOT_1_1TIOFeatures.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html,2,['safe'],['safe']
Safety,"imental::NTupleSize_t ROOT::Experimental::Internal::RPageSource::GetNElements ; (; ColumnHandle_t ; columnHandle). Definition at line 219 of file RPageStorage.cxx. ◆ GetNEntries(). ROOT::Experimental::NTupleSize_t ROOT::Experimental::Internal::RPageSource::GetNEntries ; (; ). Definition at line 214 of file RPageStorage.cxx. ◆ GetReadOptions(). const RNTupleReadOptions & ROOT::Experimental::Internal::RPageSource::GetReadOptions ; (; ); const. inline . Definition at line 714 of file RPageStorage.hxx. ◆ GetSharedDescriptorGuard(). const RSharedDescriptorGuard ROOT::Experimental::Internal::RPageSource::GetSharedDescriptorGuard ; (; ); const. inline . Takes the read lock for the descriptor. ; Multiple threads can take the lock concurrently. The underlying std::shared_mutex, however, is neither read nor write recursive: within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special care in sections protected by GetSharedDescriptorGuard() and GetExclDescriptorGuard() especially to avoid that the locks are acquired indirectly (e.g. by a call to GetNEntries()). As a general guideline, no other method of the page source should be called (directly or indirectly) in a guarded section. ; Definition at line 722 of file RPageStorage.hxx. ◆ GetType(). EPageStorageType ROOT::Experimental::Internal::RPageSource::GetType ; (; ). inlinefinalvirtual . Whether the concrete implementation is a sink or a source. ; Implements ROOT::Experimental::Internal::RPageStorage.; Definition at line 713 of file RPageStorage.hxx. ◆ LoadClusters(). virtual std::vector< std::unique_ptr< RCluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:13372,avoid,avoid,13372,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['avoid'],['avoid']
Safety,"imit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441337,abort,aborted,441337,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['abort'],['aborted']
Safety,"implemented from TSelector.; Definition at line 56 of file TSelHist.h. ◆ IsA(). TClass * TSelHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelHist.h. ◆ Process(). Bool_t TSelHist::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 267 of file TSelHist.cxx. ◆ SetInputList(). void TSelHist::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 55 of file TSelHist.h. ◆ SetObject(). void TSelHist::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelHist.h. ◆ SetOption(). void TSelHist::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelHist.h. ◆ SlaveBegin(). void TSelHist::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is deprecated (on PROOF 0 is passed). ; Reimplemented from TSelector.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:15433,Abort,Abort,15433,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,1,['Abort'],['Abort']
Safety,"implified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  fit1.C Simple fitting example (1-d histogram with an interpreted function) ;  fit2.C Fitting a 2-D histogram This tutorial illustrates : ;  fit2a.C Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  fit2d.C Example illustrating how to fit a 2-d histogram of type y=f(x) ;  fit2dHist.C ;  fitCircle.C Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  fitcont.C Example illustrating how to draw the n-sigma contour of a Minuit fit ;  fitConvolution.C Tutorial for convolution of two functions ;  fitEllipseTGraphDLSF.cxx;  fitEllipseTGraphRMM.cxx;  fitExclude.C Illustrates how to fit excluding points in a given range ;  fithist.C Example of fit where the model is histogram + function ;  fitLinear.C Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:104354,predict,predictor,104354,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['predict'],['predictor']
Safety,"in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:6351,detect,detector,6351,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['detect'],['detector']
Safety,"in edge. . kBinCenter Get the bin center. . kBinTo Get the bin high edge. . Definition at line 252 of file RHistImpl.hxx. ◆ EColumnCppType. enum class ROOT::Experimental::Internal::EColumnCppType. strong . EnumeratorkChar ; kBool ; kByte ; kUint8 ; kUint16 ; kUint32 ; kUint64 ; kInt8 ; kInt16 ; kInt32 ; kInt64 ; kFloat ; kDouble ; kClusterSize ; kColumnSwitch ; kMax . Definition at line 119 of file RColumnElementBase.hxx. ◆ EDaosLocatorFlags. enum ROOT::Experimental::Internal::EDaosLocatorFlags. EnumeratorkCagedPage . Definition at line 43 of file RPageStorageDaos.hxx. ◆ EFindStatus. enum class ROOT::Experimental::Internal::EFindStatus. strong . Status of FindBin(x) and FindAdjustedBin(x) . EnumeratorkCanGrow The coordinate could fit after growing the axis. . kValid The returned bin index is valid. . Definition at line 259 of file RHistImpl.hxx. ◆ ENTupleMergeErrBehavior. enum class ROOT::Experimental::Internal::ENTupleMergeErrBehavior. strong . EnumeratorkAbort The merger will abort merging as soon as an error is encountered. . kSkip Upon errors, the merger will skip the current source and continue. . Definition at line 45 of file RNTupleMerger.hxx. ◆ ENTupleMergingMode. enum class ROOT::Experimental::Internal::ENTupleMergingMode. strong . EnumeratorkFilter The merger will discard all columns that aren't present in the prototype model (i.e. ; the model of the first source) . kStrict The merger will refuse to merge any 2 RNTuples whose schema doesn't match exactly. . kUnion The merger will update the output model to include all columns from all sources. ; Entries corresponding to columns that are not present in a source will be set to the default value of the type. . Definition at line 34 of file RNTupleMerger.hxx. ◆ EPageStorageType. enum class ROOT::Experimental::Internal::EPageStorageType. strong . EnumeratorkSink ; kSource . Definition at line 56 of file RPageStorage.hxx. Function Documentation. ◆ CallCommitClusterOnField(). void ROOT::Experimental::Internal::Cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:16524,abort,abort,16524,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['abort'],['abort']
Safety,"in loss: 0.679; [3, 12] train loss: 0.679; [3] val loss: 0.692; [4, 4] train loss: 0.663; [4, 8] train loss: 0.668; [4, 12] train loss: 0.650; [4] val loss: 0.708; [5, 4] train loss: 0.642; [5, 8] train loss: 0.635; [5, 12] train loss: 0.633; [5] val loss: 0.707; [6, 4] train loss: 0.607; [6, 8] train loss: 0.588; [6, 12] train loss: 0.585; [6] val loss: 0.700; [7, 4] train loss: 0.553; [7, 8] train loss: 0.564; [7, 12] train loss: 0.542; [7] val loss: 0.637; [8, 4] train loss: 0.474; [8, 8] train loss: 0.446; [8, 12] train loss: 0.436; [8] val loss: 0.758; [9, 4] train loss: 0.381; [9, 8] train loss: 0.435; [9, 12] train loss: 0.456; [9] val loss: 1.218; [10, 4] train loss: 0.438; [10, 8] train loss: 0.436; [10, 12] train loss: 0.444; [10] val loss: 0.632; Finished Training on 10 Epochs!; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchTrainedModelCNN.pt; PyTorch : [dataset] : Evaluation of PyTorch on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.12 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: BDT; : ; BDT : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN_CPU; : ; TMVA_DNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 256 , it is larger than 200; Factory : Evaluate classifier: TMVA_CNN_CPU; : ; TMVA_CNN_CPU : [dataset] : Loop over test events and fill histograms with classifier response...; : ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:41276,predict,predict,41276,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predict']
Safety,"in of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17689 server_domain_len = strlen(server_domain);; 17690 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17691 return 0;; 17692 }; 17693 if ((request_domain_len == server_domain_len); 17694 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17695 /* Request is directed to this server - full name match. */; 17696 } else {; 17697 if (request_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699 * is longer than the request name.; 17700 * Drop this case here to avoid overflows in the; 17701 * following checks. */; 17702 return 0;; 17703 }; 17704 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:526244,avoid,avoid,526244,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"in of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17690 server_domain_len = strlen(server_domain);; 17691 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17692 return 0;; 17693 }; 17694 if ((request_domain_len == server_domain_len); 17695 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17696 /* Request is directed to this server - full name match. */; 17697 } else {; 17698 if (request_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700 * is longer than the request name.; 17701 * Drop this case here to avoid overflows in the; 17702 * following checks. */; 17703 return 0;; 17704 }; 17705 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:526277,avoid,avoid,526277,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf305_condcorrprodDefinition rf305_condcorrprod.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf305_condcorrprod.C. tutorialsroofitrf305_condcorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8C.html:5327,safe,safe,5327,doc/master/rf305__condcorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html,1,['safe'],['safe']
Safety,"in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in traning sample and ""annihilate"" them; PairNegWeightsInNode Randomly pair miscl. ev. with neg. and pos. weights in node and don't boost them; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:27589,avoid,avoided,27589,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,2,['avoid'],['avoided']
Safety,"in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterium; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); IgnoreNegWeightsInTraining Ignore negative weight events in the training.; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:26184,avoid,avoided,26184,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['avoid'],['avoided']
Safety,"in volume corresponding to the variables in sumSet; inverseBinCor: divide counts in each bin by the bin volume corresponding to the variables not in sumSet. New fully parametrised Crystal Ball shape class; So far, the Crystal Ball distribution has been represented in RooFit only by the RooCBShape class, which has a Gaussian core and a single power-law tail on one side. This release introduces RooCrystalBall, which implements some common generalizations of the Crystal Ball shape:. symmetric or asymmetric power-law tails on both sides; different width parameters for the left and right sides of the Gaussian core. The new RooCrystalBall class can substitute the RooDSCBShape and RooSDSCBShape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channel. This significantly increase a performance, especially when several clients are connected.; Better security for THttpServer with webgui; If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will provide access to the widgets via websocket connection - any other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:26278,avoid,avoids,26278,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['avoid'],['avoids']
Safety,"in(Double_t x, Double_t y = 0, Double_t z = 0) const; returns the global bin number containing the given values. Note: - values which belong to dimensions higher than the current dimension; of the TEfficiency object are ignored (i.e. for 1-dimensional; efficiencies only the x-value is considered). Int_t Fit(TF1* f1, Option_t* opt = """"); fits the efficiency using the TBinomialEfficiencyFitter class. The resulting fit function is added to the list of associated functions. Options: - ""+"": previous fitted functions in the list are kept, by default; all functions in the list are deleted; - for more fitting options see TBinomialEfficiencyFitter::Fit. TH1* GetCopyPassedHisto() const; returns a cloned version of fPassedHistogram. Notes: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""passed.root"",""update"");; TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; TH1* copy = pEff->GetCopyPassedHisto();; copy->SetDirectory(gDirectory);; pFile->Write();. TH1* GetCopyTotalHisto() const; returns a cloned version of fTotalHistogram. Notes: - The histogram is filled with unit weights. You might want to scale; it with the global weight GetWeight().; - The returned object is owned by the user who has to care about the; deletion of the new TH1 object.; - This histogram is by default NOT attached to the current directory; to avoid duplication of data. If you want to store it automatically; during the next TFile::Write() command, you have to attach it to; the corresponding directory. TFile* pFile = new TFile(""total.root"",""update"");; TEfficiency* pEff = (TEfficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:54005,avoid,avoid,54005,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,6,['avoid'],['avoid']
Safety,"in) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:52103,risk,risks,52103,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['risk'],['risks']
Safety,"in) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53743,risk,risks,53743,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['risk'],['risks']
Safety,"in, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:16486,safe,safe,16486,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['safe'],['safe']
Safety,"in, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4381,safe,safe,4381,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,6,"['SAFE', 'safe']","['SAFE', 'safe']"
Safety,"in::Lookup(bool force); 1761{; 1762 TIter next(fFiles);; 1763 TChainElement* element = nullptr;; 1764 Int_t nelements = fFiles->GetEntries();; 1765 printf(""\n"");; 1766 printf(""TChain::Lookup - Looking up %d files .... \n"", nelements);; 1767 Int_t nlook = 0;; 1768 TFileStager *stg = nullptr;; 1769 while ((element = (TChainElement*) next())) {; 1770 // Do not do it more than needed; 1771 if (element->HasBeenLookedUp() && !force) continue;; 1772 // Count; 1773 nlook++;; 1774 // Get the Url; 1775 TUrl elemurl(element->GetTitle(), true);; 1776 // Save current options and anchor; 1777 TString anchor = elemurl.GetAnchor();; 1778 TString options = elemurl.GetOptions();; 1779 // Reset options and anchor; 1780 elemurl.SetOptions("""");; 1781 elemurl.SetAnchor("""");; 1782 // Locate the file; 1783 TString eurl(elemurl.GetUrl());; 1784 if (!stg || !stg->Matches(eurl)) {; 1785 SafeDelete(stg);; 1786 {; 1787 TDirectory::TContext ctxt;; 1788 stg = TFileStager::Open(eurl);; 1789 }; 1790 if (!stg) {; 1791 Error(""Lookup"", ""TFileStager instance cannot be instantiated"");; 1792 break;; 1793 }; 1794 }; 1795 Int_t n1 = (nelements > 100) ? (Int_t) nelements / 100 : 1;; 1796 if (stg->Locate(eurl.Data(), eurl) == 0) {; 1797 if (nlook > 0 && !(nlook % n1)) {; 1798 printf(""Lookup | %3d %% finished\r"", 100 * nlook / nelements);; 1799 fflush(stdout);; 1800 }; 1801 // Get the effective end-point Url; 1802 elemurl.SetUrl(eurl);; 1803 // Restore original options and anchor, if any; 1804 elemurl.SetOptions(options);; 1805 elemurl.SetAnchor(anchor);; 1806 // Save it into the element; 1807 element->SetTitle(elemurl.GetUrl());; 1808 // Remember; 1809 element->SetLookedUp();; 1810 } else {; 1811 // Failure: remove; 1812 fFiles->Remove(element);; 1813 if (gSystem->AccessPathName(eurl)); 1814 Error(""Lookup"", ""file %s does not exist\n"", eurl.Data());; 1815 else; 1816 Error(""Lookup"", ""file %s cannot be read\n"", eurl.Data());; 1817 }; 1818 }; 1819 if (nelements > 0); 1820 printf(""Lookup | %3d %% finished\n"", 100 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:64111,Safe,SafeDelete,64111,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"inDeepNet<DNN::TCuda<ScalarImpl_t>>();; 1674#endif; 1675#else; 1676 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 1677 ""you have CUDA installed and it was successfully ""; 1678 ""detected by CMAKE.""; 1679 << Endl;; 1680 return;; 1681#endif; 1682 } else if (this->GetArchitectureString() == ""CPU"") {; 1683#ifdef R__HAS_TMVACPU; 1684 // note that number of threads used for BLAS might be different; 1685 // e.g use openblas_set_num_threads(num_threads) for OPENBLAS backend; 1686 Log() << kINFO << ""Start of deep neural network training on CPU using MT, nthreads = ""; 1687 << gConfig().GetNCpu() << Endl << Endl;; 1688#else; 1689 Log() << kINFO << ""Start of deep neural network training on single thread CPU (without ROOT-MT support) "" << Endl; 1690 << Endl;; 1691#endif; 1692 TrainDeepNet<DNN::TCpu<ScalarImpl_t> >();; 1693 return;; 1694 }; 1695 else {; 1696 Log() << kFATAL << this->GetArchitectureString() <<; 1697 "" is not a supported architecture for TMVA::MethodDL""; 1698 << Endl;; 1699 }; 1700 ; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704void TMVA::MethodDL::FillInputTensor(); 1705{; 1706 // fill the input tensor fXInput from the current Event data; 1707 // with the correct shape depending on the model used; 1708 // The input tensor is used for network prediction after training ; 1709 // using a single event. The network batch size must be equal to 1. ; 1710 // The architecture specified at compile time in ArchitectureImpl_t; 1711 // is used. This should be the CPU architecture; 1712 ; 1713 if (!fNet || fNet->GetDepth() == 0) {; 1714 Log() << kFATAL << ""The network has not been trained and fNet is not built"" << Endl;; 1715 }; 1716 if (fNet->GetBatchSize() != 1) {; 1717 Log() << kFATAL << ""FillINputTensor::Network batch size must be equal to 1 when doing single event predicition"" << Endl;; 1718 }; 1719 ; 1720 // get current event; 1721 const std::vector<Float_t> &inputValues = GetEvent()->GetValues()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:67599,predict,prediction,67599,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17656,avoid,avoids,17656,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,3,['avoid'],['avoids']
Safety,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16297,avoid,avoids,16297,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,3,['avoid'],['avoids']
Safety,"inate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:18656,timeout,timeout,18656,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,2,['timeout'],['timeout']
Safety,"ind and return logical shape identified by unique 'ID' in refresh-cache. ;  ; virtual TGLPhysicalShape * FindPhysical (UInt_t phid) const;  Find and return physical shape identified by unique 'ID'. ;  ; TGLContextIdentity * GetGLCtxIdentity () const;  ; virtual UInt_t GetMaxPhysicalID ();  Returns the maximum used physical id. ;  ; void LodifySceneInfo (TGLRnrCtx &rnrCtx) override;  Setup LOD-dependant values in scene-info. ;  ; void PostDraw (TGLRnrCtx &rnrCtx) override;  Called after the rendering is finished. ;  ; void PreDraw (TGLRnrCtx &rnrCtx) override;  Initialize rendering. ;  ; void RebuildSceneInfo (TGLRnrCtx &rnrCtx) override;  Major change in scene, need to rebuild all-element draw-vector and sort it. ;  ; LogicalShapeMap_t & RefLogicalShapes ();  ; virtual void RenderAllPasses (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeout);  Do full rendering of scene. ;  ; virtual void RenderElements (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec, Bool_t check_timeout, const TGLPlaneSet_t *clipPlanes=nullptr);  Render DrawElements in elementVec with given timeout. ;  ; virtual void RenderHighlight (TGLRnrCtx &rnrCtx, DrawElementPtrVec_t &elVec);  ; void RenderOpaque (TGLRnrCtx &rnrCtx) override;  Render opaque elements. ;  ; void RenderSelOpaque (TGLRnrCtx &rnrCtx) override;  Render selected opaque elements. ;  ; void RenderSelOpaqueForHighlight (TGLRnrCtx &rnrCtx) override;  Render selected opaque elements for highlight. ;  ; void RenderSelTransp (TGLRnrCtx &rnrCtx) override;  Render selected transparent elements. ;  ; void RenderSelTranspForHighlight (TGLRnrCtx &rnrCtx) override;  Render selected transparent elements for highlight. ;  ; void RenderTransp (TGLRnrCtx &rnrCtx) override;  Render transparent elements. ;  ; Bool_t ResolveSelectRecord (TGLSelectRecord &rec, Int_t curIdx) override;  Process selection record rec. ;  ; UInt_t SizeOfScene () const;  Return memory cost of scene. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:13748,timeout,timeout,13748,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['timeout'],['timeout']
Safety,"ine 132 of file TGLSAViewer.h. ◆ MenuHidingTimeout(). void TGLSAViewer::MenuHidingTimeout ; (; ). Action for menu-hiding timeout. ; Definition at line 638 of file TGLSAViewer.cxx. ◆ operator=(). TGLSAViewer & TGLSAViewer::operator= ; (; const TGLSAViewer & ; ). private . ◆ ProcessFrameMessage(). Bool_t TGLSAViewer::ProcessFrameMessage ; (; Long_t ; msg, . Long_t ; parm1, . Long_t ;  . ). Process GUI message capture by the main GUI frame (TGLSAFrame). ; Definition at line 663 of file TGLSAViewer.cxx. ◆ ResetMenuHidingTimer(). void TGLSAViewer::ResetMenuHidingTimer ; (; Bool_t ; show_menu). private . Reset the timer for menu-bar hiding. ; Definition at line 620 of file TGLSAViewer.cxx. ◆ SelectionChanged(). void TGLSAViewer::SelectionChanged ; (; ). overridevirtual . Update GUI components for embedded viewer selection change. ; Override from TGLViewer. ; Reimplemented from TGLViewer.; Definition at line 481 of file TGLSAViewer.cxx. ◆ SetMenuHidingTimeout(). void TGLSAViewer::SetMenuHidingTimeout ; (; Long_t ; timeout). static . Set global timeout for menu-hiding in mili-seconds. ; Static function. ; Definition at line 655 of file TGLSAViewer.cxx. ◆ Show(). void TGLSAViewer::Show ; (; ). Show the viewer. ; Definition at line 500 of file TGLSAViewer.cxx. ◆ Streamer(). void TGLSAViewer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLSAViewer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 132 of file TGLSAViewer.h. ◆ ToggleEditObject(). void TGLSAViewer::ToggleEditObject ; (; ). Toggle state of the 'Edit Object' menu entry. ; Definition at line 820 of file TGLSAViewer.cxx. ◆ ToggleOrthoDolly(). void TGLSAViewer::ToggleOrthoDolly ; (; ). Toggle state of the 'Ortho allow dolly' menu entry. ; Definition at line 850 of file TGLSAViewer.cxx. ◆ ToggleOrthoRotate(). void TGLSAViewer::ToggleOrthoRotate ; (; ). Toggle state of the 'Ortho a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:46367,timeout,timeout,46367,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['timeout'],['timeout']
Safety,"ine 528 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:454; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:209; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 454 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when a very large number of files and workers is used. ; Definition at line 541 of file TTreeProcessorMT.cxx. Member Data Documentation. ◆ fEntryList. TEntryList ROOT::TTreeProcessorMT::fEntryList. private . User-defined selection of entry numbers to be processed, empty if none was provided. ; Definition at line 84 of file TTreeProcessorMT.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html:6615,safe,safe,6615,doc/v632/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMT.html,1,['safe'],['safe']
Safety,"ine 53 of file TGeoShapeAssembly.h. ◆ IsCylType(). Bool_t TGeoShapeAssembly::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoShapeAssembly.h. ◆ NeedsBBoxRecompute(). void TGeoShapeAssembly::NeedsBBoxRecompute ; (; ). inline . Definition at line 55 of file TGeoShapeAssembly.h. ◆ RecomputeBoxLast(). void TGeoShapeAssembly::RecomputeBoxLast ; (; ). Recompute bounding box of the assembly after adding a node. ; Definition at line 114 of file TGeoShapeAssembly.cxx. ◆ Safety(). Double_t TGeoShapeAssembly::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 476 of file TGeoShapeAssembly.cxx. ◆ Safety_v(). void TGeoShapeAssembly::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoShapeAssembly.cxx. ◆ SavePrimitive(). void TGeoShapeAssembly::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 542 of file TGeoShapeAssembly.cxx. ◆ SetPoints() [1/2]. void TGeoShapeAssembly::SetPoints ; (; Double_t * ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 547 of file TGeoShapeAssembly.cxx. ◆ SetPoints() [2/2]. void TGeoShapeAssembly::SetPoints ; (; Float_t * ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:30649,safe,safe,30649,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"ine 535 of file TTreeProcessorMT.cxx. ◆ Process(). void TTreeProcessorMT::Process ; (; std::function< void(TTreeReader &)> ; func). Process the entries of a TTree in parallel. ; The user-provided function receives a TTreeReader which can be used to iterate on a subrange of entries TTreeProcessorMT::Process([](TTreeReader& readerSubRange) {; // Select branches to read; while (readerSubRange.Next()) {; // Use content of current entry; }; });; ROOT::TTreeProcessorMT::Processvoid Process(std::function< void(TTreeReader &)> func)Process the entries of a TTree in parallel.Definition TTreeProcessorMT.cxx:460; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::Nextbool Next()Move to the next entry (or index of the TEntryList if that is set).Definition TTreeReader.h:216; The user needs to be aware that each of the subranges can potentially be processed in parallel. This means that the code of the user function should be thread safe.; Parameters. [in]funcUser-defined function that processes a subrange of entries . Definition at line 460 of file TTreeProcessorMT.cxx. ◆ SetTasksPerWorkerHint(). void TTreeProcessorMT::SetTasksPerWorkerHint ; (; unsigned int ; tasksPerWorkerHint). static . Set the hint for the desired number of tasks created per worker. ; Parameters. [in]tasksPerWorkerHintDesired number of tasks per worker. This allows to create a reasonable number of tasks even if any of the processed files features a bad clustering, for example with a lot of entries and just a few entries per cluster, or to limit the number of tasks spawned when a very large number of files and workers is used. ; Definition at line 548 of file TTreeProcessorMT.cxx. Member Data Documentation. ◆ fEntryList. TEntryList ROOT::TTreeProcessorMT::fEntryList. private . User-defined selection of entry numbers to be processed, empty if none was provided. ; Definition at line 85 of file TTreeProcessorMT.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html:6982,safe,safe,6982,doc/master/classROOT_1_1TTreeProcessorMT.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TTreeProcessorMT.html,1,['safe'],['safe']
Safety,"ine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. private:. static intfgCoinFlagno coin viewer;; static intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:22702,safe,safely,22702,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,3,['safe'],['safely']
Safety,"ineSlot(""x"", function, {""column1"", ""column2""}); See Define() for more information. ; Definition at line 470 of file RInterface.hxx. ◆ DefineSlotEntry(). template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefineSlotEntry ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column with a value dependent on the processing slot and the current entry. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding slot and entry). . Returnsthe first node of the computation graph for which the new quantity is defined.; This alternative implementation of Define is meant as a helper in writing entry-specific, thread-safe custom columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where T1, T2... are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter is reserved for a ULong64_t representing the current entry being processed by the current thread.; The following two Defines are equivalent, although DefineSlotEntry is slightly more performant: int function(unsigned int, ULong64_t, double, double);; Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); DefineSlotEntry(""x"", function, {""column1"", ""column2""}); ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterface::DefineRInterface< Proxied, DS_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:60244,safe,safe,60244,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"ined(_WIN64) && !defined(NO_ATOMICS); 1195 ret = InterlockedCompareExchange64(addr, newval, oldval);; 1196#elif defined(_WIN32) && !defined(NO_ATOMICS); 1197 ret = InterlockedCompareExchange(addr, newval, oldval);; 1198#elif defined(__GNUC__) \; 1199 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1200 && !defined(NO_ATOMICS); 1201 ret = __sync_val_compare_and_swap(addr, oldval, newval);; 1202#else; 1203 mg_global_lock();; 1204 ret = *addr;; 1205 if ((ret != newval) && (ret == oldval)) {; 1206 *addr = newval;; 1207 }; 1208 mg_global_unlock();; 1209#endif; 1210 return ret;; 1211}; 1212 ; 1213 ; 1214static void; 1215mg_atomic_max(volatile ptrdiff_t *addr, ptrdiff_t value); 1216{; 1217 register ptrdiff_t tmp = *addr;; 1218 ; 1219#if defined(_WIN64) && !defined(NO_ATOMICS); 1220 while (tmp < value) {; 1221 tmp = InterlockedCompareExchange64(addr, value, tmp);; 1222 }; 1223#elif defined(_WIN32) && !defined(NO_ATOMICS); 1224 while (tmp < value) {; 1225 tmp = InterlockedCompareExchange(addr, value, tmp);; 1226 }; 1227#elif defined(__GNUC__) \; 1228 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1229 && !defined(NO_ATOMICS); 1230 while (tmp < value) {; 1231 tmp = __sync_val_compare_and_swap(addr, tmp, value);; 1232 }; 1233#else; 1234 mg_global_lock();; 1235 if (*addr < value) {; 1236 *addr = value;; 1237 }; 1238 mg_global_unlock();; 1239#endif; 1240}; 1241 ; 1242 ; 1243static int64_t; 1244mg_atomic_add64(volatile int64_t *addr, int64_t value); 1245{; 1246 int64_t ret;; 1247 ; 1248#if defined(_WIN64) && !defined(NO_ATOMICS); 1249 ret = InterlockedAdd64(addr, value);; 1250#elif defined(_WIN32) && !defined(NO_ATOMICS); 1251 ret = InterlockedExchangeAdd64(addr, value) + value;; 1252#elif defined(__GNUC__) \; 1253 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1254 && !defined(NO_ATOMICS); 1255 ret = __sync_add_and_fetch(addr, value);; 1256#else; 1257 mg_global_lock();; 1258 *addr += value;; 1259 ret = (*addr);; 1260 m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:38170,Interlock,InterlockedCompareExchange,38170,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Interlock'],['InterlockedCompareExchange']
Safety,"ing class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:2122,avoid,avoid,2122,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ing example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THistPainter.html:69949,avoid,avoid,69949,root/html532/THistPainter.html,https://root.cern,https://root.cern/root/html532/THistPainter.html,4,['avoid'],['avoid']
Safety,"ing key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361395,timeout,timeout,361395,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ing key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361428,timeout,timeout,361428,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ing mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:66027,detect,detector,66027,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"ing terminator) should be specified in; 1295/// namesize.; 1296/// @note Edge cases:; 1297/// - If the number after the `;` is larger than `SHORT_MAX`, cycle is set to `0`.; 1298/// - If name ends with `;*`, cycle is set to 10000`.; 1299/// - In all other cases, i.e. when number is not a digit or buffer is a nullptr, cycle is set to `9999`.; 1300 ; 1301void TDirectory::DecodeNameCycle(const char *buffer, char *name, Short_t &cycle,; 1302 const size_t namesize); 1303{; 1304 if (!buffer) {; 1305 cycle = 9999;; 1306 return;; 1307 }; 1308 ; 1309 size_t len = 0;; 1310 const char *ni = strchr(buffer, ';');; 1311 ; 1312 if (ni) {; 1313 // Found ';'; 1314 len = ni - buffer;; 1315 ++ni;; 1316 } else {; 1317 // No ';' found; 1318 len = strlen(buffer);; 1319 ni = &buffer[len];; 1320 }; 1321 ; 1322 if (namesize) {; 1323 if (len > namesize-1ul) len = namesize-1; // accommodate string terminator; 1324 } else {; 1325 ::Warning(""TDirectory::DecodeNameCycle"",; 1326 ""Using unsafe version: invoke this method by specifying the buffer size"");; 1327 }; 1328 ; 1329 strncpy(name, buffer, len);; 1330 name[len] = '\0';; 1331 ; 1332 if (*ni == '*'); 1333 cycle = 10000;; 1334 else if (isdigit(*ni)) {; 1335 long parsed = strtol(ni,nullptr,10);; 1336 if (parsed >= (long) std::numeric_limits<Short_t>::max()); 1337 cycle = 0;; 1338 else; 1339 cycle = (Short_t)parsed;; 1340 } else; 1341 cycle = 9999;; 1342}; 1343 ; 1344void TDirectory::TContext::RegisterCurrentDirectory(); 1345{; 1346 // peg the current directory; 1347 TDirectory *current;; 1348 {; 1349 ROOT::Internal::TSpinLockGuard slg(*GetCurrentDirectoryLock());; 1350 current = TDirectory::CurrentDirectory().load();; 1351 // Don't peg if there is no current directory or if the current; 1352 // directory's destruction has already started (in another thread); 1353 // and is waiting for this thread to leave the critical section.; 1354 if (!current || !current->IsBuilt()); 1355 return;; 1356 ++(current->fContextPeg);; 1357 }; 1358 current->Register",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:46117,unsafe,unsafe,46117,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"ing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf ;  ; file  rf609_xychi2fit.C;   Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) ;  ; file  rf609_xychi2fit.py;   Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) ;  ; file  rf610_visualerror.C;   Likelihood and minimization: visualization of errors from a covariance matrix ;  ; file  rf610_visualerror.py;   Likelihood and minimization: visualization of errors from a covariance matrix ;  ; file  rf611_weightedfits.C;   Likelihood and minimization: Parameter uncertainties for weighted unbinned ML fits ;  ; file  rf612_recoverFromInvalidParameters.C;   Likelihood and minimization: Recover from regions where the function is not defined. ;  ; file  rf612_recoverFromInvalidParameters.py;   Likelihood and minimization: Recover from regions where the function is not defined. ;  ; file  rf613_global_observables.C;   This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. ;  ; file  rf613_global_observables.py;   This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. ;  ; file  rf614_binned_fit_problems.C;   A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. ;  ; file  rf614_binned_fit_problems.py;   A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. ;  ; file  rf615_simulation_based_inference.py;   Use Simulation Based Inference (SBI) in RooFit. ;  ; file  rf616_morphing.C;   Use Morphing in RooFit. ;  ; file  rf616_morphing.py;   Use Morphing in RooFit. ;  ; file  rf617_simulation_based_inference_multi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:18425,Recover,Recover,18425,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['Recover'],['Recover']
Safety,"ing the remote master or slave servers. ; Returns 0 if ok, -1 in case of error ; Definition at line 493 of file TSlave.cxx. ◆ Print(). void TSlave::Print ; (; Option_t * ; option = """"); const. overridevirtual . Printf info about slave. ; Reimplemented from TObject.; Reimplemented in TSlaveLite.; Definition at line 340 of file TSlave.cxx. ◆ SendCoordinator(). TObjString * TSlave::SendCoordinator ; (; Int_t ; kind, . const char * ; msg = 0, . Int_t ; int2 = 0 . ). protectedvirtual . Send message to intermediate coordinator. ; Only meaningful when there is one, i.e. in XPD framework ; Definition at line 643 of file TSlave.cxx. ◆ SendGroupPriority(). virtual Int_t TSlave::SendGroupPriority ; (; const char * ; , . Int_t ;  . ). inlineprotectedvirtual . Definition at line 110 of file TSlave.h. ◆ SetAlias(). void TSlave::SetAlias ; (; const char * ; alias). protectedvirtual . Set an alias for this session. ; If reconnection is supported, the alias will be communicated to the remote coordinator so that it can be recovered when reconnecting ; Definition at line 655 of file TSlave.cxx. ◆ SetArchCompiler(). void TSlave::SetArchCompiler ; (; const char * ; ac). inline . Definition at line 158 of file TSlave.h. ◆ SetInputHandler(). void TSlave::SetInputHandler ; (; TFileHandler * ; ih). Adopt and register input handler for this slave. ; Handler will be deleted by the slave. ; Definition at line 393 of file TSlave.cxx. ◆ SetInterruptHandler(). virtual void TSlave::SetInterruptHandler ; (; Bool_t ; ). inlinevirtual . Definition at line 156 of file TSlave.h. ◆ SetROOTVersion(). void TSlave::SetROOTVersion ; (; const char * ; rv). inline . Definition at line 159 of file TSlave.h. ◆ SetSessionTag(). void TSlave::SetSessionTag ; (; const char * ; st). inline . Definition at line 161 of file TSlave.h. ◆ SetSocket(). void TSlave::SetSocket ; (; TSocket * ; s). inlineprotected . Definition at line 112 of file TSlave.h. ◆ SetStatus(). virtual void TSlave::SetStatus ; (; Int_t ; st). inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:22072,recover,recovered,22072,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['recover'],['recovered']
Safety,"ingle integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:14769,safe,safe,14769,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['safe'],['safe']
Safety,ings.py ;  tdf013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  tdf014_CSVDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf014_CSVDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a TDataFrame ;  ► eve;  alice_esd.CComplex example showing ALICE ESD track visualization ;  alice_esd_html_summary.CHtml table and event summary for alice_esd.C ;  alice_esd_split.CComplex example showing ALICE ESD visualization in several views ;  alice_vsd.CComplex example showing ALICE VSD visualization ;  annotation.CDemonstrates usage of TGLAnnotation class ;  arrow.CDemonstrates usage of TEveArrow class ;  arrow_standalone.CHow to use EVE without the standard window ;  assembly.CGeometry detector assembly example ;  box.CDemonstrates usage of TEveBox class ;  boxset.CDemonstrates usage of TEveBoxSet class ;  boxset_cones.CDemonstrates usage of 'cone' mode in TEveBoxSet class ;  calo_detail.CCalorimeter detailed view by using TEveCaloDataVec as data-source ;  calorimeters.CDemonstrates usage of EVE calorimetry classes ;  camera_restore.C;  compound.CDemonstrates usage of EVE compound objects - class TEveCompound ;  csgdemo.CCombinatorial Solid Geometry example ;  geom_alias.CDemonstates usage of geometry aliases - merge ALICE ITS with ATLAS MUON ;  geom_alice_its.CShows geometry of ALICE ITS ;  geom_alice_tpc.CShows geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usag,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:99528,detect,detector,99528,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['detect'],['detector']
Safety,"ingz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) ; [in]nbinsznumber of bins along the Z axis ; [in]zlowlow edge of the Z axis first bin ; [in]zupupper edge of the Z axis last bin (not included in last bin) . Definition at line 101 of file TH3.cxx. ◆ TH3() [3/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Float_t * ; xbins, . Int_t ; nbinsy, . const Float_t * ; ybins, . Int_t ; nbinsz, . const Float_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type float. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type float and size nbinsy+1 ; [in]nbinsznumber of bins ; [in]zbinsarray of low-edges for each bin. This is an array of type float and size nbinsz+1 . Definition at line 142 of file TH3.cxx. ◆ TH3() [4/5]. TH3::TH3 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins, . Int_t ; nbinsz, . const Double_t * ; zbins . ). protected . Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input arrays of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:60561,avoid,avoid,60561,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety,"inition TSystem.cxx:653; f1TF1 * f1Definition legend1.C:11. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with ""("", the file remains opened (it is not closed). If the Postscript file name finishes with "")"" and the file has been opened with ""("", the file is closed.; Example: {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; h1TH1F * h1Definition legend1.C:5; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop one needs to detect the special cases of first and last page and then munge the argument to Print() accordingly. The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below.; Example: c1.Print(""file.ps[""); // No actual print, just open file.ps; ; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; ; c1.Print(""file.ps""); // Actually print canvas to the file; }; ; c1.Print(""file.ps]""); // No actual print, just close the file. Color Model; TPostScript support two color model RGB and CMYK. CMY and CMYK models are subtractive color models unlike RGB which is an additive. They are mainly used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more component K (black). The conversion from RGB to CMYK is:; Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);; double; TMath::MinSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:8903,detect,detect,8903,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['detect'],['detect']
Safety,"inition at line 3975 of file TGeoManager.cxx. ◆ FindDuplicateMaterial(). TGeoMaterial * TGeoManager::FindDuplicateMaterial ; (; const TGeoMaterial * ; mat); const. Find if a given material duplicates an existing one. ; Definition at line 2992 of file TGeoManager.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoManager::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 2755 of file TGeoManager.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoManager::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 2736 of file TGeoManager.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoManager::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool_t ; compmatrix = kFALSE . ). Computes as fStep the distance to next daughter of the current volume. ; The point and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:85799,safe,safety,85799,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safety']
Safety,"inition at line 60 of file TGeoPolygon.h. ◆ IsIllegalCheck(). Bool_t TGeoPolygon::IsIllegalCheck ; (; ); const. Check for illegal crossings between non-consecutive segments. ; Definition at line 295 of file TGeoPolygon.cxx. ◆ IsRightSided(). Bool_t TGeoPolygon::IsRightSided ; (; const Double_t * ; point, . Int_t ; ind1, . Int_t ; ind2 . ); const. private . Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. ; Definition at line 263 of file TGeoPolygon.cxx. ◆ IsSegConvex(). Bool_t TGeoPolygon::IsSegConvex ; (; Int_t ; i1, . Int_t ; i2 = -1 . ); const. private . Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. ; Definition at line 276 of file TGeoPolygon.cxx. ◆ operator=(). TGeoPolygon & TGeoPolygon::operator= ; (; const TGeoPolygon & ; ). privatedelete . ◆ OutscribedConvex(). void TGeoPolygon::OutscribedConvex ; (; ). private . Compute indices for the outscribed convex polygon. ; Definition at line 327 of file TGeoPolygon.cxx. ◆ Safety(). Double_t TGeoPolygon::Safety ; (; const Double_t * ; point, . Int_t & ; isegment . ); const. Compute minimum distance from POINT to any segment. Returns segment index. ; Definition at line 381 of file TGeoPolygon.cxx. ◆ SetConvex(). void TGeoPolygon::SetConvex ; (; Bool_t ; flag = kTRUE). inline . Definition at line 63 of file TGeoPolygon.h. ◆ SetNextIndex(). void TGeoPolygon::SetNextIndex ; (; Int_t ; index = -1). Sets the next polygone index. ; If index<0 sets all indices consecutive in increasing order. ; Definition at line 440 of file TGeoPolygon.cxx. ◆ SetXY(). void TGeoPolygon::SetXY ; (; Double_t * ; x, . Double_t * ; y . ). Set X/Y array pointer for the polygon and daughters. ; Definition at line 469 of file TGeoPolygon.cxx. ◆ Streamer(). void TGeoPolygon::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoPolygon::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPolygon.html:18473,Safe,Safety,18473,doc/master/classTGeoPolygon.html,https://root.cern,https://root.cern/doc/master/classTGeoPolygon.html,1,['Safe'],['Safety']
Safety,"inition at line 899 of file TGeoManager.cxx. ◆ ReplaceVolume(). Int_t TGeoManager::ReplaceVolume ; (; TGeoVolume * ; vorig, . TGeoVolume * ; vnew . ). Replaces all occurrences of VORIG with VNEW in the geometry tree. ; The volume VORIG is not replaced from the list of volumes, but all node referencing it will reference VNEW instead. Returns number of occurrences changed. ; Definition at line 1125 of file TGeoManager.cxx. ◆ ResetState(). void TGeoManager::ResetState ; (; ). Reset current state flags. ; Definition at line 2774 of file TGeoManager.cxx. ◆ ResetUserData(). void TGeoManager::ResetUserData ; (; ). Sets all pointers TGeoVolume::fField to NULL. ; User data becomes decoupled from geometry. Deletion has to be managed by users. ; Definition at line 3097 of file TGeoManager.cxx. ◆ RestoreMasterVolume(). void TGeoManager::RestoreMasterVolume ; (; ). Restore the master volume of the geometry. ; Definition at line 3118 of file TGeoManager.cxx. ◆ Safety(). Double_t TGeoManager::Safety ; (; Bool_t ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 2300 of file TGeoManager.cxx. ◆ SamplePoints(). TGeoNode * TGeoManager::SamplePoints ; (; Int_t ; npoints, . Double_t & ; dist, . Double_t ; epsil = 1E-5, . const char * ; g3path = """" . ). shoot npoints randomly in a box of 1E-5 around current point. ; return minimum distance to points outside ; Definition at line 3647 of file TGeoManager.cxx. ◆ SaveAttributes(). void TGeoManager::SaveAttributes ; (; const char * ; filename = ""tgeoatt.C""). Save current attributes in a macro. ; Definition at line 2658 of file TGeoManager.cxx. ◆ SearchNode(). TGeoNode * TGeoManager::SearchNode ; (; Bool_t ; downwards = kFALSE, . const TGeoNode * ; skipnode = nullptr . ). Returns the deepest node containing fPoint, which must be set a priori. ; Definition at line 2716 of file TGeoManager.cxx. ◆ SelectTrackingMedia(). void TGeoManager::SelectTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:130818,Safe,Safety,130818,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['Safe'],['Safety']
Safety,"ink ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a symlink from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 2826 of file TWinNTSystem.cxx. ◆ TempDirectory(). const char * TWinNTSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 2257 of file TWinNTSystem.cxx. ◆ TempFileName(). FILE * TWinNTSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 2281 of file TWinNTSystem.cxx. ◆ ThreadStub(). static void TWinNTSystem::ThreadStub ; (; void * ; Parameter). inlinestaticprivate . Definition at line 88 of file TWinNTSystem.h. ◆ TimerThread(). void TWinNTSystem::TimerThread ; (; ). private . Special Thread to check asynchronous timers. ; Definition at line 4442 of file TWinNTSystem.cxx. ◆ Umask(). int TWinNTSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 3081 of file TWinNTSystem.cxx. ◆ UnixPathName(). const char * TWinNTSystem::UnixPathName ; (; const char * ; name). overridevirtual . Convert a pathname to a unix pathname. ; E.g. from \user\root to /user/root. General rules for applications creating names for directories and files or processing names supplied by the user include the following:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:73472,safe,safely,73472,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<std::string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<std::string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:42033,avoid,avoid,42033,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,4,['avoid'],['avoid']
Safety,"input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimultaneous(const char* name, const char* title, RooAbsCategoryLValue& indexCat); Constructor with index category. PDFs associated with indexCat; states can be added after construction with the addPdf() function. RooSimultaneous can function without having a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. RooSimultaneous(const char* name, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); Constructor from index category and full list of PDFs.; In this constructor form, a PDF must be supplied for each indexCat state; to avoid ambiguities. The PDFS are associated in order with the state of the; index category as listed by the index categories type iterator. PDFs may not overlap (i.e. share any variables) with the index category (function). RooSimultaneous(const char* name, const char* title, map<string,RooAbsPdf*> pdfMap, RooAbsCategoryLValue& inIndexCat). void initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); First see if there are any RooSimultaneous input components. RooSimultaneous(const RooSimultaneous& other, const char* name = 0); Copy constructor. ~RooSimultaneous(); Destructor. RooAbsPdf* getPdf(const char* catName) const; Return the p.d.f associated with the given index category name. Bool_t addPdf(const RooAbsPdf& pdf, const char* catLabel); Associate given PDF with index category state label 'catLabel'.; The names state must be already defined in the index category. RooSimultaneous can function without having a PDF associated; with ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:46789,avoid,avoid,46789,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['avoid'],['avoid']
Safety,"input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:150918,timeout,timeout,150918,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:5815,avoid,avoid,5815,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ins_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DeclFileName(). static const char * TGeoCtub::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGeoTube.h. ◆ DistFromInside(). Double_t TGeoCtub::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoCtub::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoCtub::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoCtub::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoCtub::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoCtub::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoCtub::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoCtub::GetByteCount ; (; ); const. inlineover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:31113,safe,safe,31113,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety,"inst the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103346,safe,safety,103346,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"int length); virtual intTSystem::RecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheSystem.html:11432,timeout,timeout,11432,root/html530/TDCacheSystem.html,https://root.cern,https://root.cern/root/html530/TDCacheSystem.html,10,['timeout'],['timeout']
Safety,"int[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:19736,safe,safety,19736,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,inted; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with indirect file; [#14902] - compilation error; [#14863] - [hist] TH1::SaveAs missing default option argument causes compilation errors; [#14855] - TRatioPlot crashes if loaded from the file; [#14842] - TRatioplot gives “different” results with Web Graphics; [#14838] - Problems with Confidence Band of TRatioPlot; [#14801] - TEfficiency drawing to .C is broken; [#14793] - 6.26 cannot read file written with 6.30.4; [#14772] - [cling] Undocumented behaviour of root macro_C.so; [#14767] - rootn.exe instant crash on startup; [#14765] - TGenPhaseSpace weight normalization; [#14748] - [ntuple] Show and PrintInfo does not work for friend RNTuples; [#14601] - std::source_location not found when running with c++20 enabled; [#14599] ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26399,detect,detect,26399,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['detect'],['detect']
Safety,"interName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. TGeoShape(); constructors. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShape.html:22752,safe,safe,22752,root/html602/TGeoShape.html,https://root.cern,https://root.cern/root/html602/TGeoShape.html,2,['safe'],['safe']
Safety,"interactions. It is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame). A menu bar contains one or more popup menus and usually is placed along the top of the application window. Any popup menu is invisible until the user invokes it by using the mouse pointer or the keyboard.; Popup menus implemented by TGPopupMenu class are unique in that, by convention, they are not placed with the other GUI components in the user interfaces. Instead, a popup menu usually appears either in a menu bar or as a context menu on the TOP of the GUI. For that reason it needs gClient->GetDefaultRoot() as a parent to get the pointer to the root (i.e. desktop) window. This way a popup menu will never be embedded. NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not avoid the possibility of embedding the corresponding popup menu because the current window hierarchy can be changed by using gClient->SetRoot() method.; As a context menus TGPopupMenu shows up after pressing the right mouse button, over a popup-enabled component. The popup menu then appears under the mouse pointer.; Selecting a menu item will generate the event: kC_COMMAND, kCM_MENU, menu id, user data. ; Definition at line 282 of file TGMenu.h. Public Member Functions;  TGMenuBar (const TGWindow *p=nullptr, UInt_t w=60, UInt_t h=20, UInt_t options=kHorizontalFrame|kRaisedFrame);  Create a menu bar object. ;  ;  ~TGMenuBar () override;  Delete menu bar object. ;  ; virtual void AddPopup (const char *s, TGPopupMenu *menu, TGLayoutHints *l, TGPopupMenu *before=nullptr);  Add popup menu to menu bar. ;  ; virtual TGPopupMenu * AddPopup (const TString &s, Int_t padleft=4, Int_t padright=0, Int_t padtop=0, Int_t padbottom=0);  Add popup menu to menu bar. ;  ; virtual void AddPopup (TGHotString *s, TGPopupMenu *menu, TGLayoutHints *l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMenuBar.html:1669,avoid,avoid,1669,doc/master/classTGMenuBar.html,https://root.cern,https://root.cern/doc/master/classTGMenuBar.html,1,['avoid'],['avoid']
Safety,"interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));. Deprecation of legacy iterators; The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34. They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. RooAbsArg::clientIterator(): use clients() and begin(), end() or range-based loops instead; RooAbsArg::valueClientIterator(): use valueClients(); RooAbsArg::shapeClientIterator(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11661,safe,safe,11661,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:39073,avoid,avoids,39073,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['avoid'],['avoids']
Safety,"ints by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up functions use:; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; Note: CleanUpPush and CleanUpPop should be used as corresponding pairs like brackets; unlike pthreads cleanup stack (which is not implemented here), TThread does not force this usage.; 23.2.4.7 Finishing thread; When a thread returns from a user function the thread is finished. It also can be finished by TThread::Exit(). Then, in case of thread-detached mode, the thread vanishes completely. By default, on finishing TThread executes the most recent cleanup function (CleanUpPop(1) is called automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1112811,safe,safe,1112811,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11642,avoid,avoid,11642,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11708,avoid,avoid,11708,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11710,avoid,avoid,11710,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11710,avoid,avoid,11710,root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['avoid'],['avoid']
Safety,"ion (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 238 of file TSQLFile.h. ◆ ReadConfigurations(). Bool_t TSQLFile::ReadConfigurations ; (; ). protected . read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84410,Recover,Recover,84410,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['Recover'],['Recover']
Safety,"ion = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCtub.html:2775,safe,safe,2775,root/html530/TGeoCtub.html,https://root.cern,https://root.cern/root/html530/TGeoCtub.html,1,['safe'],['safe']
Safety,ion Buttons.h:20; kButton3Motion@ kButton3MotionDefinition Buttons.h:20; kButton3Down@ kButton3DownDefinition Buttons.h:17; kButton2Down@ kButton2DownDefinition Buttons.h:17; kKeyPress@ kKeyPressDefinition Buttons.h:20; kButton2Double@ kButton2DoubleDefinition Buttons.h:24; kArrowKeyRelease@ kArrowKeyReleaseDefinition Buttons.h:21; kButton1Double@ kButton1DoubleDefinition Buttons.h:24; kButton3Double@ kButton3DoubleDefinition Buttons.h:24; kButton1Shift@ kButton1ShiftDefinition Buttons.h:18; kButton1Motion@ kButton1MotionDefinition Buttons.h:20; kButton1Up@ kButton1UpDefinition Buttons.h:19; kWheelDown@ kWheelDownDefinition Buttons.h:18; kArrowKeyPress@ kArrowKeyPressDefinition Buttons.h:21; kButton2Up@ kButton2UpDefinition Buttons.h:19; kMouseLeave@ kMouseLeaveDefinition Buttons.h:23; kButton1Down@ kButton1DownDefinition Buttons.h:17; kMouseEnter@ kMouseEnterDefinition Buttons.h:23; ECursorECursorDefinition GuiTypes.h:372; kCross@ kCrossDefinition GuiTypes.h:374; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Size_tfloat Size_tDefinition RtypesCore.h:89; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; Version_tshort Version_tDefinition RtypesCore.h:65; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; kRed@ kRedDefinition Rtypes.h:66; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TAxis.h; TBox.h; TBuffer.h; TCanvasImp.h; ROOT_TCanvas_Updatevoid ROOT_TCanvas_Update(void *TheCanv,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:91523,Safe,SafeDelete,91523,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"ion TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:42593,timeout,timeout,42593,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,2,['timeout'],['timeout']
Safety,"ion about TGListTree and TGListTreeItem that represents given TEveElement ;  CTEveElementEditorEditor for TEveElement class ;  CTEveElementListA list of TEveElements ;  CTEveElementListProjectedA projected element list – required for proper propagation of render state to projected views ;  CTEveEventManagerBase class for event management and navigation ;  CTEveExceptionException class thrown by TEve classes and macros ;  CTEveFrameBoxDescription of a 2D or 3D frame that can be used to visually group a set of objects ;  CTEveFrameBoxGLA class encapsulating GL rendering of TEveFrameBox via a static member function ;  CTEveGDoubleValuatorComposite GUI element for selection of range (label, two number-entries and double-slider) ;  CTEveGedEditorSpecialization of TGedEditor for proper update propagation to TEveManager ;  CTEveGedNameFrameSpecialization of TGedNameFrame used in EVE ;  CTEveGedNameTextButtonSpecialization of TGTextButton for EVE name frame ;  CTEveGeoManagerHolderException safe wrapper for setting gGeoManager ;  CTEveGeoNodeWrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement ;  CTEveGeoNodeEditorEditor for TEveGeoNode class ;  ►CTEveGeoPolyShapeDescription of TEveGeoPolyShape ;  CEdge_t;  CTEveGeoShapeWrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections) ;  CTEveGeoShapeExtractGlobally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts ;  CTEveGeoShapeProjectedA 3D projected TEveGeoShape ;  CTEveGeoTopNodeA wrapper over a TGeoNode, possibly displaced with a global trasformation stored in TEveElement ;  CTEveGeoTopNodeEditorEditor for TEveGeoTopNode class ;  CTEveGListTreeEditorFrameComposite GUI frame for parallel display of a TGListTree and TEveGedEditor ;  CTEveGridStepperProvide discrete position coordinates for placement of obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:147827,safe,safe,147827,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['safe'],['safe']
Safety,"ion from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:174368,safe,safe,174368,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"ion from the currently loaded class library.; 4658/// - -1: Assume no class library loaded (emulated class).; 4659///; 4660/// Warning: If we create a new streamer info, whether or not the build; 4661/// optimizes is controlled externally to us by a global variable!; 4662/// Don't call us unless you have set that variable properly; 4663/// with TStreamer::Optimize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177119,safe,safe,177119,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"ion histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<PDF*>*fPDFBgdlist of PDFs (background); vector<PDF*>*fPDFSiglist of PDFs (signal) ; Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLikelihood.html:18851,avoid,avoid,18851,root/html530/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLikelihood.html,3,['avoid'],['avoid']
Safety,"ion in POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Implements TGeoBoolNode.; Definition at line 965 of file TGeoBoolNode.cxx. ◆ Contains(). Bool_t TGeoSubtraction::Contains ; (; const Double_t * ; point); const. overridevirtual . Find if a subtraction of two shapes contains a given point. ; Implements TGeoBoolNode.; Definition at line 1016 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoSubtraction::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 203 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoSubtraction::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1031 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoSubtraction::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1039 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoSubtraction::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1072 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoSubtraction::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 193 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoSubtractio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:16719,safe,safe,16719,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safe']
Safety,"ion is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; averWindow-averaging window of searched peaks, for details we refer to manual (applies only for Markov method). Peaks searching; Goal: to identify automatically the peaks in spectrum with the presence of the continuous background, one-fold coincidences (ridges) and statistical fluctuations - noise.; The common problems connected with correct peak identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; non-sensitivity of the algorithm to continuous background; non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; ability to identify peaks with different sigma. References:; [1] M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451. Examples of peak searching method; SearchHighRes function provides users with the possibility to vary the input parameters and with the access to the output deconvolved data in the destination spectrum. Based on the output data one can tune the parameters. Example 8 - Src.C; ; #include <TSpectrum2.h>; ; void Src(); {; const Int_t nbinsx = 64;; const Int_t nbinsy = 64;; std::vector<Double_t *> source(nbinsx)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2.html:36217,detect,detect,36217,doc/master/classTSpectrum2.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2.html,1,['detect'],['detect']
Safety,"ion specifier. Case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). See TBufferFile::WriteFloat16 for more information.; see example of use of the Double32_t data type in tutorial double32.C . Implements TBuffer.; Definition at line 678 of file TBufferFile.cxx. ◆ WriteFastArray() [1/15]. void TBufferFile::WriteFastArray ; (; const Bool_t * ; b, . Long64_t ; n . ). overridevirtual . Write array of n bools into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 1982 of file TBufferFile.cxx. ◆ WriteFastArray() [2/15]. void TBufferFile::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2010 of file TBufferFile.cxx. ◆ WriteFastArray() [3/15]. void TBufferFile::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). overridevirtual . Write array of n doubles into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2236 of file TBufferFile.cxx. ◆ WriteFastArray() [4/15]. void TBufferFile::WriteFastArray ; (; const Float_t * ; f, . Long64_t ; n . ). overridevirtual . Write array of n floats into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:81423,abort,aborts,81423,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"ion to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); Creates key for object and converts ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28648,Recover,Recover,28648,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['Recover'],['Recover']
Safety,"ion with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1028028,safe,safety,1028028,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"ion), inputColumns, variationTags, variationName);; 954 }; 955 ; 956 /// \brief Register systematic variations for multiple existing columns using custom variation tags.; 957 /// \param[in] colNames set of names of the columns for which varied values are provided.; 958 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 959 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 960 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 961 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 962 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 963 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 964 /// colName is used if none is provided.; 965 ///; 966 /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; 967 /// is avoided.; 968 ///; 969 /// \sa This Vary() overload for more information.; 970 template <typename F>; 971 RInterface<Proxied, DS_t>; 972 Vary(std::initializer_list<std::string> colNames, F &&expression, const ColumnNames_t &inputColumns,; 973 const std::vector<std::string> &variationTags, std::string_view variationName); 974 {; 975 return Vary(std::vector<std::string>(colNames), std::forward<F>(expression), inputColumns, variationTags, variationName);; 976 }; 977 ; 978 /// \brief Register systematic variations for multiple existing columns using auto-generated tags.; 979 /// \param[in] colNames set of names of the columns for which varied values are provided.; 980 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 981 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 982 /// return an RVec of varied valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:52608,avoid,avoided,52608,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['avoid'],['avoided']
Safety,"ion, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:2023,predict,predictions,2023,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['predict'],['predictions']
Safety,"ion. Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,.... Note that the passed dataSize is not the size of the array but is the number of points (N); The size of the array must be at least dataDim*dataSize. ~TKDTreeBinning(); Class's destructor. void SetNBins(UInt_t bins); Sets binning inner structure. void SortBinsByDensity(Bool_t sortAsc = kTRUE); Sorts bins by their density. void SetData(Double_t* data); Sets the data and finds minimum and maximum by dimensional coordinate. void SetTreeData(); Sets the data for constructing the kD-tree. void SetBinsContent(); Sets the bins' content. void SetBinsEdges(); Sets the bins' edges; Double_t* rawBinEdges = fDataBins->GetBoundaryExact(fDataBins->GetNNodes());. void SetBinMinMaxEdges(Double_t* binEdges); Sets the bins' minimum and maximum edges. void SetCommonBinEdges(Double_t* binEdges); Sets indexing on the bin edges which have common boundaries. void ReadjustMinBinEdges(Double_t* binEdges); Readjusts the bins' minimum edge by shifting it slightly lower; to avoid overlapping with the data. void ReadjustMaxBinEdges(Double_t* binEdges); Readjusts the bins' maximum edge; and shift it sligtly higher. const Double_t* GetBinsMinEdges() const; Returns the bins' minimum edges. const Double_t* GetBinsMaxEdges() const; Returns the bins' maximum edges. std::pair<const Double_t*, const Double_t*> GetBinsEdges() const; Returns the bins' edges. const Double_t* GetBinMinEdges(UInt_t bin) const; Returns the bin's minimum edges. 'bin' is between 0 and fNBins - 1. const Double_t* GetBinMaxEdges(UInt_t bin) const; Returns the bin's maximum edges. 'bin' is between 0 and fNBins - 1. std::pair<const Double_t*, const Double_t*> GetBinEdges(UInt_t bin) const; Returns the bin's edges. 'bin' is between 0 and fNBins - 1. UInt_t GetNBins() const; Returns the number of bins. UInt_t GetDim() const; Returns the number of dimensions. UInt_t GetBinContent(UInt_t bin) const; Returns the number of points in bin. 'bin' is between 0 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TKDTreeBinning.html:9990,avoid,avoid,9990,root/html530/TKDTreeBinning.html,https://root.cern,https://root.cern/root/html530/TKDTreeBinning.html,5,['avoid'],['avoid']
Safety,"ionOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; - The first argument is the base of the name of all the output; weight files in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TMVA session.; For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; option string; ; - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; input variables; ***/; ; TMVA::Factory factory(; ""TMVA_CNN_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification:Transformations=None:!Correlations"");; ; /***; ; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; **/; ; TMVA::DataLoader loader(""dataset"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:50035,avoid,avoid,50035,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['avoid'],['avoid']
Safety,"ion_t TGeoGtra::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 177 of file TGeoArb8.h. ◆ DeclFileName(). static const char * TGeoGtra::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 177 of file TGeoArb8.h. ◆ DistFromInside(). Double_t TGeoGtra::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromInside_v(). void TGeoGtra::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside(). Double_t TGeoGtra::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoGtra::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoGtra::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetTwistAngle(). Double_t TGeoGtra::GetTwistAngle ; (; ); const. inline . Definition at line 171 of file TGeoArb8.h. ◆ IsA(). TClass * TGeoGtra::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 177 of file TGeoArb8.h. ◆ Safety(). Double_t TGeoGtra::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Safety_v(). void TGeoGtra::Safety_v ; (; const Double_t * ; p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:29149,safe,safe,29149,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety,"ion_t TGeoTrap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TGeoArb8.h. ◆ DeclFileName(). static const char * TGeoTrap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TGeoArb8.h. ◆ DistFromInside(). Double_t TGeoTrap::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromInside_v(). void TGeoTrap::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside(). Double_t TGeoTrap::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ DistFromOutside_v(). void TGeoTrap::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Divide(). TGeoVolume * TGeoTrap::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoArb8. ◆ GetAlpha1(). Double_t TGeoTrap::GetAlpha1 ; (; ); const. inline . Definition at line 135 of file TGeoArb8.h. ◆ GetAlpha2(). Double_t TGeoTrap::GetAlpha2 ; (; ); const. inline . Definition at line 139 of file TGeoArb8.h. ◆ GetBl1(). Double_t TGeoTrap::GetBl1 ; (; ); const. inline . Definition at line 133 of file TGeoArb8.h. ◆ GetBl2(). Double_t TGeoTrap::GetBl2 ; (; ); const. inline . Definition at line 137 of file TGeoArb8.h. ◆ GetH1(). Double_t TGeoTrap::GetH1 ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:27166,safe,safe,27166,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['safe'],['safe']
Safety,"ion_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCtubDefinition TGeoTube.h:173; TGeoCtub::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:208; TGeoCtub::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoCtub::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoCtub::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoCtub::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoCtub::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoCtub::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoCtub::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoCtub::GetNlowconst Double_t * GetNlow() constDefinition TGeoTube.h:213; TGeoCtub::TGeoCtubTGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoCtub::TGeoCtubTGeoCtub(); TGeoCtub::SetPointsvoid SetPoints(Float_t *points) const override; TGeoCtub::CapacityDouble_t Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:13830,safe,safe,13830,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:125653,detect,detector,125653,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['detect'],['detector']
Safety,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:16178,safe,safety,16178,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,2,['safe'],['safety']
Safety,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoChecker.html:16297,safe,safety,16297,root/html534/TGeoChecker.html,https://root.cern,https://root.cern/root/html534/TGeoChecker.html,3,['safe'],['safety']
Safety,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:5164,risk,risk,5164,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['risk'],['risk']
Safety,"ions the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:4943,risk,risk,4943,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['risk'],['risk']
Safety,"ions the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:4943,risk,risk,4943,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['risk'],['risk']
Safety,"ions:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IBaseParam.html:1764,avoid,avoid,1764,root/html602/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"ions:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); ROOT::Math::IBaseParamIBaseParam(); ROOT::Math::IBaseParamIBaseParam(const ROOT::Math::IBaseParam&); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IBaseParam.html:1764,avoid,avoid,1764,root/html604/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,ions;  IntegratorMultiDimOptions (const IntegratorMultiDimOptions &rhs);  copy constructor ;  ;  IntegratorMultiDimOptions (IOptions *extraOpts=nullptr);  constructor using the default options can pass a pointer to extra options (N.B. ;  ;  ~IntegratorMultiDimOptions () override;  ; std::string Integrator () const override;  name of multi-dim integrator ;  ; IntegrationMultiDim::Type IntegratorType () const;  type of the integrator (return the enumeration type) ;  ; unsigned int NCalls () const;  maximum number of function calls ;  ; IntegratorMultiDimOptions & operator= (const IntegratorMultiDimOptions &rhs);  assignment operator ;  ; void Print (std::ostream &os=std::cout) const;  print all the options ;  ; void SetIntegrator (const char *name);  set multi-dim integrator name ;  ; void SetNCalls (unsigned int calls);  set maximum number of function calls ;  ;  Public Member Functions inherited from ROOT::Math::BaseIntegratorOptions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Static Public Member Functions; static ROOT::Math::IOptions & Default (const char *name);  retrieve specific options ;  ; static double DefaultAbsTolerance ();  ; static std::string DefaultIntegrator ();  ; static IntegrationMultiDim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html:1581,avoid,avoid,1581,doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,1,['avoid'],['avoid']
Safety,"iply vector in-place. ; Definition at line 727 of file REveTrans.cxx. ◆ MultLeft(). void REveTrans::MultLeft ; (; const REveTrans & ; t). Multiply from left: this = t * this. ; Definition at line 299 of file REveTrans.cxx. ◆ MultRight(). void REveTrans::MultRight ; (; const REveTrans & ; t). Multiply from right: this = this * t. ; Definition at line 315 of file REveTrans.cxx. ◆ Norm3Column(). Double_t REveTrans::Norm3Column ; (; Int_t ; col). protected . Norm 3-vector in column col. ; Definition at line 823 of file REveTrans.cxx. ◆ operator()() [1/2]. Double_t & ROOT::Experimental::REveTrans::operator() ; (; Int_t ; i, . Int_t ; j . ). inline . Definition at line 116 of file REveTrans.hxx. ◆ operator()() [2/2]. Double_t ROOT::Experimental::REveTrans::operator() ; (; Int_t ; i, . Int_t ; j . ); const. inline . Definition at line 115 of file REveTrans.hxx. ◆ operator*(). REveTrans REveTrans::operator* ; (; const REveTrans & ; t). Copy, multiply from right and return product. ; Avoid unless necessary. ; Definition at line 332 of file REveTrans.cxx. ◆ operator*=(). void ROOT::Experimental::REveTrans::operator*= ; (; const REveTrans & ; t). inline . Definition at line 76 of file REveTrans.hxx. ◆ operator=(). REveTrans & ROOT::Experimental::REveTrans::operator= ; (; const REveTrans & ; t). inline . Definition at line 63 of file REveTrans.hxx. ◆ operator[]() [1/2]. Double_t & ROOT::Experimental::REveTrans::operator[] ; (; Int_t ; i). inline . Definition at line 110 of file REveTrans.hxx. ◆ operator[]() [2/2]. Double_t ROOT::Experimental::REveTrans::operator[] ; (; Int_t ; i); const. inline . Definition at line 109 of file REveTrans.hxx. ◆ Orto3Column(). Double_t REveTrans::Orto3Column ; (; Int_t ; col, . Int_t ; ref . ). protected . Orto-norm 3-vector in column col with respect to column ref. ; Definition at line 834 of file REveTrans.cxx. ◆ OrtoNorm3(). void REveTrans::OrtoNorm3 ; (; ). Orto-norm columns 1 to 3. ; Definition at line 846 of file REveTrans.cxx. ◆ Print(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrans.html:24040,Avoid,Avoid,24040,doc/master/classROOT_1_1Experimental_1_1REveTrans.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrans.html,1,['Avoid'],['Avoid']
Safety,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); Set paraboloid dimensions. void SetDimensions(Double_t* param); Set paraboloid dimensions starting from an array. void SetPoints(Double_t* points) const; Create paraboloid mesh points.; Npoints = n*(n+1) + 2; ifirst = 0; ipoint(i,j) = 1+i*n+j; i=[0,n] j=[0,n-1]; ilast = 1+n*(n+1); Nsegments = n*(2*n+3); lower: (0, j+1); j=[0,n-1]; circle(i): (n*i+1+j, n*i+1+(j+1)%n); i=[0,n] j=[0,n-1]; generator(i): (n*i+1+j, n*(i+1)+1+j); i,j=[0,n-1]; upper: (n*n+1+j, (n+1)*n+1) j=[0,n-1]; Npolygons = n*(n+2); lower: (n+j, (j+1)%n, j) j=[0,n-1]; lateral(i): ((2*i+1)*n+j, 2*(i+1)*n+j, (2*i+3)*n+j, 2*(i+1)*n+(j+1)%n); i,j = [0,n-1]; upper: ((2n+1)*n+j, 2*n*(n+1)+(j+1)%n, 2*n*(n+1)+j) j=[0,n-1]. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:14072,Safe,Safety,14072,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,1,['Safe'],['Safety']
Safety,"ir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:23122,safe,safe,23122,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,6,['safe'],['safe']
Safety,"irectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:10288,avoid,avoid,10288,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,4,['avoid'],['avoid']
Safety,"irtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerMulti.html:5761,abort,abort,5761,root/html528/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"irtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSphere.html:8695,safe,safe,8695,root/html602/TGeoSphere.html,https://root.cern,https://root.cern/root/html602/TGeoSphere.html,2,['safe'],['safe']
Safety,"irtual Bool_t CompileVariables ();  Compiles each variable from fTreeDrawArgsParser for the tree fTree. ;  ; void FillWeight ();  Get weight from input list, if any. ;  ; virtual Bool_t ProcessSingle (Long64_t, Int_t);  Processes a single variable from an entry. ;  ; void SetCanvas (const char *objname);  Move to a canvas named <name>_canvas; create the canvas if not existing. ;  ; void SetDrawAtt (TObject *o);  Set the drawing attributes from the input list. ;  ; void SetError (const char *sub, const char *mesg);  Sets the error status. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TProfile2D * fProfile;  ;  Protected Attributes inherited from TProofDraw; Int_t fDimension;  ; TString fInitialExp;  ; TTreeFormulaManager * fManager;  ; Int_t fMultiplicity;  ; Bool_t fObjEval;  ; TTreeFormula * fSelect;  ; TString fSelection;  ; TStatus * fStatus;  ; TTree * fTree;  ; TTreeDrawArgsParser fTreeDrawArgsParser;  ; TTreeFormula * fVar [4];  ; Double_t fWeight;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawProfile2D.html:13102,Abort,Abort,13102,doc/master/classTProofDrawProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawProfile2D.html,1,['Abort'],['Abort']
Safety,"irtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:17622,timeout,timeout,17622,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['timeout'],['timeout']
Safety,"irtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:7684,safe,safe,7684,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,1,['safe'],['safe']
Safety,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:94028,avoid,avoid,94028,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"is not given, the name of the key will be the name as returned; 1889/// by obj->GetName().; 1890///; 1891/// The option can be a combination of:; 1892/// - ""SingleKey""; 1893/// - ""Overwrite""; 1894/// - ""WriteDelete""; 1895/// Using the ""Overwrite"" option a previous key with the same name is; 1896/// overwritten. The previous key is deleted before writing the new object.; 1897/// Using the ""WriteDelete"" option a previous key with the same name is; 1898/// deleted only after the new object has been written. This option; 1899/// is safer than kOverwrite but it is slower.; 1900/// The ""SingleKey"" option is only used by TCollection::Write() to write; 1901/// a container with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1919 return 0;; 1920 }; 1921 ; 1922 if (!fFile->IsWritable()) {; 1923 if (!fFile->TestBit(TFile::kWriteError)) {; 1924 // Do not print the error if the file already had a SysError.; 1925 Error(""WriteTObject"",""Directory %s is not writable"", fFile->GetName());; 1926 }; 1927 return 0;; 1928 }; 1929 ; 1930 if (!obj) return 0;; 1931 ; 1932 TString opt = option;; 1933 opt.ToLower();; 1934 ; 1935 TKey *key=0, *oldke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:65558,avoid,avoid,65558,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );; 4194 ; 4195 if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject; 4196 && fundType->GetType() > 0) {; 4197 // Fundamental type, no a class.; 4198 return kUnknown;; 4199 }; 4200 ; 4201 // Migrated from within TClass::GetClass; 4202 // If we want to know if a class or a namespace with this name exists in the; 4203 // interpreter and this is an enum in the type system, before or after loading; 4204 // according to the autoload function argument, return kUnknown.; 4205 if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone)); 4206 return kUnknown;; 4207 ; 4208 const char *classname = name;; 4209 ; 4210 // RAII to suspend and restore auto-loading and auto-parsing based on some ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:162360,Avoid,Avoid,162360,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"is painted; 49 - then the sum of the first and second histograms is painted, and so on; 50 ; 51The axis ranges are computed automatically along the X and Y axes to display the complete; 52histogram collection.; 53 ; 54Warning: Histogram bins with negative content may produce wrong plots.; 55 ; 56### Stack's drawing options; 57 ; 58The specific stack's drawing options are:; 59 ; 60 - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; 61 as if the option ""same"" had been specified.; 62 ; 63 - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THStack_8cxx_source.html:2660,avoid,avoids,2660,doc/master/THStack_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html,1,['avoid'],['avoids']
Safety,"is robj is read by TObject::Streamer, the pidf is read. At this point, robj is entered into the table of objects of the TProcessID corresponding to pidf. WARNING1:; If MyClass is the class of the referenced object, The TObject part of MyClass must be Streamed. One should not call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2:; A TRef cannot point to another TRef. ObjectNumber; When an object is referenced (see TRef assignment operator or TRefArray::Add) a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. fUniqueID is some sort of serial object number in the current session. One can retrieve at any time the current value of fgNumber by calling the static function TProcessID::GetObjectCount or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the ObjectNumber at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be saved at the beginning of one event and reset to this original value at the end of the event via TProcessID::SetObjectCount(saveNumber). These actions may be stacked. Action on Demand; The normal behaviour of a TRef has been described above. In addition, TRef supports also ""Actions on Demand"". It may happen that the object referenced is not yet in memory, on a separate file or not yet computed. In this case TRef is able to automatically execute an action:. call to a compiled function (static function of member function); call to an interpreted function; execution of a C++ script. How to select this option? In the definition of the TRef data member in the original class, do: TRef fRef; //EXEC:execName. points to something; When the special key",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:4469,avoid,avoid,4469,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['avoid'],['avoid']
Safety,"is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9857,safe,safety,9857,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safety']
Safety,"is, name, classname, addr, bufsize, 0, /*compress=*/ ROOT::RCompressionSetting::EAlgorithm::kInherit, isptrptr);; 2513 fBranches.Add(branch);; 2514 return branch;; 2515 }; 2516 ; 2517 if (cl == TClonesArray::Class()) {; 2518 // Special case of TClonesArray.; 2519 // No dummy object is created.; 2520 // The streamer info is not rebuilt unoptimized.; 2521 // No dummy top-level branch is created.; 2522 // No splitting is attempted.; 2523 TBranchElement* branch = new TBranchElement(this, name, (TClonesArray*) objptr, bufsize, splitlevel%kSplitCollectionOfPointers);; 2524 fBranches.Add(branch);; 2525 if (isptrptr) {; 2526 branch->SetAddress(addr);; 2527 } else {; 2528 branch->SetObject(addr);; 2529 }; 2530 return branch;; 2531 }; 2532 ; 2533 //; 2534 // If we are not given an object to use as an i/o buffer; 2535 // then create a temporary one which we will delete just; 2536 // before returning.; 2537 //; 2538 ; 2539 bool delobj = false;; 2540 ; 2541 if (!objptr) {; 2542 objptr = (char*) cl->New();; 2543 delobj = true;; 2544 }; 2545 ; 2546 //; 2547 // Avoid splitting unsplittable classes.; 2548 //; 2549 ; 2550 if ((splitlevel > 0) && !cl->CanSplit()) {; 2551 if (splitlevel != 99) {; 2552 Warning(""Bronch"", ""%s cannot be split, resetting splitlevel to 0"", cl->GetName());; 2553 }; 2554 splitlevel = 0;; 2555 }; 2556 ; 2557 //; 2558 // Make sure the streamer info is built and fetch it.; 2559 //; 2560 // If we are splitting, then make sure the streamer info; 2561 // is built unoptimized (data members are not combined).; 2562 //; 2563 ; 2564 TStreamerInfo* sinfo = BuildStreamerInfo(cl, objptr, splitlevel==0);; 2565 if (!sinfo) {; 2566 Error(""Bronch"", ""Cannot build the StreamerInfo for class: %s"", cl->GetName());; 2567 return nullptr;; 2568 }; 2569 ; 2570 //; 2571 // Create a dummy top level branch object.; 2572 //; 2573 ; 2574 Int_t id = -1;; 2575 if (splitlevel > 0) {; 2576 id = -2;; 2577 }; 2578 TBranchElement* branch = new TBranchElement(this, name, sinfo, id, objptr, bufsize,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:101263,Avoid,Avoid,101263,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"is.GetXmin())/fCellX;; 528 fStepY = (fYaxis.GetXmax() - fYaxis.GetXmin())/fCellY;; 529 ; 530 delete [] fIsEmpty;; 531 delete [] fCompletelyInside;; 532 fIsEmpty = new Bool_t [fNCells];; 533 fCompletelyInside = new Bool_t [fNCells];; 534 ; 535 // Initializes the flags; 536 for (int i = 0; i<fNCells; i++) {; 537 fIsEmpty[i] = kTRUE;; 538 fCompletelyInside[i] = kFALSE;; 539 }; 540 ; 541 // TList iterator; 542 TIter next(fBins);; 543 TObject *obj;; 544 ; 545 while((obj = next())){ // Loop over bins and add them to the partition; 546 AddBinToPartition((TH2PolyBin*) obj);; 547 }; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Make a complete copy of the underlying object. If 'newname' is set,; 552/// the copy's name will be set to that name.; 553 ; 554TObject* TH2Poly::Clone(const char* newname) const; 555{; 556 // TH1::Clone relies on ::Copy to implemented by the derived class.; 557 // Until this is implemented, revert to the much slower default version; 558 // (and possibly non-thread safe).; 559 ; 560 return TNamed::Clone(newname);; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Clears the contents of all bins in the histogram.; 565 ; 566void TH2Poly::ClearBinContents(); 567{; 568 TIter next(fBins);; 569 TObject *obj;; 570 TH2PolyBin *bin;; 571 ; 572 // Clears the bin contents; 573 while ((obj = next())) {; 574 bin = (TH2PolyBin*) obj;; 575 bin->ClearContent();; 576 }; 577 ; 578 // Clears the statistics; 579 fTsumw = 0;; 580 fTsumw2 = 0;; 581 fTsumwx = 0;; 582 fTsumwx2 = 0;; 583 fTsumwy = 0;; 584 fTsumwy2 = 0;; 585 fEntries = 0;; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Reset this histogram: contents, errors, etc.; 590 ; 591void TH2Poly::Reset(Option_t *opt); 592{; 593 TIter next(fBins);; 594 TObject *obj;; 595 TH2PolyBin *bin;; 596 ; 597 // Clears the bin contents; 598 while ((obj = next())) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:21210,safe,safe,21210,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['safe'],['safe']
Safety,"isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 // sanity check.; 2210 newType = -1;; 2211 }; 2212 }; 2213 }; 2214 }; 2215 }; 2216 ; 2217 if (newType > 0) {; 2218 // Case of a numerical type; 2219 if (element->GetType() >= TStreamerInfo::kObject) {; 2220 // Old type was not a numerical type.; 2221 element->SetNewType(TVirtualStreamerInfo::kUnsupportedConversion);; 2222 } else if (element->GetType() != newType) {; 2223 element->SetNewType(newType);; 2224 if (gDebug > 0) {; 2225 // coverity[mixed_enums] - All the values of EDataType have the same semantic in EReadWrite; 2226 Info(""BuildOld"", ""element: %s %s::%s has new type: %s/%d"", element->GetTypeName(), GetName(), element->GetName(), dm ? dm->GetFullTypeName() : TDataType::GetTypeName((EDataType)newType), newType);; 2227 }; 2228 }; 2229 } else if (newClass.GetClass()) {; 2230 // Sometime BuildOld is called again.; 2231 // In that case we might already have fix up the streamer element.; 2232 // So we need to go back to the original information!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:86116,sanity check,sanity check,86116,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"ison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:91662,avoid,avoid,91662,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"issing;; 2465 element->SetOffset(kMissing);; 2466 }; 2467 ; 2468 if (offset != kMissing && fClass->GetState() <= TClass::kEmulated && !fClass->fIsSyntheticPair) {; 2469 // Note the initialization in this case are; 2470 // delayed until __after__ the schema evolution; 2471 // section, just in case the info has changed.; 2472 ; 2473 // The class is NOT known to Cling, i.e. is emulated,; 2474 // and we need to use the calculated offset.; 2475 ; 2476 Int_t asize;; 2477 if (element->GetType() == TStreamerInfo::kSTL &&; 2478 strcmp(element->GetName(),""This"") == 0 &&; 2479 strcmp(element->GetTypeName(),GetName()) == 0 &&; 2480 !fClass->GetCollectionProxy()) {; 2481 // Humm .. we are missing the collection Proxy; 2482 // for a proxied (custom) collection ... avoid; 2483 // an infinite recursion and take a wild guess; 2484 asize = sizeof(std::vector<int>);; 2485 } else {; 2486 // Regular case; 2487 asize = element->GetSize();; 2488 }; 2489 // align the non-basic data types (required on alpha and IRIX!!); 2490 if ((offset % kSizeOfPtr) != 0) {; 2491 offset = offset - (offset % kSizeOfPtr) + kSizeOfPtr;; 2492 }; 2493 element->SetOffset(offset);; 2494 offset += asize;; 2495 }; 2496 ; 2497 if (!wasCompiled && rules) {; 2498 if (rules.HasRuleWithSource( element->GetName(), kTRUE ) ) {; 2499 ; 2500 if (allocClass == 0) {; 2501 infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()));; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.Has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:99050,avoid,avoid,99050,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFilePrefetch.html:7231,Safe,Safe,7231,root/html530/TFilePrefetch.html,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"ist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFilePrefetch.html:7359,Safe,Safe,7359,root/html532/TFilePrefetch.html,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"ist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ; file  statsEditing.C;   Edit statistics box. ;  ; file  testSmooth.C;   Histogram smoothing. ;  ; file  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ; file  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ; file  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ; file  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ; file  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ; file  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ; file  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  tprofile2polyRealistic.C;   Different charges depending on region ;  ; file  tprofile2polyRealisticModuleError.C;   Simulate faulty detector panel w.r.t. ;  ; file  transpad.C;   Example of a canvas showing two histograms with different scales. ;  ; file  twoscales.C;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  twoscales.py;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  xyplot.C;   Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ;  ; file  ZoomHistogram.C;   Changing the Range on the X-Axis of a Histogram ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__hist.html:6611,detect,detector,6611,doc/master/group__tutorial__hist.html,https://root.cern,https://root.cern/doc/master/group__tutorial__hist.html,1,['detect'],['detector']
Safety,"istFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0;  ; virtual void DistFromInside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const;  ; virtual Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0;  ; virtual void DistFromOutside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const;  ; virtual TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute mouse actions on this shape. ;  ; virtual const char * GetAxisName (Int_t iaxis) const =0;  ; virtual Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0;  ; virtual void GetBoundingCylinder (Double_t *param) const =0;  ; virtual const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const;  Stub implementation to avoid forcing implementation at this stage. ;  ; virtual Int_t GetByteCount () const =0;  ; virtual Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const =0;  ; Int_t GetId () const;  ; virtual TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const =0;  ; virtual void GetMeshNumbers (Int_t &, Int_t &, Int_t &) const;  ; const char * GetName () const override;  Get the shape name. ;  ; virtual Int_t GetNmeshVertices () const;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; virtual Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const =0;  ; virtual void InspectShape () const =0;  ; void InvertShapeBit (UInt_t f);  ; TClass * IsA () const override;  ; virtual Bool_t IsAssembly () const;  ; virtual Bool_t IsComposite () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:11247,avoid,avoid,11247,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['avoid'],['avoid']
Safety,"istance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:15969,safe,safe,15969,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,"istancetoPrimitive(Int_t px, Int_t py); virtual voidSetConnection(TShape* connection); Int_tTShape::ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TShape*fConnectionshape to represent the each ""end"" of the polyline; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tfHasDrawnflag to avoid multiply plots; Color_tTAttLine::fLineColorline color; Bool_tfLineFlagFlag whether we should connect the points with ""line"" (option ""L""); Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; Bool_tfPointFlagFlag whether we should paint ""points"" (option ""P""); TPoints3DABC*fPointsPolyLine itself; TShape*fShapeshape for draw each segment of the polylins; EShapeTypesfShapeTypeshape of the segment connections; _x3d_sizeof_*fSizeX3D! the X3D buffer sizes; Bool_tfSmoothMake smooth connections; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_tfWidthFactorfactor to calculate the the tube diameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPolyLineShape(); to be documented. TPolyLineShape(TPoints3DABC* points, Option_t* option = ""P""); fShape = new TTUBE(""tube"",""tube"",""void"",0.5,0.5);. ~TPolyLineShape(); to be documented. void Create(); to be documented. Size3D * CreateX3DSize(Bool_t marker = kFALSE); to be documented. Int_t SetConnection(EShapeTypes connection = kBrik); to be documented. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPolyLineShape.html:9836,avoid,avoid,9836,root/html528/TPolyLineShape.html,https://root.cern,https://root.cern/root/html528/TPolyLineShape.html,4,['avoid'],['avoid']
Safety,"istograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<TMVA::PDF*>*fPDFBgdlist of PDFs (background); vector<TMVA::PDF*>*fPDFSiglist of PDFs (signal); Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodLikelihood.html:20114,avoid,avoid,20114,root/html602/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodLikelihood.html,2,['avoid'],['avoid']
Safety,"ists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 211 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 212 Int_t GetNmeshVertices() const override;; 213 const Double_t *GetNlow() const { return &fNlow[0]; }; 214 const Double_t *GetNhigh() const { return &fNhigh[0]; }; 215 Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const;; 216 void InspectShape() const override;; 217 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 218 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 219 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 220 void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx,; 221 Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 222 void SetDimensions(Double_t *param) override;; 223 void SetPoints(Double_t *points) const override;; 224 void SetPoints(Float_t *points) const override;; 225 ; 226 ClassDefOverride(TGeoCtub, 1) // cut tube segment class; 227};; 228 ; 229#endif; b#define b(i)Definition RSha256.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:12105,Safe,Safety,12105,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:28807,safe,safely,28807,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,12,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"it(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10483,abort,abort,10483,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,1,['abort'],['abort']
Safety,"it(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:10584,abort,abort,10584,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,1,['abort'],['abort']
Safety,"it(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:11713,abort,abort,11713,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,1,['abort'],['abort']
Safety,"ite ; (; Option_t * ; option = """"); const. virtual . Paint this composite shape into the current 3D viewer Returns bool flag indicating if the caller should continue to paint child objects. ; Definition at line 429 of file TGeoCompositeShape.cxx. ◆ RegisterYourself(). void TGeoCompositeShape::RegisterYourself ; (; ). Register the shape and all components to TGeoManager class. ; Definition at line 475 of file TGeoCompositeShape.cxx. ◆ Safety(). Double_t TGeoCompositeShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 521 of file TGeoCompositeShape.cxx. ◆ Safety_v(). void TGeoCompositeShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 629 of file TGeoCompositeShape.cxx. ◆ SavePrimitive(). void TGeoCompositeShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 531 of file TGeoCompositeShape.cxx. ◆ SetDimensions(). void TGeoCompositeShape::SetDimensions ; (; Double_t * ; ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoCompositeShape.h. ◆ SetPoints() [1/2]. void TGeoCompositeShape::SetPoints ; (; Double_t * ; points); const. overridevirtual . create points for a composite shape ; Reimplemented from TGeoBBox.; Definition at line 548 of file TGeoCompositeShape.cxx. ◆ SetPoints() [2/2]. void TGeoCompositeShape::SetPoints ; (; Flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:43177,safe,safe,43177,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"iteBasket) {; 1202 // Nothing to do.; 1203 } else {; 1204 basket->DropBuffers();; 1205 if (basket == fCurrentBasket) {; 1206 fCurrentBasket = nullptr;; 1207 fFirstBasketEntry = -1;; 1208 fNextBasketEntry = -1;; 1209 }; 1210 delete basket;; 1211 --fNBaskets;; 1212 fBaskets[ibasket] = nullptr;; 1213 }; 1214 }; 1215 }; 1216 }; 1217 return nbytes;; 1218}; 1219 ; 1220////////////////////////////////////////////////////////////////////////////////; 1221/// Return pointer to basket basketnumber in this Branch; 1222///; 1223/// If a new buffer must be created and the user_buffer argument is non-null,; 1224/// then the memory in the user_buffer will be shared with the returned TBasket.; 1225 ; 1226TBasket* TBranch::GetBasketImpl(Int_t basketnumber, TBuffer *user_buffer); 1227{; 1228 // This counter in the sequential case collects errors coming also from; 1229 // different files (suppose to have a program reading f1.root, f2.root ...); 1230 // In the mt case, it is made atomic: it safely collects errors from; 1231 // different files processed simultaneously.; 1232 static std::atomic<Int_t> nerrors(0);; 1233 ; 1234 // reference to an existing basket in memory ?; 1235 if (basketnumber <0 || basketnumber > fWriteBasket) return nullptr;; 1236 TBasket *basket = (TBasket*)fBaskets.UncheckedAt(basketnumber);; 1237 if (basket) return basket;; 1238 if (basketnumber == fWriteBasket) return nullptr;; 1239 ; 1240 // create/decode basket parameters from buffer; 1241 TFile *file = GetFile(0);; 1242 if (file == nullptr) {; 1243 return nullptr;; 1244 }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:42958,safe,safely,42958,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['safe'],['safely']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:16574,avoid,avoid,16574,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,2,['avoid'],['avoid']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(const TF1* f1) const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effective variance"" m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph.html:15578,avoid,avoid,15578,root/html532/TGraph.html,https://root.cern,https://root.cern/root/html532/TGraph.html,1,['avoid'],['avoid']
Safety,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(const TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:16081,avoid,avoid,16081,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,1,['avoid'],['avoid']
Safety,"ithin; Project2(). - TreatEmptyCells - if this option is set false (default),; it is not checked, wether the cell or its neighbors are empty; or not. If this option is set true, than only non-empty; neighbor cells are taken into account for weighting. If the; cell, which contains txvec is empty, than its value is; replaced by the average value of the non-empty neighbor cells. Float_t WeightGaus(TMVA::PDEFoamCell* , vector<Float_t>& , UInt_t dim = 0); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). - dim - number of dimensions for the calculation of the euclidean distance.; If dim=0, all dimensions of the foam are taken. Else only the first 'dim'; coordinates of 'txvec' are used for the calculation of the euclidean distance. Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. TMVA::PDEFoamCell* FindCell(vector<Float_t>& ); Find cell that contains 'xvec' (in foam coordinates [0,1]). Loop to find cell that contains 'xvec' starting at root cell,; and traversing binary tree to find the cell quickly. Note, that; if 'xvec' lies outside the foam, the cell which is nearest to; 'xvec' is returned. (The returned pointer should never be; NULL.). void FindCellsRecursive(vector<Float_t>& , TMVA::PDEFoamCell* , vector<TMVA::PDEFoamCell*,allocator<TMVA::PDEFoamCell*> >& ); This is a helper function for FindCells(). It saves in 'cells'; all cells, which contain txvec. It works analogous to; FindCell(). Parameters:. - txvec - vector of variables (no targets!) (transformed into; foam). - cell - cell to start searching with (usually root cell; fCells[0]). - cells - list of cells found. std::vector<TMVA::PDEFoamCell*> FindCells(vector<Float_t>& ); Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:23178,avoid,avoid,23178,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['avoid'],['avoid']
Safety,"ithout affecting the cache stack. ; Definition at line 2657 of file TGeoNavigator.cxx. ◆ FindInCluster(). TGeoNode * TGeoNavigator::FindInCluster ; (; Int_t * ; cluster, . Int_t ; nc . ). protected . Find a node inside a cluster of overlapping nodes. ; Current node must be on top of all the nodes in cluster. Always nc>1. ; Definition at line 2159 of file TGeoNavigator.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoNavigator::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 624 of file TGeoNavigator.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoNavigator::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 1178 of file TGeoNavigator.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoNavigator::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:27427,safe,safe,27427,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"itialize GD path search. ;  ; Double_t LossFunction (const Event &e) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; Double_t LossFunction (UInt_t evtidx) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; Double_t LossFunction (UInt_t evtidx, UInt_t itau) const;  Implementation of squared-error ramp loss function (eq 39,40 in ref 1) This is used for binary Classifications where y = {+1,-1} for (sig,bkg) ;  ; void MakeGDPath ();  The following finds the gradient directed path in parameter space. ;  ; Double_t Penalty () const;  This is the ""lasso"" penalty To be used for regression. ;  ; Double_t Risk (UInt_t ind1, UInt_t ind2, Double_t neff) const;  risk assessment ;  ; Double_t Risk (UInt_t ind1, UInt_t ind2, Double_t neff, UInt_t itau) const;  risk assessment for tau model <itau> ;  ; Double_t RiskPath () const;  ; Double_t RiskPerf () const;  ; Double_t RiskPerf (UInt_t itau) const;  ; UInt_t RiskPerfTst ();  Estimates the error rate with the current set of parameters. ;  ; void SetGDErrScale (Double_t s);  ; void SetGDNPathSteps (Int_t np);  ; void SetGDPathStep (Double_t s);  ; void SetGDTau (Double_t t);  ; void SetGDTauPrec (Double_t p);  ; void SetGDTauRange (Double_t t0, Double_t t1);  ; void SetGDTauScan (UInt_t n);  ; void SetMsgType (EMsgType t);  ; void SetRuleFit (RuleFit *rf);  ; Int_t Type (const Event *e) const;  . Protected Types; typedef std::vector< constTMVA::Event * >::const_iterator EventItr;  . Protected Member Functions; Double_t CalcAverageResponse ();  calculate the average response - TODO : rewrite bad dependancy on EvaluateAverage() ! ;  ; Double_t CalcAverageResponseOLD ();  ; Double_t CalcAverageTruth ();  calculate the average truth ;  ; void CalcFStar ();  Estimates F* (optimum scoring function) for all events for the given ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:1756,Risk,Risk,1756,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,8,"['Risk', 'risk']","['Risk', 'RiskPath', 'RiskPerf', 'RiskPerfTst', 'risk']"
Safety,ition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TRO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:160878,detect,detected,160878,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['detect'],['detected']
Safety,ition TROOT.cxx:2895; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TRO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:161054,detect,detected,161054,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['detect'],['detected']
Safety,"ition at line 1889 of file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:88711,Recover,Recover,88711,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Recover'],['Recover']
Safety,"ition at line 2630 of file TWinNTSystem.cxx. ◆ ResetSignal(). void TWinNTSystem::ResetSignal ; (; ESignals ; sig, . Bool_t ; reset = kTRUE . ). overridevirtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 1425 of file TWinNTSystem.cxx. ◆ ResetSignals(). void TWinNTSystem::ResetSignals ; (; ). overridevirtual . Reset signals handlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 1433 of file TWinNTSystem.cxx. ◆ Select() [1/2]. Int_t TWinNTSystem::Select ; (; TFileHandler * ; h, . Long_t ; to . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4628 of file TWinNTSystem.cxx. ◆ Select() [2/2]. Int_t TWinNTSystem::Select ; (; TList * ; active, . Long_t ; timeout . ). overridevirtual . Select on file descriptors. The timeout to is in millisec. ; Reimplemented from TSystem.; Definition at line 4591 of file TWinNTSystem.cxx. ◆ SendBuf(). int TWinNTSystem::SendBuf ; (; int ; sock, . const void * ; buf, . int ; length . ). overridevirtual . Send a buffer headed by a length indicator. ; Returns length of sent buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 4945 of file TWinNTSystem.cxx. ◆ SendRaw(). int TWinNTSystem::SendRaw ; (; int ; sock, . const void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 5010 of file TWinNTSystem.cxx. ◆ SetDynamicPath(). void TWinNTSystem::SetDynamicPath ; (; const char * ; path). overridevirtual . Set the dynamic path to a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:68711,timeout,timeout,68711,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"ition at line 379 of file TPad.cxx. Member Function Documentation. ◆ AbsCoordinates(). void TPad::AbsCoordinates ; (; Bool_t ; set). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 167 of file TPad.h. ◆ AbsPixeltoX(). Double_t TPad::AbsPixeltoX ; (; Int_t ; px). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 168 of file TPad.h. ◆ AbsPixeltoXY(). void TPad::AbsPixeltoXY ; (; Int_t ; xpixel, . Int_t ; ypixel, . Double_t & ; x, . Double_t & ; y . ). virtual . Convert absolute pixel into X/Y coordinates. ; Definition at line 7378 of file TPad.cxx. ◆ AbsPixeltoY(). Double_t TPad::AbsPixeltoY ; (; Int_t ; py). inlineoverridevirtual . Implements TVirtualPad.; Definition at line 169 of file TPad.h. ◆ Add(). void TPad::Add ; (; TObject * ; obj, . Option_t * ; opt = """", . Bool_t ; modified = kTRUE . ). overridevirtual . Add an object to list of primitives with speicified draw option When. ; modified set to kTRUE (default) pad will be marked as modifiedLet avoid usage of gPad when drawing object(s) in canvas or in subpads.; auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; c1->Divide(2,2);; ; for (Int_t n = 1; n <= 4; ++n) {; auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; h1->FillRandom(""gaus"", 2000 + n*1000);; c1->GetPad(n)->Add(h1);; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; int; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5. Implements TVirtualPad.; Definition at line 418 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:54839,avoid,avoid,54839,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety,"ition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:22115,safe,safe,22115,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:22076,safe,safe,22076,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:25315,safe,safe,25315,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 57 of file TGeoVGShape.h. ◆ Draw(). void TGeoVGShape::Draw ; (; Option_t * ; option = """"). inlineoverridevirtual . Draw this shape. ; Reimplemented from TGeoShape.; Definition at line 58 of file TGeoVGShape.h. ◆ GetAxisName(). const char * TGeoVGShape::GetAxisName ; (; Int_t ; iaxis); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoVGShape.h. ◆ GetAxisRange(). Double_t TGeoVGShape::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 60 of file TGeoVGShape.h. ◆ GetBoundingCylinder(). void TGeoVGShape::GetBoundingCylinder ; (; Double_t * ; param); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 64 of file TGeoVGShape.h. ◆ GetBuffer3D(). const TBuffer3D & TGeoVGShape::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. inlineoverridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoVGShape.h. ◆ GetByteCount(). Int_t TGeoVGShape::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 69 of file TGeoVGShape.h. ◆ GetFittingBox(). Int_t TGeoVGShape::GetFittingBox ; (; const TGeoBBox * ; parambox, . TGeoMatrix * ; mat, . Double_t & ; dx, . Double_t & ; dy, . Double_t & ; dz . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 76 of file TGeoVGShape.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoVGShape::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 80 of file TGeoVGShape.h. ◆ GetMeshNumbers(). void TGeoVGShape::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 84 of file TGeoVGShape.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:27289,avoid,avoid,27289,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['avoid'],['avoid']
Safety,"ition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21386,safe,safe,21386,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21478,safe,safe,21478,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety,"ition of ECellValue . Definition at line 119 of file PDEFoamKernelGauss.cxx. ◆ IsA(). virtual TClass * TMVA::PDEFoamKernelGauss::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::PDEFoamKernelBase.; Definition at line 61 of file PDEFoamKernelGauss.h. ◆ Sqr(). template<typename T > . T TMVA::PDEFoamKernelGauss::Sqr ; (; T ; x); const. inlineprotected . Definition at line 45 of file PDEFoamKernelGauss.h. ◆ Streamer(). virtual void TMVA::PDEFoamKernelGauss::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::PDEFoamKernelBase. ◆ StreamerNVirtual(). void TMVA::PDEFoamKernelGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file PDEFoamKernelGauss.h. ◆ WeightGaus(). Float_t TMVA::PDEFoamKernelGauss::WeightGaus ; (; PDEFoam * ; foam, . PDEFoamCell * ; cell, . std::vector< Float_t > & ; txvec . ). protected . Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. ; Parameters:; cell - the cell; txvec - the transformed event variables (in [0,1]) (coordinates <0 are set to 0, >1 are set to 1). Returns:. \[; e^(\frac{-(\frac{d}{\sigma})^2}{2}); \]. where:; d - is the euclidean distance between 'txvec' and the point of the 'cell' which is most close to 'txvec' (in order to avoid artefacts because of the form of the cells).; \( sigma = \frac{1}{VolFrac} \) . Definition at line 182 of file PDEFoamKernelGauss.cxx. Member Data Documentation. ◆ fSigma. Float_t TMVA::PDEFoamKernelGauss::fSigma. protected . width of gauss curve ; Definition at line 42 of file PDEFoamKernelGauss.h. Libraries for TMVA::PDEFoamKernelGauss:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/PDEFoamKernelGauss.h; tmva/tmva/src/PDEFoamKernelGauss.cxx. TMVAPDEFoamKernelGauss. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelGauss.html:15239,avoid,avoid,15239,doc/master/classTMVA_1_1PDEFoamKernelGauss.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"ition of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:15294,safe,safe,15294,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,2,['safe'],['safe']
Safety,"itional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987617,safe,safety,987617,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolume(); TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:16771,avoid,avoided,16771,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeAssembly(); TGeoVolumeAssembly(const char* name); TGeoVolumeAssembly(const TGeoVolumeAssembly&); virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:16734,avoid,avoided,16734,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeMulti(); TGeoVolumeMulti(const char* name, TGeoMedium* med = 0); virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:16725,avoid,avoided,16725,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,1,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:16771,avoid,avoided,16771,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:16734,avoid,avoided,16734,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['avoid'],['avoided']
Safety,"itioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI divisioned is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeMulti.html:16725,avoid,avoided,16725,root/html602/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html,2,['avoid'],['avoided']
Safety,"itor::ResetInterrupt ; (; ). inline . Definition at line 72 of file TMonitor.h. ◆ Select() [1/3]. TSocket * TMonitor::Select ; (; ). Return pointer to socket for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. ◆ Select() [2/3]. TSocket * TMonitor::Select ; (; Long_t ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. ◆ Select() [3/3]. Int_t TMonitor::Select ; (; TList * ; rdready, . TList * ; wrready, . Long_t ; timeout . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. ◆ SetInterest(). void TMonitor::SetInterest ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Set interest mask for socket sock to interest. ; If the socket is not in the active list move it or add it there. If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 180 of file TMonitor.cxx. ◆ SetReady(). void TMonitor::SetReady ; (; TSocket * ; sock). private . Called by TSocketHandler::Notify() to signal which socket is ready to be read or written. ; User should not call t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:22375,timeout,timeout,22375,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"its : show credits"");; 1254 Printf("" .demo : launch GUI demo"");; 1255 Printf("" .forum bug : ask for help with a bug or crash at the ROOT forum."");; 1256 Printf("" .gh [bug|feature|improvement]\n""; 1257 "" : submit a bug report, feature or improvement suggestion"");; 1258 Printf("" .help Class::Member : open reference guide for that class member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:50630,abort,abort,50630,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Fri Dec 2 14:26:41 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:22744,abort,abort,22744,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Mon Jul 4 15:21:38 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgSet.html:22230,abort,abort,22230,root/html530/RooArgSet.html,https://root.cern,https://root.cern/root/html530/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Sat Oct 9 22:38:34 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgSet.html:22019,abort,abort,22019,root/html528/RooArgSet.html,https://root.cern,https://root.cern/root/html528/RooArgSet.html,1,['abort'],['abort']
Safety,"itten for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. Bool_t isInRange(const char* rangeSpec). TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Tue Jun 2 15:27:50 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooArgSet.html:24015,abort,abort,24015,root/html604/RooArgSet.html,https://root.cern,https://root.cern/root/html604/RooArgSet.html,1,['abort'],['abort']
Safety,"itten; automatically to a file during the next TFile::Write command.; ; Example:; create a twodimensional TEfficiency object with; - name = ""eff""; - title = ""my efficiency""; - axistitles: x, y and LaTeX formated epsilon as label for Z axis; - 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; from first bin) upto 10 (upper edge of last bin); - 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; edge from first bin) upto 5 (upper edge of last bin); TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; to fullfill the conditions mentioned in CheckConsistency, otherwise the construction will fail.; As the histograms already exist, the new TEfficiency is by default not attached; to the current directory to avoid duplication of data. If you want to store the; new object anyway, you can either write it directly by calling Write or attach it to a directory using SetDirectory.; This also applies for TEfficiency objects created by the copy constructor TEfficiency(const TEfficiency& rEff). Example 1:; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");; //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; // this will write the TEfficiency object to ""myfile.root""; // AND pEff will be attached to the current directory; pEff->Write();; }; Example 2:; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");; //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; //this will attach the TEfficiency object to the current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEfficiency.html:3512,avoid,avoid,3512,root/html602/TEfficiency.html,https://root.cern,https://root.cern/root/html602/TEfficiency.html,2,['avoid'],['avoid']
Safety,"ity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 378 of file THashList.cxx. ◆ Remove() [2/2]. TObject * THashList::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 391 of file THashList.cxx. ◆ Streamer(). void THashList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates. ◆ StreamerNVirtual(). void THashList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 72 of file THashList.h. ◆ UseRWLock(). bool THashList::UseRWLock ; (; Bool_t ; enable = true). overridevirtual . Set this collection to use a RW lock upon access, making it thread safe. ; Return the previous state.; Note: To test whether the usage is enabled do: collection->TestBit(TCollection::kUseRWLock); ; Reimplemented from TCollection.; Definition at line 409 of file THashList.cxx. Member Data Documentation. ◆ fTable. THashTable* THashList::fTable. protected . Definition at line 37 of file THashList.h. Libraries for THashList:. [legend]; The documentation for this class was generated from the following files:; core/cont/inc/THashList.h; core/cont/src/THashList.cxx. THashList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:48 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:33621,safe,safe,33621,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['safe'],['safe']
Safety,"ity"");; f1->GetHistogram()->SetMinimum(0.0);; f1->GetHistogram()->SetMaximum(1.0);; TF1 *f2 = new TF1(""f2"",RiskProfile,0,2.5,1);; f2->SetParameter(0,10.);; f2->SetLineColor(50);; f2->Draw(""CSAME"");; ; TLegend *legend1 = new TLegend(0.50,0.65,0.70,0.82);; legend1->AddEntry(f1,""1-exp(-2.0*x)"",""l"");; legend1->AddEntry(f2,""1-exp(-10.*x)"",""l"");; legend1->Draw();; ; // vertical bar chart of portfolio distribution; ; c1->cd(2);; TH1F *h1 = new TH1F(""h1"",""Portfolio Distribution"",nrStocks,0,0);; TH1F *h2 = new TH1F(""h2"",""Portfolio Distribution"",nrStocks,0,0);; h1->SetStats(0);; h1->SetFillColor(49);; h2->SetFillColor(50);; h1->SetBarWidth(0.45);; h1->SetBarOffset(0.1);; h2->SetBarWidth(0.4);; h2->SetBarOffset(0.55);; for (Int_t i = 0; i < nrStocks; i++) {; h1->Fill(stocks[i],weight1[i]);; h2->Fill(stocks[i],weight2[i]);; }; ; h1->Draw(""BAR2 HIST"");; h2->Draw(""BAR2SAME HIST"");; ; TLegend *legend2 = new TLegend(0.50,0.65,0.70,0.82);; legend2->AddEntry(h1,""high risk"",""f"");; legend2->AddEntry(h2,""low risk"",""f"");; legend2->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TArrayF.h; TCanvas.h; TF1.h; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TGondzioSolver.h; TH1.h; TLegend.h; TMath.h; TMatrixDSym.h; TMatrixD.h; TQpProbDens.h; Form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:13416,risk,risk,13416,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,2,['risk'],['risk']
Safety,"iven direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:5138,Safe,Safety,5138,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['Safe'],['Safety']
Safety,"iven variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] IN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8C.html:6423,safe,safe,6423,doc/master/rf202__extendedmlfit_8C.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html,1,['safe'],['safe']
Safety,"ivname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTorusDimensions(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1, Double_t dphi); Set torus dimensions. void SetDimensions(Double_t* param); Set torus dimensions starting from a list. void SetPoints(Double_t* points) const; Create torus mesh points. void SetPoints(Float_t* points) const; Create torus mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments()+1;; Int_t numPoints = n*(n-1);; Int_t numSegs = (2*n-1)*(n-1);; Int_t numPolys = (n-1)*(n-1);. Bool_t hasrmin = (fRmin>0)?kTRUE:kFALSE;; Bool_t hasphi = (fDphi<360",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:14463,Safe,Safety,14463,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,3,['Safe'],['Safety']
Safety,"ize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:3387,safe,safe,3387,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['safe'],['safe']
Safety,"ize(EAddToList addToGlobalList); 803{; 804 // add to global list of functions if default adding is on OR if bit is set; 805 bool doAdd = ((addToGlobalList == EAddToList::kDefault && fgAddToGlobList); 806 || addToGlobalList == EAddToList::kAdd);; 807 if (doAdd && gROOT) {; 808 SetBit(kNotGlobal, kFALSE);; 809 R__LOCKGUARD(gROOTMutex);; 810 // Store formula in linked list of formula in ROOT; 811 TF1 *f1old = (TF1 *)gROOT->GetListOfFunctions()->FindObject(fName);; 812 if (f1old) {; 813 gROOT->GetListOfFunctions()->Remove(f1old);; 814 // We removed f1old from the list, it is not longer global.; 815 // (See TF1::AddToGlobalList which requires this flag to be correct).; 816 f1old->SetBit(kNotGlobal, kTRUE);; 817 }; 818 gROOT->GetListOfFunctions()->Add(this);; 819 } else; 820 SetBit(kNotGlobal, kTRUE);; 821 ; 822 if (gStyle) {; 823 SetLineColor(gStyle->GetFuncColor());; 824 SetLineWidth(gStyle->GetFuncWidth());; 825 SetLineStyle(gStyle->GetFuncStyle());; 826 }; 827 SetFillStyle(0);; 828}; 829 ; 830////////////////////////////////////////////////////////////////////////////////; 831/// Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ); 832/// After having called this static method, all the functions created afterwards will follow the; 833/// desired behaviour.; 834///; 835/// By default the functions are added automatically; 836/// It returns the previous status (true if the functions are added automatically); 837 ; 838Bool_t TF1::DefaultAddToGlobalList(Bool_t on); 839{; 840 return fgAddToGlobList.exchange(on);; 841}; 842 ; 843////////////////////////////////////////////////////////////////////////////////; 844/// Add to global list of functions (gROOT->GetListOfFunctions() ); 845/// return previous status (true if the function was already in the list false if not); 846 ; 847Bool_t TF1::AddToGlobalList(Bool_t on); 848{; 849 if (!gROOT) return false;; 850 ; 851 bool prevStatus = !TestBit(kNotGlobal);; 852 if (on) {; 85",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:29442,avoid,avoid,29442,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ize);  ; int CompressionSettings (RCompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:7812,safe,safe,7812,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,2,['safe'],['safe']
Safety,"ize;; 1907 // case of batch prediction for; 1908 if (ievt_end <= lastEvt) {; 1909 ; 1910 if (ievt == firstEvt) {; 1911 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1917 << "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:77133,predict,prediction,77133,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"izerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at time t,; based on the numbers already processed and the latests worker measured speeds.; If t <= 0 the current time is used.; Only the estimation for the entries is currently implemented.; This is needed to smooth the instantaneous rate plot. void MarkBad(TSlave* s, TProofProgressStatus* status, TList** missingFiles); This method c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:12959,predict,predict,12959,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,6,['predict'],['predict']
Safety,izerOptions::SetDefaultPrecision ; (; double ; prec). static . Set the default Minimizer precision. ; (used only by MInuit and Minuit2) It is used to specify the numerical precision used for computing the objective function. It should be left to the default value found by the Minimizer (typically double precision) ; Definition at line 59 of file MinimizerOptions.cxx. ◆ SetDefaultPrintLevel(). void ROOT::Math::MinimizerOptions::SetDefaultPrintLevel ; (; int ; level). static . Set the default Print Level. ; Possible levels are from 0 (minimal printing) to 3 (maximum printing) ; Definition at line 75 of file MinimizerOptions.cxx. ◆ SetDefaultStrategy(). void ROOT::Math::MinimizerOptions::SetDefaultStrategy ; (; int ; strat). static . Set the default strategy. ; The strategy is a parameter used only by Minuit and Minuit2. Possible values are:; strat = 0 : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; strat = 1 (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; strat = 2 Perform several full Hessian computations during the minimization. Slower and not always working better than strat=1. . Definition at line 71 of file MinimizerOptions.cxx. ◆ SetDefaultTolerance(). void ROOT::Math::MinimizerOptions::SetDefaultTolerance ; (; double ; tol). static . Set the Minimization tolerance. ; The Default value for Minuit and Minuit2 is 0.01 ; Definition at line 55 of file MinimizerOptions.cxx. ◆ SetErrorDef(). void ROOT::Math::MinimizerOptions::SetErrorDef ; (; double ; err). inline . set error def ; Definition at line 228 of file MinimizerOptions.h. ◆ SetExtraOptions(). void ROOT::Math::MinimizerOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 210 of file MinimizerOptions.cxx. ◆ SetMaxFunctionCalls(). void ROOT::Math::MinimizerOptions::SetMaxFunctionCalls ; (; unsigned int ; maxfcn). inline ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:14678,Avoid,Avoid,14678,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['Avoid'],['Avoid']
Safety,"jan95 == -1) {; 3862 ::SysError(""TUnixSystem::UnixNow"", ""error converting 950001 0:00 to time_t"");; 3863 return 0;; 3864 }; 3865 }; 3866 ; 3867 struct timeval t;; 3868 gettimeofday(&t, nullptr);; 3869 return Long64_t(t.tv_sec-(Long_t)jan95)*1000 + t.tv_usec/1000;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124778,timeout,timeout,124778,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; ROOT::TSchemaRule::ReadFuncPtr_tfReadFunc!; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFunc!; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TStreamerElement. ←; TStreamerArtificial. Function documentation; void Streamer(TBuffer& ); Avoid streaming the synthetic/artificial streamer elements. ROOT::TSchemaRule::ReadFuncPtr_t GetReadFunc(); Return the read function if any. ROOT::TSchemaRule::ReadRawFuncPtr_t GetReadRawFunc(); Return the raw read function if any. TStreamerElement& operator=(const TStreamerArtificial& ). TStreamerArtificial(const TStreamerArtificial& ). TStreamerArtificial(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); TStreamerArtificial() : fReadFunc(0),fReadRawFunc(0) {}. {}. void SetReadFunc(ROOT::TSchemaRule::ReadFuncPtr_t val); { fReadFunc = val; }. void SetReadRawFunc(ROOT::TSchemaRule::ReadRawFuncPtr_t val); { fReadRawFunc = val; }. » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: e0eac11e63ad37390c9467c97c5c6849c4ab7d39 $ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerArtificial.html:10896,Avoid,Avoid,10896,root/html602/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html602/TStreamerArtificial.html,1,['Avoid'],['Avoid']
Safety,"ject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:2215,safe,safe,2215,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,3,['safe'],['safe']
Safety,"ject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShapeAssembly.html:1852,safe,safe,1852,root/html532/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html532/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:2510,safe,safe,2510,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,1,['safe'],['safe']
Safety,"ject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TBuffer::EModeTBuffer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned int>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBufferJSON.html:20198,recover,recovered,20198,root/html604/TBufferJSON.html,https://root.cern,https://root.cern/root/html604/TBufferJSON.html,1,['recover'],['recovered']
Safety,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; voidTGeoSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCompositeShape.html:13646,Safe,SafetyPhi,13646,root/html530/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html,2,['Safe'],['SafetyPhi']
Safety,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualPacketizer.html:5780,abort,abort,5780,root/html530/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html530/TVirtualPacketizer.html,2,['abort'],['abort']
Safety,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:9406,Safe,SafetyPhi,9406,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,2,['Safe'],['SafetyPhi']
Safety,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); voidSetCurrentZ(Double_t z, Int_t iz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:10062,Safe,SafetyPhi,10062,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['Safe'],['SafetyPhi']
Safety,"ject::Print(Option_t* option = """") const; Bool_tProcessEvents(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTTimer::Remove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTTimer::Reset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTimer::SetCommand(const char* command); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTTimer::SetInterruptSyscalls(Bool_t set = kTRUE); voidTTimer::SetObject(TObject* object); static voidTObject::SetObjectStat(Bool_t stat); voidTTimer::SetTime(Long_t milliSec); voidTTimer::SetTimerID(UInt_t id = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidTTimer::SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); virtual voidTTimer::Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); virtual voidTTimer::Stop(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTTimer::Timeout()SIGNAL ; TProcessEventTimer(Long_t delay); TProcessEventTimer(TProcessEventTimer&&); TProcessEventTimer(const TProcessEventTimer&); virtual voidTTimer::TurnOff()SIGNAL ; virtual voidTTimer::TurnOn()SIGNAL ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProcessEventTimer.html:8720,Timeout,Timeout,8720,root/html602/TProcessEventTimer.html,https://root.cern,https://root.cern/root/html602/TProcessEventTimer.html,2,['Timeout'],['Timeout']
Safety,"ject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:11792,abort,abort,11792,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLocal.html:11559,abort,abort,11559,root/html604/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLocal.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualMCGeometry&operator=(const TVirtualMCGeometry&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCGeometry(). Destructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:9127,detect,detector,9127,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,4,['detect'],['detector']
Safety,"ject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. TGLAutoRotator(const TGLAutoRotator& ). TGLAutoRota",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLAutoRotator.html:7140,Timeout,Timeout,7140,root/html530/TGLAutoRotator.html,https://root.cern,https://root.cern/root/html530/TGLAutoRotator.html,4,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"ject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:9131,Safe,SafetySeg,9131,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,1,['Safe'],['SafetySeg']
Safety,"ject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoGtra&operator=(const TGeoGtra&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidTGeoArb8::SetPoints(Double_t* points) const; virtual voidTGeoArb8::SetPoints(Float_t* points) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:10291,Safe,SafetyToFace,10291,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['Safe'],['SafetyToFace']
Safety,"ject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrap&operator=(const TGeoTrap&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidTGeoArb8::SetPoints(Double_t* points) const; virtual voidTGeoArb8::SetPoints(Float_t* points) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:10150,Safe,SafetyToFace,10150,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,2,['Safe'],['SafetyToFace']
Safety,"ject::operator new[](size_t sz, void* vp); TParallelMergingFile&operator=(const TParallelMergingFile&); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTMemFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tTFile::ReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTMemFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelMergingFile.html:11321,Recover,Recover,11321,root/html602/TParallelMergingFile.html,https://root.cern,https://root.cern/root/html602/TParallelMergingFile.html,2,['Recover'],['Recover']
Safety,"jets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; //fill some histograms; hdmd->Fill(*fDm_d);; h2->Fill(*fDm_d,*fRpd0_t/0.029979*1.8646/ *fPtd0_d);; ; return kTRUE;; }; ; void h1analysisTreeReader::Begin(TTree* /*myTree*/) {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Reset();; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""Begin"", ""starting h1analysis with process option: %s"", option.Data());; ; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is processed in SlaveBegin and we do not need; // to do anything here; } else {; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; void h1analysisTreeReader::SlaveBegin(TTree *myTree){; ; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; Init(myTree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process option: %s (tree: %p)"", option.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:3233,avoid,avoid,3233,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,2,['avoid'],['avoid']
Safety,"jority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining after the training which splits ; : are considered statistically insignificant and are removed. The; : user is advised to carefully watch the BDT screen output for; : the comparison between efficiencies obtained on the training and; : the independent test sample. They should be equal within statistical; : errors, in order to minimize statistical fluctuations in different samples.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; BDTG : #events: (reweighted) sig: 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:32250,risk,risk,32250,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['risk'],['risk']
Safety,"k illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume * ; vol, . TGeoVoxelFinder * ; voxels, . Double_t * ; xyz, . Int_t ; npoints . ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. ◆ Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoChecker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TGeoChecker.h. ◆ CleanPoints(). void TGeoChecker::CleanPoints ; (; Double_t * ; points, . Int_t & ; numPoints . ); const. private . Number of points on mesh ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21786,Safe,Safety,21786,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['Safe'],['Safety']
Safety,"k;}; 4143 case 17: {b.ReadFastArray((ULong64_t*)fAddress, n); break;}; 4144 case 18: {b.ReadFastArray((bool*) fAddress, n); break;}; 4145 case 9: {; 4146 TVirtualStreamerInfo* si = GetInfoImp();; 4147 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4148 Double_t *xx = (Double_t*) fAddress;; 4149 for (Int_t ii=0;ii<n;ii++) {; 4150 b.ReadDouble32(&(xx[ii]),se);; 4151 }; 4152 break;; 4153 }; 4154 case 19: {; 4155 TVirtualStreamerInfo* si = GetInfoImp();; 4156 TStreamerElement* se = (TStreamerElement*) si->GetElement(fID);; 4157 Float_t *xx = (Float_t*) fAddress;; 4158 for (Int_t ii=0;ii<n;ii++) {; 4159 b.ReadFloat16(&(xx[ii]),se);; 4160 }; 4161 break;; 4162 }; 4163 }; 4164 return;; 4165 } else if (fType <= 2) { // branch in split mode; 4166 // FIXME: This should probably be < 60 instead.; 4167 if (fStreamerType > 40 && fStreamerType < 55) {; 4168 Int_t atype = fStreamerType - 40;; 4169 Int_t n;; 4170 if (fBranchCount==nullptr) {; 4171 // Missing fBranchCount. let's attempts to recover.; 4172 ; 4173 TString countname( GetName() );; 4174 Ssiz_t dot = countname.Last('.');; 4175 if (dot>=0) {; 4176 countname.Remove(dot+1);; 4177 } else {; 4178 countname = """";; 4179 }; 4180 TString counter( GetTitle() );; 4181 Ssiz_t loc = counter.Last('[');; 4182 if (loc>=0) {; 4183 counter.Remove(0,loc+1);; 4184 }; 4185 loc = counter.Last(']');; 4186 if (loc>=0) {; 4187 counter.Remove(loc);; 4188 }; 4189 countname += counter;; 4190 SetBranchCount((TBranchElement *)fTree->GetBranch(countname));; 4191 }; 4192 if (fBranchCount) {; 4193 n = (Int_t)fBranchCount->GetValue(0,0);; 4194 } else {; 4195 Warning(""ReadLeaves"",""Missing fBranchCount for %s. Data will not be read correctly by the MakeClass mode."",GetName());; 4196 n = 0;; 4197 }; 4198 fNdata = n;; 4199 Char_t isArray;; 4200 b >> isArray;; 4201 switch (atype) {; 4202 case 1: {b.ReadFastArray((Char_t*) fAddress, n); break;}; 4203 case 2: {b.ReadFastArray((Short_t*) fAddress, n); break;}; 4204 case 3: {b.ReadFastArray((Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:154555,recover,recover,154555,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['recover'],['recover']
Safety,"kAddedcondition usd to signal the addition of a new red block; TList*fReadBlockslist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). » Author: Elvin Sindrilaru 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFilePrefetch.html:7155,Safe,Safe,7155,root/html530/TFilePrefetch.html,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"kAddedcondition usd to signal the addition of a new red block; TList*fReadBlockslist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFilePrefetch.html:7283,Safe,Safe,7283,root/html532/TFilePrefetch.html,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(tree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:2238,predict,prediction,2238,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['predict'],['prediction']
Safety,"kBFGS.; This implementation, written by C. Delaere, is inspired from the mlpfit package from J.Schwindling et al. with some extensions:. the algorithms are globally the same; in TMultilayerPerceptron, there is no limitation on the number of layers/neurons, while MLPFIT was limited to 2 hidden layers; TMultilayerPerceptron allows you to save the network in a root file, and provides more export functionalities; TMultilayerPerceptron gives more flexibility regarding the normalization of inputs/outputs; TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to use cross-entropy errors, which allows to train a network for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2033,predict,predictions,2033,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['predict'],['predictions']
Safety,"kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (eithe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9402,Abort,Abort,9402,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,1,['Abort'],['Abort']
Safety,"kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:57661,safe,safe,57661,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['safe'],['safe']
Safety,"kFALSE, Bool_t wait_process=kFALSE);  Execute WS request. ;  ; std::shared_ptr< THttpWSHandler > FindWS (const char *name);  Find web-socket handler with given name. ;  ; const char * GetCors () const;  Returns specified CORS domain. ;  ; const char * GetCorsCredentials () const;  Returns specified CORS credentials value - if any. ;  ; const char * GetItemField (const char *fullname, const char *name);  Get item field from sniffer. ;  ; TRootSniffer * GetSniffer () const;  returns pointer on objects sniffer ;  ; const char * GetTopName () const;  returns name of top item in objects hierarchy ;  ; Bool_t Hide (const char *fullname, Bool_t hide=kTRUE);  Hides folder or element from web gui. ;  ; TClass * IsA () const override;  ; Bool_t IsAnyEngine () const;  ; Bool_t IsCors () const;  Returns kTRUE if CORS was configured. ;  ; Bool_t IsCorsCredentials () const;  Returns kTRUE if Access-Control-Allow-Credentials header should be used. ;  ; Bool_t IsFileRequested (const char *uri, TString &res) const;  Check if file is requested, thread safe. ;  ; Bool_t IsReadOnly () const;  returns read-only mode ;  ; Bool_t IsTerminated () const;  returns kTRUE, if server was terminated ;  ; Bool_t IsWSOnly () const;  returns true if only websockets are handled by the server ;  ; Int_t ProcessRequests ();  Process submitted requests, must be called from appropriate thread. ;  ; Bool_t Register (const char *subfolder, TObject *obj);  Register object in subfolder. ;  ; Bool_t RegisterCommand (const char *cmdname, const char *method, const char *icon=nullptr);  Register command which can be executed from web interface. ;  ; void RegisterWS (std::shared_ptr< THttpWSHandler > ws);  Register WS handler. ;  ; void Restrict (const char *path, const char *options);  Restrict access to specified object. ;  ; void SetCors (const std::string &domain=""*"");  Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header. ;  ; void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:3447,safe,safe,3447,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['safe'],['safe']
Safety,"kLoadTree ; kPrint ; kRemoveFriend ; kSetBranchStatus . Definition at line 211 of file TTree.h. ◆ ESetBranchAddressStatus. enum TTree::ESetBranchAddressStatus. EnumeratorkMissingBranch ; kInternalError ; kMissingCompiledCollectionProxy ; kMismatch ; kClassMismatch ; kMatch ; kMatchConversion ; kMatchConversionCollection ; kMakeClass ; kVoidPtr ; kNoCheck ; kNeedEnableDecomposedObj ; kNeedDisableDecomposedObj ; kDecomposedObjMask . Definition at line 232 of file TTree.h. ◆ EStatusBits. enum TTree::EStatusBits. EnumeratorkForceRead ; kCircular ; kOnlyFlushAtCluster If set, the branch's buffers will grow until an event cluster boundary is hit, guaranteeing a basket per cluster. ; This mode does not provide any guarantee on the memory bounds in the case of extremely large events. . kEntriesReshuffled If set, signals that this TTree is the output of the processing of another TTree, and the entries are reshuffled w.r.t. ; to the original TTree. As a safety measure, a TTree with this bit set cannot add friends nor can be added as a friend. If you know what you are doing, you can manually unset this bit with ResetBit(EStatusBits::kEntriesReshuffled). . Definition at line 250 of file TTree.h. Constructor & Destructor Documentation. ◆ TTree() [1/3]. TTree::TTree ; (; ). Default constructor and I/O constructor. ; Note: We do not insert ourself into the current directory. ; Definition at line 737 of file TTree.cxx. ◆ TTree() [2/3]. TTree::TTree ; (; const char * ; name, . const char * ; title, . Int_t ; splitlevel = 99, . TDirectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:67840,safe,safety,67840,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['safe'],['safety']
Safety,"kQT_HexagonXY; kQT_HexagonYX; kQT_Hexagon_End; };; enum TEveDigitSet::ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; void*TEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefCoordDefault value for third coordinate (C); Float_tfDefHeightBreadth assigned to second coordinate (B); Float_tfDefWidthBreadth assigned to first coordinate (A); Int_tTEveDigitSet::fDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveQuadSet.html:24382,avoid,avoid,24382,root/html528/TEveQuadSet.html,https://root.cern,https://root.cern/root/html528/TEveQuadSet.html,1,['avoid'],['avoid']
Safety,"kRose = 96; kRust = 97; kSandyTerrain = 98; kSienna = 99; kSolar = 100; kSouthWest = 101; kStarryNight = 102; kSunset = 103; kTemperatureMap = 104; kThermometer = 105; kValentine = 106; kVisibleSpectrum = 107; kWaterMelon = 108; kCool = 109; kCopper = 110; kGistEarth = 111. ; Interpreter Library; Many, many bugs have been fixed; thanks to everyone who has reported them!; Cling; Cling is now using a new just-in-time compilation engine called OrcJIT, a development based on MCJIT. It enables interpretation of inline assembly and exceptions; it will hopefully in the near future also support interpreting thread local storage (but doesn’t at the moment).; Thanks to the new JIT, cling also comes with debug symbols for interpreted code; you can enable them with “.debug”.; Function evaluation; Function calls through TMethodCall etc have been accelerated.; llvm / clang; llvm / clang were updated to r227800. This includes everything from the clang 3.6 release.; Dictionary Generation; Detect usage of #pragma once for inlined headers.; Turn on verbosity of genreflex if the VERBOSE environment variable is defined.; Optimise forward declarations in rootmap files in order to make their interpretation faster.; Propagate attributes specified in xml selection files to selected classes even when selected through typedefs.; Optimise selection procedure caching selected declarations in the selection rules, therewith avoiding to query the AST twice.; Include in the PCH all the STL and C headers to guarantee portability of binaries from SLC6 to CC7.; I/O Libraries; I/O New functionalities. Support for forward_list and I/O of unordered stl containers.; Support for std::complex. I/O Behavior change. The I/O now properly skip the content of base class onfile that have been removed from the in-memory class layout.; The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:7271,Detect,Detect,7271,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['Detect'],['Detect']
Safety,"k_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:370587,timeout,timeout,370587,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"k_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:370620,timeout,timeout,370620,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be cross",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2951,safe,safe,2951,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:18708,avoid,avoid,18708,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['avoid'],['avoid']
Safety,"kept, by default all functions in the list are deleted; ""N"": do not store fitted function; for more fitting options see TBinomialEfficiencyFitter::Fit . Definition at line 2555 of file TEfficiency.cxx. ◆ GetBetaAlpha(). Double_t TEfficiency::GetBetaAlpha ; (; Int_t ; bin = -1); const. inline . Definition at line 110 of file TEfficiency.h. ◆ GetBetaBeta(). Double_t TEfficiency::GetBetaBeta ; (; Int_t ; bin = -1); const. inline . Definition at line 111 of file TEfficiency.h. ◆ GetConfidenceLevel(). Double_t TEfficiency::GetConfidenceLevel ; (; ); const. inline . Definition at line 112 of file TEfficiency.h. ◆ GetCopyPassedHisto(). TH1 * TEfficiency::GetCopyPassedHisto ; (; ); const. Returns a cloned version of fPassedHistogram. ; Notes:; The histogram is filled with unit weights. You might want to scale it with the global weight GetWeight().; The returned object is owned by the user who has to care about the deletion of the new TH1 object.; This histogram is by default NOT attached to the current directory to avoid duplication of data. If you want to store it automatically during the next TFile::Write() command, you have to attach it to the corresponding directory. TFile* pFile = new TFile(""passed.root"",""update"");; TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; TH1* copy = pEff->GetCopyPassedHisto();; copy->SetDirectory(gDirectory);; pFile->Write();; TEfficiency::GetCopyPassedHistoTH1 * GetCopyPassedHisto() constReturns a cloned version of fPassedHistogram.Definition TEfficiency.cxx:2617; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937. Definition at line 2617 of file TEfficiency.cxx. ◆ GetCopyTotalHisto(). TH1 * TEfficiency::GetCopyTotalHisto ; (; ); const. Returns a cloned version of fTotalHistogram. ; Notes:; The histogram is filled with unit weights. You might want to scale it with the global weight GetWeight().;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:93865,avoid,avoid,93865,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['avoid'],['avoid']
Safety,"kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); # stride for maxpool is equal to pool size; model.add(MaxPooling2D(pool_size=(2, 2))); model.add(Flatten()); model.add(Dense(64, activation=""tanh"")); # model.add(Dropout(0.2)); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_cnn.h5""); model.summary(); ; if not os.path.exists(""model_cnn.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_CNN_Classification"", ""Booking convolutional keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_cnn.h5"",; FilenameTrainedModel=""trained_model_cnn.h5"",; NumEpochs=max_epochs,; BatchSize=100,; GpuOptions=""allow_growth=True"",; ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ; ## Train Methods; ; factory.TrainAllMethods(); ; ## Test and Evaluate Methods; ; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; ## Plot ROC Curve; ; c1 = factory.GetROCCurve(loader); c1.Draw(); ; # close outputfile to save output file; outputFile.Close(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:15699,avoid,avoid,15699,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['avoid'],['avoid']
Safety,"ket is ready. ; Definition at line 530 of file TMonitor.cxx. ◆ Remove(). void TMonitor::Remove ; (; TSocket * ; sock). virtual . Remove a socket from the monitor. ; Definition at line 214 of file TMonitor.cxx. ◆ RemoveAll(). void TMonitor::RemoveAll ; (; ). virtual . Remove all sockets from the monitor. ; Definition at line 241 of file TMonitor.cxx. ◆ ResetInterrupt(). void TMonitor::ResetInterrupt ; (; ). inline . Definition at line 72 of file TMonitor.h. ◆ Select() [1/3]. TSocket * TMonitor::Select ; (; ). Return pointer to socket for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. ◆ Select() [2/3]. TSocket * TMonitor::Select ; (; Long_t ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. ◆ Select() [3/3]. Int_t TMonitor::Select ; (; TList * ; rdready, . TList * ; wrready, . Long_t ; timeout . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. ◆ SetInterest(). void TMonitor::SetInterest ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Set interest mask for socket sock to interest. ; If the socket is not in the active list move it or add it there. If interest=kRead then we want to monitor the socket for read r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:21987,timeout,timeout,21987,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"ket& xs); virtual voidTObject::Paint(Option_t* option = """"); Bool_tPing(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidRemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tSendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidSendUrgent(Int_t type, Int_t int1, Int_t int2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterrupt(); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocket.html:6206,timeout,timeout,6206,root/html528/TXSocket.html,https://root.cern,https://root.cern/root/html528/TXSocket.html,1,['timeout'],['timeout']
Safety,"kets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMonitor.html:13335,Avoid,Avoids,13335,root/html534/TMonitor.html,https://root.cern,https://root.cern/root/html534/TMonitor.html,1,['Avoid'],['Avoids']
Safety,"kets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMonitor.html:13842,Avoid,Avoids,13842,root/html604/TMonitor.html,https://root.cern,https://root.cern/root/html604/TMonitor.html,1,['Avoid'],['Avoids']
Safety,"kets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:13842,Avoid,Avoids,13842,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,1,['Avoid'],['Avoids']
Safety,"ks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeometry.html:1030,detect,detector,1030,root/html528/TGeometry.html,https://root.cern,https://root.cern/root/html528/TGeometry.html,6,['detect'],['detector']
Safety,"l : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 337 of file TCollection.h. Function Documentation. ◆ HasBeenDeleted(). R__ALWAYS_INLINE bool ROOT::Detail::HasBeenDeleted ; (; const TObject * ; obj). Check if the TObject's memory has been deleted. ; WarningThis should be only used for error mitigation as the answer is only sometimes correct. It actually just checks whether the object has been deleted, so this will falsely return true for an object that has been destructed but its memory has not been deleted. This will return an undefined value if the memory is re-used between the deletion and the check. i.e. This is useful to prevent a segmentation fault in case where the problem can be detected when the deletion and the usage are 'close-by' . In enviroment where delete taints (changes) the memory, this function always returns false as the marker left by ~TObject will be overwritten. ; Parameters. objThe memory to check . Returnstrue if the object has been destructed and it can be inferred that it has been deleted ; Definition at line 402 of file TObject.h. ◆ HasCallOp() [1/2]. template<typename T > . constexpr bool ROOT::Detail::HasCallOp ; (; char ; ). constexpr . Definition at line 32 of file TypeTraits.hxx. ◆ HasCallOp() [2/2]. template<typename T > . constexpr auto ROOT::Detail::HasCallOp ; (; int ; ); -> decltype(&T::operator(), true) . constexpr . Definition at line 31 of file TypeTraits.hxx. ◆ operator_equal_impl(). template<class ArrayL , class ArrayR > . bool ROOT::Detail::operator_equal_impl ; (; ArrayL const & ; lhs, . size_t const ; lhs_size, . ArrayR const & ; rhs, . size_t const ; rhs_size . ). inline . Definition at line 456 of file span.hx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail.html:4812,detect,detected,4812,doc/master/namespaceROOT_1_1Detail.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail.html,2,['detect'],['detected']
Safety,"l Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPgon.html:2172,safe,safe,2172,root/html530/TGeoPgon.html,https://root.cern,https://root.cern/root/html530/TGeoPgon.html,1,['safe'],['safe']
Safety,"l PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ColumnsRooCmdArg Columns(Int_t ncol)Definition RooGlobalFunc.cxx:513; RooFit::SiblingRooCmdArg Sibling(const RooAbsCollection &sibling)Definition RooGlobalFunc.cxx:521; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf407_latextablesDefinition rf407_latextables.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.71\pm 0.06$\\; $\verb+sigma1+ $ & $ 0.5$\\; $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lc|lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$ & $\verb+mean+ $ & $ 5$\\; $\verb+a1+ $ &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8C.html:5102,safe,safe,5102,doc/master/rf407__latextables_8C.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html,1,['safe'],['safe']
Safety,"l Run(). TThread(TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create a detached thread. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; To start the thread call Run(). TThread(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TThread.html:10125,safe,safe,10125,root/html530/TThread.html,https://root.cern,https://root.cern/root/html530/TThread.html,3,['safe'],['safe']
Safety,"l and have to be recomputed, taking into account; 2887/// the number of entries in each tree.; 2888///; 2889/// The new TEntryList is owned by the TChain and gets deleted when the chain; 2890/// is deleted. This TEntryList is returned by GetEntryList() function, and after; 2891/// GetEntryList() function is called, the TEntryList is not owned by the chain; 2892/// any more and will not be deleted with it.; 2893 ; 2894void TChain::SetEventList(TEventList *evlist); 2895{; 2896 fEventList = evlist;; 2897 if (fEntryList) {; 2898 if (fEntryList->TestBit(kCanDelete)) {; 2899 TEntryList *tmp = fEntryList;; 2900 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2901 delete tmp;; 2902 } else {; 2903 fEntryList = nullptr;; 2904 }; 2905 }; 2906 ; 2907 if (!evlist) {; 2908 fEntryList = nullptr;; 2909 fEventList = nullptr;; 2910 return;; 2911 }; 2912 ; 2913 if(fProofChain) {; 2914 //on proof, fEventList and fEntryList shouldn't be set at the same time; 2915 if (fEntryList){; 2916 //check, if the chain is the owner of the previous entry list; 2917 //(it happens, if the previous entry list was created from a user-defined; 2918 //TEventList in SetEventList() function); 2919 if (fEntryList->TestBit(kCanDelete)){; 2920 TEntryList *tmp = fEntryList;; 2921 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2922 delete tmp;; 2923 } else {; 2924 fEntryList = nullptr;; 2925 }; 2926 }; 2927 return;; 2928 }; 2929 ; 2930 char enlistname[100];; 2931 snprintf(enlistname,100, ""%s_%s"", evlist->GetName(), ""entrylist"");; 2932 TEntryList *enlist = new TEntryList(enlistname, evlist->GetTitle());; 2933 enlist->SetDirectory(nullptr);; 2934 ; 2935 Int_t nsel = evlist->GetN();; 2936 Long64_t globalentry, localentry;; 2937 const char *treename;; 2938 const char *filename;; 2939 if (fTreeOffset[fNtrees-1]==TTree::kMaxEntries){; 2940 //Load all the tree headers if the tree offsets are not known; 2941 //It is assumed here, that loading the last tree will load all; 2942 //previous ones;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:106042,Avoid,Avoid,106042,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"l and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26371,safe,safe,26371,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"l bin volume, (M = N(sumSet)), making the return value the integral over the function represented by this histogram ; Definition at line 1889 of file RooDataHist.cxx. ◆ sumEntries() [1/2]. double RooDataHist::sumEntries ; (; ); const. overridevirtual . Sum the weights of all bins. ; Implements RooAbsData.; Definition at line 2114 of file RooDataHist.cxx. ◆ sumEntries() [2/2]. double RooDataHist::sumEntries ; (; const char * ; cutSpec, . const char * ; cutRange = nullptr . ); const. overridevirtual . Return the sum of weights in all entries matching cutSpec (if specified) and in named range cutRange (if specified) Return the. ; Implements RooAbsData.; Definition at line 2125 of file RooDataHist.cxx. ◆ sumW2Array(). double const * RooDataHist::sumW2Array ; (; ); const. inline . Definition at line 219 of file RooDataHist.h. ◆ weight() [1/3]. double RooDataHist::weight ; (; ); const. inlineoverridevirtual . Return weight of last bin that was requested with get(). ; Deprecated:Use the safer weight(std::size_t) const. ; Implements RooAbsData.; Definition at line 185 of file RooDataHist.h. ◆ weight() [2/3]. double RooDataHist::weight ; (; const RooArgSet & ; bin, . Int_t ; intOrder = 1, . bool ; correctForBinSize = false, . bool ; cdfBoundaries = false, . bool ; oneSafe = false . ). Return the weight at given coordinates with optional interpolation. ; Parameters. [in]binCoordinates for which the weight should be calculated. ; [in]intOrderInterpolation order, i.e. how many neighbouring bins are used for the interpolation. If zero, the bare weight for the bin enclosing the coordinatesis returned. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. ; [in]oneSafeIgnored. . Definition at line 1434 of file RooDataHist.cxx. ◆ weight() [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:80509,safe,safer,80509,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safer']
Safety,"l rectangular regions called ""cells"". Each cell stores the pointers of the bins intersecting it. When a coordinate is to be filled, the method finds which cell the coordinate falls into. Since the cells are rectangular, this can be done very quickly. It then only loops over the bins associated with that cell and calls IsInside() only on that bins. This reduces considerably the number of bins on which IsInside() is called and therefore speed up by a huge factor the filling compare to the brute force approach where IsInside() is called for all bins.; The addition of bins to the appropriate cells is done when the bin is added to the histogram. To do this, AddBin() calls the AddBinToPartition() method. This method adds the input bin to the partitioning matrix.; The number of partition cells per axis can be specified in the constructor. If it is not specified, the default value of 25 along each axis will be assigned. This value was chosen because it is small enough to avoid slowing down AddBin(), while being large enough to enhance Fill() by a considerable amount. Regardless of how it is initialized at construction time, it can be changed later with the ChangePartition() method. ChangePartition() deletes the old partition matrix and generates a new one with the specified number of cells on each axis.; The optimum number of partition cells per axis changes with the number of times Fill() will be called. Although partitioning greatly speeds up filling, it also adds a constant time delay into the code. When Fill() is to be called many times, it is more efficient to divide the histogram into a large number cells. However, if the histogram is to be filled only a few times, it is better to divide into a small number of cells. ; Definition at line 66 of file TH2Poly.h. Public Member Functions;  TH2Poly ();  Default Constructor. No boundaries specified. ;  ;  TH2Poly (const char *name, const char *title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup);  Constructor wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:5317,avoid,avoid,5317,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['avoid'],['avoid']
Safety,"l tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. ◆ RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. ◆ ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoParallelWorld::StreamerNVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26194,Safe,SafetyLoop,26194,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyLoop']
Safety,"l voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:10982,timeout,timeout,10982,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,3,['timeout'],['timeout']
Safety,"l void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal when some socket is ready. ;  ; virtual void Remove (TSocket *sock);  Remove a socket from the monitor. ;  ; virtual void RemoveAll ();  Remove all sockets from the monitor. ;  ; void ResetInterrupt ();  ; TSocket * Select ();  Return pointer to socket for which an event is waiting. ;  ; TSocket * Select (Long_t timeout);  Return pointer to socket for which an event is waiting. ;  ; Int_t Select (TList *rdready, TList *wrready, Long_t timeout);  Return numbers of sockets that are ready for reading or writing. ;  ; virtual void SetInterest (TSocket *sock, Int_t interest=kRead);  Set interest mask for socket sock to interest. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t Checked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:2551,timeout,timeout,2551,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"l(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12057,timeout,timeout,12057,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualProofPlayer.html:9694,abort,abort,9694,root/html530/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html530/TVirtualProofPlayer.html,8,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"l. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Double_t GetMaximumStored() const; {return fMaximum;}. Double_t GetMinimumStored() const; {return fMinimum;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:65654,safe,safe,65654,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['safe'],['safe']
Safety,"l. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetParameter(Int_t ipar) const; getter methods. Double_t GetParameter(const TString& name) const. const Double_t * GetParameters() const. Int_t GetParNumber(const char* name) const. const char * GetParName(Int_t ipar) const. void SetParameter(Int_t param, Double_t value); setter methods. void SetParameters(const Double_t* params). void SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:59303,safe,safe,59303,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['safe'],['safe']
Safety,"l2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles; Double_tTGeoArb8::fXY[8][2]list of vertices; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Tra; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Trap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrap.html:17609,safe,safe,17609,root/html602/TGeoTrap.html,https://root.cern,https://root.cern/root/html602/TGeoTrap.html,2,['safe'],['safe']
Safety,"l::Internal::RFieldDescriptorBuilder;  A helper class for piece-wise construction of an RFieldDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable;  Used to loop over a field's child fields. More...;  ; class  ROOT::Experimental::Detail::RFieldVisitor;  Abstract base class for classes implementing the visitor design pattern. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RHeaderExtension;  Summarizes information about fields and the corresponding columns that were added after the header has been serialized. More...;  ; class  ROOT::Experimental::RNTupleProcessor::RIterator;  Iterator over the entries of an RNTuple, or vertical concatenation thereof. More...;  ; class  ROOT::Experimental::Internal::RMiniFileReader;  Read RNTuple data blocks from a TFile container, provided by a RRawFile. More...;  ; class  ROOT::RNTuple;  Representation of an RNTuple data set in a ROOT file. More...;  ; class  ROOT::Experimental::Detail::RNTupleAtomicCounter;  A thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::Detail::RNTupleCalcPerf;  A metric element that computes its floating point value from other counters. More...;  ; class  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:6571,safe,safe,6571,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['safe'],['safe']
Safety,"l;  Reset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void ResetGlobalVar (void *obj) final;  Reset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void RewindDictionary () final;  Rewind Cling dictionary to the point where it was before executing the current macro. ;  ; void * RewindInterpreterMutex ();  Reset the interpreter lock to the state it had before interpreter-related calls happened. ;  ; void SaveContext () final;  Save the current Cling state. ;  ; void SaveGlobalsContext () final;  Save the current Cling state of global objects. ;  ; void SetAlloclockfunc (void(*)()) const final;  [Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect critical section of its code (non-thread safe parts). ;  ; void SetAllocunlockfunc (void(*)()) const final;  [Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect critical section of its code (non-thread safe parts). ;  ; void * SetAutoLoadCallBack (void *cb) final;  ; int SetClassAutoLoading (int) const final;  Enable/Disable the AutoLoading of libraries. ;  ; int SetClassAutoparsing (int) final;  Enable/Disable the Autoparsing of headers. ;  ; void SetClassInfo (TClass *cl, Bool_t reload=kFALSE, Bool_t silent=kFALSE) final;  Set pointer to the TClingClassInfo in TClass. ;  ; Int_t SetClassSharedLibs (const char *cls, const char *libs) final;  Register the AutoLoading information for a class. ;  ; void SetDeclAttr (DeclId_t, const char *) final;  ; void SetErrmsgcallback (void *p) const final;  Set a callback to receive error messages. ;  ; Bool_t SetErrorMessages (Bool_t enable=kTRUE) final;  If error messages are disabled, the interpreter should suppress its failures and warning messages from stdout. ;  ; void SetGetline (const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:30333,safe,safe,30333,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['safe'],['safe']
Safety,"lFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoParallelWorld (const TGeoParallelWorld &)=delete;  switch between different algorithm implementations ;  ; TGeoParallelWorld & operator= (const TGeoParallelWorld &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; AccelerationMode fAccMode = AccelerationMode::kVoxelFinder;  to keep the vector of primitive axis aligned bounding boxes ;  ; void * fBoundingBoxes = nullptr;  stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ;  ; void * fBVH = nullptr;  array of physical nodes ;  ; TGeoManager * fGeoManager;  ; Bool_t fIsClosed;  ; TGeoPhysicalNode * fLastState;  helper volume ;  ; TObjArray * fPaths;  ; TObjArray * fPhysical;  Last PN touched. ;  ; std::vector< unsigned int > fSafetyCandidateStore {};  A regular 3D cache layer for fast point-based safety lookups. ;  ; TGeoVoxelGrid< SafetyVoxelInfo > * fSafetyVoxelCache;  BVH helper structure for safety and navigation. ;  ; Bool_t fUseOverlaps;  ; TGeoVolume * fVolume;  Closed flag. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; TGeoPhysicalNode * FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:13808,safe,safety,13808,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,2,"['Safe', 'safe']","['SafetyVoxelInfo', 'safety']"
Safety,"lIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; TClass * IsA () const override;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components with cache-and-track. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:5673,safe,safe,5673,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['safe'],['safe']
Safety,"lResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLocal.html:11399,timeout,timeout,11399,root/html604/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLocal.html,1,['timeout'],['timeout']
Safety,"lResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSlave.html:11255,timeout,timeout,11255,root/html604/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSlave.html,1,['timeout'],['timeout']
Safety,"lResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLocal.html:11499,timeout,timeout,11499,root/html534/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLocal.html,2,['timeout'],['timeout']
Safety,"lType TGeoIntersection::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 156 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoIntersection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 166 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoIntersection::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 1230 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoIntersection::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 1238 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoIntersection::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1641 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoIntersection::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1665 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoIntersection::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1684 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoIntersection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoIntersection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:18335,Safe,Safety,18335,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['Safe'],['Safety']
Safety,"lType(). Bool_t TGeoVGShape::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoVGShape.h. ◆ IsReflected(). Bool_t TGeoVGShape::IsReflected ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoShape.; Definition at line 93 of file TGeoVGShape.h. ◆ IsValidBox(). Bool_t TGeoVGShape::IsValidBox ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 94 of file TGeoVGShape.h. ◆ IsVecGeom(). Bool_t TGeoVGShape::IsVecGeom ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoShape.; Definition at line 95 of file TGeoVGShape.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoVGShape::MakeBuffer3D ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 97 of file TGeoVGShape.h. ◆ Paint(). void TGeoVGShape::Paint ; (; Option_t * ; option = """"). inlineoverridevirtual . Paint this shape. ; Reimplemented from TGeoShape.; Definition at line 98 of file TGeoVGShape.h. ◆ Safety(). Double_t TGeoVGShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 468 of file TGeoVGShape.cxx. ◆ SetDimensions(). void TGeoVGShape::SetDimensions ; (; Double_t * ; param). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 99 of file TGeoVGShape.h. ◆ SetPoints() [1/2]. void TGeoVGShape::SetPoints ; (; Double_t * ; points); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 100 of file TGeoVGShape.h. ◆ SetPoints() [2/2]. void TGeoVGShape::SetPoints ; (; Float_t * ; points); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 101 of file TGeoVGShape.h. ◆ SetSegsAndPols(). void TGeoVGShape::SetSegsAndPols ; (; TBuffer3D & ; buff); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 102 of file TGeoVGShape.h. ◆ Sizeof3D(). void TGeoVGShape::Sizeof3D ; (; ); const. inlineoverridevirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:30661,Safe,Safety,30661,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['Safe'],['Safety']
Safety,"l_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed, so there's no need to; sync() them manually. Int_t SysStat(Int_t fd, Long_t* i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:23934,timeout,timeout,23934,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['timeout'],['timeout']
Safety,"l_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSetProxy.html:11738,safe,safeDeleteList,11738,root/html532/RooSetProxy.html,https://root.cern,https://root.cern/root/html532/RooSetProxy.html,1,['safe'],['safeDeleteList']
Safety,"l_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSetProxy.html:11676,safe,safeDeleteList,11676,root/html530/RooSetProxy.html,https://root.cern,https://root.cern/root/html530/RooSetProxy.html,1,['safe'],['safeDeleteList']
Safety,"l_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoScaledShape&operator=(const TGeoScaledShape&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoScaledShape.html:8219,safe,safe,8219,root/html602/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html602/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"l_t GetCredentialsFromEnv (const char *accessKeyEnv, const char *secretKeyEnv, const char *tokenEnv, TString &outAccessKey, TString &outSecretKey, TString &outToken);  Sets the access and secret keys from the environmental variables, if they are both set. ;  ; Bool_t ParseOptions (Option_t *options, TString &accessKey, TString &secretKey, TString &token);  Extracts the S3 authentication key pair (access key and secret key) from the options. ;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:43686,timeout,timeout,43686,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['timeout'],['timeout']
Safety,"l_t fgAddDirectory = kTRUE;  ! Flag to add histograms to the directory ;  ; static Int_t fgBufferSize = 1000;  ! Default buffer size for automatic histograms ;  ; static Bool_t fgDefaultSumw2 = kFALSE;  ! Flag to call TH1::Sumw2 automatically at histogram creation time ;  ; static Bool_t fgStatOverflows = kFALSE;  ! Flag to use under/overflows in statistics ;  . #include <TH2.h>. Inheritance diagram for TH2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TH2() [1/7]. TH2::TH2 ; (; ). protected . 2-D histogram default constructor. ; Definition at line 73 of file TH2.cxx. ◆ TH2() [2/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . Double_t ; xlow, . Double_t ; xup, . Int_t ; nbinsy, . Double_t ; ylow, . Double_t ; yup . ). protected . Constructor for fix bin size 2-D histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) . Definition at line 97 of file TH2.cxx. ◆ TH2() [3/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . Double_t ; ylow, . Double_t ; yup . ). protected . Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:57454,avoid,avoid,57454,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['avoid'],['avoid']
Safety,"lag controls if HESSE before MIGRAD as well, off by default . Optimize(bool flag) Activate constant term optimization of test statistic during minimization (on by default) . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, off by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 to 2, default is 1) . MaxCalls(int n) Change maximum number of likelihood function calls from MINUIT (if n <= 0, the default of 500 * #parameters is used) . EvalErrorWall(bool flag=true) When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter to force it out of that region. This can, however, mean that the fitter gets lost in this region. If this happens, try switching it off. . RecoverFromUndefinedRegions(double strength) When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region. strength controls the magnitude of the penalty term. Leaving out this argument defaults to 10. Switch off with strength = 0.. SumW2Error(bool flag) Apply correction to errors and covariance matrix. This uses two covariance matrices, one with the weights, the other with squared weights, to obtain the correct errors for weighted likelihood fits. If this option is activated, the corrected covariance matrix is calculated as \( V_\mathrm{corr} = V C^{-1} V \), where \( V \) is the original covariance matrix and \( C \) is the inverse of the covariance matrix calculated using the squared weights. This allows to switch between two interpretations of errors: . SumW2Error Interpretation . true The errors reflect the uncertainty of the Monte Carlo simulation. Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; Example: Simulation w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:106755,Recover,RecoverFromUndefinedRegions,106755,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety,"laneNormal(Double_t *p1, Double_t *p2, Double_t *p3, Double_t *norm); TGeoArb8::CapacityDouble_t Capacity() const override; TGeoArb8::SafetyToFaceDouble_t SafetyToFace(const Double_t *point, Int_t iseg, Bool_t in) const; TGeoArb8::Sizeof3Dvoid Sizeof3D() const override; TGeoArb8::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::IsTwistedBool_t IsTwisted() constDefinition TGeoArb8.h:80; TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoArb8::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoArb8::InspectShapevoid InspectShape() const override; TGeoArb8::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoArb8::TGeoArb8TGeoArb8(); TGeoArb8::GetTwistDouble_t GetTwist(Int_t iseg) const; TGeoArb8::TGeoArb8TGeoArb8(Double_t dz, Double_t *vertices=nullptr); TGeoArb8::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoArb8::IsSamePointstatic Bool_t IsSamePoint(const Double_t *p1, const Double_t *p2)Definition TGeoArb8.h:74; TGeoArb8::~TGeoArb8~TGeoArb8() override; TGeoArb8::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoArb8.h:73; TGeoArb8::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *) const overrideDefinition TGeoArb8.h:69; TGeoArb8::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::SetPlaneVerticesvoid SetPlaneVertices(Double_t zpl, Double_t *vertices) const; TGeoArb8::ComputeBBoxvoid ComputeBBox() override; TGeoArb8::GetFittingBoxInt_t GetFit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:13740,Safe,Safety,13740,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"lap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate nod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103078,safe,safety,103078,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"lass * TGeoHalfSpace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoHalfSpace.h. ◆ IsCylType(). Bool_t TGeoHalfSpace::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoHalfSpace.h. ◆ operator=(). TGeoHalfSpace & TGeoHalfSpace::operator= ; (; const TGeoHalfSpace & ; ). privatedelete . ◆ Safety(). Double_t TGeoHalfSpace::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 202 of file TGeoHalfSpace.cxx. ◆ Safety_v(). void TGeoHalfSpace::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 291 of file TGeoHalfSpace.cxx. ◆ SavePrimitive(). void TGeoHalfSpace::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 215 of file TGeoHalfSpace.cxx. ◆ SetDimensions(). void TGeoHalfSpace::SetDimensions ; (; Double_t * ; param). overridevirtual . Set half-space parameters as stored in an array. ; Reimplemented from TGeoBBox.; Definition at line 234 of file TGeoHalfSpace.cxx. ◆ SetPoints() [1/2]. void TGeoHalfSpace::SetPoints ; (; Double_t * ; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 62 of file TGeoHalfSpace.h. ◆ SetPoints() [2/2]. void TGeoHalfSpace::SetPoints ; (; Float_t * ; ); const. inlineove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:31274,safe,safe,31274,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety,"lass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetInputList (TList *input);  ; virtual void SetObject (TObject *obj);  ; virtual void SetOption (const char *option);  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawHist.html:1535,Abort,Abort,1535,doc/master/classTProofDrawHist.html,https://root.cern,https://root.cern/doc/master/classTProofDrawHist.html,6,['Abort'],['Abort']
Safety,"lass TAttCanvas; 2247/// class TButton; 2248/// (header1.h header2.h .. headerN.h); 2249/// class TMyClass; 2250 ; 2251int CreateNewRootMapFile(const std::string &rootmapFileName,; 2252 const std::string &rootmapLibName,; 2253 const std::list<std::string> &classesDefsList,; 2254 const std::list<std::string> &classesNames,; 2255 const std::list<std::string> &nsNames,; 2256 const std::list<std::string> &tdNames,; 2257 const std::list<std::string> &enNames,; 2258 const std::list<std::string> &varNames,; 2259 const HeadersDeclsMap_t &headersClassesMap,; 2260 const std::unordered_set<std::string> headersToIgnore); 2261{; 2262 // Create the rootmap file from the selected classes and namespaces; 2263 std::ofstream rootmapFile(rootmapFileName.c_str());; 2264 if (!rootmapFile) {; 2265 ROOT::TMetaUtils::Error(nullptr, ""Opening new rootmap file %s\n"", rootmapFileName.c_str());; 2266 return 1;; 2267 }; 2268 ; 2269 // Keep track of the classes keys; 2270 // This is done to avoid duplications of keys with typedefs; 2271 std::unordered_set<std::string> classesKeys;; 2272 ; 2273 ; 2274 // Add the ""section""; 2275 if (!classesNames.empty() || !nsNames.empty() || !tdNames.empty() ||; 2276 !enNames.empty() || !varNames.empty()) {; 2277 ; 2278 // Add the template definitions; 2279 if (!classesDefsList.empty()) {; 2280 rootmapFile << ""{ decls }\n"";; 2281 for (auto & classDef : classesDefsList) {; 2282 rootmapFile << classDef << std::endl;; 2283 }; 2284 rootmapFile << ""\n"";; 2285 }; 2286 rootmapFile << ""[ "" << rootmapLibName << "" ]\n"";; 2287 ; 2288 // Loop on selected classes and insert them in the rootmap; 2289 if (!classesNames.empty()) {; 2290 rootmapFile << ""# List of selected classes\n"";; 2291 for (auto & className : classesNames) {; 2292 rootmapFile << ""class "" << className << std::endl;; 2293 classesKeys.insert(className);; 2294 }; 2295 // And headers; 2296 std::unordered_set<std::string> treatedHeaders;; 2297 for (auto & className : classesNames) {; 2298 // Don't treat templates; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:90040,avoid,avoid,90040,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"lass TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:1229,Timeout,Timeout,1229,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,4,['Timeout'],['Timeout']
Safety,"lass TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:1253,Timeout,Timeout,1253,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['Timeout'],['Timeout']
Safety,"lass to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F *, T >;  CFuncEvaluator< F *const, T >;  CParamFunctorTemplParam Functor class for Multidimensional functions ;  ►CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CMemFuncEvaluator;  CPlaceExpr;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlainParameters;  CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:52428,avoid,avoid,52428,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['avoid'],['avoid']
Safety,"lass(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:2111,safe,safe,2111,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,2,['safe'],['safe']
Safety,"lassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:138879,safe,safe,138879,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"lassInit) {; 3708 ; 3709 R__LOCKGUARD(gInterpreterMutex);; 3710 if (!fHasRootPcmInfo) {; 3711 // The bases are in our ProtoClass; we don't need the class info.; 3712 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3713 if (proto && proto->FillTClass(this)); 3714 return fBase;; 3715 }; 3716 }; 3717 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3718 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3719 LoadClassInfo();; 3720 }; 3721 }; 3722 if (!fClassInfo); 3723 return nullptr;; 3724 ; 3725 if (!gInterpreter); 3726 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3727 ; 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 if (!fBase.load()) {; 3730 gInterpreter->CreateListOfBaseClasses(this);; 3731 }; 3732 }; 3733 return fBase;; 3734}; 3735 ; 3736////////////////////////////////////////////////////////////////////////////////; 3737/// Return a list containing the TEnums of a class.; 3738///; 3739/// The list returned is safe to use from multiple thread without explicitly; 3740/// taking the ROOT global lock.; 3741///; 3742/// In the case the TClass represents a namespace, the returned list will; 3743/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3744///; 3745/// In the case the TClass represents a class or struct and requestListLoading; 3746/// is true, the list is immutable (and thus safe to access from multiple thread; 3747/// without taking the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or struct and requestListLoading; 3750/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3751/// which will implicit take the ROOT global lock upon any access.; 3752 ; 3753TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3754{; 3755 auto temp = fEnums.load();; 3756 if (temp) {; 3757 if (requestListLoading) {; 3758 if (fProperty == -1) Property();; 3759 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3760 R__L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:141630,safe,safe,141630,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"lassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrap.html:3201,safe,safe,3201,root/html532/TGeoTrap.html,https://root.cern,https://root.cern/root/html532/TGeoTrap.html,1,['safe'],['safe']
Safety,"lassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGtra.html:3180,safe,safe,3180,root/html532/TGeoGtra.html,https://root.cern,https://root.cern/root/html532/TGeoGtra.html,1,['safe'],['safe']
Safety,"lasses are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, sp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:3205,avoid,avoiding,3205,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['avoid'],['avoiding']
Safety,"lated likelihood approach by transforming linearly the input variables into a diagonal space, using the square-root of the covariance matrix; The method of maximum likelihood is the most straightforward, and certainly among the most elegant multivariate analyser approaches. We define the likelihood ratio, \( R_L \), for event \( i \), by:. \[; R_L(i) = \frac{L_S(i)}{L_B(i) + L_B(i)}; \]. Here the signal and background likelihoods, \( L_S \), \( L_B \), are products of the corresponding probability densities, \( p_S \), \( p_B \), of the \( N_{var} \) discriminating variables used in the MVA:. \[; L_S(i) \ \prod_{j=1}^{N_{var}} p_{Sj} (i); \]. and accordingly for \( L_B \). In practise, TMVA uses polynomial splines to estimate the probability density functions (PDF) obtained from the distributions of the training variables.; Note that in TMVA the output of the likelihood ratio is transformed by:. \[; R_L(i) \to R'_L(i) = -\frac{1}{\tau} ln(R_L^{-1}(i) -1); \]. to avoid the occurrence of heavy peaks at \( R_L = 0.1 \) .; Decorrelated (or ""diagonalized"") Likelihood; The biggest drawback of the Likelihood approach is that it assumes that the discriminant variables are uncorrelated. If it were the case, it can be proven that the discrimination obtained by the above likelihood ratio is optimal, ie, no other method can beat it. However, in most practical applications of MVAs correlations are present. ; Linear correlations, measured from the training sample, can be taken into account in a straightforward manner through the square-root of the covariance matrix. The square-root of a matrix \( C \) is the matrix \( C′ \) that multiplied with itself yields \( C \): \( C \)= \( C′C′ \). We compute the square-root matrix (SQM) by means of diagonalising ( \( D \)) the covariance matrix:. \[; D = S^TCS \Rightarrow C' = S \sqrt{DS^T}; \]. and the linear transformation of the linearly correlated into the uncorrelated variables space is then given by multiplying the measured variable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:1477,avoid,avoid,1477,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['avoid'],['avoid']
Safety,"lated to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotically correct uncertainties for extended unbinned likelihood fits; Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights. This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:9191,safe,safe,9191,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['avoid', 'safe']","['avoided', 'safe']"
Safety,"lative importance of variable ivar ; Definition at line 2766 of file DecisionTree.cxx. ◆ IsA(). virtual TClass * TMVA::DecisionTree::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::BinaryTree.; Definition at line 243 of file DecisionTree.h. ◆ PruneNode(). void TMVA::DecisionTree::PruneNode ; (; TMVA::DecisionTreeNode * ; node). prune away the subtree below the node ; Definition at line 1194 of file DecisionTree.cxx. ◆ PruneNodeInPlace(). void TMVA::DecisionTree::PruneNodeInPlace ; (; TMVA::DecisionTreeNode * ; node). prune a node temporarily (without actually deleting its descendants which allows testing the pruned tree quality for many different pruning stages without ""touching"" the tree. ; Definition at line 1217 of file DecisionTree.cxx. ◆ PruneTree(). Double_t TMVA::DecisionTree::PruneTree ; (; const EventConstList * ; validationSample = nullptr). prune (get rid of internal nodes) the Decision tree to avoid overtraining several different pruning methods can be applied as selected by the variable ""fPruneMethod"". ; Definition at line 964 of file DecisionTree.cxx. ◆ SamplePurity(). Double_t TMVA::DecisionTree::SamplePurity ; (; EventList ; eventSample). private . calculates the purity S/(S+B) of a given event sample ; Definition at line 2722 of file DecisionTree.cxx. ◆ SetAnalysisType(). void TMVA::DecisionTree::SetAnalysisType ; (; Types::EAnalysisType ; t). inline . Definition at line 189 of file DecisionTree.h. ◆ SetMinLinCorrForFisher(). void TMVA::DecisionTree::SetMinLinCorrForFisher ; (; Double_t ; min). inline . Definition at line 192 of file DecisionTree.h. ◆ SetNodePurityLimit(). void TMVA::DecisionTree::SetNodePurityLimit ; (; Double_t ; p). inline . Definition at line 161 of file DecisionTree.h. ◆ SetNVars(). void TMVA::DecisionTree::SetNVars ; (; Int_t ; n). inline . Definition at line 194 of file DecisionTree.h. ◆ SetParentTreeInNodes(). void TMVA::DecisionTree::SetParentTreeInNodes ; (; Node * ; n =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:23477,avoid,avoid,23477,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['avoid'],['avoid']
Safety,"lback_t ; func). Set call-back function for new connection. ; Definition at line 1743 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 693 of file RWebWindow.cxx. ◆ SetConnToken(). void RWebWindow::SetConnToken ; (; const std::string & ; token = """"). Configures connection token (default none) When specified, in URL of webpage such token should be provided as &token=value parameter, otherwise web window will refuse connection. ; Definition at line 715 of file RWebWindow.cxx. ◆ SetDataCallBack(). void RWebWindow::SetDataCallBack ; (; WebWindowDataCallback_t ; func). Set call-back function for data, received from the clients via websocket. ; Function should have signature like void func(unsigned connid, const std::string &data) First argument identifies connection (unique for each window), second argument is received data; At the moment when callback is assigned, RWebWindow working thread is detected. If called not from main application thread, RWebWindow::Run() function must be regularly called from that thread.; Most simple way to assign call-back - use of c++11 lambdas like: auto win = RWebWindow::Create();; win->SetDefaultPage(""file:./page.htm"");; win->SetDataCallBack(; [](unsigned connid, const std::string &data) {; printf(""Conn:%u data:%s\n"", connid, data.c_str());; }; );; win->Show();; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:44355,detect,detected,44355,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['detect'],['detected']
Safety,"lback_t ; func). Set call-back function for new connection. ; Definition at line 1785 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 694 of file RWebWindow.cxx. ◆ SetConnToken(). void RWebWindow::SetConnToken ; (; const std::string & ; token = """"). Configures connection token (default none) When specified, in URL of webpage such token should be provided as &token=value parameter, otherwise web window will refuse connection. ; Definition at line 716 of file RWebWindow.cxx. ◆ SetDataCallBack(). void RWebWindow::SetDataCallBack ; (; WebWindowDataCallback_t ; func). Set call-back function for data, received from the clients via websocket. ; Function should have signature like void func(unsigned connid, const std::string &data) First argument identifies connection (unique for each window), second argument is received data; At the moment when callback is assigned, RWebWindow working thread is detected. If called not from main application thread, RWebWindow::Run() function must be regularly called from that thread.; Most simple way to assign call-back - use of c++11 lambdas like: auto win = RWebWindow::Create();; win->SetDefaultPage(""file:./page.htm"");; win->SetDataCallBack(; [](unsigned connid, const std::string &data) {; printf(""Conn:%u data:%s\n"", connid, data.c_str());; }; );; win->Show();; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:43239,detect,detected,43239,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['detect'],['detected']
Safety,"ld = nullptr;; 499 ClearThreadsMap();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503/// Destructor; 504 ; 505TGeoManager::~TGeoManager(); 506{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21619,Safe,SafeDelete,21619,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"ld::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; Int_t binMapEta[49+2];; Int_t binMapPt[49+2];; // overflow and underflow bins are not used; binMapEta[0]=-1;; binMapEta[49+1]=-1;; binMapPt[0]=-1;; binMapPt[49+1]=-1;; for(Int_t i=1;i<=49;i++) {; // all bins (i) with the same (i-1)/7 are added; binMapEta[i] = (i-1)/7 +1;; // all bins (i) with the same (i-1)%7 are added; binMapPt[i] = (i-1)%7 +1;; }; TH1D *etaHist=new TH1D(""eta(unfolded)"","";eta"",7,etamin,etamax);; TH1D *etaCorr=new TH2D(""eta(unfolded)"","";eta;eta"",7,etamin,etamax,7,etamin,etamax);; TH1D *ptHist=new TH1D(""pt(unfolded)"","";pt"",7,ptmin,ptmax);; TH1D *ptCorr=new TH2D(""pt(unfolded)"","";pt;pt"",7,ptmin,ptmax,7,ptmin,ptmax);; unfold.GetOutput(etaHist,binMapEta);; unfold.GetRhoIJ(etaCorrt,binMapEta);; unfold.GetOutput(ptHist,binMapPt);; unfold.GetRhoIJ(ptCorrt,binMapPt);. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:8064,avoid,avoid,8064,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['avoid'],['avoid']
Safety,"lders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by the producer, and creating a reference to the folder by the user.; 10.3.1 Creating a Folder Hierarchy; To create a folder hierarchy you add the top folder of your hierarchy to //root. Then you add a folder to an existing folder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421495,Detect,Detector,421495,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Detect'],['Detector']
Safety,"lding the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7075f00/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x69b2ac0/V- RooRealVar::meanG = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x7002610/V- RooRealVar::yieldSig = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 0x76dd3d0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x733d770/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x71a3180/V- RooRealVar::meanG_Sample1 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x769f520/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; 0x74a38c0/V- RooRealVar::M = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf514__RooCustomizer_8py.html:3920,safe,safe,3920,doc/master/rf514__RooCustomizer_8py.html,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html,1,['safe'],['safe']
Safety,"le TBasket.h. ◆ fBufferSize. Int_t TBasket::fBufferSize {0}. protected . fBuffer length in bytes ; Definition at line 62 of file TBasket.h. ◆ fCompressedBufferRef. TBuffer* TBasket::fCompressedBufferRef {nullptr}. protected . ! Compressed buffer. ; Definition at line 74 of file TBasket.h. ◆ fDisplacement. Int_t* TBasket::fDisplacement {nullptr}. protected . ![fNevBuf] Displacement of entries in fBuffer(TKey) ; Definition at line 70 of file TBasket.h. ◆ fEntryOffset. Int_t* TBasket::fEntryOffset {nullptr}. protected . [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ; Special value of -1 indicates that the offset generation MUST be performed on first read. ; Definition at line 71 of file TBasket.h. ◆ fHeaderOnly. bool TBasket::fHeaderOnly {false}. protected . True when only the basket header must be read/written. ; Definition at line 66 of file TBasket.h. ◆ fIOBits. UChar_t TBasket::fIOBits {0}. protected . !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ; Definition at line 67 of file TBasket.h. ◆ fLast. Int_t TBasket::fLast {0}. protected . Pointer to last used byte in basket. ; Definition at line 65 of file TBasket.h. ◆ fLastWriteBufferSize. Int_t TBasket::fLastWriteBufferSize[3] = {0,0,0}. protected . ! Size of the buffer last three buffers we wrote it to disk ; Definition at line 75 of file TBasket.h. ◆ fNevBuf. Int_t TBasket::fNevBuf {0}. protected . Number of entries in basket. ; Definition at line 64 of file TBasket.h. ◆ fNevBufSize. Int_t TBasket::fNevBufSize {0}. protected . Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ; Definition at line 63 of file TBasket.h. ◆ fNextBufferSizeRecord. UChar_t TBasket::fNextBufferSizeRecord {0}. protected . ! Index into fLastWriteBufferSize of the last buffer written to disk ; Definition at line 77 of file TBasket.h. ◆ fOwnsCompressedBuffer. bool TBasket::fOwnsCompressedBuffer {false}. protected . ! Whether ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:31796,avoid,avoid,31796,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['avoid'],['avoid']
Safety,"le TFile.h. ◆ SetFileBytesRead(). void TFile::SetFileBytesRead ; (; Long64_t ; bytes = 0). static . Definition at line 4608 of file TFile.cxx. ◆ SetFileBytesWritten(). void TFile::SetFileBytesWritten ; (; Long64_t ; bytes = 0). static . Definition at line 4611 of file TFile.cxx. ◆ SetFileReadCalls(). void TFile::SetFileReadCalls ; (; Int_t ; readcalls = 0). static . Definition at line 4614 of file TFile.cxx. ◆ SetOffset(). void TFile::SetOffset ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Definition at line 2253 of file TFile.cxx. ◆ SetOnlyStaged(). Bool_t TFile::SetOnlyStaged ; (; Bool_t ; onlystaged). static . Sets only staged flag. ; Returns previous value of flag. When true we check before opening the file if it is staged, if not, the open fails. ; Definition at line 4744 of file TFile.cxx. ◆ SetOpenTimeout(). UInt_t TFile::SetOpenTimeout ; (; UInt_t ; timeout). static . Sets open timeout time (in ms). Returns previous timeout value. ; Definition at line 4724 of file TFile.cxx. ◆ SetOption(). virtual void TFile::SetOption ; (; Option_t * ; option = "">""). inlinevirtual . Definition at line 289 of file TFile.h. ◆ SetReadaheadSize(). void TFile::SetReadaheadSize ; (; Int_t ; bufsize = 256000). static . Definition at line 4605 of file TFile.cxx. ◆ SetReadCalls(). virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one can still read the StreamerInfo with myfile.ReadStreamerInfo(); ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:95106,timeout,timeout,95106,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"le TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoSubtraction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 203 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoSubtraction::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 875 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoSubtraction::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 883 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoSubtraction::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1177 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoSubtraction::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1201 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoSubtraction::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1220 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoSubtraction::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoSubtraction::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 203 of file TGeoBoolNode.h. Libraries for TGeoSubtraction:. [legend]; The documentation for this class was generated from the foll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:18421,safe,safety,18421,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safety']
Safety,"le TGeoParaboloid.h. ◆ GetRhi(). Double_t TGeoParaboloid::GetRhi ; (; ); const. inline . Definition at line 57 of file TGeoParaboloid.h. ◆ GetRlo(). Double_t TGeoParaboloid::GetRlo ; (; ); const. inline . Definition at line 56 of file TGeoParaboloid.h. ◆ InspectShape(). void TGeoParaboloid::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoParaboloid::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoParaboloid.h. ◆ IsCylType(). Bool_t TGeoParaboloid::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoParaboloid.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoParaboloid::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoParaboloid & TGeoParaboloid::operator= ; (; const TGeoParaboloid & ; ). privatedelete . ◆ Safety(). Double_t TGeoParaboloid::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoParaboloid::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoParaboloid::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoParaboloid::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetParaboloidDimensions(). void TGeoParaboloid::SetParaboloidDimensions ; (; Double_t ; rlo, . Double_t ; rhi, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoParaboloid::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoParaboloid::SetPoints ; (; Float_t * ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:28355,Safe,Safety,28355,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['Safe'],['Safety']
Safety,"le TGeoTorus.h. ◆ GetR(). Double_t TGeoTorus::GetR ; (; ); const. inline . Definition at line 73 of file TGeoTorus.h. ◆ GetRmax(). Double_t TGeoTorus::GetRmax ; (; ); const. inline . Definition at line 75 of file TGeoTorus.h. ◆ GetRmin(). Double_t TGeoTorus::GetRmin ; (; ); const. inline . Definition at line 74 of file TGeoTorus.h. ◆ InspectShape(). void TGeoTorus::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTorus::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoTorus.h. ◆ IsCylType(). Bool_t TGeoTorus::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoTorus.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTorus::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoTorus & TGeoTorus::operator= ; (; const TGeoTorus & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTorus::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTorus::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTorus::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTorus::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTorus::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTorus::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoTorus::SetSegsAndPols ; (; TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:29469,Safe,Safety,29469,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['Safe'],['Safety']
Safety,"le and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferred and asynchronous.; 23.2.4.5 Deferred; Set by TThread::SetCancelDeferred() (default): When the user knows safe places in their code where a thread can be canceled without risk for the rest of the system, they can define these points by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the operator delete is dangerous. Use th->Delete() instead. C++ delete is safe only if thread is not running. Often during the canceling, some clean up actions must be taken. To define clean up functions use:; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1112270,safe,safe,1112270,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"le can have multiple versions of the same class, for example objects of old and new versions of a class can be in the same file. The StreamerInfois described in detail in the section on Streamers.; 11.1.5 The List of Keys and the List of Free Blocks; The last three entries on the output of TFile::Map() are the list of keys, the list of free segments, and the address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440126,Recover,Recovery,440126,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Recover'],['Recovery']
Safety,"le gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const TClass * ; cl). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1903 of file TSQLFile.cxx. ◆ ResetErrno(). void TSQLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85907,recover,recovery,85907,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovery']
Safety,"le gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXML objects When saving, all this elements are linked to root xml node At the end StreamerInfo structures are added After xml document is saved, all nodes will be unlinked from root node and kept in memory. ; Only Close() or destructor release memory, used by xml structures ; Definition at line 454 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67958,recover,recovery,67958,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovery']
Safety,"le if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441199,recover,recover,441199,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['recover'],"['recover', 'recovered']"
Safety,"le xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7fff963ebea0 RooAddPdf::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:6386,safe,safe,6386,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,1,['safe'],['safe']
Safety,"le); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5440 int truncated;; 5441 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5442 STARTUPINFOA si;; 5443 PROCESS_INFORMATION pi = {0};; 5444 ; 5445 (void)envp;; 5446 ; 5447 memset(&si, 0, sizeof(si));; 5448 si.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:159891,timeout,timeout,159891,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"le); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5441 int truncated;; 5442 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5443 STARTUPINFOA si;; 5444 PROCESS_INFORMATION pi = {0};; 5445 ; 5446 (void)envp;; 5447 ; 5448 memset(&si, 0, sizeof(si));; 5449 si.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:159923,timeout,timeout,159923,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"le. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:13191,safe,safe,13191,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,3,['safe'],['safe']
Safety,"le32_t. This is actually a correct case.; 1577 } else {; 1578 Error(""Branch"", ""The class requested (%s) for \""%s\"" is different from the type of the pointer passed (%s)"",; 1579 claim->GetName(), branchname, ptrClass->GetName());; 1580 }; 1581 } else if (actualClass && (claim != actualClass) && !actualClass->InheritsFrom(claim)) {; 1582 if (claim->IsLoaded() && actualClass->IsLoaded() && strcmp( claim->GetTypeInfo()->name(), actualClass->GetTypeInfo()->name() ) == 0) {; 1583 // The type is the same according to the C++ type_info, we must be in the case of; 1584 // a template of Double32_t. This is actually a correct case.; 1585 } else {; 1586 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1587 actualClass->GetName(), branchname, claim->GetName());; 1588 }; 1589 }; 1590 }; 1591 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1592 Error(""Branch"", writeStlWithoutProxyMsg,; 1593 claim->GetName(), branchname, claim->GetName());; 1594 return nullptr;; 1595 }; 1596 return Branch(branchname, classname, (void*) addobj, bufsize, splitlevel);; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Same as TTree::Branch but automatic detection of the class name.; 1601/// \see TTree::Branch for other details.; 1602 ; 1603TBranch* TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:60243,detect,detection,60243,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detection']
Safety,"le; TStringTNamed::fTitleobject title; Double_tfTl1half length in x at low z and y high edge; Double_tfTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:14612,safe,safe,14612,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,3,['safe'],['safe']
Safety,"le; static Int_t _nameLength;  . #include <RooGenContext.h>. Inheritance diagram for RooGenContext:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooGenContext(). RooGenContext::RooGenContext ; (; const RooAbsPdf & ; model, . const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false, . const RooArgSet * ; forceDirect = nullptr . ). Initialize a new context for generating events with the specified variables, using the specified PDF model. ; A prototype dataset (if provided) is not cloned and still belongs to the caller. The contents and shape of this dataset can be changed between calls to generate() as long as the expected columns to be copied to the generated dataset are present. Any argument supplied in the forceDirect RooArgSet are always offered for internal generation to the p.d.f., even if this is deemed unsafe by the logic of RooGenContext. ; Definition at line 62 of file RooGenContext.cxx. ◆ ~RooGenContext(). RooGenContext::~RooGenContext ; (; ). overridedefault . Member Function Documentation. ◆ attach(). void RooGenContext::attach ; (; const RooArgSet & ; params). overridevirtual . Attach the cloned model to the event buffer we will be filling. ; Reimplemented from RooAbsGenContext.; Definition at line 305 of file RooGenContext.cxx. ◆ Class(). static TClass * RooGenContext::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooGenContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooGenContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file RooGenContext.h. ◆ DeclFileName(). static const char * RooGenContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:18707,unsafe,unsafe,18707,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['unsafe'],['unsafe']
Safety,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:21188,avoid,avoid,21188,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,4,['avoid'],['avoid']
Safety,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19836,avoid,avoid,19836,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,1,['avoid'],['avoid']
Safety,"leBytesRead();; 318 static Long64_t GetFileBytesWritten();; 319 static Int_t GetFileReadCalls();; 320 static Int_t GetReadaheadSize();; 321 ; 322 static void SetFileBytesRead(Long64_t bytes = 0);; 323 static void SetFileBytesWritten(Long64_t bytes = 0);; 324 static void SetFileReadCalls(Int_t readcalls = 0);; 325 static void SetReadaheadSize(Int_t bufsize = 256000);; 326 static void SetReadStreamerInfo(Bool_t readinfo=kTRUE);; 327 static Bool_t GetReadStreamerInfo();; 328 ; 329 static Long64_t GetFileCounter();; 330 static void IncrementFileCounter();; 331 ; 332 static Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected = kTRUE,; 333 Bool_t forceCacheread = kFALSE);; 334 static const char *GetCacheFileDir();; 335 static Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);; 336 static Bool_t Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,; 337 UInt_t buffersize = 1000000);; 338 ; 339 static UInt_t SetOpenTimeout(UInt_t timeout); // in ms; 340 static UInt_t GetOpenTimeout(); // in ms; 341 static Bool_t SetOnlyStaged(Bool_t onlystaged);; 342 static Bool_t GetOnlyStaged();; 343 ; 344 ClassDefOverride(TFile,8) //ROOT file; 345};; 346 ; 347#define gFile (TFile::CurrentFile()); 348 ; 349/**; 350\class TFileOpenHandle; 351\ingroup IO; 352Class holding info about the file being opened; 353*/; 354class TFileOpenHandle : public TNamed {; 355 ; 356friend class TFile;; 357 ; 358private:; 359 TString fOpt; ///< Options; 360 Int_t fCompress{0}; ///< Compression level and algorithm; 361 Int_t fNetOpt{0}; ///< Network options; 362 TFile *fFile{nullptr}; ///< TFile instance of the file being opened; 363 ; 364 TFileOpenHandle(TFile *f) : TNamed("""",""""), fOpt(""""), fCompress(ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault),; 365 fNetOpt(0), fFile(f) { }; 366 TFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp,; 367 Int_t no) : TNamed(n,t), fOpt(o), fCompress(cmp),; 368 fNetOpt(no), fFile(nullptr)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:17031,timeout,timeout,17031,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"le_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set sock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11376,timeout,timeout,11376,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"le_t *norm) override;  Normal computation. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside this shape. ;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; TGeoVolume * Divide (TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t) override;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; const char * GetName () const override;  Get the shape name. ;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; TGeoShape * GetShape () const;  ; vecgeom::cxx::VPlacedVolume * GetVGShape () const;  ; void InspectShape () const override;  Print info about the VecGeom solid. ;  ; Bool_t IsAssembly () const override;  ; Bool_t IsComposite () const override;  ; Bool_t IsCylType () const override;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:1917,avoid,avoid,1917,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['avoid'],['avoid']
Safety,"le_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Bool_t HasRmin () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetTubeDimensions (Double_t rmin, Double_t rmax, Double_t dz);  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:5715,Safe,Safety,5715,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,6,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }; ; //_____________________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }; //_____________________________________________________________________; Bool_t h1analysisTreeReader::Process(Long64_t entry){; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; myTreeReader.SetLocalEntry(entry);; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Return as soon as a bad entry is detected; if (TMath::Abs(*fMd0_d-1.8646) >= 0.04) return kFALSE;; if (*fPtds_d <= 2.5) return kFALSE;; if (TMath::Abs(*fEtads_d) >= 1.5) return kFALSE;; (*fIk)--; //original fIk used f77 convention starting at 1; (*fIpi)--;; ; ; if (fNhitrp.At(*fIk)* fNhitrp.At(*fIpi) <= 1) return kFALSE;; ; ; if (fRend.At(*fIk) -fRstart.At(*fIk) <= 22) return kFALSE;; if (fRend.At(*fIpi)-fRstart.At(*fIpi) <= 22) return kFALSE;; if (fNlhk.At(*fIk) <= 0.1) return kFALSE;; if (fNlhpi.At(*fIpi) <= 0.1) return kFALSE;; (*fIpis)--; if (fNlhpi.At(*fIpis) <= 0.1) return kFALSE;; if (*fNjets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; //fill some histograms; hdmd->Fill(*fDm_d);; h2->Fill(*fDm_d,*fRpd0_t/0.029979*1.8646/ *fPtd0_d);; ; return kTRUE;; }; ; void h1analysisTreeReader::Begin(TTree* /*myTree*/) {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:1683,detect,detected,1683,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['detect'],['detected']
Safety,"le_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetFormulavirtual const TFormula * GetFormula() constDefinition TF1.h:485; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetParametervirtual Double_t GetParameter(const TString &name) constDefinition TF1.h:544; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::GetParametersvirtual void GetParameters(Double_t *params)Definition TF1.h:552; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:48556,safe,safe,48556,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['safe'],['safe']
Safety,"le_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:15185,safe,safe,15185,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"le_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoConeSeg.html:9140,Safe,SafetyPhi,9140,root/html530/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html,2,['Safe'],['SafetyPhi']
Safety,"le_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeSeg.html:9120,Safe,SafetyPhi,9120,root/html530/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html,2,['Safe'],['SafetyPhi']
Safety,"le_t cm, Double_t sm, Double_t cdfi);  ; static Double_t SafetyS (const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz=0);  ;  Static Public Member Functions inherited from TGeoTube; static Double_t Capacity (Double_t rmin, Double_t rmax, Double_t dz);  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void ComputeNormalS (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax, Double_t dz);  ; static const char * DeclFileName ();  ; static Double_t DistFromInsideS (const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);  ; static Double_t DistFromOutsideS (const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);  ; static void DistToTube (Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);  ; static Double_t SafetyS (const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz=0);  ;  Static Public Member Functions inherited from TGeoBBox; static Bool_t AreOverlapping (const TGeoBBox *box1, const TGeoMatrix *mat1, const TGeoBBox *box2, const TGeoMatrix *mat2) R__DEPRECATED(6;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Contains (const Double_t *point, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin);  ; static const char * DeclFileName ();  ; static Double_t DistFromInside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ; static Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ;  Static Public Member Functions inherited from TGeoShape; static Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:20090,Safe,SafetyS,20090,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,2,['Safe'],['SafetyS']
Safety,"le_t dz, Double_t *vertices=nullptr);  ;  TGeoArb8 (Double_t dz, Double_t *vertices=nullptr);  ;  ~TGeoArb8 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; void ComputeTwist ();  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetClosestEdge (const Double_t *point, Double_t *vert, Int_t &isegment) const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; Bool_t GetPointsOnFacet (Int_t, Int_t, Double_t *) const override;  ; Double_t GetTwist (Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:1437,safe,safe,1437,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety,"le_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:16988,safe,safe,16988,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['safe'],['safe']
Safety,"le_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:15450,safe,safe,15450,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety,"le_t fstyle)Set the fill area style.Definition TAttFill.h:39; TCanvasThe Canvas class.Definition TCanvas.h:23; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintEvalErrorsRooCmdArg PrintEvalErrors(Int_t numErrors)Definition RooGlobalFunc.cxx:725; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::RecoverFromUndefinedRegionsRooCmdArg RecoverFromUndefinedRegions(double strength)When parameters are chosen such that a PDF is undefined, try to indicate to the minimiser how to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:8175,Recover,RecoverFromUndefinedRegionsRooCmdArg,8175,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,2,['Recover'],"['RecoverFromUndefinedRegions', 'RecoverFromUndefinedRegionsRooCmdArg']"
Safety,"le_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:14884,safe,safe,14884,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,1,['safe'],['safe']
Safety,"le_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHype.html:15083,safe,safe,15083,root/html530/TGeoHype.html,https://root.cern,https://root.cern/root/html530/TGeoHype.html,2,['safe'],['safe']
Safety,"le_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:8186,Safe,SafetyS,8186,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,1,['Safe'],['SafetyS']
Safety,"le_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNumberOfDivisions () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Double_t GetTheta1 () const;  ; Double_t GetTheta2 () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Int_t IsOnBoundary (const Double_t *point) const;  ; Bool_t IsPointInside (const Double_t *point, Bool_t checkR=kTRUE, Bool_t checkTh=kTRUE, Bool_t checkPh=kTRUE) const;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetDimensions (Double_t *param, Int_t nparam);  ; virtual void SetNumberOfDivisions (Int_t p);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetSphDimensions (Double_t rmin, Double_t rmax, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:3424,Safe,Safety,3424,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Set dimensions of the cone segment. void SetDimensions(Double_t* param); Set dimensions of the cone segment from an array. void SetPoints(Double_t* points) const; Create cone segment mesh points. void SetPoints(Float_t* points) const; Create cone segment mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!pain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:17508,Safe,SafetyS,17508,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,3,['Safe'],['SafetyS']
Safety,"le_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:2820,safe,safe,2820,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,9,['safe'],['safe']
Safety,"le_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, Double_t* local) const; Convert a vector from mother reference to local reference system. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert the point coordinates from local reference system to mother reference. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a vector from local reference system to mother reference. void ls(Option_t* option = """") const; Print the path (A/B/C/...) to this node on stdout. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void PrintCandidates() const; print daughters candidates for containing current point; cd();. void PrintOverlaps() const; print possible overlapping nodes; if (!IsOverlapping()) {printf(""node %s is ONLY\n"", GetName()); return;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape. void SetOverlaps(Int_t* ovlp, Int_t novlp); set the list of overlaps for this node (ovlp must be created with operator new). void SetVisibility(Bool_t vis = kTRUE); Set visibility of the node (obsolete). void VisibleDaughters(Bool_t vis = kTRUE); Set visibility of the daughters (obsolete). void cd() const; {;}. Int_t GetByteCount() const; {return 44;}. TGeoNode * GetDaughter(Int_t ind) const; {return fVolume->GetNode(ind);}. TGeoMatrix * GetMatrix() const. Int_t GetColour() const; {return fVolume->GetLineColor();}. Int_t GetIndex() const; {return 0;}. TGeoPatternFinder * GetFinder() const; {return 0;}. TGeoMedium * GetMedium() const; {return fVolume->GetMedium();}. TGeoVolume * GetMotherVolume() const; {return fMother;}. Int_t GetNdaughters() const; {return fVolume->GetNdaughters();}. TObjArray * GetNodes() const; {return fVolume->GetNodes();}. Int_t GetNumber() const; {return fNumber;}. Int_t * GetOverlaps(Int_t& novlp) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNode.html:14748,Safe,Safety,14748,root/html528/TGeoNode.html,https://root.cern,https://root.cern/root/html528/TGeoNode.html,3,['Safe'],['Safety']
Safety,"le_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Double_tSafetyToSegment(Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:7980,Safe,SafetyPhi,7980,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,1,['Safe'],['SafetyPhi']
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:22450,safe,safe,22450,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPgon.html:24200,safe,safe,24200,root/html604/TGeoPgon.html,https://root.cern,https://root.cern/root/html604/TGeoPgon.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:24200,safe,safe,24200,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:7825,safe,safe,7825,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,1,['safe'],['safe']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TShape.html:8707,avoid,avoid,8707,root/html528/TShape.html,https://root.cern,https://root.cern/root/html528/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TShape.html:8776,avoid,avoid,8776,root/html530/TShape.html,https://root.cern,https://root.cern/root/html530/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TShape.html:8776,avoid,avoid,8776,root/html532/TShape.html,https://root.cern,https://root.cern/root/html532/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←. TBRIK; ←. TGTRA. TPARA. TTRAP. TTRD1. TTRD2. TPCON; ←. TPGON. TPolyLineShape. TSPHE.  [more...]. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TShape.html:9551,avoid,avoid,9551,root/html604/TShape.html,https://root.cern,https://root.cern/root/html604/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←. TBRIK; ←. TGTRA. TPARA. TTRAP. TTRD1. TTRD2. TPCON; ←. TPGON. TPolyLineShape. TSPHE.  [more...]. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TShape.html:9551,avoid,avoid,9551,root/html602/TShape.html,https://root.cern,https://root.cern/root/html602/TShape.html,1,['avoid'],['avoid']
Safety,"lection status ;; 2202 if (haveCompSel) plotOnCompSelect(nullptr) ;; 2203 ; 2204 return ret ;; 2205}; 2206 ; 2207 ; 2208//_____________________________________________________________________________; 2209/// Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; 2210/// the scale factor for a PDF can be interpreted in three different ways. The interpretation; 2211/// is controlled by ScaleType; 2212/// ```; 2213/// Relative - Scale factor is applied on top of PDF normalization scale factor; 2214/// NumEvent - Scale factor is interpreted as a number of events. The surface area; 2215/// under the PDF curve will match that of a histogram containing the specified; 2216/// number of event; 2217/// Raw - Scale factor is applied to the raw (projected) probability density.; 2218/// Not too useful, option provided for completeness.; 2219/// ```; 2220// coverity[PASS_BY_VALUE]; 2221RooPlot* RooAbsPdf::plotOn(RooPlot *frame, PlotOpt o) const; 2222{; 2223 ; 2224 // Sanity checks; 2225 if (plotSanityChecks(frame)) return frame ;; 2226 ; 2227 // More sanity checks; 2228 double nExpected(1) ;; 2229 if (o.stype==RelativeExpected) {; 2230 if (!canBeExtended()) {; 2231 coutE(Plotting) << ""RooAbsPdf::plotOn("" << GetName(); 2232 << ""): ERROR the 'Expected' scale option can only be used on extendable PDFs"" << endl ;; 2233 return frame ;; 2234 }; 2235 frame->updateNormVars(*frame->getPlotVar()) ;; 2236 nExpected = expectedEvents(frame->getNormVars()) ;; 2237 }; 2238 ; 2239 // Adjust normalization, if so requested; 2240 if (o.stype != Raw) {; 2241 ; 2242 if (frame->getFitRangeNEvt() && o.stype==Relative) {; 2243 // If non-default plotting range is specified, adjust number of events in fit range; 2244 o.scaleFactor *= frame->getFitRangeNEvt()/nExpected ;; 2245 } else if (o.stype==RelativeExpected) {; 2246 o.scaleFactor *= nExpected ;; 2247 } else if (o.stype==NumEvent) {; 2248 o.scaleFactor /= nExpected ;; 2249 }; 2250 o.scaleFactor *= frame->getFitRangeBinW() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:108381,Sanity check,Sanity checks,108381,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,"['Sanity check', 'sanity check']","['Sanity checks', 'sanity checks']"
Safety,"lel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetIndexvirtual Int_t * GetIndex()Definition TTree.h:521; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:69734,detect,detection,69734,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['detect'],['detection']
Safety,"lemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ IsA(). TClass * TGeoPcon::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 109 of file TGeoPcon.h. ◆ IsCylType(). Bool_t TGeoPcon::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoPcon.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon & ; ). protecteddelete . ◆ Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. ◆ Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_t ; ipl). inline . Definition at line 96 of file TGeoPcon.h. ◆ Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_t ; ipl). inline . Definition at line 95 of file TGeoPcon.h. ◆ Safety(). Double_t TGeoPcon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Bool_t ; in = kTRUE, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [1/2]. void TGeoPcon::SetPoints ; (; Double_t * ; poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31481,Safe,Safety,31481,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['Safe'],['Safety']
Safety,"lemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4425 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:68253,predict,predicted,68253,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"lemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4501 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:69521,predict,predicted,69521,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"lementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); Absolute Tolerance is not used in this class. . double Result() const; Returns the result of the last integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; This method is not implemented. . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface; Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. . void SetFunction(const ROOT::Math::IGenFunction& , bool copy = false); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations.; \@param copy Indicates whether the function has to be copied. double Integral(); This method is not implemented. . double IntegralUp(double a); This method is not implemented. . double IntegralLow(double b); This method is not implemented. . double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void CalcGaussLegendreSamplingPoints(); Middle functions. Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 22728 2008-03-19 10:05:41Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html:4027,unsafe,unsafe,4027,root/html526/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety,"length bytes into buffer. ;  ; Int_t RedirectOutput (const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11258,timeout,timeout,11258,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:2356,abort,abort,2356,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,3,['abort'],"['abort', 'aborting']"
Safety,"les = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeSeg.html:2718,safe,safe,2718,root/html530/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html,1,['safe'],['safe']
Safety,"les that should be checked for write events. ;  ; Int_t fSigcnt {0};  ; TSeqCollection * fSignalHandler {nullptr};  ; TFdSet * fSignals {nullptr};  Files with writes waiting. ;  ; TString fSoExt;  ; TSeqCollection * fStdExceptionHandler {nullptr};  ; TList * fTimers {nullptr};  ; TString fWdpath;  ; TFdSet * fWritemask {nullptr};  Files that should be checked for read events. ;  ; TFdSet * fWriteready {nullptr};  Files with reads waiting. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TUnixSystem.h>. Inheritance diagram for TUnixSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TUnixSystem(). TUnixSystem::TUnixSystem ; (; ). Definition at line 575 of file TUnixSystem.cxx. ◆ ~TUnixSystem(). TUnixSystem::~TUnixSystem ; (; ). virtual . Reset to original state. ; Definition at line 581 of file TUnixSystem.cxx. Member Function Documentation. ◆ Abort(). void TUnixSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 2202 of file TUnixSystem.cxx. ◆ AcceptConnection(). int TUnixSystem::AcceptConnection ; (; int ; sock). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 3276 of file TUnixSystem.cxx. ◆ AccessPathName(). Bool_t TUnixSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 1579 of file TUnixSystem.cxx. ◆ AddDynamicPath(). void TUnixSystem::AddDynamicPath ; (; const char * ; lib). overridevirtual . Add a new directory to the dyn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:38104,Abort,Abort,38104,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['Abort'],['Abort']
Safety,"les with writes waiting. ;  ; TString fSoExt;  ; TSeqCollection * fStdExceptionHandler {nullptr};  ; TList * fTimers {nullptr};  ; TString fWdpath;  ; TFdSet * fWritemask {nullptr};  Files that should be checked for read events. ;  ; TFdSet * fWriteready {nullptr};  Files with reads waiting. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TWinNTSystem.h>. Inheritance diagram for TWinNTSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ThreadMsgFunc_t. typedef Bool_t(* TWinNTSystem::ThreadMsgFunc_t) (MSG *). Definition at line 61 of file TWinNTSystem.h. Constructor & Destructor Documentation. ◆ TWinNTSystem(). TWinNTSystem::TWinNTSystem ; (; ). ctor ; Definition at line 985 of file TWinNTSystem.cxx. ◆ ~TWinNTSystem(). TWinNTSystem::~TWinNTSystem ; (; ). virtual . dtor ; Definition at line 1048 of file TWinNTSystem.cxx. Member Function Documentation. ◆ Abort(). void TWinNTSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 3949 of file TWinNTSystem.cxx. ◆ AcceptConnection(). int TWinNTSystem::AcceptConnection ; (; int ; socket). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 5525 of file TWinNTSystem.cxx. ◆ AccessPathName(). Bool_t TWinNTSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the WinNT access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 2557 of file TWinNTSystem.cxx. ◆ AddDynamicPath(). void TWinNTSystem::AddDynamicPath ; (; const char * ; dir). overridevirtual . Add a new directory ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:37167,Abort,Abort,37167,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['Abort'],['Abort']
Safety,"lete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8588,Safe,SafetySeg,8588,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['Safe'],['SafetySeg']
Safety,"level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Input",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:15646,recover,recover,15646,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"lf-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:12996,safe,safe,12996,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,3,['safe'],['safe']
Safety,"lfSpace::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Check the inside status for each of the points in the array. ; Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point ; Reimplemented from TGeoBBox.; Definition at line 249 of file TGeoHalfSpace.cxx. ◆ DeclFileName(). static const char * TGeoHalfSpace::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 66 of file TGeoHalfSpace.h. ◆ DistancetoPrimitive(). Int_t TGeoHalfSpace::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . A half-space does not have a mesh primitive. ; Reimplemented from TGeoBBox.; Definition at line 105 of file TGeoHalfSpace.cxx. ◆ DistFromInside(). Double_t TGeoHalfSpace::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 113 of file TGeoHalfSpace.cxx. ◆ DistFromInside_v(). void TGeoHalfSpace::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 269 of file TGeoHalfSpace.cxx. ◆ DistFromOutside(). Double_t TGeoHalfSpace::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 142 of file TGeoHalfSpace.cxx. ◆ DistFromOutside_v(). void TGeoHalfSpace::DistFromOutside_v ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:27304,safe,safe,27304,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety,"lic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void CleanPoints (Double_t *points, Int_t &numPoints) const;  Number of points on mesh to be checked. ;  ; Int_t NChecksPerVolume (TGeoVolume *vol);  Compute number of overlaps combinations to check per volume. ;  ; Int_t PropagateInGeom (Double_t *, Double_t *);  Propagate from START along DIR from boundary to boundary until exiting geometry. ;  ; void Score (TGeoVolume *, Int_t, Double_t);  Score a hit for VOL. ;  ; Double_t TimingPerVolume (TGeoVolume *);  Compute timing per ""FindNextBoundary"" + ""Safety"" call. ;  . Private Attributes; TBuffer3D * fBuff1;  ; TBuffer3D * fBuff2;  ; Bool_t * fFlags;  Array of timing per volume. ;  ; Bool_t fFullCheck;  ; TGeoManager * fGeoManager;  ; Int_t fNchecks;  Selected node for overlap checking. ;  ; Int_t fNmeshPoints;  Number of checks for current volume. ;  ; TGeoNode * fSelectedNode;  Timer. ;  ; TStopwatch * fTimer;  Array of flags per volume. ;  ; Double_t * fVal1;  ; Double_t * fVal2;  Array of number of crossings per volume. ;  ; TGeoVolume * fVsafe;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:15735,Safe,Safety,15735,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['Safe'],['Safety']
Safety,"lid_col_y = df.FilterMissing(""x"");; auto display_x = df_valid_col_x.Display<int>({""x""});; auto display_y = df_valid_col_y.Display<int>({""y""});; NoteSee FilterAvailable() if you want to discard the entries in case there is a missing value instead. ; Definition at line 388 of file RInterface.hxx. ◆ Foreach(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::Foreach ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. This slot index will be assigned a different value, 0 to poolSize - 1, for each thread of execution. This is meant as a h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:76538,safe,safety,76538,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safety']
Safety,"like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if (fEntries > 0) {; 1518 // set fBuffer to zero to avoid calling BufferEmpty in Reset; 1519 Double_t *buffer = fBuffer; fBuffer=nullptr;; 1520 Reset(""ICES""); // do not reset list of functions; 1521 fBuffer = buffer;; 1522 }; 1523 }; 1524 if (2*nbentries+2 >= fBufferSize) {; 1525 BufferEmpty(1);; 1526 if (!fBuffer); 1527 // to avoid infinite recursion Fill->BufferFill->Fill; 1528 return Fill(x,w);; 1529 // this cannot happen; 1530 R__ASSERT(0);; 1531 }; 1532 fBuffer[2*nbentries+1] = w;; 1533 fBuffer[2*nbentries+2] = x;; 1534 fBuffer[0] += 1;; 1535 return -2;; 1536}; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Check bin limits.; 1540 ; 1541bool TH1::CheckBinLimits(const TAxis* a1, const TAxis * a2); 1542{; 1543 const TArrayD * h1Array = a1->GetXbins();; 1544 const TArrayD * h2Array = a2->GetXbins();; 1545 Int_t fN = h1Array->fN;; 1546 if ( fN != 0 ) {; 1547 if ( h2Array->fN != fN ) {; 1548 return false;; 1549 }; 1550 else {; 1551 for ( int i = 0; i < fN; ++i ) {; 1552 // for i==fN (nbin+1) a->GetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:59329,avoid,avoid,59329,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['avoid'],['avoid']
Safety,"limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume * ; vol, . TGeoVoxelFinder * ; voxels, . Double_t * ; xyz, . Int_t ; npoints . ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. ◆ Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoChecker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TGeoChecker.h. ◆ CleanPoints(). void TGeoChecker::CleanPoints ; (; Double_t * ; points, . Int_t & ; numPoints . ); const. private . Number of points on mesh to be checked. ; Clean-up the mesh of pcon/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21845,safe,safety,21845,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2063 of file TBufferFile.cxx. ◆ WriteFastArray() [9/15]. void TBufferFile::WriteFastArray ; (; const UChar_t * ; c, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 517 of file TBufferFile.h. ◆ WriteFastArray() [10/15]. void TBufferFile::WriteFastArray ; (; const UInt_t * ; i, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 523 of file TBufferFile.h. ◆ WriteFastArray() [11/15]. void TBufferFile::WriteFastArray ; (; const ULong64_t * ; l, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 526 of file TBufferFile.h. ◆ WriteFastArray() [12/15]. void TBufferFile::WriteFastArray ; (; const ULong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:84277,abort,aborts,84277,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"line width. ;  ; virtual TClass * IsA () const;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; void FindMomentumLimits (REveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from ROOT::Experimental::REveElement; virtual void AnnihilateRecursively ();  Protected member function called from REveElement::Annihilate(). ;  ; void assign_element_id_recurisvely ();  ; void assign_scene_recursively (REveScene *s);  ; ElementId_t get_mother_id () const;  ; ElementId_t get_scene_id () const;  ; virtual void PreDeleteElement ();  Vertex / normal / triangle index information for rendering. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  . Protected Attributes; Double_t fLimP;  ; Double_t fLimPt;  ; Double_t fMaxP;  ; Double_t fMaxPt;  ; Double_t fMinP;  ; Double_t fMinPt;  ; REveTrackPropagator * fPropagator {nullptr};  ; Bool_t fRecurse;  ; Bool_t fRnrLine;  ; Bool_t fRnrPoints;  ;  Protected Attributes inherited from ROOT::Experimental::REveElement; AuntList_t fAunts;  ; Bool_t fCanEditMainColor {kFALSE};  ; Bool_t fCanEditMainTrans {kFALSE};  ; Bool_t fCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html:19916,detect,detected,19916,doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,1,['detect'],['detected']
Safety,"line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first value corresponds to HistSize, the (optional) second one to HistSave. You can set ROOT_HIST=0 to disable the history.; 2.7.3 Tracking Memory Leaks; You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see TObjectTable). To use this facility, edit the file $ROOTSYS/etc/system.rootrc or .rootrc if you have this file and add the two following lines:; Root.ObjectStat: 1; In your code or on the command line you can type the line:; gObjectTable->Print();; This line will print the list of all active classes and the number of instances for each class. By comparing consecutive print outs, you can see objects that you forgot to delete. Note that this method cannot show leaks coming from the allocation of non-objects or classes unknown to ROOT.; 2.8 Converting from PAW to ROOT; The web page at: http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE gives the “translation” table of some commonly used PAW commands into ROOT. If you move the mouse cursor over the picture at: http://root.cern.ch/root/HowtoConvertFromPAW.html#SET, you will get the corresponding ROOT commands as tooltips.; 2.8.1 Converting HBOOK/PAW Files; ROOT has a utility",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:66403,detect,detect,66403,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detect']
Safety,"lineprivate . Definition at line 3151 of file RInterface.hxx. ◆ DefinePerSample() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename RetType_t = typename TTraits::CallableTraits<F>::ret_type> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefinePerSample ; (; std::string_view ; name, . F ; expression . ). inline . Define a new column that is updated when the input sample changes. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionA C++ callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54349,safe,safe,54349,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"linevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 287 of file TFile.h. ◆ SetFileBytesRead(). void TFile::SetFileBytesRead ; (; Long64_t ; bytes = 0). static . Definition at line 4608 of file TFile.cxx. ◆ SetFileBytesWritten(). void TFile::SetFileBytesWritten ; (; Long64_t ; bytes = 0). static . Definition at line 4611 of file TFile.cxx. ◆ SetFileReadCalls(). void TFile::SetFileReadCalls ; (; Int_t ; readcalls = 0). static . Definition at line 4614 of file TFile.cxx. ◆ SetOffset(). void TFile::SetOffset ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Definition at line 2253 of file TFile.cxx. ◆ SetOnlyStaged(). Bool_t TFile::SetOnlyStaged ; (; Bool_t ; onlystaged). static . Sets only staged flag. ; Returns previous value of flag. When true we check before opening the file if it is staged, if not, the open fails. ; Definition at line 4744 of file TFile.cxx. ◆ SetOpenTimeout(). UInt_t TFile::SetOpenTimeout ; (; UInt_t ; timeout). static . Sets open timeout time (in ms). Returns previous timeout value. ; Definition at line 4724 of file TFile.cxx. ◆ SetOption(). virtual void TFile::SetOption ; (; Option_t * ; option = "">""). inlinevirtual . Definition at line 289 of file TFile.h. ◆ SetReadaheadSize(). void TFile::SetReadaheadSize ; (; Int_t ; bufsize = 256000). static . Definition at line 4605 of file TFile.cxx. ◆ SetReadCalls(). virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:95038,timeout,timeout,95038,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"ling.cxx. ◆ TCling_GenerateDictionary() [1/2]. int TCling_GenerateDictionary ; (; const std::string & ; className, . const std::vector< std::string > & ; headers, . const std::vector< std::string > & ; fwdDecls, . const std::vector< std::string > & ; unknown . ). Definition at line 820 of file TCling.cxx. ◆ TCling_GenerateDictionary() [2/2]. int TCling_GenerateDictionary ; (; const std::vector< std::string > & ; classes, . const std::vector< std::string > & ; headers, . const std::vector< std::string > & ; fwdDecls, . const std::vector< std::string > & ; unknown . ). Definition at line 699 of file TCling.cxx. ◆ TClingLookupHelper__AutoParse(). bool TClingLookupHelper__AutoParse ; (; const char * ; cname). Allow calling autoparsing from TMetaUtils. ; Definition at line 894 of file TCling.cxx. ◆ TClingLookupHelper__ExistingTypeCheck(). bool TClingLookupHelper__ExistingTypeCheck ; (; const std::string & ; tname, . std::string & ; result . ). Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ; Definition at line 903 of file TCling.cxx. Variable Documentation. ◆ fantomline. const char* fantomline = ""TRint::EndOfLineAction();"". Definition at line 841 of file TCling.cxx. ◆ gIgnoredPCMNames. const std::unordered_set<std::string> gIgnoredPCMNames. static . Initial value:= {""libCore"",; ""libRint"",; ""libThread"",; ""libRIO"",; ""libImt"",; ""libMultiProc"",; ""libcomplexDict"",; ""libdequeDict"",; ""liblistDict"",; ""libforward_listDict"",; ""libvectorDict"",; ""libmapDict"",; ""libmultimap2Dict"",; ""libmap2Dict"",; ""libmultimapDict"",; ""libsetDict"",; ""libmultisetDict"",; ""libunordered_setDict"",; ""libunordered_multisetDict"",; ""libunordered_mapDict"",; ""libunordered_multimapDict"",; ""libvalarrayDict"",; ""G__GenVector32"",; ""G__Smatrix32""}. List of dicts that have the PCM information already in the PCH. ; Definition at line 1939 of file TCling.cxx. ◆ HaveFullGlobalModuleIndex. bool HaveFullGlobalModuleIndex = false. static . Definition at line 1079 of file TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:23185,avoid,avoid,23185,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['avoid'],['avoid']
Safety,"ling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:5104,avoid,avoid,5104,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['avoid'],['avoid']
Safety,"lipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114583,detect,detector,114583,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103536,avoid,avoid,103536,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"lizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:116582,avoid,avoid,116582,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"lizedName != name);; 3139 }; 3140 ; 3141 if (!load) return nullptr;; 3142 ; 3143// This assertion currently fails because of; 3144// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3145// TClass *c2 = TClass::GetClass(""std::iostream"");; 3146// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3147// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3148// uses only 'part' of TMetaUtils::GetNormalizedName.; 3149 ; 3150// if (!cl) {; 3151// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3152// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3155// altcl->GetName(), name, normalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3160 // and we want to make that the TClass for the pair goes through the regular creation; 3161 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3162 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3163 // will be used to create the TProtoClass (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:119333,avoid,avoid,119333,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3636 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:82789,safe,safe,82789,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['safe'],['safe']
Safety,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3703 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:82790,safe,safe,82790,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['safe'],['safe']
Safety,"ll be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85551,recover,recovered,85551,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"ll be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67602,recover,recovered,67602,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"ll function, you must use; 70the pointer to the current Tree to call `GetEntry(entry)`.; 71entry is always the local entry number in the current tree.; 72Assuming that fChain is the pointer to the TChain being processed,; 73use `fChain->GetTree()->GetEntry(entry);`; 74*/; 75 ; 76#include ""TROOT.h""; 77#include ""TSystem.h""; 78#include ""TTree.h""; 79#include ""TError.h""; 80#include ""TSelector.h""; 81#include ""TClass.h""; 82#include ""TInterpreter.h""; 83 ; 84ClassImp(TSelector);; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4333,Abort,Abort,4333,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['Abort'],['Abort']
Safety,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:11188,avoid,avoid,11188,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['avoid'],['avoid']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ;  pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  pyroot003_prettyPrinting.py This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:145458,detect,detector,145458,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ;  pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:143270,detect,detector,143270,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['detect'],['detector']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;  staff.py example of macro to read data from an ascii file and create a root file with a Tree ;  surfaces.py Surfaces example ;  test.py ;  tornado.pyTornado example ;  tree.py This macro displays the Tree data structures ;  zdemo.py This macro is an example of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:138575,detect,detector,138575,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['detect'],['detector']
Safety,"lled. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:13821,Safe,Safety,13821,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,3,['Safe'],['Safety']
Safety,"llfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179522,timeout,timeout,179522,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"llfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179554,timeout,timeout,179554,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fInsideNotifystd::atomic< Bool_t > fInsideNotifyDefinition TSystem.h:286; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:56545,timeout,timeout,56545,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix chosen by the user for ACLiC.Definition TSystem.cxx:4001; TSystem::SetDynamicPathvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:187912,timeout,timeout,187912,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"lls a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Create a scaled shape starting from a non-scaled one. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoScaledShape.h 40117 2011-07-04 12:17:06Z agheata $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:13708,Safe,Safety,13708,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"llsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:193214,Abort,Abortvirtual,193214,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,3,['Abort'],"['Abort', 'Abortvirtual']"
Safety,"lnumnodes = 0;; 1259 ; 1260 // for (auto &node : fDesc); 1261 // node.SetDisplayed(false);; 1262 ; 1263 // build all shapes in volume decreasing order; 1264 for (auto &sid : fSortMap) {; 1265 fDrawIdCut++; //; 1266 auto &desc = fDesc[sid];; 1267 ; 1268 if ((viscnt[sid] <= 0) || (desc.vol <= 0)); 1269 continue;; 1270 ; 1271 auto shape = GetVolume(sid)->GetShape();; 1272 if (!shape); 1273 continue;; 1274 ; 1275 // now we need to create TEveGeoPolyShape, which can provide all rendering data; 1276 auto &shape_descr = MakeShapeDescr(shape);; 1277 ; 1278 // should not happen, but just in case; 1279 if (shape_descr.nfaces <= 0) {; 1280 R__LOG_ERROR(RGeomLog()) << ""No faces for the shape "" << shape->GetName() << "" class "" << shape->ClassName();; 1281 continue;; 1282 }; 1283 ; 1284 // check how many faces are created; 1285 totalnumfaces += shape_descr.nfaces * viscnt[sid];; 1286 if ((GetMaxVisFaces() > 0) && (totalnumfaces > GetMaxVisFaces())); 1287 break;; 1288 ; 1289 // also avoid too many nodes; 1290 totalnumnodes += viscnt[sid];; 1291 if ((GetMaxVisNodes() > 0) && (totalnumnodes > GetMaxVisNodes())); 1292 break;; 1293 ; 1294 // desc.SetDisplayed(true);; 1295 }; 1296 ; 1297 // finally we should create data for streaming to the client; 1298 // it includes list of visible nodes and rawdata; 1299 ; 1300 RGeomDrawing drawing;; 1301 ResetRndrInfos();; 1302 bool has_shape = false;; 1303 ; 1304 ScanNodes(true, level, [&, this](RGeomNode &node, std::vector<int> &stack, bool, int seqid) {; 1305 if ((node.sortid < fDrawIdCut) && (viscnt[node.id] > 0)) {; 1306 drawing.visibles.emplace_back(node.id, seqid, stack);; 1307 ; 1308 auto &item = drawing.visibles.back();; 1309 item.color = node.color;; 1310 item.opacity = node.opacity;; 1311 ; 1312 auto volume = GetVolume(node.id);; 1313 ; 1314 auto &sd = MakeShapeDescr(volume->GetShape());; 1315 ; 1316 item.ri = sd.rndr_info();; 1317 if (sd.has_shape()); 1318 has_shape = true;; 1319 }; 1320 return true;; 1321 });; 1322 ; 1323 CollectNodes(d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:39120,avoid,avoid,39120,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"lobal mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17847,safe,safe,17847,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety,"local' is defined) checks file locality (i.e.; 870/// protocol 'file://') returning the result in '*local' .; 871 ; 872void TEntryList::GetFileName(const char *filename, TString &fn, bool *local); 873{; 874 TUrl u(filename, true);; 875 if (local) *local = (!strcmp(u.GetProtocol(), ""file"")) ? true : false;; 876 if (strlen(u.GetAnchor()) > 0) {; 877 fn.Form(""%s#%s"", u.GetFile(), u.GetAnchor());; 878 } else {; 879 fn = u.GetFile();; 880 }; 881 // Done; 882 return;; 883}; 884 ; 885////////////////////////////////////////////////////////////////////////////////; 886/// Return the entry list, corresponding to treename and filename; 887/// By default, the filename is first tried as is, and then, if the corresponding list; 888/// is not found, the filename is expanded to the absolute path, and compared again.; 889/// To avoid it, use option ""ne""; 890 ; 891TEntryList *TEntryList::GetEntryList(const char *treename, const char *filename, Option_t *opt); 892{; 893 if (gDebug > 1); 894 Info(""GetEntryList"",""tree: %s, file: %s"",; 895 (treename ? treename : ""-""), (filename ? filename : ""-""));; 896 ; 897 if (!treename || !filename) return nullptr;; 898 TString option = opt;; 899 option.ToUpper();; 900 bool nexp = option.Contains(""NE"");; 901 ; 902 TString fn;; 903 bool local;; 904 GetFileName(filename, fn, &local);; 905 if (nexp) local = false;; 906 ; 907 if (gDebug > 1); 908 Info(""GetEntryList"", ""file: %s, local? %d"", filename, local);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:30106,avoid,avoid,30106,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['avoid'],['avoid']
Safety,"lock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endif /* OPENSSL_API_1_1 */; 15666 ; 15667static int; 15668sslize(struct mg_connection *conn,; 15669 int (*func)(SSL *),; 15670 const struct mg_client_options *client_options); 15671{; 15672 int ret, err;; 15673 int short_trust;; 15674 unsigned timeout = 1024;; 15675 unsigned i;; 15676 ; 15677 if (!conn) {; 15678 return 0;; 15679 }; 15680 ; 15681 short_trust =; 15682 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:463056,timeout,timeout,463056,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endif /* OPENSSL_API_1_1 */; 15667 ; 15668static int; 15669sslize(struct mg_connection *conn,; 15670 int (*func)(SSL *),; 15671 const struct mg_client_options *client_options); 15672{; 15673 int ret, err;; 15674 int short_trust;; 15675 unsigned timeout = 1024;; 15676 unsigned i;; 15677 ; 15678 if (!conn) {; 15679 return 0;; 15680 }; 15681 ; 15682 short_trust =; 15683 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:463089,timeout,timeout,463089,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:16457,Timeout,Timeout,16457,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Timeout'],['Timeout']
Safety,"log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:14288,safe,safely,14288,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,3,['safe'],['safely']
Safety,"long the dynamic path for library maps. ;  ; void Reset () final;  Pressing Ctrl+C should forward here. ;  ; void ResetAll () final;  Reset the Cling state to its initial state. ;  ; void ResetGlobals () final;  Reset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void ResetGlobalVar (void *obj) final;  Reset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void RewindDictionary () final;  Rewind Cling dictionary to the point where it was before executing the current macro. ;  ; void * RewindInterpreterMutex ();  Reset the interpreter lock to the state it had before interpreter-related calls happened. ;  ; void SaveContext () final;  Save the current Cling state. ;  ; void SaveGlobalsContext () final;  Save the current Cling state of global objects. ;  ; void SetAlloclockfunc (void(*)()) const final;  [Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect critical section of its code (non-thread safe parts). ;  ; void SetAllocunlockfunc (void(*)()) const final;  [Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect critical section of its code (non-thread safe parts). ;  ; void * SetAutoLoadCallBack (void *cb) final;  ; int SetClassAutoLoading (int) const final;  Enable/Disable the AutoLoading of libraries. ;  ; int SetClassAutoparsing (int) final;  Enable/Disable the Autoparsing of headers. ;  ; void SetClassInfo (TClass *cl, Bool_t reload=kFALSE, Bool_t silent=kFALSE) final;  Set pointer to the TClingClassInfo in TClass. ;  ; Int_t SetClassSharedLibs (const char *cls, const char *libs) final;  Register the AutoLoading information for a class. ;  ; void SetDeclAttr (DeclId_t, const char *) final;  ; void SetErrmsgcallback (void *p) const final;  Set a callback to receive error messages. ;  ; Bool_t SetErrorMessages (Bool_t enable=kTRUE) fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:30123,safe,safe,30123,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['safe'],['safe']
Safety,"lot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weightSquared() const. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE, Bool_t oneSafe = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:29621,safe,safe,29621,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,3,['safe'],['safe']
Safety,"lptr); ; # Use the histogram afterwards; print(hin.GetName()); NoteThe TFile::Close method automatically sets the current directory in the program to the gROOT object. If you want to restore the status of the current directory to some other file that was opened prior to the with statement, you can use the context manager functionality offered by TContext. Definition at line 53 of file TFile.h. Classes; struct  InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  . Public Types; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:6103,timeout,timeout,6103,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"lres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:185858,timeout,timeout,185858,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:185890,timeout,timeout,185890,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:4775,avoid,avoid,4775,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361465,timeout,timeout,361465,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361498,timeout,timeout,361498,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TVirtualProofPlayer. ←. TProofPlayer; ←. TProofPlayerLocal. TProofPlayerRemote; ←. TProofPlayerLite. TProofPlayerSuperMaster. TProofPlayerSlave. Function documentation; TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0); Create a PROOF player. TVirtualProofPlayer(); { ResetBit(TVirtualProofPlayer::kIsSubmerger); }. virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:14054,abort,abort,14054,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"lse {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrowser*) next())); 2084 b->Add(ap, ap->ApplicationName());; 2085 gROOT->RefreshBrowsers();; 2086 } else {; 2087 SafeDelete(ap);; 2088 ::Error(""TApplication::Open"",; 2089 ""TApplicationRemote for %s could not be instantiated"", url);; 2090 }; 2091 ; 2092 // Done; 2093 return ap;; 2094}; 2095 ; 2096////////////////////////////////////////////////////////////////////////////////; 2097/// Static function used to close a remote application; 2098 ; 2099void TApplication::Close(TApplication *app); 2100{; 2101 if (app) {; 2102 app->Terminate(0);; 2103 fgApplications->Remove(app);; 2104 gROOT->GetListOfBrowsables()->RecursiveRemove(app);; 2105 TIter next(gROOT->GetListOfBrowsers());; 2106 TBrowser *b;; 2107 while ((b = (TBrowser*) next())); 2108 b->RecursiveRemove(app);; 2109 gROOT->RefreshBrowsers();; 2110 }; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Show available sessions; 2115 ; 2116void TApplication::ls(Option_t *opt) const; 2117{; 2118 if (fgApplications) {; 2119 TIter nxa(fgApplications);; 2120 TApplication *a = nullptr;; 2121 while ((a = (TApplication *) nxa())) {; 2122 a->Print(opt);; 2123 }; 2124 } else {; 2125 Print(opt);; 2126 }; 2127}; 2128 ; 2129////////////////////////////////////////////////////////////////////////////////; 2130/// Static method returning the list of available applications; 2131 ; 2132TList *TApplication::GetApplications(); 2133{; 2134 return fgApplications;; 2135}; SafeDelete#define SafeDelete(p)Definition RConfig.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:80023,Safe,SafeDelete,80023,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"lt matrix. . static void ActivationFunctionForward (Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const double coef=0.0, const AFloat alpha=1, const AFloat beta=0);  ; static void ActivationFunctionBackward (Tensor_t &dX, const Tensor_t &Y, const Tensor_t &dY, const Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const AFloat alpha=1, const AFloat beta=0);  Computes the gradient of the activation function. ;  ; static void IdentityDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Relu (Tensor_t &B);  ; static void ReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Sigmoid (Tensor_t &B);  ; static void SigmoidDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Tanh (Tensor_t &B);  ; static void TanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void FastTanh (Tensor_t &B);  ; static void FastTanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SymmetricRelu (Tensor_t &B);  ; static void SymmetricReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SoftSign (Tensor_t &B);  ; static void SoftSignDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Gauss (Tensor_t &B);  ; static void GaussDerivative (Tensor_t &B, const Tensor_t &A);  ; Loss Functions; Loss functions compute a scalar value given the output of the network for a given training input and the expected network prediction Y that quantifies the quality of the prediction.; For each function also a routing that computes the gradients (suffixed by Gradients) must be provided for the starting of the backpropagation algorithm. . static Scalar_t MeanSquaredError (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static void MeanSquaredErrorGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t CrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Sigmoid t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html:10247,predict,prediction,10247,doc/master/classTMVA_1_1DNN_1_1TCuda.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html,2,['predict'],['prediction']
Safety,"lt(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:10443,abort,abort,10443,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,1,['abort'],['abort']
Safety,"lternate(context, inside[1], newName);; 1671 ; 1672 if (altcl) {; 1673 std::string alternate = inside[0];; 1674 alternate.append(""<"");; 1675 alternate.append(newName);; 1676 // We are intentionally dropping any further arguments,; 1677 // they would be using the wrong typename and would also be; 1678 // somewhat superflous since this is for the old layout.; 1679 if (alternate[alternate.length()-1]=='>') {; 1680 alternate.append("" "");; 1681 }; 1682 alternate.append("">"");; 1683 return TClass::GetClass(alternate.c_str(),true,true);; 1684 }; 1685 }; 1686 return 0;; 1687 }; 1688 ; 1689 // Makes sure kBuildOldUsed set once BuildOld finishes; 1690 struct TBuildOldGuard {; 1691 TBuildOldGuard(TStreamerInfo* info): fInfo(info) {; 1692 fInfo->SetBit(TStreamerInfo::kBuildRunning);; 1693 }; 1694 ~TBuildOldGuard() {; 1695 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 1696 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 1697 }; 1698 TStreamerInfo* fInfo;; 1699 };; 1700}; 1701 ; 1702////////////////////////////////////////////////////////////////////////////////; 1703/// rebuild the TStreamerInfo structure; 1704 ; 1705void TStreamerInfo::BuildOld(); 1706{; 1707 R__LOCKGUARD(gInterpreterMutex);; 1708 ; 1709 if ( TestBit(kBuildOldUsed) ) return;; 1710 ; 1711 // Are we recursing on ourself?; 1712 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 1713 ; 1714 // This is used to avoid unwanted recursive call to Build and make sure; 1715 // that we record the execution of BuildOld.; 1716 TBuildOldGuard buildOldGuard(this);; 1717 ; 1718 if (gDebug > 0) {; 1719 printf(""\n====>Rebuilding TStreamerInfo for class: %s, version: %d\n"", GetName(), fClassVersion);; 1720 }; 1721 ; 1722 Bool_t wasCompiled = IsCompiled();; 1723 ; 1724 if (fClass->GetClassVersion() == fClassVersion) {; 1725 if (!fClass->HasInterpreterInfo() || fClass->GetCollectionType() || TClassEdit::IsSTLBitset(GetName())); 1726 {; 1727 // Handle emulated classes and STL containers specially.; 1728 // in this case BuildRealData w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:65799,avoid,avoid,65799,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ltiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DistSampler.html:2542,avoid,avoid,2542,root/html528/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DistSampler.html,4,['avoid'],['avoid']
Safety,"lume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppckov, Float_t* absco, Float_t* effic, Float_t* rindex); Helper function for resolving MANY.; Specify the ONLY volume that overlaps with the; specified MANY and has to be substracted.; (Geant4 only); Define the tables for UV photon tracking in medium itmed.; Please note that it is the user's responsibility to; provide all the coefficients:; itmed Tracking medium number; npckov Number of bins of each table; ppckov Value of photon momentum (in GeV); absco Absorption coefficients; dielectric: absorption length in cm; metals : absorption fraction (0<=x<=1); effic Detection efficiency for UV photons; rindex Refraction index (if=0 metal). void DefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); The same as previous but in double precision. functions for definition of surfaces; and material properties for optical physics. Define the optical surface; name surface name; model selection of model (see #EMCOpSurfaceModel values); surfaceType surface type (see #EMCOpSurfaceType values); surfaceFinish surface quality (see #EMCOpSurfaceType values); sigmaAlpha an unified model surface parameter; (Geant4 only). void SetSkinSurface(const char* name, const char* volName, const char* opSurfaceName); Define the optical surface border; name border surface name; vol1Name first volume name; vol1CopyNo first volume copy number; vol2Name second volume name; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:23502,Detect,Detection,23502,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,6,['Detect'],['Detection']
Safety,"ly (e.g. slicey). This should be done as if the coordinate system; 344of the generic slice was the same as the one of the divided volume. The generic; 345slice in case of PHI division is centered with respect to X axis. If the; 346family contains slices of different sizes, any volume positioned inside should; 347fit into the smallest one.; 348 Examples for specific divisions according to shape types can be found inside; 349shape classes.; 350 ; 351~~~ {.cpp}; 352 TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; 353~~~; 354 ; 355 The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; 356volume is in fact a virtual container that does not represent a physical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:18763,avoid,avoided,18763,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['avoid'],['avoided']
Safety,"ly crash."");; 2154 element->SetOffset(0);; 2155 element->Init(this);; 2156 dmType = element->GetTypeName();; 2157 dmIsPtr = false;; 2158 }; 2159 }; 2160 } // Class corresponding to StreamerInfo is emulated or not.; 2161 ; 2162 // Now let's deal with Schema evolution; 2163 Int_t newType = -1;; 2164 TClassRef newClass;; 2165 ; 2166 if (dm && dm->IsPersistent()) {; 2167 auto theType = isStdArray ? dt : dm->GetDataType();; 2168 if (theType) {; 2169 Bool_t isArray = isStdArray || element->GetArrayLength() >= 1;; 2170 Bool_t hasCount = element->HasCounter();; 2171 // data member is a basic type; 2172 if ((fClass == TObject::Class()) && !strcmp(dm->GetName(), ""fBits"")) {; 2173 //printf(""found fBits, changing dtype from %d to 15\n"", dtype);; 2174 newType = kBits;; 2175 } else {; 2176 // All the values of EDataType have the same semantic in EReadWrite; 2177 newType = (EReadWrite)theType->GetType();; 2178 }; 2179 if ((newType == ::kChar_t) && dmIsPtr && !isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:85889,sanity check,sanity check,85889,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"ly(const char *name);; 344 TGeoVolumeMulti *MakeVolumeMulti(const char *name, TGeoMedium *medium);; 345 void SetTopVolume(TGeoVolume *vol);; 346 ; 347 //--- geometry queries; 348 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 349 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 350 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 351 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 352 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 353 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 354 Double_t *FindNormal(Bool_t forward = kTRUE);; 355 Double_t *FindNormalFast();; 356 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 357 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 358 void ResetState();; 359 Double_t Safety(Bool_t inside = kFALSE);; 360 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 361 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 362 void DisableInactiveVolumes() { fActivity = kTRUE; }; 363 void EnableInactiveVolumes() { fActivity = kFALSE; }; 364 void SetCurrentTrack(Int_t i) { fCurrentTrack = (TVirtualGeoTrack *)fTracks->At(i); }; 365 void SetCurrentTrack(TVirtualGeoTrack *track) { fCurrentTrack = track; }; 366 Int_t GetNtracks() const { return fNtracks; }; 367 TVirtualGeoTrack *GetCurrentTrack() { return fCurrentTrack; }; 368 TVirtualGeoTrack *GetLastTrack(); 369 {; 370 return (TVirtualGeoTrack *)((fNtracks > 0) ? fTracks->At(fNtracks - 1) : nullptr);; 371 }; 372 const Double_t *GetLastPoint() const { return GetCurrentNavigator()->GetLastPoint(); }; 373 TVirtualGeoTrack *GetTrack(Int_t index); 374 {; 375 return (index < fNtracks) ? (TVirtualGeoTrack *)fTracks->At(index) : nullptr;; 376 }; 377 Int_t GetTrackIndex(Int_t id) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:20424,Safe,Safety,20424,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['Safe'],['Safety']
Safety,"ly, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5115,avoid,avoid,5115,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['avoid'],['avoid']
Safety,"ly. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:13167,timeout,timeout,13167,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,3,['timeout'],['timeout']
Safety,"lysis bins in the proper order. Each node of the tree is responsible for a group of bins. That group may consist of . several unconnected bins, each with a dedicated name. . bins organized in a multidimensional distribution, defined by a set of axes. The axes are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2042,detect,detector,2042,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety,"l ; level, . const char * ; mess . ). overridevirtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented from TSystem.; Definition at line 2654 of file TUnixSystem.cxx. ◆ TempDirectory(). const char * TUnixSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 1503 of file TUnixSystem.cxx. ◆ TempFileName(). FILE * TUnixSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 1523 of file TUnixSystem.cxx. ◆ Umask(). int TUnixSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 1901 of file TUnixSystem.cxx. ◆ UnixFilestat(). int TUnixSystem::UnixFilestat ; (; const char * ; fpath, . FileStat_t & ; buf . ). staticprotected . Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Definition at line 4039 of file TUnixSystem.cxx. ◆ UnixFSstat(). int TUnixSystem::UnixFSstat ; (; const char * ; path, . Long_t * ; id, . Long_t * ; bsize, . Long_t * ; blocks, . Long_t * ; bfree . ). staticprotected . Get info about a file system: id, bsize, bfree, blocks. ; Id is file system type (machine dependend, see stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:71032,safe,safely,71032,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"m access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:211204,detect,detector,211204,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['detect'],['detector']
Safety,"m and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:13407,safe,safe,13407,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,4,['safe'],['safe']
Safety,"m, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBox::SetPoints(Double_t* points) const; virtual voidTGeoBBox::SetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveGeoPolyShape.html:8016,Safe,SafetyPhi,8016,root/html530/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html530/TEveGeoPolyShape.html,2,['Safe'],['SafetyPhi']
Safety,"m, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:4713,safe,safely,4713,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,2,['safe'],['safely']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimer.html:15434,Timeout,Timeout,15434,root/html534/TTimer.html,https://root.cern,https://root.cern/root/html534/TTimer.html,2,['Timeout'],['Timeout']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimer.html:15984,Timeout,Timeout,15984,root/html604/TTimer.html,https://root.cern,https://root.cern/root/html604/TTimer.html,2,['Timeout'],['Timeout']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:15984,Timeout,Timeout,15984,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['Timeout'],['Timeout']
Safety,"m>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 2075 while (idcur < fEND) {; 2076 Seek(idcur); // NOLINT: silence clang-tidy warnings; 2077 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 2078 if (ReadBuffer(header, nread)) { // NOLINT: silence clang-tidy warnings; 2079 // ReadBuffer returns kTRUE in case of failure.; 2080 Error(""Recover"",""%s: failed to read the key data from disk at %lld."",; 2081 GetName(),idcur);; 2082 break;; 2083 }; 2084 buffer = header;; 2085 bufread = header;; 2086 frombuf(buffer, &nbytes);; 2087 if (!nbytes) {; 2088 Error(""Recover"",""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 2089 break;; 2090 }; 2091 if (nbytes < 0) {; 2092 idcur -= nbytes;; 2093 if (fWritable) new TFree(fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:74321,Recover,Recover,74321,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Recover'],['Recover']
Safety,"mInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, Double_t b, Double_t dz); Set dimensions of the eliptical tube. void SetDimensions(Double_t* param); Set shape dimensions starting from an array. void SetPoints(Double_t* points) const; Create eliptical tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Returns the number of vertices on the mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:13860,Safe,Safety,13860,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,3,['Safe'],['Safety']
Safety,"mSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:5039,avoid,avoid,5039,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,1,['avoid'],['avoid']
Safety,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd1.html:12871,safe,safe,12871,root/html528/TGeoTrd1.html,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html,6,['safe'],['safe']
Safety,"macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows:; <file>.root are considered ROOT files and added to the InputFiles() list; <macro>.C are considered ROOT macros and also added to the InputFiles() list; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; last one will prevail; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplication.html:14935,timeout,timeout,14935,root/html526/TApplication.html,https://root.cern,https://root.cern/root/html526/TApplication.html,1,['timeout'],['timeout']
Safety,"make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::Resetvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:148129,recover,recover,148129,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['recover'],['recover']
Safety,"mal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. ; Given a path which doesn't belong to the dCache managed filesystem, it falls back to the ordinary TFile behaviour. ; Definition at line 25 of file TDCacheFile.h. Public Types; enum  EOnErrorAction { kOnErrorRetry = 1; , kOnErrorFail = 0; , kOnErrorDefault = -1; };  Note: This must be kept in sync with values #defined in dcap.h. More...;  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:1403,timeout,timeout,1403,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"mal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoXtru.html:17151,Safe,Safety,17151,root/html528/TGeoXtru.html,https://root.cern,https://root.cern/root/html528/TGeoXtru.html,1,['Safe'],['Safety']
Safety,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:3685,safe,safe,3685,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,3,['safe'],['safe']
Safety,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:3664,safe,safe,3664,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,3,['safe'],['safe']
Safety,"mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:2084,safe,safe,2084,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,1,['safe'],['safe']
Safety,"match = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name of MakeClass mode; 245 kNeedDisableDecomposedObj = BIT(30),; 246 kDecomposedObjMask = kNeedEnableDecomposedObj | kNeedDisableDecomposedObj; 247 };; 248 ; 249 // TTree status bits; 250 enum EStatusBits {; 251 kForceRead = BIT(11),; 252 kCircular = BIT(12),; 253 /// If set, the branch's buffers will grow until an event cluster boundary is hit,; 254 /// guaranteeing a basket per cluster. This mode does not provide any guarantee on the; 255 /// memory bounds in the case of extremely large events.; 256 kOnlyFlushAtCluster = BIT(14),; 257 /// If set, signals that this TTree is the output of the processing of another TTree, and; 258 /// the entries are reshuffled w.r.t. to the original TTree. As a safety measure, a TTree; 259 /// with this bit set cannot add friends nor can be added as a friend. If you know what; 260 /// you are doing, you can manually unset this bit with `ResetBit(EStatusBits::kEntriesReshuffled)`.; 261 kEntriesReshuffled = BIT(19) // bits 15-18 are used by TChain; 262 };; 263 ; 264 // Split level modifier; 265 enum {; 266 kSplitCollectionOfPointers = 100; 267 };; 268 ; 269 class TClusterIterator; 270 {; 271 private:; 272 TTree *fTree; // TTree upon which we are iterating.; 273 Int_t fClusterRange; // Which cluster range are we looking at.; 274 Long64_t fStartEntry; // Where does the cluster start.; 275 Long64_t fNextEntry; // Where does the cluster end (exclusive).; 276 Long64_t fEstimatedSize; // If positive, the calculated estimated tree size.; 277 ; 278 Long64_t GetEstimatedClusterSize();; 279 ; 280 protected:; 281 friend class TTree;; 282 TClusterIterator(TTree *tree, Long64_t firstEntry);; 283 ; 284 public:; 285 // Intentionally used the default copy constructor and default destructor; 286 // as the T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:12532,safe,safety,12532,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safety']
Safety,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; The c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:118680,avoid,avoid,118680,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; The call to pn1->Align() will invalidate the pointer to the node B_1 in pn2 object.. The way out is to either call pn1->Align() before the creation of pn2, either to use a global method that will correct all existing physical nodes:; void RefreshPhysicalNodes(Bool_t lock = kTRUE); The method above will optionally lock the possibility of doing any further misalignment.; 18.9 Geometry I/O; Once geom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1016419,avoid,avoid,1016419,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"mation(const TGeoMatrix *matrix)TGeoManager; AddVolume(TGeoVolume *volume)TGeoManager; AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")TGeoManager; AppendPad(Option_t *option="""")TObjectvirtual; BombTranslation(const Double_t *tr, Double_t *bombtr)TGeoManager; Browse(TBrowser *b) overrideTGeoManagervirtual; BuildDefaultMaterials()TGeoManager; cd(const char *path="""")TGeoManagervirtual; CdDown(Int_t index)TGeoManager; CdNext()TGeoManager; CdNode(Int_t nodeid)TGeoManager; CdTop()TGeoManager; CdUp()TGeoManager; CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)TGeoManager; CheckBoundaryReference(Int_t icheck=-1)TGeoManager; CheckedHash()TObjectinline; CheckGeometry(Option_t *option="""")TGeoManager; CheckGeometryFull(Int_t ntracks=1000000, Double_t vx=0., Double_t vy=0., Double_t vz=0., Option_t *option=""ob"")TGeoManager; CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")TGeoManager; CheckPath(const char *path) constTGeoManager; CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)TGeoManager; CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)TGeoManager; Class()TGeoManagerstatic; Class_Name()TGeoManagerstatic; Class_Version()TGeoManagerinlinestatic; ClassName() constTObjectvirtual; CleanGarbage()TGeoManager; Clear(Option_t *option="""") overrideTNamedvirtual; ClearAttributes()TGeoManager; ClearNavigators()TGeoManager; ClearOverlaps()TGeoManager; ClearPhysicalNodes(Bool_t mustdelete=kFALSE)TGeoManager; ClearShape(const TGeoShape *shape)TGeoManager; ClearThreadData() constTGeoManager; ClearThreadsMap()TGeoManagerstatic; ClearTracks()TGeoManagerinline; Clone(const char *newname="""") const overrideTNamedvirtual; CloseGeometry(Option_t *option=""d"")TGeoManager; Compare(const TObject *obj) const overrideTNamedvirtual; ConstPropMap_t typedefTGeoManagerprivate; ConvertReflections()TGeoManager; Copy(TObject &named) const overrideTNamedvirtual; CountLevels()TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager-members.html:2001,safe,safety,2001,doc/master/classTGeoManager-members.html,https://root.cern,https://root.cern/doc/master/classTGeoManager-members.html,1,['safe'],['safety']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamKernelGauss.html:7355,avoid,avoid,7355,root/html534/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:7992,avoid,avoid,7992,root/html604/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamKernelGauss.html:7984,avoid,avoid,7984,root/html602/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamKernelGauss.html,1,['avoid'],['avoid']
Safety,"may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441132,recover,recovery,441132,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Recover', 'recover']","['Recover', 'recovery']"
Safety,"may hold multi-dimensional distributions. ; For example, the ""measurement"" tree could have two leaves, one for the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the signal and one for the background. Each of the leaves may then have a multi-dimensional distribution. ; The class TUnfoldBinning takes care to map all bins of the ""measurement"" to a one-dimensional vector y. Similarly, the ""truth"" bins are mapped to the vector x.; How to choose the regularisation settings; In TUnfoldDensity, two methods are implemented to determine tau**2 . ScanLcurve() locate the tau where the L-curve plot has a ""kink"" this function is implemented in the TUnfold class . ScanTau() finds the solution such that some variable (e.g. global correlation coefficient) is minimized. This function is implemented in the TUnfoldDensity class . Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the MC prediction. Typical no-go cases of the L-curve scan are: . the number of measurements is too small (e.g. ny=nx) . the input data have no statistical fluctuations [identical MC events are used to fill the matrix of migrations and the vector y for a ""closure test""] . The algorithm (2) only works if the variable does have a real minimum as a function of tau. If global correlations are minimized, the situation is as follows: The matrix of migration typically introduces negative correlations. The area constraint introduces some positive correlation. Regularisation on the ""size"" introduces no correlation. Regularisation on 1st or 2nd derivatives adds positive correlations. ; For these reasons, ""size"" regularisation does not work well with the tau-scan: the higher tau, the smaller rho, but there is no minimum. As a result, large values of tau (too strong regularisation) are found. In contrast, the tau-scan is expected to work better with 1st or 2nd derivative ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:4144,predict,prediction,4144,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['predict'],['prediction']
Safety,"mber Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightUpdates;  The accumulation of the square of the past weight updates associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2934,avoid,avoid,2934,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['avoid'],['avoid']
Safety,"mber Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Adagrad.h>. Inheritance diagram for TMVA::DNN::TAdagr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:2589,avoid,avoid,2589,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['avoid'],['avoid']
Safety,"mbers |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TTimer Class ReferenceCore ROOT classes » Base ROOT classes. ; Handles synchronous and a-synchronous timer events. . synchronous timer is registered into TSystem and is processed within the standard ROOT event-loop.; asynchronous timer is passed to the operating system which sends an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; Sub-class TTimer and override the Notify() method.; Re-implement the TObject::HandleTimer() method in your class and pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1085,timeout,timeout,1085,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"mbers; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:10495,avoid,avoid,10495,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['avoid'],['avoid']
Safety,"mbie ();  . #include <TSelector.h>. Inheritance diagram for TSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15573,abort,aborted,15573,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,2,['abort'],['aborted']
Safety,"md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/); 213{; 214 md5_word_t a = pms->abcd[0], b = pms->abcd[1], c = pms->abcd[2],; 215 d = pms->abcd[3];; 216 md5_word_t t;; 217#if BYTE_ORDER > 0; 218 /* Define storage only for big-endian CPUs. */; 219 md5_word_t X[16];; 220#else; 221 /* Define storage for little-endian or both types of CPUs. */; 222 md5_word_t xbuf[16];; 223 const md5_word_t *X;; 224#endif; 225 ; 226 {; 227#if BYTE_ORDER == 0; 228 /*; 229 * Determine dynamically whether this is a big-endian or; 230 * little-endian machine, since we can use a more efficient; 231 * algorithm on the latter.; 232 */; 233 static const int w = 1;; 234 ; 235 if (*((const md5_byte_t *)&w)) /* dynamic little-endian */; 236#endif; 237#if BYTE_ORDER <= 0 /* little-endian */; 238 {; 239 /*; 240 * On little-endian machines, we can process properly aligned; 241 * data without copying it.; 242 */; 243 if (!(((uintptr_t) data) & 3)) {; 244 /* data are properly aligned, a direct assignment is possible */; 245 /* cast through a (void *) should avoid a compiler warning,; 246 see; 247 https://github.com/bel2125/civetweb/issues/94#issuecomment-98112861; 248 */; 249 X = (const md5_word_t *)(const void *)data;; 250 } else {; 251 /* not aligned */; 252 memcpy(xbuf, data, 64);; 253 X = xbuf;; 254 }; 255 }; 256#endif; 257#if BYTE_ORDER == 0; 258 else /* dynamic big-endian */; 259#endif; 260#if BYTE_ORDER >= 0 /* big-endian */; 261 {; 262 /*; 263 * On big-endian machines, we must arrange the bytes in the; 264 * right order.; 265 */; 266 const md5_byte_t *xp = data;; 267 int i;; 268 ; 269#if BYTE_ORDER == 0; 270 X = xbuf; /* (dynamic only) */; 271#else; 272#define xbuf X /* (static only) */; 273#endif; 274 for (i = 0; i < 16; ++i, xp += 4); 275 xbuf[i] = (md5_word_t)(xp[0]) + (md5_word_t)(xp[1] << 8); 276 + (md5_word_t)(xp[2] << 16); 277 + (md5_word_t)(xp[3] << 24);; 278 }; 279#endif; 280 }; 281 ; 282#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n)))); 283 ; 284/* Round 1. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:9974,avoid,avoid,9974,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['avoid'],['avoid']
Safety,"me ();  ; static constexpr Version_t Class_Version ();  ; static void ComputeNormalS (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  ; static const char * DeclFileName ();  ; static Double_t DistFromInsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi);  ; static Double_t DistFromOutsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi);  ; static Double_t DistToCons (const Double_t *point, const Double_t *dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2);  ; static Double_t SafetyS (const Double_t *point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz=0);  ;  Static Public Member Functions inherited from TGeoCone; static Double_t Capacity (Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2);  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void ComputeNormalS (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2);  ; static const char * DeclFileName ();  ; static Double_t DistFromInsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2);  ; static Double_t DistFromOutsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2);  ; static void DistToCone (const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:16404,Safe,SafetyS,16404,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['Safe'],['SafetyS']
Safety,"me in the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectory::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offer better protection and avoid the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectory.html:15782,avoid,avoid,15782,root/html528/TDirectory.html,https://root.cern,https://root.cern/root/html528/TDirectory.html,6,['avoid'],['avoid']
Safety,"me into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:3885,detect,detected,3885,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['detect'],['detected']
Safety,"me of an element.; Here we attempt to cast the assigned object into TNamed and call; SetName() there.; If you override this call NameTitleChanged() from there. void SetElementTitle(const char* title); Virtual function for setting of title of an element.; Here we attempt to cast the assigned object into TNamed and call; SetTitle() there.; If you override this call NameTitleChanged() from there. void SetElementNameTitle(const char* name, const char* title); Virtual function for setting of name and title of render element.; Here we attempt to cast the assigned object into TNamed and call; SetNameTitle() there.; If you override this call NameTitleChanged() from there. void NameTitleChanged(); Virtual function called when a name or title of the element has; been changed.; If you override this, call also the version of your direct base-class. void SetVizModel(TEveElement* model); Set visualization-parameter model element.; Calling of this function from outside of EVE should in principle; be avoided as it can lead to dis-synchronization of viz-tag and; viz-model. Bool_t FindVizModel(); Find model element in VizDB that corresponds to previously; assigned fVizTag and set fVizModel accordingly.; If the tag is not found in VizDB, the old model-element is kept; and false is returned. Bool_t ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Set the VizTag, find model-element from the VizDB and copy; visualization-parameters from it. If the model is not found and; fallback_tag is non-null, its search is attempted as well.; For example: ApplyVizTag(""TPC Clusters"", ""Clusters"");. If the model-element can not be found a warning is printed and; false is returned. void PropagateVizParamsToProjecteds(); Propagate visualization parameters to dependent elements. MainColor is propagated independently in SetMainColor().; In this case, as fMainColor is a pointer to Color_t, it should; be set in TProperClass::CopyVizParams(). Render state is not propagated. Maybe it should be,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:13674,avoid,avoided,13674,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['avoid'],['avoided']
Safety,"me of your last pull or clone. Get the current list of remotes (including URIs) with; git remote -v. Get the current list of defined branches with; git branch -a. Change to (creating if necessary) a local branch tracking an existing remote branch of the same name:; git checkout <branch>. Update your local repository ref database without altering the current working area:; git fetch <remote>. Update your current local branch with respect to your repository's current idea of a remote branch's status:; git merge <branch>. Pull remote ref information from all remotes and merge local branches with their remote tracking branches (if applicable):; git pull. Examine changes to the current local branch with respect to its tracking branch:; git cherry -v. Push changes to the remote tracking branch:; git push. Push all changes to all tracking branches:; git push --all. Some more advanced operations. Important tip: if you're going to do a git operation the outcome of which is even remotely uncertain to be the desired one: make a copy of your repository:; mkdir -p <path-to-safe-dir>; tar -cf - . | tar -xC <path-to-safe-dir>. Disk space is cheap and rm -rf is easy. Note that you must copy the entire repository, since all the important information is in the .git directory tree at the top level. Stashing; This is a good way quickly to get a clean tree if you want to merge or rebase (see below) to import changes from a branch without having to commit your current work. Save uncommitted changes to the current working area to the stash (not a commit operation):; git stash. Apply previously-saved stash:; git stash pop. (pops off the changes and applies them to the current working area) or; git stash apply. which applies the changes but retains them on the stack.; Examine the current state of the stash:; git stash list. Clear the entire stash:; git stash clear. Rebasing; Rebasing is changing history, if you think that git stores history. As mentioned above, it doesn't: it saves objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:10269,safe,safe-dir,10269,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['safe'],['safe-dir']
Safety,"me, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;; 148 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 149 Int_t GetByteCount() const override { return 56; }; 150 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 151 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 152 Int_t GetNmeshVertices() const override;; 153 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 154 Double_t GetPhi1() const { return fPhi1; }; 155 Double_t GetPhi2() const { return fPhi2; }; 156 void InspectShape() const override;; 157 TBuffer3D *MakeBuffer3D() const override;; 158 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 159 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 160 static Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1,; 161 Double_t phi2, Int_t skipz = 0);; 162 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 163 void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2);; 164 void SetDimensions(Double_t *param) override;; 165 void SetPoints(Double_t *points) const override;; 166 void SetPoints(Float_t *points) const override;; 167 void SetSegsAndPols(TBuffer3D &buff) const override;; 168 void Sizeof3D() const override;; 169 ; 170 ClassDefOverride(TGeoTubeSeg, 2) // cylindrical tube segment class; 171};; 172 ; 173class TGeoCtub : public TGeoTubeSeg {; 174protected:; 175 // data members; 176 Double_t fNlow[3]; // normal to lower cut plane; 177 Double_t fNhigh[3]; // normal to higher cut plane; 178 ; 179public:; 180 // constructors; 181 TGeoCtub();; 182 TGeoCtub(Double_t rmin, Double_t rmax,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:8720,safe,safe,8720,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,me::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 448 of file TSessionViewer.h. ◆ DeclFileName(). static const char * TSessionQueryFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 448 of file TSessionViewer.h. ◆ Feedback(). void TSessionQueryFrame::Feedback ; (; TList * ; objs). Feedback function connected to Feedback signal. ; Used to update feedback histograms. ; Definition at line 2550 of file TSessionViewer.cxx. ◆ GetQueryEditFrame(). TEditQueryFrame * TSessionQueryFrame::GetQueryEditFrame ; (; ); const. inline . Definition at line 419 of file TSessionViewer.h. ◆ GetStatsCanvas(). TCanvas * TSessionQueryFrame::GetStatsCanvas ; (; ); const. inline . Definition at line 418 of file TSessionViewer.h. ◆ GetTab(). TGTab * TSessionQueryFrame::GetTab ; (; ); const. inline . Definition at line 420 of file TSessionViewer.h. ◆ IndicateStop(). void TSessionQueryFrame::IndicateStop ; (; Bool_t ; aborted). Indicate that Cancel or Stop was clicked. ; Definition at line 2878 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionQueryFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 448 of file TSessionViewer.h. ◆ Modified(). void TSessionQueryFrame::Modified ; (; Bool_t ; mod = kTRUE). Notify changes in query editor settings. ; Definition at line 2531 of file TSessionViewer.cxx. ◆ OnBtnAbort(). void TSessionQueryFrame::OnBtnAbort ; (; ). Abort processing query. ; Definition at line 3070 of file TSessionViewer.cxx. ◆ OnBtnFinalize(). void TSessionQueryFrame::OnBtnFinalize ; (; ). Finalize query. ; Definition at line 2954 of file TSessionViewer.cxx. ◆ OnBtnRetrieve(). void TSessionQueryFrame::OnBtnRetrieve ; (; ). Retrieve query. ; Definition at line 3018 of file TSessionViewer.cxx. ◆ OnBtnShowLog(). void TSessionQueryFrame::OnBtnShowLog ; (; ). Show query log. ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:35028,abort,aborted,35028,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['abort'],['aborted']
Safety,"me::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK butto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleDialog.html:22155,avoid,avoid,22155,root/html528/TStyleDialog.html,https://root.cern,https://root.cern/root/html528/TStyleDialog.html,8,['avoid'],['avoid']
Safety,"me;  ; TString fTitle;  . Static Protected Attributes; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TMemFile.h>. Inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:42523,Timeout,Timeout,42523,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,2,['Timeout'],['Timeout']
Safety,"me;; 469 errmsg += ""\"" does not correspond to column type, which is "";; 470 errmsg += GetTypeName(name);; 471 throw std::runtime_error(errmsg);; 472 }; 473 ; 474 fValues[index].fIsActive = true;; 475 return std::vector<void *>{fNSlots, &fValues[index].fPtr};; 476}; 477 ; 478////////////////////////////////////////////////////////////////////////////; 479/// Returns a range of size 1 as long as more rows are available in the SQL result set.; 480/// This inherently serialized the RDF independent of the number of slots.; 481std::vector<std::pair<ULong64_t, ULong64_t>> RSqliteDS::GetEntryRanges(); 482{; 483 std::vector<std::pair<ULong64_t, ULong64_t>> entryRanges;; 484 int retval = sqlite3_step(fDataSet->fQuery);; 485 switch (retval) {; 486 case SQLITE_DONE: return entryRanges;; 487 case SQLITE_ROW:; 488 entryRanges.emplace_back(fNRow, fNRow + 1);; 489 fNRow++;; 490 return entryRanges;; 491 default:; 492 SqliteError(retval);; 493 // Never here; 494 abort();; 495 }; 496}; 497 ; 498////////////////////////////////////////////////////////////////////////////; 499/// Returns the C++ type for a given column name, implemented as a linear search through all the columns.; 500std::string RSqliteDS::GetTypeName(std::string_view colName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if (colName == fColumnNames[i]) {; 506 return fgTypeNames[static_cast<int>(fColumnTypes[i])];; 507 }; 508 }; 509 throw std::runtime_error(""Unknown column: "" + std::string(colName));; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////; 513/// A linear search through the columns for the given name; 514bool RSqliteDS::HasColumn(std::string_view colName) const; 515{; 516 return std::find(fColumnNames.begin(), fColumnNames.end(), colName) != fColumnNames.end();; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////; 520/// Resets the SQlite query engine at the beginning of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:20911,abort,abort,20911,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['abort'],['abort']
Safety,"means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 867 of file TUDPSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TUDPSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 898 of file TUDPSocket.cxx. ◆ Select(). Int_t TUDPSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 407 of file TUDPSocket.cxx. ◆ Send() [1/4]. Int_t TUDPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Definition at line 464 of file TUDPSocket.cxx. ◆ Send() [2/4]. Int_t TUDPSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:29162,detect,detected,29162,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,3,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"means that, for multi-thread event loops, there is no; 902guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51743,safe,safe,51743,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"means that, for multi-thread event loops, there is no; 942guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53383,safe,safe,53383,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"med] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows and unspecified number of columns .; nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(Int_t row_lwb, Int_t row_upb, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with row range, [row_lwb..row_upb] and unspecified column; range . nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(const TMatrixDSparse& a, Int_t verbose); Constructor for matrix A . TDecompSparse(const TDecompSparse& anoth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompSparse.html:10685,detect,detected,10685,root/html528/TDecompSparse.html,https://root.cern,https://root.cern/root/html528/TDecompSparse.html,4,['detect'],['detected']
Safety,"members ; TGeoCtub Class Reference. . Definition at line 173 of file TGeoTube.h. Public Member Functions;  TGeoCtub ();  ;  TGeoCtub (const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);  ;  TGeoCtub (Double_t *params);  ;  TGeoCtub (Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);  ;  ~TGeoCtub () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:1322,safe,safe,1322,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ment::EChangeBitsTEveElement::kCBVisibility; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TEveDigitSet::ERenderMode_ekRM_AsIs; static TEveDigitSet::ERenderMode_ekRM_Fill; static TEveDigitSet::ERenderMode_ekRM_Line; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tfAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; TEveDigitSet::Callback_foofCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; Color_tfColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tfDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TRefArray*fDigitIdsArray holding references to external objects.; Bool_tfDisableLightingDis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveDigitSet.html:25028,avoid,avoid,25028,root/html602/TEveDigitSet.html,https://root.cern,https://root.cern/root/html602/TEveDigitSet.html,2,['avoid'],['avoid']
Safety,"mented based on TGeoVoxelGrid caching. ; Definition at line 245 of file TGeoParallelWorld.cxx. ◆ FindNodeLoop(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeLoop ; (; Double_t ; point[3]). private . Finds physical node containing the point using simple algorithm (for debugging) ; Definition at line 353 of file TGeoParallelWorld.cxx. ◆ FindNodeOrig(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeOrig ; (; Double_t ; point[3]). private . Finds physical node containing the point (original version based on TGeoVoxelFinder) ; Definition at line 318 of file TGeoParallelWorld.cxx. ◆ GetAccelerationMode(). AccelerationMode const & TGeoParallelWorld::GetAccelerationMode ; (; ); const. inline . Definition at line 96 of file TGeoParallelWorld.h. ◆ GetBVHSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetBVHSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. ◆ GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. ◆ GetLoopSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetLoopSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses trivial algorithm to do so. ; Definition at line 740 of file TGeoParallelWorld.cxx. ◆ GetVolume(). TGeoVolume * TGeoParallelWorld::GetVolume ; (; ); const. inline . Definition at line 144 of file TGeoParallelWorld.h. ◆ InitSafetyVoxel(). void TGeoParallelWorld::InitSafetyVoxel ; (; TGeoVoxelGridIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:23323,safe,safety,23323,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"ments TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2404 of file TBufferFile.cxx. ◆ WriteFastArrayDouble32(). void TBufferFile::WriteFastArrayDouble32 ; (; const Double_t * ; d, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n doubles (as float) into the I/O buffer. ; see comments about Double32_t encoding at TBufferFile::WriteDouble32 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n floats (as truncated float) into the I/O buffer. ; see comments about Float16_t encoding at TBufferFile::WriteFloat16 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2265 of file TBufferFile.cxx. ◆ WriteFastArrayString(). void TBufferFile::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2033 of file TBufferFile.cxx. ◆ WriteFloat(). void TBufferFile::WriteFloat ; (; Float_t ; f). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 349 of file TBufferFile.h. ◆ WriteFloat16(). void TBufferFile::WriteFloat16 ; (; Float_t * ; f, . TStreamerElement * ; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:88220,abort,aborts,88220,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"meric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956////////////////////////////////////////////////////////////////////////////////; 957/// Returns minimum of array a of length n.; 958 ; 959template <typename T>; 960T TMath::MinElement(Long64_t n, const T *a) {; 961 return *std::min_element(a,a+n);; 962}; 963 ; 964////////////////////////////////////////////////////////////////////////////////; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:33977,avoid,avoid,33977,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['avoid'],['avoid']
Safety,"meters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big() ; The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1027819,safe,safe,1027819,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"meters theFitP = kNotEnforced;; 413 if (fAllVarsI[ivar] == """" || fAllVarsI[ivar] == ""NotEnforced"") theFitP = kNotEnforced;; 414 else if (fAllVarsI[ivar] == ""FMax"" ) theFitP = kForceMax;; 415 else if (fAllVarsI[ivar] == ""FMin"" ) theFitP = kForceMin;; 416 else if (fAllVarsI[ivar] == ""FSmart"" ) theFitP = kForceSmart;; 417 else {; 418 Log() << kFATAL << ""unknown value \'"" << fAllVarsI[ivar]; 419 << ""\' for fit parameter option "" << Form(""VarProp[%i]"",ivar) << Endl;; 420 }; 421 (*fFitParams)[ivar] = theFitP;; 422 ; 423 if (theFitP != kNotEnforced); 424 Log() << kINFO << ""Use \"""" << fAllVarsI[ivar]; 425 << ""\"" cuts for variable: "" << ""'"" << (*fInputVars)[ivar] << ""'"" << Endl;; 426 }; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// cut evaluation: returns 1.0 if event passed, 0.0 otherwise; 431 ; 432Double_t TMVA::MethodCuts::GetMvaValue( Double_t* err, Double_t* errUpper ); 433{; 434 // cannot determine error; 435 NoErrorCalc(err, errUpper);; 436 ; 437 // sanity check; 438 if (fCutMin == NULL || fCutMax == NULL || fNbins == 0) {; 439 Log() << kFATAL << ""<Eval_Cuts> fCutMin/Max have zero pointer. ""; 440 << ""Did you book Cuts ?"" << Endl;; 441 }; 442 ; 443 const Event* ev = GetEvent();; 444 ; 445 // sanity check; 446 if (fTestSignalEff > 0) {; 447 // get efficiency bin; 448 Int_t ibin = fEffBvsSLocal->FindBin( fTestSignalEff );; 449 if (ibin < 0 ) ibin = 0;; 450 else if (ibin >= fNbins) ibin = fNbins - 1;; 451 ; 452 Bool_t passed = kTRUE;; 453 for (UInt_t ivar=0; ivar<GetNvar(); ivar++); 454 passed &= ( (ev->GetValue(ivar) > fCutMin[ivar][ibin]) &&; 455 (ev->GetValue(ivar) <= fCutMax[ivar][ibin]) );; 456 ; 457 return passed ? 1. : 0. ;; 458 }; 459 else return 0;; 460}; 461 ; 462////////////////////////////////////////////////////////////////////////////////; 463/// print cuts; 464 ; 465void TMVA::MethodCuts::PrintCuts( Double_t effS ) const; 466{; 467 std::vector<Double_t> cutsMin;; 468 std::vector<Double_t> cutsMax;; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:16340,sanity check,sanity check,16340,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"mething to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. The current directory (gFile) is changed to this file. ; Reimplemented in TSQLFile, TXMLFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 2162 of file TFile.cxx. ◆ ResetErrno(). void TFile::ResetErrno ; (; ); const. virtual . Method resetting the errno. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, and TMemFile.; Definition at line 1254 of file TFile.cxx. ◆ Seek(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:90125,Recover,Recover,90125,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Recover'],['Recover']
Safety,"method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1738 of file TFumili.cxx. ◆ FitChisquareI(). void TFumili::FitChisquareI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1809 of file TFumili.cxx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1884 of file TFumili.cxx. ◆ FitLikelihoodI(). void TFumili::FitLikelihoodI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:30928,predict,predict,30928,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['predict'],['predict']
Safety,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCtub.html:9475,Safe,SafetyS,9475,root/html530/TGeoCtub.html,https://root.cern,https://root.cern/root/html530/TGeoCtub.html,2,['Safe'],['SafetyS']
Safety,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:8320,safe,safe,8320,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoUnion.html:10105,safe,safe,10105,root/html604/TGeoUnion.html,https://root.cern,https://root.cern/root/html604/TGeoUnion.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoUnion.html:10105,safe,safe,10105,root/html602/TGeoUnion.html,https://root.cern,https://root.cern/root/html602/TGeoUnion.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"metimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:4068,safe,safe,4068,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['safe'],['safe']
Safety,"metry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape sur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4484,safe,safe,4484,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,3,['safe'],['safe']
Safety,"mg_cry_ctx_internal(phys_ctx,; 16729 ""external_ssl_ctx callback returned error: %i"",; 16730 callback_ret);; 16731 return 0;; 16732 } else if (callback_ret > 0) {; 16733 /* Callback exists and returns >0: Initializing complete,; 16734 * civetweb should not modify the SSL context. */; 16735 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16736 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16737 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16738 return 0;; 16739 }; 16740 return 1;; 16741 }; 16742 /* If the callback does not exist or return 0, civetweb must initialize; 16743 * the SSL context. Handle ""domain"" callback next. */; 16744 ; 16745 /* Check for external domain SSL_CTX callback. */; 16746 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16747 ? 0; 16748 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16749 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16750 &ssl_ctx,; 16751 phys_ctx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:497201,Abort,Abort,497201,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Abort'],['Abort']
Safety,"mg_cry_ctx_internal(phys_ctx,; 16730 ""external_ssl_ctx callback returned error: %i"",; 16731 callback_ret);; 16732 return 0;; 16733 } else if (callback_ret > 0) {; 16734 /* Callback exists and returns >0: Initializing complete,; 16735 * civetweb should not modify the SSL context. */; 16736 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16737 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16738 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16739 return 0;; 16740 }; 16741 return 1;; 16742 }; 16743 /* If the callback does not exist or return 0, civetweb must initialize; 16744 * the SSL context. Handle ""domain"" callback next. */; 16745 ; 16746 /* Check for external domain SSL_CTX callback. */; 16747 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16748 ? 0; 16749 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16750 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16751 &ssl_ctx,; 16752 phys_ctx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:497234,Abort,Abort,497234,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Abort'],['Abort']
Safety,"milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:13348,timeout,timeout,13348,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,3,['timeout'],['timeout']
Safety,"min = fUxmax = fUymax = 0;; 367 ; 368 // Set pad parameters and Compute conversion coefficients; 369 SetPad(name, title, xlow, ylow, xup, yup, color, bordersize, bordermode);; 370 Range(0, 0, 1, 1);; 371 SetBit(kMustCleanup);; 372 SetBit(kCanDelete);; 373}; 374 ; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n = 1; n <= 4; ++n) {; 412/// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; 413/// h1->FillRandom(""gaus"", 2000 + n*1000);; 414/// c1->GetPad(n)->Add(h1);; 415/// }; 416/// ~~~; 417 ; 418void TPad::Add(TObject *obj, Option_t *opt, Bool_t modified); 419{; 420 if (!obj); 421 return;; 422 ; 423 if (!fPrimitives); 424 fPrim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:11631,Safe,SafeDelete,11631,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"min1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:2202,safe,safe,2202,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,1,['safe'],['safe']
Safety,"mits (most recent at the bottom) along with instructions on what to do. Commits can have their log messages reworded; commits can be removed entirely, combined with other commits or re-ordered. If you specified any rewording or squashing, you will be taken to an edit session for the commit message(s) after saving and exiting the current edit session.; Squash, re-order or reword commits since divergence from :; git rebase -i <branch>. Keep up to date with remote branches without merging.; git pull --rebase. or; git fetch <remote>; git rebase <remote>/<branch>. Resolving conflicts; Any pull, merge, or rebase operation can result in a conflict during the application of a particular change from the remote branch. Follow the on-screen instructions to resolve problems. This will usually consist of doing a git status to list conflicts, editing the files and using git add to mark each conflict resolved. The process must either be allowed to continue by issuing a git rebase --continue or git merge --continue command, or the operation can be reverted with --abort instead of --continue. If in doubt, copy your repository.; Making a new remote branch. Create a new local branch based on an existing one:; git checkout -b <branch>. Do stuff.; Push the branch to the remote:; git push <remote> <local-branch-name>[:<new-remote-branch-name>]. Tagging. Tag the current state of a branch (eg for release):; git tag -am <message> <version>. Note that the -a creates an annotated tag, which is itself a commit with a hash and a commit message. This is the closest analogue to the CVS tag command. Omitting the -a option will create a, ""simple tag"" which is actually a branch. In general, you will probably prefer annotated tags with version-branches created explicitly as desired.; Push the tag to the remote:; git push --tags. Special notes on mis-tagging.; There are several things that can go wrong with tagging:. One can omit an intended -a option;; One can misspell the tag; or; One can omit or (h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:13183,abort,abort,13183,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['abort'],['abort']
Safety,"mizer status. ;  ; void saveStatus (const char *label, int status);  ; int seek ();  Execute SEEK. ;  ; void setEps (double eps);  Change MINUIT epsilon. ;  ; void setErrorLevel (double level);  Set the level for MINUIT error analysis to the given value. ;  ; void setEvalErrorWall (bool flag);  ; bool setLogFile (const char *logf=nullptr);  ; void setMaxFunctionCalls (int n);  Change maximum number of likelihood function class from MINUIT (RooMinimizer default 500 * #parameters) ;  ; void setMaxIterations (int n);  Change maximum number of MINUIT iterations (RooMinimizer default 500 * #parameters) ;  ; void setMinimizerType (std::string const &type);  Choose the minimizer algorithm. ;  ; void setOffsetting (bool flag);  Enable internal likelihood offsetting for enhanced numeric precision. ;  ; void setPrintEvalErrors (int numEvalErrors);  ; void setPrintLevel (int newLevel);  Change the MINUIT internal printing level. ;  ; void setProfile (bool flag=true);  ; void setRecoverFromNaNStrength (double strength);  Try to recover from invalid function values. ;  ; void setStrategy (int istrat);  Change MINUIT strategy to istrat. ;  ; void setVerbose (bool flag=true);  ; int simplex ();  Execute SIMPLEX. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void zeroEvalCount ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:4960,recover,recover,4960,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['recover'],['recover']
Safety,"mment = 0;; 226 if (signalMethod != (TMethod *) -1) // -1 in case of interpreted class; 227 comment = signalMethod->GetCommentString();; 228 ; 229 if (!comment || !comment[0] || strstr(comment,""*SIGNAL"")){; 230 ::Error(""TQObject::CheckConnectArgs"",; 231 ""signal %s::%s(%s), to declare signal use comment //*SIGNAL*"",; 232 sender_class->GetName(), signal_method, signal_proto);; 233 delete [] signal_method;; 234 return -1;; 235 }; 236#endif; 237 ; 238 // cleaning; 239 delete [] signal_method;; 240 ; 241 auto len2 = strlen(slot)+1;; 242 char *slot_method = new char[len2];; 243 if (slot_method) strlcpy(slot_method, slot, len2);; 244 ; 245 char *slot_proto;; 246 char *slot_params = nullptr;; 247 ; 248 if ((slot_proto = strchr(slot_method,'('))) {; 249 ; 250 // substitute first '(' symbol with '\0'; 251 *slot_proto++ = '\0';; 252 ; 253 // substitute last ')' symbol with '\0'; 254 if ((tmp = strrchr(slot_proto,')'))) *tmp = '\0';; 255 }; 256 ; 257 if (!slot_proto) slot_proto = (char*)""""; // avoid zero strings; 258 if ((slot_params = strchr(slot_proto,'='))) *slot_params = ' ';; 259 ; 260 TFunction *slotMethod = nullptr;; 261 if (!receiver_class) {; 262 // case of slot_method is compiled/intrepreted function; 263 slotMethod = gROOT->GetGlobalFunction(slot_method,nullptr,kFALSE);; 264 } else {; 265 slotMethod = !slot_params ?; 266 GetMethodWithPrototype(receiver_class,; 267 slot_method,; 268 slot_proto,; 269 nargs) :; 270 GetMethod(receiver_class,; 271 slot_method, slot_params);; 272 }; 273 ; 274 if (!slotMethod) {; 275 if (!slot_params) {; 276 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 277 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 278 slot_method) : slot_method, slot_proto);; 279 } else {; 280 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 281 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 282 slot_method) : slot_method, slot_params);; 283 }; 284 delete [] slot_method;; 285 return -1;; 286 }; 287 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:8407,avoid,avoid,8407,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTableLayout.html:9696,Sanity check,Sanity check,9696,root/html534/TGTableLayout.html,https://root.cern,https://root.cern/root/html534/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTableLayout.html:10148,Sanity check,Sanity check,10148,root/html604/TGTableLayout.html,https://root.cern,https://root.cern/root/html604/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTableLayout.html:10148,Sanity check,Sanity check,10148,root/html602/TGTableLayout.html,https://root.cern,https://root.cern/root/html602/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addNumIntDep (RooAbsArg const &arg);  Sort numeric integration variables in summation and integration lists. ;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:60899,Avoid,Avoids,60899,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Avoid'],['Avoids']
Safety,"momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id - NEW. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol volume name of the starting node; number copy number of topvol (relevant for gsposp); nlevel number of levels in the tree structure; to be written out, starting from topvol; (Geant3 only); Deprecated; Set geometry from Root (built via TGeo). void SetUserParameters(Bool_t isUserParameters); Activate the parameters defined in tracking media; (DEEMAX, STMIN, STEMAX), which are, be default, ignored.; In Geant4 case, only STEMAX is taken into account.; In FLUKA, all tracking media parameters are ignored. Int_t VolId(const char* volName) const. get methods. Return the unique numeric identifier for volume name volName. const char* VolName(Int_t id) const; Return the volume name for a given volume identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:26063,detect,detector,26063,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,2,['detect'],['detector']
Safety,"mory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::IsATClass * IsA() const overrideDefinition TFile.h:344; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:229161,Recover,Recovervirtual,229161,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,"['Recover', 'recover']","['Recover', 'Recovervirtual', 'recover']"
Safety,"mory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is stro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:10231,safe,safe,10231,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"mpinfo,compinfo->fOffset) ); break;; 3257 case TStreamerInfo::kUInt: readSequence->AddAction( ReadBasicType<UInt_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3258 case TStreamerInfo::kULong: readSequence->AddAction( ReadBasicType<ULong_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3259 case TStreamerInfo::kULong64: readSequence->AddAction( ReadBasicType<ULong64_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3260 case TStreamerInfo::kBits: readSequence->AddAction( ReadBasicType<BitsMarker>, new TBitsConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3261 case TStreamerInfo::kFloat16: {; 3262 if (element->GetFactor() != 0) {; 3263 readSequence->AddAction( ReadBasicType_WithFactor<float>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3264 } else {; 3265 Int_t nbits = (Int_t)element->GetXmin();; 3266 if (!nbits) nbits = 12;; 3267 readSequence->AddAction( ReadBasicType_NoFactor<float>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3268 }; 3269 break;; 3270 }; 3271 case TStreamerInfo::kDouble32: {; 3272 if (element->GetFactor() != 0) {; 3273 readSequence->AddAction( ReadBasicType_WithFactor<double>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3274 } else {; 3275 Int_t nbits = (Int_t)element->GetXmin();; 3276 if (!nbits) {; 3277 readSequence->AddAction( ConvertBasicType<float,double>::Action, new TConfiguration(this,i,compinfo,compinfo->fOffset) );; 3278 } else {; 3279 readSequence->AddAction( ReadBasicType_NoFactor<double>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3280 }; 3281 }; 3282 break;; 3283 }; 3284 case TStreamerInfo::kTNamed: readSequence->AddAction( ReadTNamed, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3285 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 3286 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:145945,avoid,avoid,145945,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mplate <typename T>; 919 INLINE_TEMPLATE_ARGS Int_t ReadBasicType_NoFactor(TBuffer &buf, void *addr, const TConfiguration *config); 920 {; 921 // Stream a Float16 or Double32 where a factor has not been specified.; 922 ; 923 TConfNoFactor *conf = (TConfNoFactor *)config;; 924 Int_t nbits = conf->fNbits;; 925 ; 926 buf.ReadWithNbits( (T*)( ((char*)addr) + config->fOffset ), nbits );; 927 return 0;; 928 }; 929 ; 930 INLINE_TEMPLATE_ARGS Int_t ReadTString(TBuffer &buf, void *addr, const TConfiguration *config); 931 {; 932 // Read in a TString object.; 933 ; 934 // Idea: We could separate the TString Streamer in its two parts and; 935 // avoid the if (buf.IsReading()) and try having it inlined.; 936 ((TString*)(((char*)addr)+config->fOffset))->TString::Streamer(buf);; 937 return 0;; 938 }; 939 ; 940 INLINE_TEMPLATE_ARGS Int_t ReadTObject(TBuffer &buf, void *addr, const TConfiguration *config); 941 {; 942 // Read in a TObject object part.; 943 ; 944 // Idea: We could separate the TObject Streamer in its two parts and; 945 // avoid the if (buf.IsReading()).; 946 ((TObject*)(((char*)addr)+config->fOffset))->TObject::Streamer(buf);; 947 return 0;; 948 }; 949 ; 950 INLINE_TEMPLATE_ARGS Int_t ReadTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 951 {; 952 // Read in a TNamed object part.; 953 // Since the TNamed streamer is solely delegating back to the StreamerInfo we; 954 // can skip the streamer.; 955 ; 956 // Idea: We could extract the code from ReadClassBuffer and avoid one function; 957 // code.; 958 static const TClass *TNamed_cl = TNamed::Class();; 959 return buf.ReadClassBuffer(TNamed_cl,(((char*)addr)+config->fOffset));; 960 }; 961 ; 962 class TConfigSTL : public TConfiguration {; 963 // Configuration object for the kSTL case; 964 private:; 965 void Init() {; 966 TVirtualCollectionProxy *proxy = fNewClass->GetCollectionProxy();; 967 if (proxy) {; 968 fCreateIterators = proxy->GetFunctionCreateIterators();; 969 fCreateWriteIterators = proxy->GetFunction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:38385,avoid,avoid,38385,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mplateProxy *pytmpl, bool use_targs, uint64_t sighash, CPPOverload *pymeth);  ; bool UseStrictOwnership (CallContext *ctxt);  ; static void vectoriter_dealloc (vectoriterobject *vi);  ; static PyObject * vectoriter_iternext (vectoriterobject *vi);  . Variables; PyTypeObject CPPDataMember_Type;  ; PyTypeObject CPPExcInstance_Type;  ; PyTypeObject CPPInstance_Type;  ; PyTypeObject CPPOverload_Type;  ; PyTypeObject CPPScope_Type;  ; PyTypeObject CustomInstanceMethod_Type;  ; static PyMemberDef dm_members [];  ; static PyMethodDef dm_methods [];  ; static PyNumberMethods ep_as_number;  ; static PyMethodObject * free_list;  ; PyObject * gAbrtException = nullptr;  ; PyObject * gBusException = nullptr;  ; std::ostringstream gCapturedError;  ; static ConvFactories_t gConvFactories;  ; PyObject * gDefaultObject = nullptr;  ; bool gDictLookupActive = false;  ; dict_lookup_func gDictLookupOrg = 0;  ; static ExecFactories_t gExecFactories;  ; PyObject * gIllException = nullptr;  ; std::set< std::string > gIteratorTypes;  ; PyObject * gNullPtrObject = nullptr;  ; std::streambuf * gOldErrorBuffer = nullptr;  ; std::set< Cppyy::TCppType_t > gPinnedTypes;  ; PyObject * gPyTypeMap = nullptr;  ; PyObject * gSegvException = nullptr;  ; PyObject * gThisModule = nullptr;  ; PyTypeObject IndexIter_Type;  ; PyTypeObject InstanceArrayIter_Type;  ; PyTypeObject LowLevelView_Type;  ; static PyGetSetDef meta_getset [];  ; static PyMethodDef meta_methods [];  ; static int numfree = 0;  ; static PyNumberMethods op_as_number;  ; static PySequenceMethods op_as_sequence;  ; static PyGetSetDef op_getset [];  ; static PyMethodDef op_methods [];  ; PyTypeObject RefFloat_Type;  Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ;  ; PyTypeObject RefInt_Type;  ; const int SMALL_ARGS_N = 8;  ; PyTypeObject TemplateProxy_Type;  ; static PyMappingMethods tpp_as_mapping;  ; static PyGetSetDef tpp_getset [];  ; static PyMethodDef tpp_methods [];  ; static PyGetSetDef tptc_getset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:20245,detect,detectable,20245,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['detect'],['detectable']
Safety,"mplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFlatRandomGen;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation ;  CFumiliStandardMaximumLikelihoodFCNClass implementing the Elements member function for the standard maximum likelihood method ;  CFunctionGradient;  CFunctionMinimizerBase class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or ""step size""), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:56437,predict,predicted,56437,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['predict'],['predicted']
Safety,"mporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877466,safe,safely,877466,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safely']
Safety,"mpute bounding box of the assembly. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Compute normal to closest surface from POINT. Should not be called. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the assembly. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the hyperboloid. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from outside point to surface of the hyperboloid. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:1756,safe,safe,1756,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"mpute stream, if it's not the default stream.Definition CudaMatrix.h:282; TMVA::DNN::TCudaMatrix::fNColssize_t fNColsDefinition CudaMatrix.h:118; TMVA::DNN::TCudaMatrix::GetOnesstatic AFloat * GetOnes()Definition CudaMatrix.h:125; TMVA::DNN::TCudaMatrix::~TCudaMatrix~TCudaMatrix()=default; TMVA::DNN::TCudaMatrix::fOnesstatic AFloat * fOnesVector used for summations of columns.Definition CudaMatrix.h:111; TMVA::DNN::TCudaMatrix::fCublasHandlestatic cublasHandle_t fCublasHandleDefinition CudaMatrix.h:109; TMVA::DNN::TCudaMatrix::fInstancesstatic size_t fInstancesCurrent number of matrix instances.Definition CudaMatrix.h:108; TMVA::DNN::TCudaMatrix::GetNrowssize_t GetNrows() constDefinition CudaMatrix.h:159; TMVA::DNN::TCudaMatrix::operator=TCudaMatrix & operator=(TCudaMatrix &&)=default; TMVA::DNN::TCudaMatrix::InitializeCurandStatesvoid InitializeCurandStates()Definition CudaMatrix.cu:140; TMVA::DNN::TCudaMatrix::GetDataPointerAFloat * GetDataPointer()Definition CudaMatrix.h:164; TMVA::DNN::TCudaMatrix::fNOnesstatic size_t fNOnesCurrent length of the one vector.Definition CudaMatrix.h:112; TMVA::DNN::TCudaMatrix::TCudaMatrixTCudaMatrix(TCudaMatrix &&)=default; TMVA::DNN::TCudaMatrix::GetCurandStatesPointerstatic curandState_t * GetCurandStatesPointer()Definition CudaMatrix.h:152; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTTMatrixT.Definition TMatrixT.h:40; bool; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TMVA::DNN::cudaErrorvoid cudaError(cudaError_t code, const char *file, int line, bool abort=true)Function to check cuda return code.Definition CudaMatrix.h:198; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; mTMarker mDefinition textangle.C:8. tmvatmvaincTMVADNNArchitecturesCudaCudaMatrix.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:57 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:17603,abort,abort,17603,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['abort'],['abort']
Safety,"mputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:4111,safe,safe,4111,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,9,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"mputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax1 () const;  ; virtual Double_t GetRmax2 () const;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:1318,safe,safe,1318,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"mum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78}; 79 ; 80 ; 81////////////////////////////////////////////////////////////////////////////////; 82/// Constructor for fix bin size 2-D histograms.; 83/// Creates the main histogram structure.; 84///; 85/// \param[in] name name of histogram (avoid blanks); 86/// \param[in] title histogram title.; 87/// If title is of the form `stringt;stringx;stringy;stringz`,; 88/// the histogram title is set to `stringt`,; 89/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 90/// \param[in] nbinsx number of bins along the X axis; 91/// \param[in] xlow low edge of the X axis first bin; 92/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:3731,avoid,avoid,3731,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n *width and *height.; string – String whose dimensions are to be computed. numChars – Number of characters to consider from string, or < 0 for strlen(). wrapLength – Longest permissible line length, in pixels. <= 0 means no automatic wrapping: just let lines get as long as needed. justify – How to justify lines. flags – Flag bits OR-ed together. kTextIgnoreTabs means that tab characters should not be expanded. kTextIgnoreNewlines means that newline characters should not cause a line break. width – Filled with width of string. height – Filled with height of string. ; Definition at line 661 of file TGFont.cxx. ◆ DeclFileName(). static const char * TGFont::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 209 of file TGFont.h. ◆ DrawChars(). void TGFont::DrawChars ; (; Drawable_t ; dst, . GContext_t ; gc, . const char * ; source, . Int_t ; numChars, . Int_t ; x, . Int_t ; y . ); const. Perform a quick sanity check to ensure we won't overflow the X coordinate space. ; Definition at line 1493 of file TGFont.cxx. ◆ DrawCharsExp(). void TGFont::DrawCharsExp ; (; Drawable_t ; dst, . GContext_t ; gc, . const char * ; source, . Int_t ; numChars, . Int_t ; x, . Int_t ; y . ); const. Draw a string of characters on the screen. ; DrawCharsExp() expands control characters that occur in the string to \X or \xXX sequences. DrawChars() just draws the strings.; dst – Window or pixmap in which to draw. gc – Graphics context for drawing characters. source – Characters to be displayed. Need not be'\0' terminated. For DrawChars(), all meta-characters (tabs, control characters, and newlines) should be stripped out of the string that is passed to this function. If they are not stripped out, they will be displayed as regular printing characters. numChars – Number of characters in string. x, y – Coordinates at which to place origin of string when drawing. ; Definition at line 1463 of file TGFont.cxx. ◆ GetFontAttributes(). FontAt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:17557,sanity check,sanity check,17557,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['sanity check'],['sanity check']
Safety,"n = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11634,timeout,timeout,11634,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety,"n = kTRUE). overridevirtual . Switch on/off merge timer. ; Reimplemented from TProofPlayer.; Definition at line 1814 of file TProofPlayer.cxx. ◆ SetSelectorDataMembersFromOutputList(). void TProofPlayerRemote::SetSelectorDataMembersFromOutputList ; (; ). protected . Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster. ◆ StreamerNVirtual(). void TProofPlayerRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 366 of file TProofPlayer.h. Member Data Docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37234,timeout,timeout,37234,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['timeout'],['timeout']
Safety,"n = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42632,timeout,timeout,42632,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,2,['timeout'],['timeout']
Safety,"n = std::min(outAxis.GetLast(),outAxis.GetNbins() ) ;; 1902 ; 1903 if ( lastbin < firstbin && inAxis.TestBit(TAxis::kAxisRange) ) {; 1904 firstbin = inAxis.GetFirst();; 1905 lastbin = inAxis.GetLast();; 1906 // For special case of TAxis::SetRange, when first == 1 and last; 1907 // = N and the range bit has been set, the TAxis will return 0; 1908 // for both.; 1909 if (firstbin == 0 && lastbin == 0); 1910 {; 1911 firstbin = 1;; 1912 lastbin = inAxis.GetNbins();; 1913 }; 1914 }; 1915 if (firstbin < 0) firstbin = 1;; 1916 if (lastbin < 0) lastbin = inN;; 1917 if (lastbin > inN+1) lastbin = inN;; 1918 ; 1919 // Create the profile histogram; 1920 char *pname = (char*)name;; 1921 if (name && strcmp(name, expectedName) == 0) {; 1922 Int_t nch = strlen(GetName()) + 5;; 1923 pname = new char[nch];; 1924 snprintf(pname,nch,""%s%s"",GetName(),name);; 1925 }; 1926 TProfile *h1=nullptr;; 1927 //check if a profile with identical name exist; 1928 // if compatible reset and re-use previous histogram; 1929 TObject *h1obj = gROOT->FindObject(pname);; 1930 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 1931 if (h1obj->IsA() != TProfile::Class() ) {; 1932 Error(""DoProfile"",""Histogram with name %s must be a TProfile and is a %s"",name,h1obj->ClassName());; 1933 return nullptr;; 1934 }; 1935 h1 = (TProfile*)h1obj;; 1936 // reset the existing histogram and set always the new binning for the axis; 1937 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 1938 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 1939 h1->Reset();; 1940 const TArrayD *xbins = outAxis.GetXbins();; 1941 if (xbins->fN == 0) {; 1942 if ( originalRange ); 1943 h1->SetBins(outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax());; 1944 else; 1945 h1->SetBins(lastOutBin-firstOutBin+1,outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin));; 1946 } else {; 1947 // case variable bins; 1948 if (originalRange );",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:78028,avoid,avoid,78028,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186020,timeout,timeout,186020,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"n == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186052,timeout,timeout,186052,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:25554,safe,safety,25554,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,2,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:22354,safe,safety,22354,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:22315,safe,safety,22315,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34672,safe,safety,34672,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34460,safe,safety,34460,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21625,safe,safety,21625,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21717,safe,safety,21717,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safety']
Safety,"n Z. When positioning volumes inside slices, one can do it using the generic volume family (e.g. slicey). This should be done as if the coordinate system of the generic slice was the same as the one of the divided volume. The generic slice in case of PHI division is centered with respect to X axis. If the family contains slices of different sizes, any volume positioned inside should fit into the smallest one. Examples for specific divisions according to shape types can be found inside shape classes.; TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping volume is in fact a virtual container that does not represent a physical object. It contains a list of nodes that are not its daughters but that must be checked always before the container itself. This list must be defined by users and it is checked and resolved in a priority order. Note that the feature is non-standard to geometrical modelers and it was introduced just to support conversions of GEANT3 geometries, therefore its extensive usage should be avoided. ; Definition at line 266 of file TGeoVolume.h. Public Member Functions;  TGeoVolumeMulti ();  dummy constructor ;  ;  TGeoVolumeMulti (const char *name, TGeoMedium *med=nullptr);  default constructor ;  ;  ~TGeoVolumeMulti () override;  Destructor. ;  ; TGeoNode * AddNode (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option="""") override;  Add a new node to the list of nodes. ;  ; void AddNodeOverlap (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option="""") override;  Add a new node to the list of nodes, This node is possibly overlapping with other daughters of the volume or extruding the volume. ;  ; void AddVolume (TGeoVolume *vol);  Add a volume with valid shape to the list of volumes. ;  ; TGeoVolume * Divide (const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""") override;  division of multiple volumes ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:8581,avoid,avoided,8581,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['avoid'],['avoided']
Safety,"n a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  CParamFunctorParam Functor class for Multidimensional functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F * >;  CFuncEvaluator< F *const >;  CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CPlaceExpr;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlainParameters;  CPlane3DClass describing a geometrical plane in 3 dimensions ;  CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:45266,avoid,avoid,45266,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['avoid'],['avoid']
Safety,"n at line 3556 of file TBufferJSON.cxx. ◆ JsonReadCollection(). void TBufferJSON::JsonReadCollection ; (; TCollection * ; obj, . const TClass * ; objClass . ). protected . read content of ROOT collection ; Definition at line 1674 of file TBufferJSON.cxx. ◆ JsonReadFastArray(). template<typename T > . void TBufferJSON::JsonReadFastArray ; (; T * ; arr, . Int_t ; arrsize, . bool ; asstring = false . ). protected . Template method to read array from the JSON. ; Definition at line 2752 of file TBufferJSON.cxx. ◆ JsonReadObject(). void * TBufferJSON::JsonReadObject ; (; void * ; obj, . const TClass * ; objClass = nullptr, . TClass ** ; readClass = nullptr . ). protected . Read object from current JSON node. ; Definition at line 1772 of file TBufferJSON.cxx. ◆ JsonReadTObjectMembers(). void TBufferJSON::JsonReadTObjectMembers ; (; TObject * ; tobj, . void * ; node = nullptr . ). protected . Read TObject data members from JSON. ; Do not call TObject::Streamer() to avoid special tweaking of TBufferJSON interface ; Definition at line 1979 of file TBufferJSON.cxx. ◆ JsonSpecialClass(). Int_t TBufferJSON::JsonSpecialClass ; (; const TClass * ; cl); const. protected . return non-zero value when class has special handling in JSON it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6) ; Definition at line 1285 of file TBufferJSON.cxx. ◆ JsonStartElement(). void TBufferJSON::JsonStartElement ; (; const TStreamerElement * ; elem, . const TClass * ; base_class . ). protected . Start new class member in JSON structures. ; Definition at line 1212 of file TBufferJSON.cxx. ◆ JsonStartObjectWrite(). TJSONStackObj * TBufferJSON::JsonStartObjectWrite ; (; const TClass * ; obj_class, . TStreamerInfo * ; info = nullptr . ). protected . Start object element with typeinfo. ; Definition at line 1178 of file TBufferJSON.cxx. ◆ JsonWriteArrayCompress(). template<typename T > . void TBufferJSON::JsonWriteArrayCompress ; (; const T * ; vname, . Int_t ; ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:63849,avoid,avoid,63849,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"n at line 72 of file TGeoHype.h. ◆ GetStOut(). Double_t TGeoHype::GetStOut ; (; ); const. inline . Definition at line 73 of file TGeoHype.h. ◆ HasInner(). Bool_t TGeoHype::HasInner ; (; ); const. inline . Definition at line 74 of file TGeoHype.h. ◆ InspectShape(). void TGeoHype::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoHype::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoHype.h. ◆ IsCylType(). Bool_t TGeoHype::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoHype.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoHype::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoHype & TGeoHype::operator= ; (; const TGeoHype & ; ). privatedelete . ◆ RadiusHypeSq(). Double_t TGeoHype::RadiusHypeSq ; (; Double_t ; z, . Bool_t ; inner . ); const. ◆ Safety(). Double_t TGeoHype::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoHype::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToHype(). Double_t TGeoHype::SafetyToHype ; (; const Double_t * ; point, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoHype::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoHype::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetHypeDimensions(). void TGeoHype::SetHypeDimensions ; (; Double_t ; rin, . Double_t ; stin, . Double_t ; rout, . Double_t ; stout, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoHype::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:33092,Safe,Safety,33092,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['Safe'],['Safety']
Safety,"n contain class version . *:object other object, column contain object id . *:rawdata raw data, column contains id of raw data from streamer table . *:Int_t column with integer value . Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage. This and several other options can be changed only when TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before first write operation. These options are: . Name Description . SetUseSuffixes() suffix usage in column names (default - on) . SetArrayLimit() defines maximum array size, which can has column for each element (default 21) . SetTablesType() table type name in MySQL database (default ""InnoDB"") . SetUseIndexes() usage of indexes in database (default kIndexesBasic) . Normally these functions should be called immediately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT SQL commands are used before and after data storage. If TSQLFile detects any problems, ROLLBACK command will be used to restore previous state of data base. If transactions not supported by SQL server, they can be disabled by SetUseTransactions(kTransactionsOff). Or user can take responsibility to use transactions function himself. By default only indexes for basic tables are created. In most cases usage of indexes increase performance to data reading, but it also can increase time of writing data to database. There are several modes of index usage available in SetUseIndexes() method There is MakeSelectQuery(TClass*) method, which produces SELECT statement to get objects data of specified class. Difference from simple statement like: mysql> SELECT * FROM TH1I_ver1 that not only data for that class, but also data from parent classes will be extracted from other tables and combined in single result table. Such select query can be useful for external access to objects data.; Up to now MySQL 4.1 and Oracle 9i were tested. Some extra work is required for other SQL databases. Hopefully, this s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:4490,detect,detects,4490,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['detect'],['detects']
Safety,"n detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming over the response matrix ;  ; Int_t GetNpar (void) const;  get number of truth parameters determined in recent unfolding ;  ; Int_t GetNr (void) const;  get number of regularisation conditions ;  ; void GetOutput (TH1 *output, const Int_t *binMap=nullptr) const;  get output distribution, possibly cumulated over several bins ;  ; void GetProbabilityMatrix (TH2 *A, EHistMap histmap) const;  get matrix of probabilities ;  ; Double_t GetRhoAvg (void) const;  get average global correlation determined in recent unfolding ;  ; Double_t GetRhoI (TH1 *rhoi, const Int_t *binMap=nullptr, TH2 *invEmat=nullptr) const;  get global correlation coefficiencts, possibly cumulated over several bins ;  ; void GetRhoIJ (TH2 *rhoij, const Int_t *binMap=nullptr) const;  get correlation coefficiencts, possibly cumulated over several bins ;  ; Double_t GetRhoMax (void) const;  get maximum global correlation determined in recent unfolding ;  ; TVectorD GetSqrtEvEmatrix (void) const;  ; double GetSURE (void) const;  return Stein's unbiased risk estimator See e.g. ;  ; Double_t GetTau (void) const;  return regularisation parameter ;  ; Int_t RegularizeBins (int start, int step, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:20811,risk,risk,20811,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,2,['risk'],['risk']
Safety,"n detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming over the response matrix ;  ; Int_t GetNpar (void) const;  get number of truth parameters determined in recent unfolding ;  ; Int_t GetNr (void) const;  get number of regularisation conditions ;  ; void GetOutput (TH1 *output, const Int_t *binMap=nullptr) const;  get output distribution, possibly cumulated over several bins ;  ; void GetProbabilityMatrix (TH2 *A, EHistMap histmap) const;  get matrix of probabilities ;  ; Double_t GetRhoAvg (void) const;  get average global correlation determined in recent unfolding ;  ; Double_t GetRhoI (TH1 *rhoi, const Int_t *binMap=nullptr, TH2 *invEmat=nullptr) const;  get global correlation coefficiencts, possibly cumulated over several bins ;  ; void GetRhoIJ (TH2 *rhoij, const Int_t *binMap=nullptr) const;  get correlation coefficiencts, possibly cumulated over several bins ;  ; Double_t GetRhoMax (void) const;  get maximum global correlation determined in recent unfolding ;  ; TVectorD GetSqrtEvEmatrix (void) const;  ; double GetSURE (void) const;  return Stein's unbiased risk estimator See e.g. ;  ; Double_t GetTau (void) const;  return regularisation parameter ;  ; TClass * IsA () const override;  ; Int_t Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:6897,risk,risk,6897,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['risk'],['risk']
Safety,"n entry- or event-list to be used as event selection. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Definition at line 919 of file TDSet.cxx. ◆ Remove(). Int_t TDSet::Remove ; (; TDSetElement * ; elem, . Bool_t ; deleteElem = kTRUE . ). Remove TDSetElement 'elem' from the list. ; Return 0 on success, -1 if the element is not in the list ; Definition at line 1576 of file TDSet.cxx. ◆ Reset(). void TDSet::Reset ; (; ). virtual . Reset or initialize access to the elements. ; Reimplemented in TDSetProxy.; Definition at line 1369 of file TDSet.cxx. ◆ SetDirectory(). void TDSet::SetDirectory ; (; const char * ; dir). Set/change directory. ; Definition at line 1041 of file TDSet.cxx. ◆ SetEntryList(). void TDSet::SetEntryList ; (; TObject * ; aList). virtual . Set entry (or event) list for this data set. ; Definition at line 1893 of file TDSet.cxx. ◆ SetLookedUp(). void TDSet::SetLookedUp ; (; ). Flag all the elements as looked-up, so to avoid opening the files if the functionality is not supported. ; Definition at line 1657 of file TDSet.cxx. ◆ SetObjName(). void TDSet::SetObjName ; (; const char * ; objname). Set/change object name. ; Definition at line 1026 of file TDSet.cxx. ◆ SetSrvMaps(). void TDSet::SetSrvMaps ; (; TList * ; srvmaps = 0). Set (or unset) the list for mapping servers coordinate for files. ; Reinitialize the related iterator if needed. Used by TProof. ; Definition at line 1172 of file TDSet.cxx. ◆ SetWriteV3(). void TDSet::SetWriteV3 ; (; Bool_t ; on = kTRUE). Set/Reset the 'OldStreamer' bit in this instance and its elements. ; Needed for backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:28242,avoid,avoid,28242,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['avoid'],['avoid']
Safety,"n false. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 5078 of file TTreeFormula.cxx. ◆ SwitchToFormLeafInfo(). bool TTreeFormula::SwitchToFormLeafInfo ; (; Int_t ; code). protectedvirtual . Convert the underlying lookup method from the direct technique (dereferencing the address held by the branch) to the method using TFormLeafInfo. ; This is in particular useful in the case where we need to append an additional TFormLeafInfo (for example to call a method). Return false if the switch was unsuccessful (basically in the case of an old style split tree). ; Definition at line 5714 of file TTreeFormula.cxx. ◆ UpdateFormulaLeaves(). void TTreeFormula::UpdateFormulaLeaves ; (; ). virtual . This function is called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreePlayer.; A safer alternative would be to recompile the whole thing .... However currently compile HAS TO be called from the constructor! ; Definition at line 5107 of file TTreeFormula.cxx. Friends And Related Symbol Documentation. ◆ TTreeFormulaManager. friend class TTreeFormulaManager. friend . Definition at line 60 of file TTreeFormula.h. Member Data Documentation. ◆ fAliases. TObjArray TTreeFormula::fAliases. protected . ! List of TTreeFormula for each alias used. ; Definition at line 107 of file TTreeFormula.h. ◆ fAliasesUsed. std::vector<std::string> TTreeFormula::fAliasesUsed. protected . ! List of aliases used during the parsing of the expression. ; Definition at line 128 of file TTreeFormula.h. ◆ fAxis. TAxis* TTreeFormula::fAxis. protected . ! pointer to histogram axis if this is a string ; Definition at line 122 of file TTreeFormula.h. ◆ fBranches. TObjArray TTreeFormula::fBranches. protected . ! List of branches to read. Similar to fLeaves but duplicates are zeroed out. ; Definition at line 109 of file TTreeForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:50705,safe,safer,50705,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['safe'],['safer']
Safety,"n geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. ◆ TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeoParallelWorld.cxx. ◆ VoxelSafety(). double TGeoParallelWorld::VoxelSafety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26549,safe,safety,26549,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"n in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create ""symbolic links"" to any complex path to make it more representable for the object it designates:; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoPNEntry::SetPhysicalNodevoid SetPhysicalNode(TGeoPhysicalNode *node)Setter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:115437,detect,detector,115437,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:91213,recover,recoverable,91213,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['recover'],['recoverable']
Safety,"n matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag . Definition at line 1353 of file TGeoManager.cxx. ◆ operator=(). TGeoManager & TGeoManager::operator= ; (; const TGeoManager & ; ). protecteddelete . ◆ OptimizeVoxels(). void TGeoManager::OptimizeVoxels ; (; const char * ; filename = ""tgeovox.C""). Optimize voxelization type for all volumes. Save best choice in a macro. ; Definition at line 2484 of file TGeoManager.cxx. ◆ Parse(). Int_t TGeoManager::Parse ; (; const char * ; expr, . TString & ; expr1, . TString & ; expr2, . TString & ; expr3 . ). static . Parse a string boolean expression and do a syntax check. ; Find top level boolean operator and returns its type. Fill the two substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression. Parentheses should be used to avoid ambiguities. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C) eliminate not needed parentheses . Definition at line 2540 of file TGeoManager.cxx. ◆ PopDummy(). void TGeoManager::PopDummy ; (; Int_t ; ipop = 9999). inline . Definition at line 597 of file TGeoManager.h. ◆ PopPath() [1/2]. Bool_t TGeoManager::PopPath ; (; ). inline . Definition at line 592 of file TGeoManager.h. ◆ PopPath() [2/2]. Bool_t TGeoManager::PopPath ; (; Int_t ; index). inline . Definition at line 593 of file TGeoManager.h. ◆ PopPoint() [1/2]. Bool_t TGeoManager::PopPoint ; (; ). inline . Definition at line 595 of file TGeoManager.h. ◆ PopPoint() [2/2]. Bool_t TGeoManager::PopPoint ; (; Int_t ; index). inline . Definition at line 596 of file TGeoManager.h. ◆ PrintOverlaps(). void TGeoManager::PrintOverlaps ; (; ); const. Prints the current list of overlaps. ; Definition at line 3881 of file TGeoManager.cxx. ◆ PushPath(). Int_t TGeoManager::PushPath ; (; Int_t ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:127243,avoid,avoid,127243,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['avoid'],['avoid']
Safety,"n of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoXtru.html:17210,Safe,SafetyToSector,17210,root/html530/TGeoXtru.html,https://root.cern,https://root.cern/root/html530/TGeoXtru.html,4,"['Safe', 'safe']","['SafetyToSector', 'safety']"
Safety,"n of list of TExecs. ; Definition at line 2409 of file TCanvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2440 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2418 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2429 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2451 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2476 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2532 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1183 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:93350,Avoid,Avoids,93350,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['Avoid'],['Avoids']
Safety,"n of list of TExecs. ; Definition at line 2422 of file TCanvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2453 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2431 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2442 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2464 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2489 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2545 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1185 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:93795,Avoid,Avoids,93795,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['Avoid'],['Avoids']
Safety,"n or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  ; int WaitForTimed (WebWindowWaitFunc_t check, double duration);  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  . Static Public Member Functions; static std::shared_ptr< RWebWindow > Create ();  Create new RWebWindow Using default RWebWindowsManager. ;  ; static bool EmbedFileDialog (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embedded() providing received string as second argument. ;  ; static bool IsFileDialogMessage (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ;  ; static unsigned ShowWindow (std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""");  Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ;  . Private Types; using ConnectionsList_t = std::vector< std::shared_ptr< WebConn > >;  ; enum  EQueueEntryKind { kind_None; , kind_Connect; , kind_Data; , kind_Disconnect; };  ; using timestamp_t = std::chrono::time_point< std::chrono::system_clock >;  . Private Member Functions; bool _CanTrustIn (std::shared_ptr< WebConn > &conn, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:11888,detect,detect,11888,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['detect'],['detect']
Safety,"n parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:33292,safe,safe,33292,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['safe'],['safe']
Safety,"n source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:188529,avoid,avoid,188529,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n style. ;  . Static Public Attributes; static constexpr auto kBigNumber = TTree::kMaxEntries;  ;  Static Public Attributes inherited from TTree; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Member Functions; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:43667,detect,detection,43667,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['detect'],['detection']
Safety,"n the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:7785,abort,abort,7785,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,9,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"n will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:38242,avoid,avoid,38242,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"n will naturally belong to all overlapping partners. The answer provided by the modeller to “Where am I?” is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:947046,avoid,avoid,947046,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"n'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42556,timeout,timeout,42556,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['timeout'],['timeout']
Safety,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:9015,safe,safety,9015,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,3,['safe'],['safety']
Safety,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:9113,safe,safety,9113,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,3,['safe'],['safety']
Safety,"n(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma clang diagnostic push; 3544#pragma clang diagnostic ignored ""-Wunreachable-code""; 3545 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:104346,safe,safe,104346,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"n(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma clang diagnostic push; 3545#pragma clang diagnostic ignored ""-Wunreachable-code""; 3546 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:104378,safe,safe,104378,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"n) ; Definition at line 987 of file MethodCuts.cxx. ◆ MatchCutsToPars() [2/2]. void TMVA::MethodCuts::MatchCutsToPars ; (; std::vector< Double_t > & ; pars, . Double_t * ; cutMin, . Double_t * ; cutMax . ). private . translates cuts into parameters ; Definition at line 1009 of file MethodCuts.cxx. ◆ MatchParsToCuts() [1/2]. void TMVA::MethodCuts::MatchParsToCuts ; (; const std::vector< Double_t > & ; pars, . Double_t * ; cutMin, . Double_t * ; cutMax . ). private . translates parameters into cuts ; Definition at line 974 of file MethodCuts.cxx. ◆ MatchParsToCuts() [2/2]. void TMVA::MethodCuts::MatchParsToCuts ; (; Double_t * ; , . Double_t * ; , . Double_t * ;  . ). private . ◆ PrintCuts(). void TMVA::MethodCuts::PrintCuts ; (; Double_t ; effS); const. print cuts ; Definition at line 465 of file MethodCuts.cxx. ◆ ProcessOptions(). void TMVA::MethodCuts::ProcessOptions ; (; ). virtual . process user options. ; sanity check, do not allow the input variables to be normalised, because this only creates problems when interpreting the cuts ; Implements TMVA::MethodBase.; Definition at line 363 of file MethodCuts.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/3]. void TMVA::MethodCuts::ReadWeightsFromStream ; (; std::istream & ; i). virtual . read the cuts from stream ; Implements TMVA::MethodBase.; Definition at line 1217 of file MethodCuts.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodCuts::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read coefficients from xml weight file ; Implements TMVA::MethodBase.; Definition at line 1327 of file MethodCuts.cxx. ◆ SetTestSignalEfficiency(). void TMVA::MethodCuts::SetTestSignalEfficiency ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:45958,sanity check,sanity check,45958,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['sanity check'],['sanity check']
Safety,"n), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:2616,recover,recovered,2616,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['recover'],['recovered']
Safety,"n). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18558,safe,safe,18558,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,6,['safe'],['safe']
Safety,"n, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11511 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11512 ; 11513 /* Make up and send the status line */; 11514 status_text = ""OK"";; 11515 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11516 != NULL) {; 11517 conn->status_code = atoi(status);; 11518 status_text = status;; 11519 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11520 status_text++;; 11521 }; 11522 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11523 != NULL) {; 11524 conn->status_code = 307;; 11525 } else {; 11526 conn->status_code = 200;; 11527 }; 11528 connection_state =; 11529 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11530 if (!header_has_option(connection_state, ""keep-alive"")) {; 11531 conn->must_close = 1;; 11532 }; 11533 ; 11534 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11535 ; 11536 (v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:333011,abort,abort,333011,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"n, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != NULL) {; 11518 conn->status_code = atoi(status);; 11519 status_text = status;; 11520 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11521 status_text++;; 11522 }; 11523 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11524 != NULL) {; 11525 conn->status_code = 307;; 11526 } else {; 11527 conn->status_code = 200;; 11528 }; 11529 connection_state =; 11530 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11531 if (!header_has_option(connection_state, ""keep-alive"")) {; 11532 conn->must_close = 1;; 11533 }; 11534 ; 11535 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11536 ; 11537 (v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:333044,abort,abort,333044,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"n, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ;  ; void BuildBVH ();  Build the BVH acceleration structure. ;  ; bool CheckBVH (void *, size_t) const;  Check/validate the BVH acceleration structure. ;  ; void CheckOverlaps (Double_t ovlp=0.001);  Check overlaps within a tolerance value. ;  ; Bool_t CloseGeometry ();  The main geometry must be closed. ;  ; void Draw (Option_t *option) override;  Draw the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundary (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  ; TGeoPhysicalNode * FindNode (Double_t point[3]);  ; AccelerationMode const & GetAccelerationMode () const;  ; TGeoManager * GetGeometry () const;  ; TGeoVolume * GetVolume () const;  ; TClass * IsA () const override;  ; Bool_t IsClosed () const;  ; Bool_t IsUsingOverlaps () const;  ; void PrintBVH () const;  Prints the BVH. ;  ; Int_t PrintDetectedOverlaps () const;  Print the overlaps which were detected during real tracking. ;  ; void RefreshPhysicalNodes ();  Refresh the node pointers and re-voxelize. ;  ; void ResetOverlaps () const;  Reset overlapflag for all volumes in geometry. ;  ; Double_t Safety (Double_t point[3], Double_t safmax=1.E30);  ; void SetAccelerationMode (AccelerationMode const &mode);  ; void SetUseOverlaps (Bool_t flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:3329,detect,detected,3329,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['detect'],['detected']
Safety,"n. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXProofServ.html:19563,timeout,timeout,19563,root/html604/TXProofServ.html,https://root.cern,https://root.cern/root/html604/TXProofServ.html,2,['timeout'],['timeout']
Safety,"n. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:19562,timeout,timeout,19562,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,2,['timeout'],['timeout']
Safety,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:126194,avoid,avoid,126194,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:128945,avoid,avoid,128945,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n.h. ◆ IsIllegalCheck(). Bool_t TGeoPolygon::IsIllegalCheck ; (; ); const. Check for illegal crossings between non-consecutive segments. ; Definition at line 295 of file TGeoPolygon.cxx. ◆ IsRightSided(). Bool_t TGeoPolygon::IsRightSided ; (; const Double_t * ; point, . Int_t ; ind1, . Int_t ; ind2 . ); const. private . Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. ; Definition at line 263 of file TGeoPolygon.cxx. ◆ IsSegConvex(). Bool_t TGeoPolygon::IsSegConvex ; (; Int_t ; i1, . Int_t ; i2 = -1 . ); const. private . Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. ; Definition at line 276 of file TGeoPolygon.cxx. ◆ operator=(). TGeoPolygon & TGeoPolygon::operator= ; (; const TGeoPolygon & ; ). privatedelete . ◆ OutscribedConvex(). void TGeoPolygon::OutscribedConvex ; (; ). private . Compute indices for the outscribed convex polygon. ; Definition at line 327 of file TGeoPolygon.cxx. ◆ Safety(). Double_t TGeoPolygon::Safety ; (; const Double_t * ; point, . Int_t & ; isegment . ); const. Compute minimum distance from POINT to any segment. Returns segment index. ; Definition at line 381 of file TGeoPolygon.cxx. ◆ SetConvex(). void TGeoPolygon::SetConvex ; (; Bool_t ; flag = kTRUE). inline . Definition at line 63 of file TGeoPolygon.h. ◆ SetNextIndex(). void TGeoPolygon::SetNextIndex ; (; Int_t ; index = -1). Sets the next polygone index. ; If index<0 sets all indices consecutive in increasing order. ; Definition at line 440 of file TGeoPolygon.cxx. ◆ SetXY(). void TGeoPolygon::SetXY ; (; Double_t * ; x, . Double_t * ; y . ). Set X/Y array pointer for the polygon and daughters. ; Definition at line 469 of file TGeoPolygon.cxx. ◆ Streamer(). void TGeoPolygon::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoPolygon::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 67 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPolygon.html:18505,Safe,Safety,18505,doc/master/classTGeoPolygon.html,https://root.cern,https://root.cern/doc/master/classTGeoPolygon.html,1,['Safe'],['Safety']
Safety,"n::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:13748,avoid,avoid,13748,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,3,['avoid'],['avoid']
Safety,"n::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:12729,safe,safeDeleteList,12729,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,2,['safe'],['safeDeleteList']
Safety,"n="""") const override;  Print the path (A/B/C/...) to this node on stdout. ;  ; virtual TGeoNode * MakeCopyNode () const;  ; virtual void MasterToLocal (const Double_t *master, Double_t *local) const;  Convert the point coordinates from mother reference to local reference system. ;  ; virtual void MasterToLocalVect (const Double_t *master, Double_t *local) const;  Convert a vector from mother reference to local reference system. ;  ; Bool_t MayOverlap (Int_t iother) const;  Check the overlab between the bounding box of the node overlaps with the one the brother with index IOTHER. ;  ; void Paint (Option_t *option="""") override;  Paint this node and its content according to visualization settings. ;  ; void PrintCandidates () const;  print daughters candidates for containing current point ;  ; void PrintOverlaps () const;  print possible overlapping nodes ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const;  computes the closest distance from given point to this shape ;  ; void SaveAttributes (std::ostream &out);  save attributes for this node ;  ; void SetAllInvisible ();  ; void SetCloned (Bool_t flag=kTRUE);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  ; void SetFWExtension (TGeoExtension *ext);  Connect framework defined extension to the node. ;  ; void SetInvisible ();  ; void SetMotherVolume (TGeoVolume *mother);  ; void SetNumber (Int_t number);  ; void SetOverlapping (Bool_t flag=kTRUE);  ; void SetOverlaps (Int_t *ovlp, Int_t novlp);  set the list of overlaps for this node (ovlp must be created with operator new) ;  ; void SetUserExtension (TGeoExtension *ext);  Connect user-defined extension to the node. ;  ; void SetVirtual ();  ; void SetVisibility (Bool_t vis=kTRUE) override;  Set visibility of the node (obsolete). ;  ; void SetVolume (TGeoVolume *volume);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void VisibleDaughters (Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:9628,Safe,Safety,9628,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,1,['Safe'],['Safety']
Safety,"nCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBuffer.html:16730,avoid,avoiding,16730,root/html530/TBuffer.html,https://root.cern,https://root.cern/root/html530/TBuffer.html,3,['avoid'],['avoiding']
Safety,"nName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so with different 'slot' numbers. RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; ROOT::RDF::SampleCallback_t GetSampleCallback(): if present, it must return a callable with the appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing of every sample, as in DefinePerSample().; Helper MakeNew(void *newResult): if implemented, it enables varying the action's result with VariationsFor(). It takes a type-erased new result that can be safely cast to a std::shared_ptr<Result_t> * (a pointer to shared pointer) and should be used as the action's output result. In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Examples; See this tutorial for an example implementation of an action helper.; It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx. ; Definition at line 2984 of file RInterface.hxx. ◆ Cache() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Template Parameters. ColumnTypesvariadic list of branch/column types. .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:41018,safe,safely,41018,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safely']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__VavilovAccurateCdf.html:2838,avoid,avoid,2838,root/html528/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html530/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html532/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:9362,safe,safe,9362,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['safe'],['safe']
Safety,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:14016,safe,safe,14016,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['safe'],['safe']
Safety,"nSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28554,recover,recovery,28554,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['recover'],['recovery']
Safety,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:17465,safe,safe,17465,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['safe'],['safe']
Safety,"n] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.Set(nbinsy,ylow,yup);; 106 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 107}; 108 ; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// Constructor for variable bin size (along X axis) 2-D histograms using an input array; 112/// of type double.; 113///; 114/// \param[in] name name of histogram (avoid blanks); 115/// \param[in] title histogram title.; 116/// If title is of the form `stringt;stringx;stringy;stringz`; 117/// the histogram title is set to `stringt`,; 118/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 119/// \param[in] nbinsx number of bins; 120/// \param[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:5101,avoid,avoid,5101,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nager::GetTmaxDouble_t GetTmax() constDefinition TGeoManager.h:214; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::GetListOfOpticalSurfacesTObjArray * GetListOfOpticalSurfaces() constDefinition TGeoManager.h:480; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different tracking media.Definition TGeoManager.cxx:3708; TGeoManager::EnableInactiveVolumesvoid EnableInactiveVolumes()Definition TGeoManager.h:363; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:84626,Safe,Safety,84626,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nal programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:47801,safe,safe,47801,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:54672,avoid,avoid,54672,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compila",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:56312,avoid,avoid,56312,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:47104,safe,safe,47104,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['safe'],['safe']
Safety,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:3402,safe,safe,3402,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,3,['safe'],['safe']
Safety,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:3381,safe,safe,3381,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,3,['safe'],['safe']
Safety,"name, GetName());; 3783 }; 3784 return (UShort_t)npids;; 3785}; 3786 ; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Write the list of TStreamerInfo as a single object in this file; 3790/// The class Streamer description for all classes written to this file; 3791/// is saved. See class TStreamerInfo.; 3792 ; 3793void TFile::WriteStreamerInfo(); 3794{; 3795 //if (!gFile) return;; 3796 if (!fWritable) return;; 3797 if (!fClassIndex) return;; 3798 if (fIsPcmFile) return; // No schema evolution for ROOT PCM files.; 3799 if (fClassIndex->fArray[0] == 0; 3800 && fSeekInfo != 0) {; 3801 // No need to update the index if no new classes added to the file; 3802 // but write once an empty StreamerInfo list to mark that there is no need; 3803 // for StreamerInfos in this file.; 3804 return;; 3805 }; 3806 if (gDebug > 0) Info(""WriteStreamerInfo"", ""called for file %s"",GetName());; 3807 ; 3808 SafeDelete(fInfoCache);; 3809 ; 3810 // build a temporary list with the marked files; 3811 TIter next(gROOT->GetListOfStreamerInfo());; 3812 TStreamerInfo *info;; 3813 TList list;; 3814 TList listOfRules;; 3815 listOfRules.SetOwner(kTRUE);; 3816 listOfRules.SetName(""listOfRules"");; 3817 std::set<TClass*> classSet;; 3818 ; 3819 while ((info = (TStreamerInfo*)next())) {; 3820 Int_t uid = info->GetNumber();; 3821 if (fClassIndex->fArray[uid]) {; 3822 list.Add(info);; 3823 if (gDebug > 0) printf("" -class: %s info number %d saved\n"",info->GetName(),uid);; 3824 ; 3825 // Add the IO customization rules to the list to be saved for the underlying; 3826 // class but make sure to add them only once.; 3827 TClass *clinfo = info->GetClass();; 3828 if (clinfo && clinfo->GetSchemaRules()) {; 3829 if ( classSet.find( clinfo ) == classSet.end() ) {; 3830 if (gDebug > 0) printf("" -class: %s stored the I/O customization rules\n"",info->GetName());; 3831 ; 3832 TObjArrayIter it( clinfo->GetSchemaRules()->GetRules() );; 3833 ROOT::TSchemaRule *rule;; 3834 whi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:138469,Safe,SafeDelete,138469,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"name, const char *mode=""a"", RedirectHandle_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; void ResetTimer (TTimer *ti) override;  Reset a-sync timer. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDisplay () override;  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; void SetDynamicPath (const char *lib) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int option, int val) override;  Set socket option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:10141,timeout,timeout,10141,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['timeout'],['timeout']
Safety,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqCollection ();  ; void Add (TObject *obj) override;  ; TClass * IsA () const override;  ; virtual Bool_t IsSorted () const;  ; Int_t LastIndex () const;  ; Long64_t Merge (TCollection *list);  Merge this collection with all collections coming in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:6419,safe,safe,6419,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['safe'],['safe']
Safety,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; virtual TObjLink * FirstLink () const;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Bool_t IsAscending ();  ; TObject * La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:4494,safe,safe,4494,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['safe'],['safe']
Safety,"nce which can be queried programmatically to get information about the effects of the individual cuts. . Stats() Return a TStatistic object filled with the input columns. . StdDev() Return the unbiased standard deviation of the processed column values. . Sum() Return the sum of the values in the column. If the type of the column is inferred, the return type is double, the type of the column otherwise. . Take() Extract a column from the dataset as a collection of values, e.g. a std::vector<float> for a column of type float. . Instant action Description . Foreach() Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. . ForeachSlot() Same as Foreach(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case slot will always be 0. . Snapshot() Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . Describe() Get useful information describing the dataframe, e.g. columns and their types. . GetColumnNames() Get the names of all the available columns of the dataset. . GetColumnType() Return the type of a given column as a string. . GetColumnTypeNamesList() Return the list of type names of columns in the dataset. . GetDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:8351,safe,safe,8351,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"nce; Inherited Members; Includes; Libraries. Function documentation; TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:14510,safe,safe,14510,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,3,['safe'],['safe']
Safety,"nch *mother = br->GetMother();; 6124 if (strncmp(brname,branchname,nbch)) {; 6125 if (mother != br) {; 6126 const char *mothername = mother->GetName();; 6127 UInt_t motherlen = strlen(mothername);; 6128 if (!strcmp(mothername, branchname)) {; 6129 return leaf;; 6130 } else if (nbch > motherlen && strncmp(mothername,branchname,motherlen)==0 && (mothername[motherlen-1]=='.' || branchname[motherlen]=='.')) {; 6131 // The left part of the requested name match the name of the mother, let's see if the right part match the name of the branch.; 6132 if (strncmp(brname,branchname+motherlen+1,nbch-motherlen-1)) {; 6133 // No it does not; 6134 continue;; 6135 } // else we have match so we can proceed.; 6136 } else {; 6137 // no match; 6138 continue;; 6139 }; 6140 } else {; 6141 continue;; 6142 }; 6143 }; 6144 // The start of the branch name is identical to the content; 6145 // of 'aname' before the first '/'.; 6146 // Let's make sure that it is not longer (we are trying; 6147 // to avoid having jet2/value match the branch jet23; 6148 if ((strlen(brname) > nbch) && (brname[nbch] != '.') && (brname[nbch] != '[')) {; 6149 continue;; 6150 }; 6151 }; 6152 return leaf;; 6153 }; 6154 if (!fFriends) return nullptr;; 6155 TFriendLock lock(this,kGetLeaf);; 6156 TIter next(fFriends);; 6157 TFriendElement *fe;; 6158 while ((fe = (TFriendElement*)next())) {; 6159 TTree *t = fe->GetTree();; 6160 if (t) {; 6161 leaf = t->GetLeaf(branchname, leafname);; 6162 if (leaf) return leaf;; 6163 }; 6164 }; 6165 ; 6166 //second pass in the list of friends when the leaf name; 6167 //is prefixed by the tree name; 6168 TString strippedArg;; 6169 next.Reset();; 6170 while ((fe = (TFriendElement*)next())) {; 6171 TTree *t = fe->GetTree();; 6172 if (!t) continue;; 6173 const char *subname = strstr(leafname,fe->GetName());; 6174 if (subname != leafname) continue;; 6175 Int_t l = strlen(fe->GetName());; 6176 subname += l;; 6177 if (*subname != '.') continue;; 6178 subname++;; 6179 strippedArg += subname;; 6180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:241733,avoid,avoid,241733,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch::GetReadBasketInt_t GetReadBasket() constDefinition TBranch.h:236; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:31981,avoid,avoid,31981,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,1,['avoid'],['avoid']
Safety,"ncludes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:12843,safe,safe,12843,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,6,['safe'],['safe']
Safety,"ncludes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:9987,avoid,avoid,9987,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,2,['avoid'],['avoid']
Safety,"nction checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTIdleTimer.html:2189,Timeout,Timeout,2189,doc/master/classTIdleTimer.html,https://root.cern,https://root.cern/doc/master/classTIdleTimer.html,19,['Timeout'],['Timeout']
Safety,"nction checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSingleShotCleaner.html:2407,Timeout,Timeout,2407,doc/master/classTSingleShotCleaner.html,https://root.cern,https://root.cern/doc/master/classTSingleShotCleaner.html,1,['Timeout'],['Timeout']
Safety,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:12463,safe,safe,12463,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,1,['safe'],['safe']
Safety,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScaledShape.html:12238,safe,safe,12238,root/html528/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"nction pbject implementing the operator()(const double * x, const double * p) in an interface-like IParamFunction with a vector storing and caching internally the parameter values ;  CWrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(const double * ) in an interface-like IParamFunction, by fixing some of the variables and define them as parameters ;  CWrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime ;  ►NMeta;  ►NSelection;  CClassAttributesUsed to specify attributes of classes in the ""DictSelection"" syntax ;  CKeepFirstTemplateArgumentsUsed to specify the number of arguments to be kept ;  CMemberAttributesUsed to specify attributes of data members in the ""DictSelection"" syntax ;  CSelectNoInstanceUsed to avoid to select all instances of a template ;  ►NMinuit2;  CABObj;  CABObj< sym, LASymMatrix, double >;  CABObj< vec, LAVector, double >;  CABProd;  CABSum;  CAlgebraicProdType;  CAlgebraicProdType< gen, gen >;  CAlgebraicProdType< gen, sym >;  CAlgebraicProdType< gen, vec >;  CAlgebraicProdType< sym, gen >;  CAlgebraicProdType< sym, sym >;  CAlgebraicProdType< sym, vec >;  CAlgebraicProdType< T, T >;  CAlgebraicProdType< vec, gen >;  CAlgebraicProdType< vec, sym >;  CAlgebraicSumType;  CAlgebraicSumType< gen, vec >;  CAlgebraicSumType< sym, vec >;  CAlgebraicSumType< T, T >;  CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:53674,avoid,avoid,53674,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,6,['avoid'],['avoid']
Safety,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73229,recover,recovers,73229,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['recover'],['recovers']
Safety,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the underdeterminedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:77218,recover,recovers,77218,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['recover'],['recovers']
Safety,"ncy; 1548/// indicated in theString; 1549///; 1550/// ""theString"" must have two entries:; 1551/// - `[0]`: ""Efficiency""; 1552/// - `[1]`: the value of background efficiency at which the signal efficiency; 1553/// is to be returned; 1554 ; 1555Double_t TMVA::MethodCuts::GetEfficiency( const TString& theString, Types::ETreeType type, Double_t& effSerr ); 1556{; 1557 Data()->SetCurrentType(type);; 1558 ; 1559 Results* results = Data()->GetResults( GetMethodName(), Types::kTesting, GetAnalysisType() );; 1560 ; 1561 // parse input string for required background efficiency; 1562 TList* list = gTools().ParseFormatLine( theString, "":"" );; 1563 ; 1564 if (list->GetSize() > 2) {; 1565 delete list;; 1566 Log() << kFATAL << ""<GetEfficiency> wrong number of arguments""; 1567 << "" in string: "" << theString; 1568 << "" | required format, e.g., Efficiency:0.05, or empty string"" << Endl;; 1569 return -1;; 1570 }; 1571 ; 1572 // sanity check; 1573 Bool_t computeArea = (list->GetSize() < 2); // the area is computed; 1574 ; 1575 // that will be the value of the efficiency retured (does not affect; 1576 // the efficiency-vs-bkg plot which is done anyway.; 1577 Float_t effBref = (computeArea?1.:atof( ((TObjString*)list->At(1))->GetString() ));; 1578 ; 1579 delete list;; 1580 ; 1581 ; 1582 // first round ? --> create histograms; 1583 if (results->GetHist(""MVA_EFF_BvsS"")==0) {; 1584 ; 1585 if (fBinaryTreeS!=0) { delete fBinaryTreeS; fBinaryTreeS = 0; }; 1586 if (fBinaryTreeB!=0) { delete fBinaryTreeB; fBinaryTreeB = 0; }; 1587 ; 1588 // the variables may be transformed by a transformation method: to coherently; 1589 // treat signal and background one must decide which transformation type shall; 1590 // be used: our default is signal-type; 1591 fBinaryTreeS = new BinarySearchTree();; 1592 fBinaryTreeS->Fill( GetEventCollection(Types::kTesting), fSignalClass );; 1593 fBinaryTreeB = new BinarySearchTree();; 1594 fBinaryTreeB->Fill( GetEventCollection(Types::kTesting), fBackgroundClass );; 1595 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:60877,sanity check,sanity check,60877,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:13238,safe,safeDeleteList,13238,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,1,['safe'],['safeDeleteList']
Safety,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:13272,safe,safeDeleteList,13272,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['safe'],['safeDeleteList']
Safety,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1544,redund,redundant,1544,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['redund'],['redundant']
Safety,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:15854,safe,safe,15854,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,6,['safe'],['safe']
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:19583,safe,safe,19583,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCtub.html:21333,safe,safe,21333,root/html604/TGeoCtub.html,https://root.cern,https://root.cern/root/html604/TGeoCtub.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCtub.html:21333,safe,safe,21333,root/html602/TGeoCtub.html,https://root.cern,https://root.cern/root/html602/TGeoCtub.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWout",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:5859,safe,safe,5859,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['safe'],['safe']
Safety,"nd(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72212,Recover,Recover,72212,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Recover'],['Recover']
Safety,"ndards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.; 134template <typename T, bool isDynamic, typename Range_t>; 135class RRangeCast {; 136 ; 137public:; 138 RRangeCast(Range_t &&inputRange) : fInputRange{inputRange}; 139 {; 140 static_assert(ROOT::Internal::hasBeginEnd<Range_t>(0),; 141 ""Type with no `begin` or `end` method passed to `RRangeCast`"");; 142 }; 143 ; 144 using const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>;; 145 const_iterator begin() const { return std::cbegin(fInputRange); }; 146 const_iterator end() const { return std::cend(fInputRange); }; 147 ; 148 using iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>;; 149 iterator begin() { return std::begin(fInputRange); }; 150 iterator end() { return std::end(fInputRange); }; 151 ; 152private:; 153 Range_t fInputRange;; 154};; 155 ; 156/// Takes any collection that can be used in range-based loops and applies; 157/// static_cast<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:4121,avoid,avoid,4121,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,2,['avoid'],['avoid']
Safety,"ndary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:86273,Safe,Safe,86273,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"nder, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TQt5Timer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQt5Timer(). TQt5Timer::TQt5Timer ; (; Long_t ; milliSec, . Bool_t ; mode . ). inline . Definition at line 72 of file rootqt5.cpp. Member Function Documentation. ◆ Timeout(). void TQt5Timer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process all qt5 events in main ROOT thread ; Reimplemented from TTimer.; Definition at line 76 of file rootqt5.cpp. gui/qt5webdisplay/rootqt5.cpp. TQt5Timer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt5Timer.html:17381,Timeout,Timeout,17381,doc/master/classTQt5Timer.html,https://root.cern,https://root.cern/doc/master/classTQt5Timer.html,3,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"nder, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TQt6Timer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQt6Timer(). TQt6Timer::TQt6Timer ; (; Long_t ; milliSec, . Bool_t ; mode . ). inline . Definition at line 51 of file rootqt6.cpp. Member Function Documentation. ◆ Timeout(). void TQt6Timer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process all qt6 events in main ROOT thread ; Reimplemented from TTimer.; Definition at line 55 of file rootqt6.cpp. gui/qt6webdisplay/rootqt6.cpp. TQt6Timer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt6Timer.html:17381,Timeout,Timeout,17381,doc/master/classTQt6Timer.html,https://root.cern,https://root.cern/doc/master/classTQt6Timer.html,3,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"ndicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:3404,safe,safe,3404,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['safe'],['safe']
Safety,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 175 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 184 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:19994,avoid,avoid,19994,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['avoid'],['avoid']
Safety,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 164 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1035 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 181 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 190 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:19995,avoid,avoid,19995,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['avoid'],['avoid']
Safety,"ndomRays (Int_t nrays=1000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays and plot intersections with surfaces for current top node. ;  ; void RefreshPhysicalNodes (Bool_t lock=kTRUE);  Refresh physical nodes to reflect the actual geometry paths after alignment was applied. ;  ; void RegisterMatrix (const TGeoMatrix *matrix);  Register a matrix to the list of matrices. ;  ; void RemoveMaterial (Int_t index);  Remove material at given index. ;  ; void RemoveNavigator (const TGeoNavigator *nav);  Clear a single navigator. ;  ; Int_t ReplaceVolume (TGeoVolume *vorig, TGeoVolume *vnew);  Replaces all occurrences of VORIG with VNEW in the geometry tree. ;  ; void ResetState ();  Reset current state flags. ;  ; void ResetUserData ();  Sets all pointers TGeoVolume::fField to NULL. ;  ; void RestoreMasterVolume ();  Restore the master volume of the geometry. ;  ; Double_t Safety (Bool_t inside=kFALSE);  Compute safe distance from the current point. ;  ; TGeoNode * SamplePoints (Int_t npoints, Double_t &dist, Double_t epsil=1E-5, const char *g3path="""");  shoot npoints randomly in a box of 1E-5 around current point. ;  ; void SaveAttributes (const char *filename=""tgeoatt.C"");  Save current attributes in a macro. ;  ; TGeoNode * SearchNode (Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr);  Returns the deepest node containing fPoint, which must be set a priori. ;  ; void SelectTrackingMedia ();  Define different tracking media. ;  ; TGeoPNEntry * SetAlignableEntry (const char *unique_name, const char *path, Int_t uid=-1);  Creates an alignable object with unique name corresponding to a path and adds it to the list of alignables. ;  ; void SetAllIndex ();  Assigns uid's for all materials,media and matrices. ;  ; void SetAnimateTracks (Bool_t flag=kTRUE);  ; void SetBombFactors (Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3);  Set factors that wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:45303,Safe,Safety,45303,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ne can access a file using the specified access mode. ;  ; void FreeDirectory (void *dirp) override;  Free directory via httpd. ;  ; const char * GetDirEntry (void *dirp) override;  Get directory entry via httpd. Returns 0 in case no more entries. ;  ; Int_t GetPathInfo (const char *path, FileStat_t &buf) override;  Get info about a file. ;  ; TClass * IsA () const override;  ; Int_t MakeDirectory (const char *name) override;  Make a directory via httpd. Not supported. ;  ; void * OpenDirectory (const char *name) override;  Open a directory via httpd. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unlink (const char *path) override;  Unlink, i.e. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual void AddTimer (TTimer *t);  Add timer to list of system timers. ;  ; virtual int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1);  Announce TCP/IP service. ;  ; virtual int AnnounceUdpServic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:1555,Abort,Abort,1555,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,2,['Abort'],['Abort']
Safety,"ne class member, from another. ;  ; void SetTypenameTag (const char *tag=""_typename"");  Configures _typename tag in JSON structures By default ""_typename"" field in JSON structures used to store class information One can specify alternative tag like ""$typename"" or ""xy"", but such JSON can not be correctly used in JSROOT If empty string is provided, class information will not be stored. ;  ; void SetTypeversionTag (const char *tag=nullptr);  Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ;  ; void SkipObjectAny () final;  Skip any kind of object from buffer. ;  ; TString StoreObject (const void *obj, const TClass *cl);  Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void StreamObject (TObject *obj) override;  ; void StreamObject (void *obj, const char *className, const TClass *onFileClass=nullptr) override;  stream object to/from buffer ;  ; void StreamObject (void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr) override;  stream object to/from buffer ;  ; void StreamObject (void *obj, const TClass *cl, const TClass *onFileClass=nullptr) final;  stream object to/from buffer ;  ; void WriteArray (const Bool_t *b, Int_t n) final;  Write array of Bool_t to buffer. ;  ; void WriteArray (const Char_t *c, Int_t n) final;  Write array of Char_t to buffer. ;  ; void WriteArray (const Double_t *d, Int_t n) final;  Write array of Double_t to buffer. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:13842,safe,safely,13842,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['safe'],['safely']
Safety,"ne of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do to execute with native compiler: .x tree2a.C+ ; Note that since IO is involved, ACLiC has to be invoked to create the dictionary of class Gctrak. ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; const Int_t MAXMEC = 30;; ; class Gctrak : public TObject {; public:; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7]; //! not persistent; Int_t nmec;; Int_t *lmec; //[nmec]; Int_t *namec; //[nmec]; Int_t nstep; //! not persistent; Int_t pid;; Float_t destep;; Float_t destel; //! not persistent; Float_t safety; //! not persistent; Float_t sleng; //! not persistent; Float_t step; //! not persistent; Float_t snext; //! not persistent; Float_t sfield; //! not persistent; Float_t tofg; //! not persistent; Float_t gekrat; //! not persistent; Float_t upwght; //! not persistent; ; Gctrak() {lmec=nullptr; namec=nullptr;}; ; ClassDefOverride(Gctrak,1); };; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:1193,safe,safety,1193,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['safe'],['safety']
Safety,"ne; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:17539,avoid,avoid,17539,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,1,['avoid'],['avoid']
Safety,"nect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; TString GetJobAd ();  Get job Ad. ;  ; Bool_t StartSlaves (Bool_t) override;  Setup Condor workers using dynamic information. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ;  ; Int_t Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; Int_t Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; TSlave * CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir);  Create a new TSlave of type TSlave::kSlave. ;  ; TSlave * CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1);  Create a new TSlave of type TSlave::kMaster. ;  ; TList * GetEnabledPackages () const;  ; TList * GetListOfActiveSlaves () const;  ; TVirtualProofPlayer * GetPlayer () const;  ; TPluginHandler * GetProgressDialog () const;  ; Int_t GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0);  Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ;  ; void HandleLibIncPath (const char *what, Bool_t add, const char *dirs);  Handle lib, inc search paths modification request. ;  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:35588,timeout,timeout,35588,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['timeout'],['timeout']
Safety,"ned(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:598398,abort,abort,598398,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:598431,abort,abort,598431,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"nel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking volume(s). Return the current volume ID and copy number. Int_t CurrentVolOffID(Int_t off, Int_t& copyNo) const; Return the current volume off upward in the geometrical tree; ID and copy number. const char* CurrentVolName() const; Return the current volume name. const char* CurrentVolOffName(Int_t off) const; Return the current volume off upward in the geometrical tree; name and copy number'; if name=0 no name is returned. const char* CurrentVolPath(); Return the path in geometry tree for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:30734,abort,abort,30734,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,5,['abort'],['abort']
Safety,"nerate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf301_composition.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf301__composition_8py.html:2270,safe,safe,2270,doc/master/rf301__composition_8py.html,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html,1,['safe'],['safe']
Safety,"nes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi == 360))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:15279,Safe,SafetyToSegment,15279,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,6,"['Safe', 'safe']","['SafetyToSegment', 'safety']"
Safety,"nes; 3 - exclude spaces as much as possible; When member_name specified, converts only this data member. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0, Int_t arraylen = -1); Converts selected data member into json. Parameter ptr specifies address in memory, where data member is located; compact parameter defines compactness of produced JSON (from 0 to 3); arraylen (when specified) is array length for this data member, //[fN] case. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass, Int_t arraylen); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void WriteObject(const TObject* obj); Convert object into json structures.; !!! Should be used only by TBufferJSON itself.; Use ConvertToJSON() methods to convert object to json; Redefined here to avoid gcc 3.x warning. TJSONStackObj * PushStack(Int_t inclevel = 0); add new level to the structures stack. TJSONStackObj * PopStack(); remove one level from stack. TJSONStackObj * Stack(Int_t depth = 0); return stack object of specified depth. void AppendOutput(const char* line0, const char* line1 = 0); Info(""AppendOutput"","" '%s' '%s'"", line0, line1?line1 : ""---"");. void JsonStartElement(const TStreamerElement* elem, const TClass* base_class = 0). void JsonDisablePostprocessing(). Int_t JsonSpecialClass(const TClass* cl) const; return non-zero value when class has special handling in JSON; it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6). void JsonWriteObject(const void* obj, const TClass* objClass, Bool_t check_map = kTRUE); Write object to buffer; If object was written before, only pointer will be stored; If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:22150,avoid,avoid,22150,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,1,['avoid'],['avoid']
Safety,"nestatic . ReturnsName of the file containing the class declaration ; Definition at line 58 of file TMLPAnalyzer.h. ◆ DrawDInput(). void TMLPAnalyzer::DrawDInput ; (; Int_t ; i). Draws the distribution (on the test sample) of the impact on the network output of a small variation of the ith input. ; Definition at line 284 of file TMLPAnalyzer.cxx. ◆ DrawDInputs(). void TMLPAnalyzer::DrawDInputs ; (; ). Draws the distribution (on the test sample) of the impact on the network output of a small variation of each input. ; DrawDInputs() draws something that approximates the distribution of the derivative of the NN w.r.t. each input. That quantity is recognized as one of the measures to determine key quantities in the network.; What is done is to vary one input around its nominal value and to see how the NN changes. This is done for each entry in the sample and produces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:14558,risk,risk,14558,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['risk'],['risk']
Safety,"new TPadPainter;; 2611 fUseGL = kFALSE;; 2612 }; 2613 }; 2614}; 2615 ; 2616////////////////////////////////////////////////////////////////////////////////; 2617/// Access and (probably) creation of pad painter.; 2618 ; 2619TVirtualPadPainter *TCanvas::GetCanvasPainter(); 2620{; 2621 if (!fPainter) CreatePainter();; 2622 return fPainter;; 2623}; 2624 ; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627///assert on IsBatch() == false?; 2628 ; 2629void TCanvas::DeleteCanvasPainter(); 2630{; 2631 if (fGLDevice != -1) {; 2632 //fPainter has a font manager.; 2633 //Font manager will delete textures.; 2634 //If context is wrong (we can have several canvases) -; 2635 //wrong texture will be deleted, damaging some of our fonts.; 2636 gGLManager->MakeCurrent(fGLDevice);; 2637 }; 2638 ; 2639 SafeDelete(fPainter);; 2640 ; 2641 if (fGLDevice != -1) {; 2642 gGLManager->DeleteGLContext(fGLDevice);//?; 2643 fGLDevice = -1;; 2644 }; 2645}; 2646 ; 2647 ; 2648////////////////////////////////////////////////////////////////////////////////; 2649/// Save provided pads/canvases into the image file(s); 2650/// Filename can include printf argument for image number - like ""image%03d.png"".; 2651/// In this case images: ""image000.png"", ""image001.png"", ""image002.png"" will be created.; 2652/// If pattern is not provided - it will be automatically inserted before extension except PDF and ROOT files.; 2653/// In last case PDF or ROOT file will contain all pads.; 2654/// Parameter option only used when output into PDF/PS files; 2655/// If TCanvas::SaveAll() called without arguments - all existing canvases will be stored in allcanvases.pdf file.; 2656 ; 2657Bool_t TCanvas::SaveAll(const std::vector<TPad *> &pads, const char *filename, Option_t *option); 2658{; 2659 if (pads.empty()) {; 2660 std::vector<TPad *> canvases;; 2661 TIter iter(gROOT->GetListOfCanvases());; 2662 while (auto c = dynamic_cast<TCanvas *>(iter())); 2663 canvases.emplace_back(c);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:85654,Safe,SafeDelete,85654,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints) ; Definition at line 320 of file BinData.cxx. ◆ BinUpEdge(). const double * ROOT::Fit::BinData::BinUpEdge ; (; unsigned int ; ipoint); const. inline . return an array containing the upper edge of the bin for coordinate i In case of empty bin they could be merged in a single larger bin Return a NULL pointer if the bin width is not stored ; Definition at line 519 of file BinData.h. ◆ ComputeSums(). void ROOT::Fit::BinData::ComputeSums ; (; ). protected . Definition at line 814 of file BinData.cxx. ◆ CoordErrors(). const double * ROOT::Fit::BinData::CoordErrors ; (; unsigned int ; ipoint); const. inline . Return a pointer to the errors in the coordinates for the given fit point. ; Definition at line 412 of file BinData.h. ◆ Error(). double ROOT::Fit::BinData::Error ; (; unsigned int ; ipoint); const. inline . Return the error on the given point. ; Safer method returning in any case the error and not the inverse as in the function above. ; Definition at line 262 of file BinData.h. ◆ ErrorPtr(). const double * ROOT::Fit::BinData::ErrorPtr ; (; unsigned int ; ipoint); const. inline . Return a pointer to the error (or the inverse error) on the value for a given point depending on the type of data. . If the data contains only value error (e.g. from histograms) returns a pointer to the inverse of the errors.; If the data contains errors in coordinates and value (e.g from TGraphErrors) returns a pointer to the corresponding value error (NOT the inverse).; If the data contains asymmetric errors return a pointer to the average error (NOT the inverse): 0.5(eu + el).; If the data does not contain errors return a nullptr. . Definition at line 249 of file BinData.h. ◆ GetAsymError(). void ROOT::Fit::BinData::GetAsymError ; (; unsigned int ; ipoint, . double & ; lowError, . double & ; highError . ); const. inline . Definition at line 307 of file BinData.h. ◆ GetBinUpEdgeComponent(). do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:20994,Safe,Safer,20994,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['Safe'],['Safer']
Safety,"new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTWebFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:11353,Recover,Recover,11353,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['Recover'],['Recover']
Safety,"nexpected: {; 4016 Fatal(""TCling::SetClassInfo::AlternateTuple"",; 4017 ""Layout of std::tuple on this platform is unexpected."");; 4018 break;; 4019 }; 4020 }; 4021 ; 4022 alternateTuple << ""};\n"";; 4023 alternateTuple << ""}}\n"";; 4024 alternateTuple << ""#endif\n"";; 4025 if (!gCling->Declare(alternateTuple.str().c_str())); 4026 {; 4027 // Declare is not silent (yet?), so add an explicit error message; 4028 // to indicate the consequence of the syntax errors.; 4029 Error(""Load"",""Could not declare %s"",alternateName.c_str());; 4030 return """";; 4031 }; 4032 alternateName = ""ROOT::Internal::"" + alternateName;; 4033 return alternateName;; 4034}; 4035 ; 4036////////////////////////////////////////////////////////////////////////////////; 4037/// Set pointer to the TClingClassInfo in TClass.; 4038/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we; 4039/// already have one.; 4040 ; 4041void TCling::SetClassInfo(TClass* cl, Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInfo to nullptr.; 4051 if (TClinginfo) {; 4052 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4053 }; 4054 delete TClinginfo;; 4055 cl->fClassInfo = nullptr;; 4056 }; 4057 return;; 4058 }; 4059 ; 4060 R__LOCKGUARD(gInterpreterMutex);; 4061 if (cl->fClassInfo && !reload) {; 4062 return;; 4063 }; 4064 //Remove the decl_id from the DeclIdToTClass map; 4065 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4066 if (TClinginfo) {; 4067 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4068 }; 4069 delete TClinginfo;; 4070 cl->fClassInfo = nullptr;; 4071 std::string name(cl->GetName());; 407",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:156333,redund,redundant,156333,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['redund'],['redundant']
Safety,"nfo *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);; 2289 return (sf == 2);; 2290}; 2291 ; 2292static void; 2293STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2294{; 2295 stop_flag_t sf;; 2296 do {; 2297 sf = mg_atomic_compare_and_swap(f, *f, v);; 2298 } while (sf != v);; 2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:70330,Interlock,Interlocked,70330,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Interlock'],['Interlocked']
Safety,"nfo *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);; 2290 return (sf == 2);; 2291}; 2292 ; 2293static void; 2294STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2295{; 2296 stop_flag_t sf;; 2297 do {; 2298 sf = mg_atomic_compare_and_swap(f, *f, v);; 2299 } while (sf != v);; 2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:70362,Interlock,Interlocked,70362,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Interlock'],['Interlocked']
Safety,"nformation about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3725,recover,recovery,3725,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"ng category sample as index:; // associate model with the physics state and model_ctl with the control state; RooSimultaneous simPdf(""simPdf"", ""simultaneous pdf"", {{""physics"", &model}, {""control"", &model_ctl}}, sample);; ; // P e r f o r m a s i m u l t a n e o u s f i t; // ---------------------------------------------------; ; // Perform simultaneous fit of model to data and model_ctl to data_ctl; std::unique_ptr<RooFitResult> fitResult{simPdf.fitTo(combData, PrintLevel(-1), Save(), PrintLevel(-1))};; fitResult->Print();; ; // P l o t m o d e l s l i c e s o n d a t a s l i c e s; // ----------------------------------------------------------------; ; // Make a frame for the physics sample; RooPlot *frame1 = x.frame(Title(""Physics sample""));; ; // Plot all data tagged as physics sample; combData.plotOn(frame1, Cut(""sample==sample::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html:4055,predict,prediction,4055,doc/master/rf501__simultaneouspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html,1,['predict'],['prediction']
Safety,"ng custom variation tags.; 1026 /// \param[in] colNames set of names of the columns for which varied values are provided.; 1027 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 1028 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 1029 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 1030 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 1031 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 1032 /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; 1033 /// `""1""`, etc. ; 1034 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1035 /// colName is used if none is provided.; 1036 ///; 1037 /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; 1038 /// is avoided.; 1039 ///; 1040 /// \sa This Vary() overload for more information.; 1041 template <typename F>; 1042 RInterface<Proxied, DS_t>; 1043 Vary(std::initializer_list<std::string> colNames, F &&expression, const ColumnNames_t &inputColumns,; 1044 std::size_t nVariations, std::string_view variationName); 1045 {; 1046 return Vary(std::vector<std::string>(colNames), std::forward<F>(expression), inputColumns, nVariations, variationName);; 1047 }; 1048 ; 1049 /// \brief Register systematic variations for a single existing column using custom variation tags.; 1050 /// \param[in] colName name of the column for which varied values are provided.; 1051 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; 1052 /// values for the specified column.; 1053 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1054 /// \param[in] variati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:56789,avoid,avoided,56789,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['avoid'],['avoided']
Safety,"ng element with the same tag will be replaced.; If update is true, existing client of tag will be updated. TEveElement* GetMaster(); Returns the master element - that is:; - master of projectable, if this is a projected;; - master of compound, if fCompound is set;; - master of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;; If non of the above is true, *this* is returned. void AddParent(TEveElement* re); Add re into the list parents.; Adding parent is subordinate to adding an element.; This is an internal function. void RemoveParent(TEveElement* re); Remove re from the list of parents.; Removing parent is subordinate to removing an element.; This is an internal function. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check external references to this and eventually auto-destruct; the render-element. void CollectSceneParents(TEveElement::List_t& scenes); Collect all parents of class TEveScene. This is needed to; automatically detect which scenes need to be updated. Overriden in TEveScene to include itself and return. void CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); Collect scene-parents from all children. This is needed to; automatically detect which scenes need to be updated during/after; a full sub-tree update.; Argument parent specifies parent in traversed hierarchy for which we can; skip the upwards search. void ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); Populates parent with elements.; parent must be an already existing representation of *this*.; Returns number of inserted elements.; If parent already has children, it does nothing. Element can be inserted in a list-tree several times, thus we can not; search through fItems to get parent here.; Anyhow, it is probably known as it must have been selected by the user. void DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); Destroy sub-tree under item 'parent' in list-tree 'ltree'. TGListTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:17709,detect,detect,17709,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['detect'],['detect']
Safety,"ng example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THistPainter.html:69960,avoid,avoid,69960,root/html530/THistPainter.html,https://root.cern,https://root.cern/root/html530/THistPainter.html,1,['avoid'],['avoid']
Safety,"ng exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; // that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; // comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; std::cout << ""Now plotting with unique normalisation for each slice."" << std::endl;; canvas->cd(1);; RooPlot* plotFrame = x.frame(RooFit::Title(""Wrong: Each slice normalised over its plotting range""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:2142,avoid,avoid,2142,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,1,['avoid'],['avoid']
Safety,"ng of the backpropagation algorithm. . static Scalar_t MeanSquaredError (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static void MeanSquaredErrorGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t CrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Sigmoid transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void CrossEntropyGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t SoftmaxCrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Softmax transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void SoftmaxCrossEntropyGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; Output Functions; Output functions transform the activations output of the output layer in the network to a valid prediction YHat for the desired usage of the network, e.g.; the identity function for regression or the sigmoid transformation for two-class classification. . static void Sigmoid (Matrix_t &YHat, const Matrix_t &);  ; static void Softmax (Matrix_t &YHat, const Matrix_t &);  ; Regularization; For each regularization type two functions are required, one named <Type>Regularization that evaluates the corresponding regularization functional for a given weight matrix and the Add<Type>RegularizationGradients, that adds the regularization component in the gradients to the provided matrix. . static Scalar_t L1Regularization (const Matrix_t &W);  ; static void AddL1RegularizationGradients (Matrix_t &A, const Matrix_t &W, Scalar_t weightDecay);  ; static Scalar_t L2Regularization (const Matrix_t &W);  ; static void AddL2RegularizationGradients (Matrix_t &A, const Matrix_t &W, Scalar_t weightDecay);  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html:9847,predict,prediction,9847,doc/master/classTMVA_1_1DNN_1_1TCpu.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html,2,['predict'],['prediction']
Safety,"ng of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 927will never receive the same slot at the same time.; 928This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 929processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 930 ; 931### Parallel execution of multiple RDataFrame event loops; 932A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of sep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:53148,safe,safe,53148,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ng of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 967will never receive the same slot at the same time.; 968This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 969processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 970 ; 971### Parallel execution of multiple RDataFrame event loops; 972A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of sep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:54788,safe,safe,54788,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21244,safe,safe,21244,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21205,safe,safe,21205,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20515,safe,safe,20515,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:20607,safe,safe,20607,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; In the prototype above, besides the current point and direction that are supposed already initialized, the only input parameter is step. This represents the maximum step allowed by the tracking algorithm or the physical step. The modeller will search for a boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:985611,safe,safety,985611,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety,"ng with several lines ; Definition at line 967 of file TApplication.cxx. ◆ GetSignalHandler(). TSignalHandler * TApplication::GetSignalHandler ; (; ); const. inline . Definition at line 107 of file TApplication.h. ◆ GitHub(). void TApplication::GitHub ; (; const char * ; line). protectedvirtual . The function ("".gh <type>"") submits a new issue on GitHub via web browser. ; NoteYou can use ""bug"", ""feature"" or ""improvement"" as <type>. ; Parameters. [in]linecommand from the command line . Definition at line 1186 of file TApplication.cxx. ◆ HandleException(). void TApplication::HandleException ; (; Int_t ; sig). virtual . Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented in TRint, and TProofServ.; Definition at line 590 of file TApplication.cxx. ◆ HandleIdleTimer(). void TApplication::HandleIdleTimer ; (; ). virtual . Handle idle timeout. ; When this timer expires the registered idle command will be executed by this routine and a signal will be emitted. ; Definition at line 577 of file TApplication.cxx. ◆ HandleTermInput(). virtual Bool_t TApplication::HandleTermInput ; (; ). inlinevirtual . Reimplemented in TRint.; Definition at line 116 of file TApplication.h. ◆ Help(). void TApplication::Help ; (; const char * ; line). protectedvirtual . The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ; NoteYou can use "".?"" as the short version of "".help"" ; Parameters. [in]linecommand from the command line . Definition at line 1208 of file TApplication.cxx. ◆ Hide(). virtual void TApplication::Hide ; (; ). inlinevirtual . Definition at line 130 of file TApplication.h. ◆ Iconify(). virtual void TApplication::Iconify ; (; ). inlinevirtual . Definition at line 131 of file TApplication.h. ◆ Init(). virtual void TApplication::Init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:28540,timeout,timeout,28540,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['timeout'],['timeout']
Safety,"ng& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:28705,abort,abort,28705,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['abort'],"['abort', 'aborts']"
Safety,"ng. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:1682,AVOID,AVOID,1682,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['AVOID'],['AVOID']
Safety,"ng::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to protect critical section; 7534/// of its code (non-thread safe parts).; 7535 ; 7536void TCling::SetAlloclockfunc(void (* /* p */ )()) const; 7537{; 7538 // nothing to do for now.; 7539}; 7540 ; 7541////////////////////////////////////////////////////////////////////////////////; 7542/// [Place holder for Mutex Unlock] Provide the interpreter with a way to; 7543/// release a lock used to protect critical section; 7544/// of its code (non-thread safe parts).; 7545 ; 7546void TCling::SetAllocunlockfunc(void (* /* p */ )()) const; 7547{; 7548 // nothing to do for now.; 7549}; 7550 ; 7551////////////////////////////////////////////////////////////////////////////////; 7552/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCallbacks->IsAutoLoadingEnabled();; 7561}; 7562 ; 7563////////////////////////////////////////////////////////////////////////////////; 7564/// Enable/Disable the AutoLoading of libraries.; 7565/// Returns the old value, i.e whether it was enabled or not.; 7566 ; 7567int TCling::SetClassAutoLoading(int autoload) const; 7568{; 7569 // If no state change is required, exit early.; 7570 // FIXME: In future ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:294442,safe,safe,294442,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safe']
Safety,"ng; 3750/// box will be sampled.; 3751 ; 3752void TGeoManager::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 3753{; 3754 GetGeomPainter()->CheckBoundaryErrors(ntracks, radius);; 3755}; 3756 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:137592,safe,safety,137592,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['safe'],['safety']
Safety,"ngFiles=0);  Resolve the end-point URL for the current elements of this data set If the removeMissing option is set to kTRUE, remove the TDSetElements that can not be located. ;  ; void Print (Option_t *option="""") const override;  Print TDSet basic or full data. When option=""a"" print full data. ;  ; virtual Long64_t Process (const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Process TDSet on currently active PROOF session. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Process TDSet on currently active PROOF session. ;  ; Int_t Remove (TDSetElement *elem, Bool_t deleteElem=kTRUE);  Remove TDSetElement 'elem' from the list. ;  ; void SetDirectory (const char *dir);  Set/change directory. ;  ; virtual void SetEntryList (TObject *aList);  Set entry (or event) list for this data set. ;  ; void SetLookedUp ();  Flag all the elements as looked-up, so to avoid opening the files if the functionality is not supported. ;  ; void SetObjName (const char *objname);  Set/change object name. ;  ; void SetSrvMaps (TList *srvmaps=0);  Set (or unset) the list for mapping servers coordinate for files. ;  ; void SetWriteV3 (Bool_t on=kTRUE);  Set/Reset the 'OldStreamer' bit in this instance and its elements. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this TTree. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Validate ();  Validate the TDSet by opening files. ;  ; void Validate (TDSet *dset);  Validate the TDSet against another TDSet. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSetProxy.html:4512,avoid,avoid,4512,doc/master/classTDSetProxy.html,https://root.cern,https://root.cern/doc/master/classTDSetProxy.html,1,['avoid'],['avoid']
Safety,"nge the current resolution model to newModel. ;  ; virtual double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const;  Default implementation of function implementing advertised integrals. ;  ; virtual double coefficient (Int_t basisIndex) const =0;  ; virtual RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; TClass * IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:4700,unsafe,unsafe,4700,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['unsafe'],['unsafe']
Safety,"nge(thisRangeName)) {; 2088 coutE(Plotting) << ""Range '"" << rangeNameToken << ""' not defined for variable '""; 2089 << frame->getPlotVar()->GetName() << ""'. Ignoring ..."" << std::endl;; 2090 continue;; 2091 }; 2092 rangeLim.push_back(frame->getPlotVar()->getRange(thisRangeName));; 2093 }; 2094 adjustNorm = true ;; 2095 hasCustomRange = true ;; 2096 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") p.d.f. curve is normalized using explicit choice of ranges '"" << pc.getString(""normRangeName"", """", false) << ""'"" << endl ;; 2097 ; 2098 nameSuffix.append(""_NormRange["" + std::string(pc.getString(""rangeName"")) + ""]"");; 2099 ; 2100 }; 2101 ; 2102 if (hasCustomRange && adjustNorm) {; 2103 // If overlapping ranges were given, remove them now; 2104 const std::size_t oldSize = rangeLim.size();; 2105 removeRangeOverlap(rangeLim);; 2106 ; 2107 if (oldSize != rangeLim.size() && !pc.hasProcessed(""NormRange"")) {; 2108 // User gave overlapping ranges. This leads to double-counting events and integrals, and must; 2109 // therefore be avoided. If a NormRange has been given, the overlap is already gone.; 2110 // It's safe to plot even with overlap now.; 2111 coutE(Plotting) << ""Requested plot/integration ranges overlap. For correct plotting, new ranges ""; 2112 ""will be defined."" << std::endl;; 2113 auto plotVar = dynamic_cast<RooRealVar*>(frame->getPlotVar());; 2114 assert(plotVar);; 2115 std::string rangesNoOverlap;; 2116 for (auto it = rangeLim.begin(); it != rangeLim.end(); ++it) {; 2117 std::stringstream rangeName;; 2118 rangeName << ""Remove_overlap_range_"" << it - rangeLim.begin();; 2119 plotVar->setRange(rangeName.str().c_str(), it->first, it->second);; 2120 if (!rangesNoOverlap.empty()); 2121 rangesNoOverlap += "","";; 2122 rangesNoOverlap += rangeName.str();; 2123 }; 2124 ; 2125 auto rangeArg = static_cast<RooCmdArg*>(cmdList.FindObject(""RangeWithName""));; 2126 if (rangeArg) {; 2127 rangeArg->setString(0, rangesNoOverlap.c_str());; 2128 } else {; 2129 plotRange = std::make_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:103796,avoid,avoided,103796,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['avoid'],['avoided']
Safety,"nges to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:10365,safe,safe,10365,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,2,['safe'],['safe']
Safety,"ngs (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel) R__DEPRECATED(6;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:13920,safe,safe,13920,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['safe'],['safe']
Safety,"ngth); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:11166,timeout,timeout,11166,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"ngth. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:13208,safe,safe,13208,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,2,['safe'],['safe']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2010-11-11 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofServ.html:17909,timeout,timeout,17909,root/html528/TXProofServ.html,https://root.cern,https://root.cern/root/html528/TXProofServ.html,2,['timeout'],['timeout']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXProofServ.html:18096,timeout,timeout,18096,root/html530/TXProofServ.html,https://root.cern,https://root.cern/root/html530/TXProofServ.html,2,['timeout'],['timeout']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXProofServ.html:18096,timeout,timeout,18096,root/html532/TXProofServ.html,https://root.cern,https://root.cern/root/html532/TXProofServ.html,2,['timeout'],['timeout']
Safety,"nherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TSelector.h>. Inheritance diagram for TSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15331,Abort,Abort,15331,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['Abort'],['Abort']
Safety,"nimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3073,recover,recovery,3073,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"nimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:13061,safe,safe,13061,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,3,['safe'],['safe']
Safety,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:10930,safe,safety,10930,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,8,['safe'],"['safe', 'safety']"
Safety,"nitTime ; (; ). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:41700,abort,abort,41700,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['abort'],['abort']
Safety,"nition RResultPtr.hxx:228; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; See the Book() method for more information and this tutorial for a more complete example.; Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and executes the callable on the values of those columns for each event that passes all upstream selections. It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:68235,safe,safety,68235,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safety']
Safety,"nition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoNavigator.h:164; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::fNormalDouble_t fNormal[3]last computed safety radiusDefinition TGeoNavigator.h:46; TGeoNavigator::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoNavigator.h:127; TGeoNavigator::PopPointBool_t PopPoint(Int_t index)Definition TGeoNavigator.h:272; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::fLastPointDouble_t fLastPoint[3]current directionDefinition TGeoNavigator.h:51; TGeoNavigator::GetStepDouble_t GetStep() constDefinition TGeoNavigator.h:128; TGeoNavigator::IsSameLocationBool_t IsSameLocation() constDefinition TGeoNavig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:20602,Safe,Safety,20602,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nition TGeoPolygon.h:52; TGeoPolygon::GetConvexVerticesvoid GetConvexVertices(Double_t *x, Double_t *y) constFill list of vertices of the convex outscribed polygon into provided arrays.Definition TGeoPolygon.cxx:252; TGeoShapeAssembly::Classstatic TClass * Class(); TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoShape::SetPointsvirtual void SetPoints(Double_t *points) const =0; TGeoShape::IsATClass * IsA() const overrideDefinition TGeoShape.h:171; TGeoTrackDefinition TGeoTrack.h:26; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::IsVisContainersBool_t IsVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:110046,safe,safe,110046,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safe']
Safety,"nition at line 227 of file TDCacheFile.cxx. ◆ ReadBuffers(). Bool_t TDCacheFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read the nbuf blocks described in arrays pos and len, where pos[i] is the seek position of block i of length len[i]. ; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 247 of file TDCacheFile.cxx. ◆ ResetErrno(). void TDCacheFile::ResetErrno ; (; ); const. overridevirtual . Method resetting the dc_errno and errno. ; Reimplemented from TFile.; Definition at line 577 of file TDCacheFile.cxx. ◆ SetOnError(). void TDCacheFile::SetOnError ; (; EOnErrorAction ; a = kOnErrorDefault). static . Set on error handler. ; Definition at line 388 of file TDCacheFile.cxx. ◆ SetOpenTimeout(). void TDCacheFile::SetOpenTimeout ; (; UInt_t ; secs). static . Set file open timeout. ; Definition at line 380 of file TDCacheFile.cxx. ◆ SetReplyHostName(). void TDCacheFile::SetReplyHostName ; (; const char * ; host_name). static . Set reply host name. ; Definition at line 396 of file TDCacheFile.cxx. ◆ Stage(). Bool_t TDCacheFile::Stage ; (; const char * ; path, . UInt_t ; secs, . const char * ; location = 0 . ). static . Stage() returns kTRUE on success and kFALSE on failure. ; Definition at line 340 of file TDCacheFile.cxx. ◆ Streamer(). void TDCacheFile::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TDCacheFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 75 of file TDCacheFile.h. ◆ SysClose(). Int_t TDCacheFile::SysClose ; (; Int_t ; fd). overrideprivatevirtual . Interface to system close. All arguments like in POSIX close. ; Reimplemented from TFile.; Definition at line 436 of file TDCacheFile.cxx. ◆ SysOpen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:47014,timeout,timeout,47014,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"nition at line 768 of file MethodDL.cxx. ◆ ParseRecurrentLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseRecurrentLayer ; (; ERecurrentLayerType ; type, . DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate rnn layer. ; Definition at line 931 of file MethodDL.cxx. ◆ ParseReshapeLayer(). template<typename Architecture_t , typename Layer_t > . void TMVA::MethodDL::ParseReshapeLayer ; (; DNN::TDeepNet< Architecture_t, Layer_t > & ; deepNet, . std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > & ; nets, . TString ; layerString, . TString ; delim . ). private . Pases the layer string and creates the appropriate reshape layer. ; Definition at line 829 of file MethodDL.cxx. ◆ PredictDeepNet(). template<typename Architecture_t > . std::vector< Double_t > TMVA::MethodDL::PredictDeepNet ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . size_t ; batchSize, . Bool_t ; logProgress . ). private . perform prediction of the deep neural network using batches (called by GetMvaValues) ; Evaluate the DeepNet on a vector of input values stored in the TMVA Event class. ; Definition at line 1828 of file MethodDL.cxx. ◆ ProcessOptions(). void TMVA::MethodDL::ProcessOptions ; (; ). privatevirtual . Implements TMVA::MethodBase.; Definition at line 219 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [1/3]. void TMVA::MethodDL::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase.; Definition at line 2330 of file MethodDL.cxx. ◆ ReadWeightsFromStream() [2/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Methods for writing and reading weights. ; Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:47641,Predict,PredictDeepNet,47641,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['Predict'],['PredictDeepNet']
Safety,"nlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:5030,abort,abort,5030,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['abort'],['abort']
Safety,"nly 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440947,recover,recovery,440947,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovery']
Safety,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:464274,timeout,timeout,464274,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:464307,timeout,timeout,464307,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"nnect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1887,Timeout,Timeout,1887,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"nnected. Bool_t TFile::fgCacheFileDisconnected = kTRUE. staticprotected . Indicates, we trust in the files in the cache dir without stat on the cached file. ; Definition at line 125 of file TFile.h. ◆ fgCacheFileForce. Bool_t TFile::fgCacheFileForce = kFALSE. staticprotected . Indicates, to force all READ to CACHEREAD. ; Definition at line 126 of file TFile.h. ◆ fgFileCounter. std::atomic< Long64_t > TFile::fgFileCounter {0}. staticprotected . Counter for all opened files. ; Definition at line 132 of file TFile.h. ◆ fGlobalRegistration. bool TFile::fGlobalRegistration = true. protected . ! if true, bypass use of global lists ; Definition at line 115 of file TFile.h. ◆ fgOnlyStaged. Bool_t TFile::fgOnlyStaged = kFALSE. staticprotected . Before the file is opened, it is checked, that the file is staged, if not, the open fails. ; Definition at line 128 of file TFile.h. ◆ fgOpenTimeout. UInt_t TFile::fgOpenTimeout = TFile::kEternalTimeout. staticprotected . Timeout for open operations in ms - 0 corresponds to blocking i/o. ; Definition at line 127 of file TFile.h. ◆ fgReadaheadSize. Int_t TFile::fgReadaheadSize = 256000. staticprotected . Readahead buffer size. ; Definition at line 134 of file TFile.h. ◆ fgReadCalls. std::atomic< Int_t > TFile::fgReadCalls {0}. staticprotected . Number of bytes read from all TFile objects. ; Definition at line 133 of file TFile.h. ◆ fgReadInfo. Bool_t TFile::fgReadInfo = kTRUE. staticprotected . if true (default) ReadStreamerInfo is called when opening a file ; Definition at line 135 of file TFile.h. ◆ fgTsSIHashes. ROOT::Internal::RConcurrentHashColl TFile::fgTsSIHashes. staticprotected . !TS Set of hashes built from read streamer infos ; Definition at line 120 of file TFile.h. ◆ fInfoCache. TList* TFile::fInfoCache {nullptr}. protected . !Cached list of the streamer infos in this file ; Definition at line 112 of file TFile.h. ◆ fInitDone. Bool_t TFile::fInitDone {kFALSE}. protected . !True if the file has been initialized ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:106695,Timeout,Timeout,106695,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Timeout'],['Timeout']
Safety,"nnection ; (; struct mg_connection * ; conn). static . Definition at line 18516 of file civetweb.c. ◆ produce_socket(). static void produce_socket ; (; struct mg_context * ; ctx, . const struct socket * ; sp . ). static . Definition at line 18809 of file civetweb.c. ◆ pull_all(). static int pull_all ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len . ). static . Definition at line 6413 of file civetweb.c. ◆ pull_inner(). static int pull_inner ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 6184 of file civetweb.c. ◆ push_all(). static int push_all ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len . ). static . Definition at line 6136 of file civetweb.c. ◆ push_inner(). static int push_inner ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 5970 of file civetweb.c. ◆ put_dir(). static int put_dir ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 10267 of file civetweb.c. ◆ put_file(). static void put_file ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 11670 of file civetweb.c. ◆ read_auth_file(). static int read_auth_file ; (; struct mg_file * ; filep, . struct read_auth_file_struct * ; workdata, . int ; depth . ). static . Definition at line 8505 of file civetweb.c. ◆ read_message(). static int read_message ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; bufsiz, . int * ; nread . ). static . Definition at line 10798 of file civetweb.c. ◆ redirect_to_https_port(). static void redirect_to_https_port ; (; struct mg_connection * ; conn, . int ; port . ). static . Definition at line 13543 of file civetweb.c. ◆ refresh_trust(). static int refresh_trust ; (; struct mg_connectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:81732,timeout,timeout,81732,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"nnot run command \""%s\"""", command);; 687 return out;; 688 }; 689 ; 690 TString line;; 691 while (line.Gets(pipe)) {; 692 if (out != """"); 693 out += ""\n"";; 694 out += line;; 695 }; 696 ; 697 Int_t r = ClosePipe(pipe);; 698 if (r) {; 699 Error(""GetFromPipe"", ""command \""%s\"" returned %d"", command, r);; 700 }; 701 return out;; 702}; 703 ; 704////////////////////////////////////////////////////////////////////////////////; 705/// Get process id.; 706 ; 707int TSystem::GetPid(); 708{; 709 AbstractMethod(""GetPid"");; 710 return -1;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Exit the application.; 715 ; 716void TSystem::Exit(int, Bool_t); 717{; 718 AbstractMethod(""Exit"");; 719 throw; // unreachable; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Abort the application.; 724 ; 725void TSystem::Abort(int); 726{; 727 AbstractMethod(""Abort"");; 728 throw; // unreachable; 729}; 730 ; 731////////////////////////////////////////////////////////////////////////////////; 732/// Print a stack trace.; 733 ; 734void TSystem::StackTrace(); 735{; 736 AbstractMethod(""StackTrace"");; 737}; 738 ; 739 ; 740//---- Directories -------------------------------------------------------------; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Create helper TSystem to handle file and directory operations that; 744/// might be special for remote file access.; 745 ; 746TSystem *TSystem::FindHelper(const char *path, void *dirptr); 747{; 748 TSystem *helper = nullptr;; 749 {; 750 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 751 ; 752 if (!fHelpers) {; 753 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 754 fHelpers = new TOrdCollection;; 755 }; 756 ; 757 if (path) {; 758 if (!GetDirPtr()) {; 759 TUrl url(path, kTRUE);; 760 if (!strcmp(url.GetProtocol(), ""file"")); 761 return nullptr;; 762 }; 763 }; 764 ; 765 // look for existing helpers; 766 TIter next(fHelper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:22030,Abort,Abort,22030,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['Abort'],['Abort']
Safety,"noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3611,recover,recovery,3611,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the assembly. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the hyperboloid. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from outside point to surface of the hyperboloid. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  in case shape has some negative parameters, these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:2227,safe,safe,2227,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"not declarations, like ""Int_t x;"").; 3584 ; 3585Longptr_t TCling::Calc(const char* line, EErrorCode* error); 3586{; 3587#ifdef R__WIN32; 3588 // Test on ApplicationImp not being 0 is needed because only at end of; 3589 // TApplication ctor the IsLineProcessing flag is set to 0, so before; 3590 // we can not use it.; 3591 if (gApplication && gApplication->GetApplicationImp()) {; 3592 while (gROOT->IsLineProcessing() && !gApplication) {; 3593 Warning(""Calc"", ""waiting for cling thread to free"");; 3594 gSystem->Sleep(500);; 3595 }; 3596 gROOT->SetLineIsProcessing();; 3597 }; 3598#endif // R__WIN32; 3599 R__LOCKGUARD_CLING(gInterpreterMutex);; 3600 if (error) {; 3601 *error = TInterpreter::kNoError;; 3602 }; 3603 cling::Value valRef;; 3604 cling::Interpreter::CompilationResult cr = cling::Interpreter::kFailure;; 3605 try {; 3606 cr = fInterpreter->evaluate(line, valRef);; 3607 }; 3608 catch (cling::InterpreterException& ex); 3609 {; 3610 Error(""Calc"", ""%s.\n%s"", ex.what(), ""Evaluation of your expression was aborted."");; 3611 ex.diagnose();; 3612 cr = cling::Interpreter::kFailure;; 3613 }; 3614 ; 3615 if (cr != cling::Interpreter::kSuccess) {; 3616 // Failure in compilation.; 3617 if (error) {; 3618 // Note: Yes these codes are weird.; 3619 *error = TInterpreter::kRecoverable;; 3620 }; 3621 return 0L;; 3622 }; 3623 if (!valRef.isValid()) {; 3624 // Failure at runtime.; 3625 if (error) {; 3626 // Note: Yes these codes are weird.; 3627 *error = TInterpreter::kDangerous;; 3628 }; 3629 return 0L;; 3630 }; 3631 ; 3632 if (valRef.isVoid()) {; 3633 return 0;; 3634 }; 3635 ; 3636 RegisterTemporary(valRef);; 3637#ifdef R__WIN32; 3638 if (gApplication && gApplication->GetApplicationImp()) {; 3639 gROOT->SetLineHasBeenProcessed();; 3640 }; 3641#endif // R__WIN32; 3642 return valRef.castAs<Longptr_t>();; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Set a getline function to call when input is needed.; 3647 ; 3648void TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:140348,abort,aborted,140348,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['abort'],['aborted']
Safety,"nputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (eithe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:10158,Abort,Abort,10158,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,2,['Abort'],['Abort']
Safety,"nr is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:37340,timeout,timeout,37340,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"ns to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*TGenCollectionProxy::fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. TEmulatedCollectionProxy & operator=(const TEmulatedCollectionProxy& ). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:7400,avoid,avoid,7400,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['avoid'],['avoid']
Safety,"ns to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*TGenCollectionProxy::fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:7146,avoid,avoid,7146,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,1,['avoid'],['avoid']
Safety,"ns, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguements are an array of expected signal, expected background, and relative; ratio of background expected in the sideband to that expected in signal region, and the number of channels. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. void AddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguments are an array of results from a main measurement, a measured background,; and relative background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. NumberCountingPdfFactory(); need one for expected and one for observed. » Author: Kyle Cranmer 28/07/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html:4260,Safe,SafeObservableCreation,4260,root/html526/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html,7,['Safe'],['SafeObservableCreation']
Safety,"ns. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); Paint the list of histograms.; By default, histograms are shown stacked.; - the first histogram is paint; - then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. If the option nostackb is specified histograms are all paint in the same pad; next to each other as bar plots. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THStack.html:15429,avoid,avoid,15429,root/html604/THStack.html,https://root.cern,https://root.cern/root/html604/THStack.html,1,['avoid'],['avoid']
Safety,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124702,sanity check,sanity check,124702,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"nsform3D< T >::Transform3D ; (; T ; xx, . T ; xy, . T ; xz, . T ; dx, . T ; yx, . T ; yy, . T ; yz, . T ; dy, . T ; zx, . T ; zy, . T ; zz, . T ; dz . ). inline . Raw constructor from 12 Scalar components. ; Definition at line 445 of file Transform3D.h. Member Function Documentation. ◆ ApplyInverse() [1/4]. template<typename T = double> . template<class CoordSystem > . DisplacementVector3D< CoordSystem > ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const DisplacementVector3D< CoordSystem > & ; p); const. inline . Directly apply the inverse affine transformation on an arbitrary coordinate-system vector. ; Involves casting to Vector(p) type. ; Definition at line 713 of file Transform3D.h. ◆ ApplyInverse() [2/4]. template<typename T = double> . Point ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const Point & ; p); const. inline . Directly apply the inverse affine transformation on points (first inverse translation then inverse rotation). ; Avoids having to calculate the inverse as an intermediate result. This is possible since the inverse of a rotation is its transpose. ; Definition at line 688 of file Transform3D.h. ◆ ApplyInverse() [3/4]. template<typename T = double> . template<class CoordSystem > . PositionVector3D< CoordSystem > ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const PositionVector3D< CoordSystem > & ; p); const. inline . Directly apply the inverse affine transformation on an arbitrary coordinate-system point. ; Involves casting to Point(p) type. ; Definition at line 702 of file Transform3D.h. ◆ ApplyInverse() [4/4]. template<typename T = double> . Vector ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const Vector & ; v); const. inline . Directly apply the inverse affine transformation on vectors. ; Avoids having to calculate the inverse as an intermediate result. This is possible since the inverse of a rotation is its transpose. ; Definition at line 675 of file Transform3D.h. ◆ AssignFrom() [1/3]. template<typename T ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html:22439,Avoid,Avoids,22439,doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,1,['Avoid'],['Avoids']
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2Poly.html:4490,avoid,avoid,4490,root/html528/TH2Poly.html,https://root.cern,https://root.cern/root/html528/TH2Poly.html,4,['avoid'],['avoid']
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:4439,avoid,avoid,4439,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['avoid'],['avoid']
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2PolyBin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2PolyBin.html:4452,avoid,avoid,4452,root/html602/TH2PolyBin.html,https://root.cern,https://root.cern/root/html602/TH2PolyBin.html,2,['avoid'],['avoid']
Safety,"nspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ IsA(). TClass * TGeoCone::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. ◆ IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone & ; ). protecteddelete . ◆ Safety(). Double_t TGeoCone::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ Safety_v(). void TGeoCone::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ SetDimensions(). void TGeoCone::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetPoints() [1/2]. void TGeoCone::SetPoints ; (; Double_t * ; points); const. overridevirtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31677,safe,safe,31677,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['safe'],['safe']
Safety,"nspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ IsA(). TClass * TGeoTube::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 91 of file TGeoTube.h. ◆ IsCylType(). Bool_t TGeoTube::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 77 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTube::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ operator=(). TGeoTube & TGeoTube::operator= ; (; const TGeoTube & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTube::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Safety_v(). void TGeoTube::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SafetyS(). static Double_t TGeoTube::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTube::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetDimensions(). void TGeoTube::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [1/2]. void TGeoTube::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [2/2]. void TGeoTube::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:30749,safe,safe,30749,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['safe'],['safe']
Safety,"nst Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Double_t GetDy () const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetOppositeCorner (const Double_t *point, Int_t inorm, Double_t *vertex, Double_t *normals) const;  ; void GetVisibleCorner (const Double_t *point, Double_t *vertex, Double_t *normals) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:2591,Safe,Safety,2591,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nst Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetSphDimensions(Double_t rmin, Double_t rmax, Double_t theta1, Double_t theta2, Double_t phi1, Double_t phi2); Set spherical segment dimensions. void SetDimensions(Double_t* param, Int_t nparam); Set dimensions of the spherical segment starting from a list of parameters. void SetDimensions(Double_t* param); Set dimensions of the spherical segment starting from a list of parameters.; Only takes rmin and rmax. void SetNumberOfDivisions(Int_t p); Set the number of divisions of mesh circles keeping aspect ratio. void SetPoints(Double_t* points) const; create sphere mesh points. void SetPoints(Float_t* points) const; create sphere mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:16480,Safe,Safety,16480,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['Safe'],['Safety']
Safety,"nst argv. ; Definition at line 1089 of file OptionParser.h. ◆ Parser() [4/5]. ROOT::option::Parser::Parser ; (; const Descriptor ; usage[], . int ; argc, . const char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX Parser(...) (gnu==false). ; Definition at line 1097 of file OptionParser.h. ◆ Parser() [5/5]. ROOT::option::Parser::Parser ; (; const Descriptor ; usage[], . int ; argc, . char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX Parser(...) (gnu==false) with non-const argv. ; Definition at line 1105 of file OptionParser.h. Member Function Documentation. ◆ error(). bool ROOT::option::Parser::error ; (; ). inline . Returns true if an unrecoverable error occurred while parsing options. ; An illegal argument to an option (i.e. CheckArg returns ARG_ILLEGAL) is an unrecoverable error that aborts the parse. Unknown options are only an error if their CheckArg function returns ARG_ILLEGAL. Otherwise they are collected. In that case if you want to exit the program if either an illegal argument or an unknown option has been passed, use code like this; if (parser.error() || options[UNKNOWN]); exit(1);. Definition at line 1264 of file OptionParser.h. ◆ instr(). static bool ROOT::option::Parser::instr ; (; char ; ch, . const char * ; st . ). inlinestaticprivate . Definition at line 1346 of file OptionParser.h. ◆ nonOption(). const char * ROOT::option::Parser::nonOption ; (; int ; i). inline . Returns nonOptions()[i] (without checking if i is in range!). ; Definition at line 1244 of file OptionParser.h. ◆ nonOptions(). const char ** ROOT::option::Parser::nonOptions ; (; ). inline . Returns a pointer to an array of non-option arguments (only valid if nonOptionsCount() >0 ). ; Note; parse() does not copy arguments, so this pointer points into the actual argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html:10077,abort,aborts,10077,doc/v632/classROOT_1_1option_1_1Parser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html,2,['abort'],['aborts']
Safety,"nst char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::GetClusterPrefetchvirtual bool GetClusterPrefetch() constDefinition TTree.h:457; TTree::BranchTBranch * Branch(const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:400; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::TTreeBranchImpReffriend TBranch * TTreeBranchImpRef(TTree *tree, const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); TTree::GetTargetMemoryRatioFloat_t GetTargetMemoryRatio() constDefinition TTree.h:560; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:67847,recover,recover,67847,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['recover'],['recover']
Safety,"nst char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:8831,safe,safe,8831,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,1,['safe'],['safe']
Safety,"nst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgSet.html:12966,safe,safeDeleteList,12966,root/html530/RooArgSet.html,https://root.cern,https://root.cern/root/html530/RooArgSet.html,1,['safe'],['safeDeleteList']
Safety,"nst; Returns current depth to which geometry is drawn. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Search the track hierarchy to find the track with the; given id. if 'primsFirst' is true, then:; first tries TGeoManager::GetTrackOfId, then does a; recursive search if that fails. this would be faster; if the track is somehow known to be a primary. TVirtualGeoTrack * GetTrackOfId(Int_t id) const; Get track with a given ID. TVirtualGeoTrack * GetParentTrackOfId(Int_t id) const; Get parent track with a given ID. Int_t GetTrackIndex(Int_t id) const; Get index for track id, -1 if not found. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void DefaultColors(); Set default volume colors according to A of material. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:47865,Safe,Safety,47865,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,12,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nst; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14432,Safe,SafetyPhi,14432,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,1,['Safe'],['SafetyPhi']
Safety,"nsverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html:8212,avoid,avoid,8212,root/html534/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html,1,['avoid'],['avoid']
Safety,"nt (e.g. Histo1D()), so we cannot deduce the type of the column at compile-time. In this case RDataFrame infers the type of the column from the TTree itself. This is why we never needed to specify the column types for all actions in the above snippets.; When the column type is not a common one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing x = 0 rather than x == 0:; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");. User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; Implementing custom actions with Book(); Through the Book() method, users can implement a custom action and have access to the same features that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; #include <ROOT/RDataFrame.hxx>; #include <memory>; ; class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;; ; public:; // We use a public type alias to advertise the type of the result of this action;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:64740,avoid,avoids,64740,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['avoid'],['avoids']
Safety,"nt len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:180251,timeout,timeout,180251,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"nt len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:180283,timeout,timeout,180283,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"nt list of defined branches with; git branch -a. Change to (creating if necessary) a local branch tracking an existing remote branch of the same name:; git checkout <branch>. Update your local repository ref database without altering the current working area:; git fetch <remote>. Update your current local branch with respect to your repository's current idea of a remote branch's status:; git merge <branch>. Pull remote ref information from all remotes and merge local branches with their remote tracking branches (if applicable):; git pull. Examine changes to the current local branch with respect to its tracking branch:; git cherry -v. Push changes to the remote tracking branch:; git push. Push all changes to all tracking branches:; git push --all. Some more advanced operations. Important tip: if you're going to do a git operation the outcome of which is even remotely uncertain to be the desired one: make a copy of your repository:; mkdir -p <path-to-safe-dir>; tar -cf - . | tar -xC <path-to-safe-dir>. Disk space is cheap and rm -rf is easy. Note that you must copy the entire repository, since all the important information is in the .git directory tree at the top level. Stashing; This is a good way quickly to get a clean tree if you want to merge or rebase (see below) to import changes from a branch without having to commit your current work. Save uncommitted changes to the current working area to the stash (not a commit operation):; git stash. Apply previously-saved stash:; git stash pop. (pops off the changes and applies them to the current working area) or; git stash apply. which applies the changes but retains them on the stack.; Examine the current state of the stash:; git stash list. Clear the entire stash:; git stash clear. Rebasing; Rebasing is changing history, if you think that git stores history. As mentioned above, it doesn't: it saves objects with parent, child and other (eg date, author, etc) information. In a truly distributed environment, the actual hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:10311,safe,safe-dir,10311,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['safe'],['safe-dir']
Safety,"nt(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced. void CheckGeometry(Option_t* option = """"); Instanciate a TGeoChecker object and investigates the geometry according to; option. Not implemented yet.; check shapes first. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """"); Check all geometry for illegal overlaps within a limit OVLP. void PrintOverlaps() const; Prints the current list of overlaps. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.; Option can be ""v"" - verbose (default). ULong_t SizeOf(const TGeoNode* node, Option_t* option); computes the total size in bytes of the branch starting w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:65259,Safe,Safety,65259,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,1,['Safe'],['Safety']
Safety,"nt, . Int_t & ; ipsec . ); const. protected . ◆ MakeBuffer3D(). TBuffer3D * TGeoPgon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ operator=(). TGeoPgon & TGeoPgon::operator= ; (; const TGeoPgon & ; ). protecteddelete . ◆ Rpg(). Double_t TGeoPgon::Rpg ; (; Double_t ; z, . Int_t ; ipl, . Bool_t ; inner, . Double_t & ; a, . Double_t & ; b . ); const. protected . ◆ Rproj(). Double_t TGeoPgon::Rproj ; (; Double_t ; z, . const Double_t * ; point, . const Double_t * ; dir, . Double_t ; cphi, . Double_t ; sphi, . Double_t & ; a, . Double_t & ; b . ); const. protected . ◆ Safety(). Double_t TGeoPgon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ Safety_v(). void TGeoPgon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ SafetyToSegment(). Double_t TGeoPgon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Int_t ; iphi, . Bool_t ; in, . Double_t ; safphi, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPgon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoPcon. ◆ SetDimensions(). void TGeoPgon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoPcon. ◆ SetNedges(). void TGeoPgon::SetNedges ; (; Int_t ; ne). inline . Definition at line 108 of file TGeoPgon.h. ◆ SetPoints() [1/2]. void TGeoPgon::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoPcon. ◆ SetPoints() [2/2]. void TGeoPgon::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoPcon. ◆ SetSegsAndPols(). void TGeoPgon::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoPcon. ◆ SetSegsAndPols",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:33037,Safe,SafetyToSegment,33037,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['Safe'],['SafetyToSegment']
Safety,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:19100,avoid,avoid,19100,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,1,['avoid'],['avoid']
Safety,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:18546,avoid,avoid,18546,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,2,['avoid'],['avoid']
Safety,"nt, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, Double_t b, Double_t dz); Set dimensions of the eliptical tube. void SetDimensions(Double_t* param); Set shape dimensions starting from an array. void SetPoints(Double_t* points) const; Create eliptical tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Returns the number of vertices on the mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:15086,Safe,Safety,15086,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['Safe'],['Safety']
Safety,"nt.h""; 63#include ""RooMsgService.h""; 64#include ""RooNumIntConfig.h""; 65#include ""RooNumRunningInt.h""; 66#include ""RooParamBinning.h""; 67#include ""RooPlot.h""; 68#include ""RooProduct.h""; 69#include ""RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:3295,detect,detected,3295,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['detect'],['detected']
Safety,"ntRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:11037,timeout,timeout,11037,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,3,['timeout'],['timeout']
Safety,"ntStyle ; (; Option_t * ; opt); const. overridevirtual . Configure mapping of Print() arguments to RooPrintable print styles. ; Reimplemented from RooPrintable.; Definition at line 1446 of file RooFitResult.cxx. ◆ edm(). double RooFitResult::edm ; (; ); const. inline . Return estimated distance to minimum. ; Definition at line 95 of file RooFitResult.h. ◆ fillCorrMatrix() [1/2]. void RooFitResult::fillCorrMatrix ; (; ). protected . Internal utility method to extract the correlation matrix and the global correlation coefficients from the MINUIT memory buffer and fill the internal arrays. ; Definition at line 689 of file RooFitResult.cxx. ◆ fillCorrMatrix() [2/2]. void RooFitResult::fillCorrMatrix ; (; const std::vector< double > & ; globalCC, . const TMatrixDSym & ; corrs, . const TMatrixDSym & ; covs . ). Function called by RooMinimizer. ; Definition at line 587 of file RooFitResult.cxx. ◆ fillLegacyCorrMatrix(). void RooFitResult::fillLegacyCorrMatrix ; (; ); const. protected . Sanity check. ; Definition at line 622 of file RooFitResult.cxx. ◆ fillPrefitCorrMatrix(). void RooFitResult::fillPrefitCorrMatrix ; (; ). protected . Definition at line 751 of file RooFitResult.cxx. ◆ floatParsFinal(). const RooArgList & RooFitResult::floatParsFinal ; (; ); const. inline . Return list of floating parameters after fit. ; Definition at line 111 of file RooFitResult.h. ◆ floatParsInit(). const RooArgList & RooFitResult::floatParsInit ; (; ); const. inline . Return list of floating parameters before fit. ; Definition at line 107 of file RooFitResult.h. ◆ globalCorr() [1/3]. const RooArgList * RooFitResult::globalCorr ; (; ). Return the list of all global correlations. ; Definition at line 454 of file RooFitResult.cxx. ◆ globalCorr() [2/3]. double RooFitResult::globalCorr ; (; const char * ; parname). Return the global correlation of the named parameter. ; Definition at line 430 of file RooFitResult.cxx. ◆ globalCorr() [3/3]. double RooFitResult::globalCorr ; (; const RooAbsArg ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:28187,Sanity check,Sanity check,28187,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['Sanity check'],['Sanity check']
Safety,"ntStyle(); Int_tWait(Int_t millisec = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSemaphore.html:5672,timeout,timeout,5672,root/html534/TSemaphore.html,https://root.cern,https://root.cern/root/html534/TSemaphore.html,1,['timeout'],['timeout']
Safety,"nt_t f)Definition TGeoShape.h:166; TGeoShape::GetNmeshVerticesvirtual Int_t GetNmeshVertices() constDefinition TGeoShape.h:127; TGeoShape::GetMeshNumbersvirtual void GetMeshNumbers(Int_t &, Int_t &, Int_t &) constDefinition TGeoShape.h:125; TGeoShape::DistToPhiMinstatic Double_t DistToPhiMin(const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in=kTRUE)compute distance from point (inside phi) to both phi planes. Return minimum.Definition TGeoShape.cxx:426; TGeoShape::SetSegsAndPolsvirtual void SetSegsAndPols(TBuffer3D &buff) const =0; TGeoShape::SetShapeBitvoid SetShapeBit(UInt_t f)Definition TGeoShape.h:165; TGeoShape::DistFromOutside_vvirtual void DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:108; TGeoShape::TGeoShapeTGeoShape()Default constructor.Definition TGeoShape.cxx:167; TGeoShape::SafetyPhistatic Double_t SafetyPhi(const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2)Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1,...Definition TGeoShape.cxx:494; TGeoShape::SetDimensionsvirtual void SetDimensions(Double_t *param)=0; TGeoShape::Sizeof3Dvirtual void Sizeof3D() const =0; TGeoShape::fShapeIdInt_t fShapeIdDefinition TGeoShape.h:71; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::GetPointsOnSegmentsvirtual Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::DistFromInside_vvirtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:105; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:13319,Safe,SafetyPhistatic,13319,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,3,"['Safe', 'safe']","['SafetyPhi', 'SafetyPhistatic', 'safety']"
Safety,"nt_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; virtual Double_t GetA () const;  ; virtual Double_t GetB () const;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetEltuDimensions (Double_t a, Double_t b, Double_t dz);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoTube;  TGeoTube ();  ;  TGeoTube (const char *name, Double_t rmin, Double_t rmax, Double_t dz);  ;  TGeoTube (Double_t *params);  ;  TGeoTube (Double_t rmin, Double_t rmax, Double_t dz);  ;  ~TGeoTube () override;  ; Double_t Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:2502,Safe,Safety,2502,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nt_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Double_t GetDphi () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual Int_t GetNsegments () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t * GetRmax () const;  ; Double_t GetRmax (Int_t ipl) const;  ; Double_t * GetRmin () const;  ; Double_t GetRmin (Int_t ipl) const;  ; Double_t * GetZ () const;  ; Double_t GetZ (Int_t ipl) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t & Phi1 ();  ; Double_t & Rmax (Int_t ipl);  ; Double_t & Rmin (Int_t ipl);  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; Double_t SafetyToSegment (const Double_t *point, Int_t ipl, Bool_t in=kTRUE, Double_t safmin=TGeoShape::Big()) const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:3331,Safe,Safety,3331,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,3,"['Safe', 'safe']","['Safety', 'SafetyToSegment', 'safe']"
Safety,"nt_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoChecker.cxx:1752; TGeoChecker::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""")Check illegal overlaps for volume VOL within a limit OVLP.Definition TGeoChecker.cxx:1427; TGeoChecker::TestOverlapsvoid TestOverlaps(const char *path)Geometry overlap checker based on sampling.Definition TGeoChecker.cxx:2761; TGeoChecker::SetSelectedNodevoid SetSelectedNode(TGeoNode *node)Definition TGeoChecker.h:93; TGeoChecker::CheckGeometryFullvoid CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)Geometry checking.Definition TGeoChecker.cxx:503; TGeoChecker::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path)shoot npoints randomly in a box of 1E-5 around current point.Definition TGeoChecker.cxx:2492; TGeoChecker::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Draw point (x,y,z) over the picture of the daughters of the volume containing this point.Definition TGeoChecker.cxx:1692; TGeoChecker::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""v"")Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION.Definition TGeoChecker.cxx:2890; TGeoChecker::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""")Print current operation progress.Definition TGeoChecker.cxx:151; TGeoChecker::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoChecker.cxx:809; TGeoChecker::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:82597,safe,safety,82597,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safety']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:19255,safe,safe,19255,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoArb8.html:21042,safe,safe,21042,root/html604/TGeoArb8.html,https://root.cern,https://root.cern/root/html604/TGeoArb8.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:21042,safe,safe,21042,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:19164,safe,safe,19164,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,6,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:20917,safe,safe,20917,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBox.html:22671,safe,safe,22671,root/html604/TGeoBBox.html,https://root.cern,https://root.cern/root/html604/TGeoBBox.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:22671,safe,safe,22671,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:22275,safe,safe,22275,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCompositeShape.html:24029,safe,safe,24029,root/html604/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html604/TGeoCompositeShape.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCompositeShape.html:24029,safe,safe,24029,root/html602/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:15059,safe,safe,15059,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHalfSpace.html:16813,safe,safe,16813,root/html604/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html604/TGeoHalfSpace.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:16813,safe,safe,16813,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:17042,safe,safe,17042,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPara.html:18794,safe,safe,18794,root/html604/TGeoPara.html,https://root.cern,https://root.cern/root/html604/TGeoPara.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPara.html:18794,safe,safe,18794,root/html602/TGeoPara.html,https://root.cern,https://root.cern/root/html602/TGeoPara.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:18898,safe,safe,18898,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoSphere.html:20652,safe,safe,20652,root/html604/TGeoSphere.html,https://root.cern,https://root.cern/root/html604/TGeoSphere.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSphere.html:20652,safe,safe,20652,root/html602/TGeoSphere.html,https://root.cern,https://root.cern/root/html602/TGeoSphere.html,2,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. Int_t GetNz() const; virtual Int_t GetByteCount() const {return 60+12*fNz;}. {return fNz;}. Int_t GetNvert() const; {return fNvert;}. Double_t GetX(Int_t i) const; {return (i<fNvert&&i>-1 &&fX!=0) ? fX[i] : -1.0E10;}. Double_t GetY(Int_t i) const; {return (i<fNvert&&i>-1 &&fY!=0) ? fY[i] : -1.0E10;}. Double_t GetXOffset(Int_t i) const; {return (i<fNz&&i>-1 && fX0!=0) ? fX0[i] : 0.0;}. Double_t GetYOffset(Int_t i) const; {return (i<fNz&&i>-1 && fY0!=0) ? fY0[i] : 0.0;}. Double_t GetScale(Int_t i) const; {return (i<fNz&&i>-1 && fScale!=0) ? fScale[i] : 1.0;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Mihaela Gheata 24/01/04 » Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:21369,safe,safe,21369,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,6,['safe'],['safe']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitter.html:16877,predict,predict,16877,root/html534/TFitter.html,https://root.cern,https://root.cern/root/html534/TFitter.html,1,['predict'],['predict']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitter.html:17450,predict,predict,17450,root/html604/TFitter.html,https://root.cern,https://root.cern/root/html604/TFitter.html,1,['predict'],['predict']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:17450,predict,predict,17450,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,1,['predict'],['predict']
Safety,"nt_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:55493,safe,safely,55493,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,5,['safe'],['safely']
Safety,"nt_t ; iaxis); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoPcon, TGeoSphere, TGeoTorus, TGeoTube, and TGeoVGShape. ◆ GetAxisRange(). Double_t TGeoBBox::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape. ◆ GetBoundingCylinder(). void TGeoBBox::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCompositeShape, TGeoHalfSpace, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, and TGeoVGShape. ◆ GetBuffer3D(). const TBuffer3D & TGeoBBox::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoShape.; Reimplemented in TGeoTessellated, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ GetByteCount(). Int_t TGeoBBox::GetByteCount ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape.; Definition at line 70 of file TGeoBBox.h. ◆ GetDX(). virtual Double_t TGeoBBox::GetDX ; (; ); const. inlinevirtual . Definition at line 79 of file TGeoBBox.h. ◆ GetDY(). virtual Double_t TGeoBBox::GetDY ; (; ); const. inlinevirtual . Definition at line 80 of file TGeoBBox.h. ◆ GetDZ(). virtual Double_t TGeoBBox::GetDZ ; (; ); const. inlinevirtual . Definition at line 81 of file TGeoBBox.h. ◆ GetFacetArea(). virtual Double_t TGeoBBox:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:30524,avoid,avoid,30524,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['avoid'],['avoid']
Safety,"ntains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTxy () const;  ; Double_t GetTxz () const;  ; Double_t GetTyz () const;  ; Double_t GetX () const;  ; Double_t GetY () const;  ; Double_t GetZ () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:2642,Safe,Safety,2642,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ntains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:3694,safe,safe,3694,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3881,avoid,avoid,3881,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['avoid'],['avoid']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3881,avoid,avoid,3881,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['avoid'],['avoid']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3881,avoid,avoid,3881,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['avoid'],['avoid']
Safety,"nted in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ GetPackets(). TList * TEventIter::GetPackets ; (; ). inline . Definition at line 89 of file TEventIter.h. ◆ InvalidatePacket(). void TEventIter::InvalidatePacket ; (; ). virtual . Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Definition at line 133 of file TEventIter.cxx. ◆ IsA(). TClass * TEventIter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree.; Definition at line 93 of file TEventIter.h. ◆ LoadDir(). Int_t TEventIter::LoadDir ; (; ). protected . Load directory. ; Definition at line 163 of file TEventIter.cxx. ◆ PreProcessEvent(). virtual void TEventIter::PreProcessEvent ; (; Long64_t ; ). inlineprotectedvirtual . Reimplemented in TEventIterTree, and TEventIterObj.; Definition at line 74 of file TEventIter.h. ◆ StopProcess(). void TEventIter::StopProcess ; (; Bool_t ; abort). virtual . Set flag to stop the process. ; Definition at line 141 of file TEventIter.cxx. ◆ Streamer(). void TEventIter::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ StreamerNVirtual(). void TEventIter::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file TEventIter.h. Member Data Documentation. ◆ fCur. Long64_t TEventIter::fCur. protected . Definition at line 64 of file TEventIter.h. ◆ fDir. TDirectory* TEventIter::fDir. protected . Definition at line 56 of file TEventIter.h. ◆ fDSet. TDSet* TEventIter::fDSet. protected . Definition at line 48 of file TEventIter.h. ◆ fElem. TDSetElement* TEventIter::fElem. protected . Definition at line 50 of file TEventIter.h. ◆ fElemCur. Long64_t TEventIter::fElemCur. protected . Definition at line 59 of file TEventIter.h. ◆ fElemFirst.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIter.html:14804,abort,abort,14804,doc/master/classTEventIter.html,https://root.cern,https://root.cern/doc/master/classTEventIter.html,1,['abort'],['abort']
Safety,"nted in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:41794,abort,abort,41794,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['abort'],['abort']
Safety,"ntent; if fname is null, send the full list of files. ; Definition at line 951 of file TApplicationServer.cxx. ◆ BrowseKey(). Int_t TApplicationServer::BrowseKey ; (; const char * ; keyname). Read key object and send it back to client. ; Definition at line 1010 of file TApplicationServer.cxx. ◆ Class(). static TClass * TApplicationServer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TApplicationServer.h. ◆ DeclFileName(). static const char * TApplicationServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TApplicationServer.h. ◆ ErrorHandler(). void TApplicationServer::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). staticprotected . The error handler function. ; It prints the message on stderr and if abort is set it aborts the application. ; Definition at line 1088 of file TApplicationServer.cxx. ◆ ExecLogon(). void TApplicationServer::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 1277 of file TApplicationServer.cxx. ◆ GetHost(). const char * TApplicationServer::GetHost ; (; ); const. inline . Definition at line 73 of file TApplicationServer.h. ◆ GetOptions(). void TApplicationServer::GetOptions ; (; Int_t * ; argc, . char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:24909,abort,abort,24909,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['abort'],['abort']
Safety,"ntents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:110702,detect,detector,110702,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"nterface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface filling the arrays x and w (static method); 3807///; 3808/// Given the number of sampling points this routine fills the arrays x and w; 3809/// of length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:144661,unsafe,unsafe,144661,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"nterface to basic system I/O routines. { return 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. Int_t GetIOVersion() const; { return fIOVersion; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. void WriteHeader(); {}. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLFile.html:34950,Recover,Recover,34950,root/html534/TXMLFile.html,https://root.cern,https://root.cern/root/html534/TXMLFile.html,1,['Recover'],['Recover']
Safety,"nterleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:37054,avoid,avoids,37054,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['avoid'],['avoids']
Safety,"nterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTipDelayTimer.html:2207,Timeout,Timeout,2207,doc/master/classTTipDelayTimer.html,https://root.cern,https://root.cern/doc/master/classTTipDelayTimer.html,3,['Timeout'],['Timeout']
Safety,"ntf(NULL,; 21331 NULL,; 21332 block,; 21333 sizeof(block),; 21334 ""%s%s\""data\"" : {%s""; 21335 ""\""read\"" : %"" INT64_FMT "",%s""; 21336 ""\""written\"" : %"" INT64_FMT ""%s""; 21337 ""}"",; 21338 (connection_info_length > 1 ? "","" : """"),; 21339 eol,; 21340 eol,; 21341 conn->consumed_content,; 21342 eol,; 21343 conn->num_bytes_sent,; 21344 eol);; 21345 connection_info_length += mg_str_append(&buffer, end, block);; 21346 }; 21347 ; 21348 /* State */; 21349 mg_snprintf(NULL,; 21350 NULL,; 21351 block,; 21352 sizeof(block),; 21353 ""%s%s\""state\"" : \""%s\"""",; 21354 (connection_info_length > 1 ? "","" : """"),; 21355 eol,; 21356 state_str);; 21357 connection_info_length += mg_str_append(&buffer, end, block);; 21358 ; 21359 /* Terminate string */; 21360 if (append_eoobj) {; 21361 strcat(append_eoobj, eoobj);; 21362 }; 21363 connection_info_length += sizeof(eoobj) - 1;; 21364 ; 21365 return (int)connection_info_length;; 21366}; 21367#endif; 21368 ; 21369 ; 21370/* Initialize this library. This function does not need to be thread safe.; 21371 */; 21372unsigned; 21373mg_init_library(unsigned features); 21374{; 21375 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21376 unsigned features_inited = features_to_init;; 21377 ; 21378 if (mg_init_library_called <= 0) {; 21379 /* Not initialized yet */; 21380 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21381 return 0;; 21382 }; 21383 }; 21384 ; 21385 mg_global_lock();; 21386 ; 21387 if (mg_init_library_called <= 0) {; 21388#if defined(_WIN32); 21389 int file_mutex_init = 1;; 21390 int wsa = 1;; 21391#else; 21392 int mutexattr_init = 1;; 21393#endif; 21394 int failed = 1;; 21395 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21396 ; 21397 if (key_create == 0) {; 21398#if defined(_WIN32); 21399 file_mutex_init =; 21400 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21401 if (file_mutex_init == 0) {; 21402 /* Start WinSock */; 21403 WSADATA data;; 21404 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:636615,safe,safe,636615,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"ntf(NULL,; 21332 NULL,; 21333 block,; 21334 sizeof(block),; 21335 ""%s%s\""data\"" : {%s""; 21336 ""\""read\"" : %"" INT64_FMT "",%s""; 21337 ""\""written\"" : %"" INT64_FMT ""%s""; 21338 ""}"",; 21339 (connection_info_length > 1 ? "","" : """"),; 21340 eol,; 21341 eol,; 21342 conn->consumed_content,; 21343 eol,; 21344 conn->num_bytes_sent,; 21345 eol);; 21346 connection_info_length += mg_str_append(&buffer, end, block);; 21347 }; 21348 ; 21349 /* State */; 21350 mg_snprintf(NULL,; 21351 NULL,; 21352 block,; 21353 sizeof(block),; 21354 ""%s%s\""state\"" : \""%s\"""",; 21355 (connection_info_length > 1 ? "","" : """"),; 21356 eol,; 21357 state_str);; 21358 connection_info_length += mg_str_append(&buffer, end, block);; 21359 ; 21360 /* Terminate string */; 21361 if (append_eoobj) {; 21362 strcat(append_eoobj, eoobj);; 21363 }; 21364 connection_info_length += sizeof(eoobj) - 1;; 21365 ; 21366 return (int)connection_info_length;; 21367}; 21368#endif; 21369 ; 21370 ; 21371/* Initialize this library. This function does not need to be thread safe.; 21372 */; 21373unsigned; 21374mg_init_library(unsigned features); 21375{; 21376 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21377 unsigned features_inited = features_to_init;; 21378 ; 21379 if (mg_init_library_called <= 0) {; 21380 /* Not initialized yet */; 21381 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21382 return 0;; 21383 }; 21384 }; 21385 ; 21386 mg_global_lock();; 21387 ; 21388 if (mg_init_library_called <= 0) {; 21389#if defined(_WIN32); 21390 int file_mutex_init = 1;; 21391 int wsa = 1;; 21392#else; 21393 int mutexattr_init = 1;; 21394#endif; 21395 int failed = 1;; 21396 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21397 ; 21398 if (key_create == 0) {; 21399#if defined(_WIN32); 21400 file_mutex_init =; 21401 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21402 if (file_mutex_init == 0) {; 21403 /* Start WinSock */; 21404 WSADATA data;; 21405 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:636648,safe,safe,636648,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"ntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetOppositeCorner(). void TGeoTrd1::GetOppositeCorner ; (; const Double_t * ; point, . Int_t ; inorm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd1::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd1::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd1::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoTrd1.h. ◆ IsCylType(). Bool_t TGeoTrd1::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoTrd1.h. ◆ operator=(). TGeoTrd1 & TGeoTrd1::operator= ; (; const TGeoTrd1 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd1::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd1::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd1::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd1::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd1::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd1::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd1::SetVertex ; (; Double_t * ; vertex); const. ◆ Sizeof3D(). void TGeoTrd1::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:27626,Safe,Safety,27626,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['Safe'],['Safety']
Safety,"ntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetOppositeCorner(). void TGeoTrd2::GetOppositeCorner ; (; const Double_t * ; point, . Int_t ; inorm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd2::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd2::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd2::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 80 of file TGeoTrd2.h. ◆ IsCylType(). Bool_t TGeoTrd2::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 70 of file TGeoTrd2.h. ◆ operator=(). TGeoTrd2 & TGeoTrd2::operator= ; (; const TGeoTrd2 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd2::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd2::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd2::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd2::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd2::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd2::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd2::SetVertex ; (; Double_t * ; vertex); const. ◆ Sizeof3D(). void TGeoTrd2::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:27849,Safe,Safety,27849,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['Safe'],['Safety']
Safety,"ntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Set cone dimensions. void SetDimensions(Double_t* param); Set cone dimensions from an array. void SetPoints(Double_t* points) const; Create cone mesh points. void SetPoints(Float_t* points) const; Create cone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:17876,Safe,SafetyS,17876,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['Safe'],['SafetyS']
Safety,"ntry (void *dirp);  Get a directory entry. Returns 0 if no more entries. ;  ; virtual Int_t GetPathInfo (const char *path, FileStat_t &buf);  Get info about a file. ;  ; virtual TClass * IsA () const;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual Int_t Locate (const char *path, TString &endurl);  ; virtual Int_t MakeDirectory (const char *dir);  Make a directory. ;  ; virtual void * OpenDirectory (const char *dir);  Open a directory. Returns 0 if directory does not exist. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual int Unlink (const char *path);  Unlink, i.e. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual Bool_t AccessPathName (const char *path, EAccessMode mode=kFileExists);  Returns FALSE if one can access a file using the specified access mode. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual void AddTimer (TTimer *t);  Add timer to list of system timers.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:1665,Abort,Abort,1665,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,2,['Abort'],['Abort']
Safety,"nts(). Bool_t TGeoConeSeg::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ InitTrigonometry(). void TGeoConeSeg::InitTrigonometry ; (; ). protected . ◆ InspectShape(). void TGeoConeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoCone. ◆ IsA(). TClass * TGeoConeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoCone.; Definition at line 183 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoConeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoCone. ◆ Safety(). Double_t TGeoConeSeg::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ Safety_v(). void TGeoConeSeg::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoCone. ◆ SafetyS(). static Double_t TGeoConeSeg::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoConeSeg::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoCone. ◆ SetConsDimensions(). void TGeoConeSeg::SetConsDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ SetDimensions(). void TGeoConeSeg::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoCone. ◆ SetPoints() [1/2]. void TGeoConeSeg::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoCone. ◆ SetPoints() [2/2]. void TGeoConeSeg::SetPoints ; (; Float_t * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:33330,Safe,SafetyS,33330,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['Safe'],['SafetyS']
Safety,"nts(). Bool_t TGeoTubeSeg::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ InitTrigonometry(). void TGeoTubeSeg::InitTrigonometry ; (; ). protected . ◆ InspectShape(). void TGeoTubeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoTube. ◆ IsA(). TClass * TGeoTubeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoTube.; Definition at line 170 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTubeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoTube. ◆ Safety(). Double_t TGeoTubeSeg::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ Safety_v(). void TGeoTubeSeg::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoTube. ◆ SafetyS(). static Double_t TGeoTubeSeg::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTubeSeg::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoTube. ◆ SetDimensions(). void TGeoTubeSeg::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoTube. ◆ SetPoints() [1/2]. void TGeoTubeSeg::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoTube. ◆ SetPoints() [2/2]. void TGeoTubeSeg::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoTube. ◆ SetSegsAndPols(). void TGeoTubeSeg::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoTube. ◆ SetTubsDimensions(). void TGeoTubeSeg::SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:31914,Safe,SafetyS,31914,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['Safe'],['SafetyS']
Safety,"nts, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Check the inside status for each of the points in the array. ; Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point ; Reimplemented from TGeoBBox.; Definition at line 382 of file TGeoScaledShape.cxx. ◆ DeclFileName(). static const char * TGeoScaledShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 71 of file TGeoScaledShape.h. ◆ DistancetoPrimitive(). Int_t TGeoScaledShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . compute closest distance from point px,py to each vertex. Should not be called. ; Reimplemented from TGeoBBox.; Definition at line 134 of file TGeoScaledShape.cxx. ◆ DistFromInside(). Double_t TGeoScaledShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from inside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 143 of file TGeoScaledShape.cxx. ◆ DistFromInside_v(). void TGeoScaledShape::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 402 of file TGeoScaledShape.cxx. ◆ DistFromOutside(). Double_t TGeoScaledShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from outside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 162 of file TGeoScaledShape.cxx. ◆ DistFromOutsid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:27281,safe,safe,27281,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,"nts, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 143 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:7640,safe,safe,7640,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"ntstatic Bool_t IsSamePoint(const Double_t *p1, const Double_t *p2)Definition TGeoArb8.h:74; TGeoArb8::~TGeoArb8~TGeoArb8() override; TGeoArb8::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoArb8.h:73; TGeoArb8::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *) const overrideDefinition TGeoArb8.h:69; TGeoArb8::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::SetPlaneVerticesvoid SetPlaneVertices(Double_t zpl, Double_t *vertices) const; TGeoArb8::ComputeBBoxvoid ComputeBBox() override; TGeoArb8::GetFittingBoxInt_t GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; TGeoBBoxDefinition TGeoBBox.h:17; TGeoGtraDefinition TGeoArb8.h:149; TGeoGtra::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoGtra::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::fTwistAngleDouble_t fTwistAngleDefinition TGeoArb8.h:152; TGeoGtra::TGeoGtraTGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:15355,safe,safe,15355,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"nue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9159,abort,aborted,9159,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,6,['abort'],['aborted']
Safety,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDNDManager.html:7386,timeout,timeout,7386,root/html528/TGDNDManager.html,https://root.cern,https://root.cern/root/html528/TGDNDManager.html,4,['timeout'],['timeout']
Safety,"number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 927will never receive the same slot at the same time.; 928This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 929processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 930 ; 931### Parallel e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:52180,safe,safe,52180,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 967will never receive the same slot at the same time.; 968This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 969processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 970 ; 971### Parallel e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53820,safe,safe,53820,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13122,recover,recover,13122,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"nvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2440 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2418 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2429 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2451 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2476 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2532 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1183 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:93441,avoid,avoid,93441,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['avoid'],['avoid']
Safety,"nvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2453 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2431 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2442 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2464 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2489 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2545 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1185 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:93886,avoid,avoid,93886,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['avoid'],['avoid']
Safety,"nverter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geomet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry__gdml.html:1427,detect,detecting,1427,doc/master/group__Geometry__gdml.html,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html,1,['detect'],['detecting']
Safety,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:1355,Timeout,Timeout,1355,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,8,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:1379,Timeout,Timeout,1379,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,4,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"o a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3636 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:82442,safe,safe,82442,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['safe'],['safe']
Safety,"o a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3703 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:82443,safe,safe,82443,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['safe'],['safe']
Safety,"o build the computation graph for the final likelihood. ; Reimplemented from RooAbsPdf.; Definition at line 1681 of file RooProdPdf.cxx. ◆ DeclFileName(). static const char * RooProdPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 190 of file RooProdPdf.h. ◆ doEvalImpl(). void RooProdPdf::doEvalImpl ; (; RooAbsArg const * ; caller, . const RooProdPdf::CacheElem & ; cache, . RooFit::EvalContext & ; ctx . ); const. private . Evaluate product of PDFs in batch mode. ; Definition at line 413 of file RooProdPdf.cxx. ◆ evaluate(). double RooProdPdf::evaluate ; (; ); const. overrideprivatevirtual . Calculate current value of object. ; Implements RooAbsReal.; Definition at line 371 of file RooProdPdf.cxx. ◆ expectedEvents(). double RooProdPdf::expectedEvents ; (; const RooArgSet * ; nset); const. overridevirtual . Return the expected number of events associated with the extendable input PDF in the product. ; If there is no extendable term, abort. ; Reimplemented from RooAbsPdf.; Definition at line 1671 of file RooProdPdf.cxx. ◆ extendMode(). RooAbsPdf::ExtendMode RooProdPdf::extendMode ; (; ); const. overridevirtual . If this product contains exactly one extendable p.d.f return the extension abilities of that p.d.f, otherwise return CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Definition at line 1660 of file RooProdPdf.cxx. ◆ factorizeProduct(). void RooProdPdf::factorizeProduct ; (; const RooArgSet & ; normSet, . const RooArgSet & ; intSet, . RooLinkedList & ; termList, . RooLinkedList & ; normList, . RooLinkedList & ; impDepList, . RooLinkedList & ; crossDepList, . RooLinkedList & ; intList . ); const. private . Factorize product in irreducible terms for given choice of integration/normalization. ; Definition at line 472 of file RooProdPdf.cxx. ◆ fillNormSetForServer(). std::unique_ptr< RooArgSet > RooProdPdf::fillNormSetForServer ; (; RooArgSet const & ; normSet, . RooAbsArg const & ; server . ); c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:89047,abort,abort,89047,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['abort'],['abort']
Safety,"o delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:10707,safe,safe,10707,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,o make sure to end it with '.gif+'. Use convert tool from ImageMagic if you want to set a different delay or enable looping. ; Definition at line 204 of file TGLAutoRotator.cxx. ◆ StartImageAutoSaveWithGUISettings(). void TGLAutoRotator::StartImageAutoSaveWithGUISettings ; (; ). Start auto-saving images as set-up via GUI. ; Definition at line 263 of file TGLAutoRotator.cxx. ◆ Stop(). void TGLAutoRotator::Stop ; (; ). Stop the auto-rotator. ; Definition at line 137 of file TGLAutoRotator.cxx. ◆ StopImageAutoSave(). void TGLAutoRotator::StopImageAutoSave ; (; ). Stops automatic saving of images. ; Definition at line 240 of file TGLAutoRotator.cxx. ◆ Streamer(). void TGLAutoRotator::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGLAutoRotator::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 114 of file TGLAutoRotator.h. ◆ Timeout(). void TGLAutoRotator::Timeout ; (; ). Called on every timer timeout. ; Moves / rotates the camera and optionally produces a screenshot. ; Definition at line 151 of file TGLAutoRotator.cxx. Member Data Documentation. ◆ fADolly. Double_t TGLAutoRotator::fADolly. protected . Definition at line 42 of file TGLAutoRotator.h. ◆ fATheta. Double_t TGLAutoRotator::fATheta. protected . Definition at line 41 of file TGLAutoRotator.h. ◆ fCamera. TGLCamera* TGLAutoRotator::fCamera. protected . Definition at line 31 of file TGLAutoRotator.h. ◆ fDeltaPhi. Double_t TGLAutoRotator::fDeltaPhi. protected . Definition at line 37 of file TGLAutoRotator.h. ◆ fDollyA0. Double_t TGLAutoRotator::fDollyA0. protected . Definition at line 44 of file TGLAutoRotator.h. ◆ fDt. Double_t TGLAutoRotator::fDt. protected . Definition at line 39 of file TGLAutoRotator.h. ◆ fImageAutoSave. Bool_t TGLAutoRotator::fImageAutoSave. protected . Definition at line 49 of file TGLAutoRotator.h. ◆ fImageCount. Int_t TGLAutoRotator::fImageCount. protec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAutoRotator.html:20274,Timeout,Timeout,20274,doc/master/classTGLAutoRotator.html,https://root.cern,https://root.cern/doc/master/classTGLAutoRotator.html,1,['Timeout'],['Timeout']
Safety,"o put a timeout on an I/O operation. By default interrupted syscalls will be restarted. ; Definition at line 199 of file TTimer.cxx. ◆ SetObject(). void TTimer::SetObject ; (; TObject * ; object). Set the object to be notified at time out. ; Removes the command to be executed (if it was set). ; Definition at line 186 of file TTimer.cxx. ◆ SetTime(). void TTimer::SetTime ; (; Long_t ; milliSec). inline . Definition at line 91 of file TTimer.h. ◆ SetTimerID(). void TTimer::SetTimerID ; (; UInt_t ; id = 0). inline . Definition at line 92 of file TTimer.h. ◆ SingleShot(). void TTimer::SingleShot ; (; Int_t ; milliSec, . const char * ; receiver_class, . void * ; receiver, . const char * ; method . ). static . This static function calls a slot after a given time interval. ; Created internal timer will be deleted after that. ; Definition at line 258 of file TTimer.cxx. ◆ Start(). void TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer with a milliSec timeout. ; If milliSec is 0 then the timeout will be the minimum timeout (see TSystem::ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or SetTime()) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also TurnOn(), Stop(), TurnOff(). ; Definition at line 213 of file TTimer.cxx. ◆ Stop(). virtual void TTimer::Stop ; (; ). inlinevirtual . Reimplemented in TGLRedrawTimer.; Definition at line 94 of file TTimer.h. ◆ Streamer(). void TTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSysEvtHandler. ◆ StreamerNVirtual(). void TTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TTimer.h. ◆ Timeout(). virtual void TTimer::Timeout ; (; ). inlinevirtual . Reimplemented in ROOT::RBrowserTimer, TCefTimer, TQt5Timer, TQt6Timer, TWebCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:24934,timeout,timeout,24934,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeaves(TBuffer& b); -- Read leaves into i/o buffers for this branch. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:22886,detect,detect,22886,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['detect'],['detect']
Safety,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:24279,detect,detect,24279,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,6,['detect'],['detect']
Safety,"o the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2203 of file TBufferFile.cxx. ◆ WriteFastArray() [5/15]. void TBufferFile::WriteFastArray ; (; const Int_t * ; ii, . Long64_t ; n . ). overridevirtual . Write array of n ints into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2096 of file TBufferFile.cxx. ◆ WriteFastArray() [6/15]. void TBufferFile::WriteFastArray ; (; const Long64_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n long longs into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:83316,abort,aborts,83316,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"o the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987737,Safe,Safe,987737,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"o the next cluster and return the starting entry; 294 // of this next cluster; 295 Long64_t Next();; 296 ; 297 // Move on to the previous cluster and return the starting entry; 298 // of this previous cluster; 299 Long64_t Previous();; 300 ; 301 // Return the start entry of the current cluster.; 302 Long64_t GetStartEntry() {; 303 return fStartEntry;; 304 }; 305 ; 306 // Return the first entry of the next cluster.; 307 Long64_t GetNextEntry() {; 308 return fNextEntry;; 309 }; 310 ; 311 Long64_t operator()() { return Next(); }; 312 };; 313 ; 314 TTree();; 315 TTree(const char* name, const char* title, Int_t splitlevel = 99, TDirectory* dir = gDirectory);; 316 ~TTree() override;; 317 ; 318 TTree(const TTree& tt) = delete;; 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:15336,safe,safe,15336,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safe']
Safety,"o to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Philippe Canal 05/2010; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TStreamerInfo.h""; 13#include ""TStreamerInfoActions.h""; 14#include ""TROOT.h""; 15#include ""TStreamerElement.h""; 16#include ""TVirtualMutex.h""; 17#include ""TInterpreter.h""; 18#include ""TError.h""; 19#include ""TVirtualArray.h""; 20#include ""TBufferFile.h""; 21#include ""TBufferText.h""; 22#include ""TMemberStreamer.h""; 23#include ""TClassEdit.h""; 24#include ""TVirtualCollectionIterators.h""; 25#include ""TProcessID.h""; 26#include ""TFile.h""; 27 ; 28static const Int_t kRegrouped = TStreamerInfo::kOffsetL;; 29 ; 30// More possible optimizations:; 31// Avoid call the virtual version of TBuffer::ReadInt and co.; 32// Merge the Reading of the version and the looking up or the StreamerInfo; 33// Avoid if (bytecnt) inside the CheckByteCount routines and avoid multiple (mostly useless nested calls); 34// Try to avoid if statement on onfile class being set (TBufferFile::ReadClassBuffer).; 35 ; 36using namespace TStreamerInfoActions;; 37 ; 38#ifdef _AIX; 39# define INLINE_TEMPLATE_ARGS; 40#else; 41# define INLINE_TEMPLATE_ARGS inline; 42#endif; 43 ; 44 ; 45namespace TStreamerInfoActions; 46{; 47 bool IsDefaultVector(TVirtualCollectionProxy &proxy); 48 {; 49 const auto props = proxy.GetProperties();; 50 const bool isVector = proxy.GetCollectionType() == ROOT::kSTLvector;; 51 const bool hasDefaultAlloc = !(props & TVirtualCollectionProxy::kCustomAlloc);; 52 const bool isEmulated = props & TVirtualCollectionProxy::kIsEmulated;; 53 ; 54 return isEmulated || (isVector && hasDefaultAlloc);; 55 }; 56 ; 57 template <type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:1192,Avoid,Avoid,1192,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"o use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml . Definition at line 3975 of file TGeoManager.cxx. ◆ FindDuplicateMaterial(). TGeoMaterial * TGeoManager::FindDuplicateMaterial ; (; const TGeoMaterial * ; mat); const. Find if a given material duplicates an existing one. ; Definition at line 2992 of file TGeoManager.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoManager::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 2755 of file TGeoManager.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoManager::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 2736 of file TGeoManager.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoManager::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool_t ; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:85690,safe,safe,85690,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safe']
Safety,"o). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInterpreter.html:20530,avoid,avoids,20530,root/html528/TInterpreter.html,https://root.cern,https://root.cern/root/html528/TInterpreter.html,4,['avoid'],['avoids']
Safety,"o, double hi)Request uniform smearing of sum of parameters in paramSet uniform smearing in range [lo,...Definition RooRandomizeParamMCSModule.cxx:124; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf803_mcstudy_addons2Definition rf803_mcstudy_addons2.py:1; ; [#0] WARNING:InputArguments -- The parameter 'wtop' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 495; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 490; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 485; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 480; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 475; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 470; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 465; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 460; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 455; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 450; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 445; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 440; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 435; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 430; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 425; [#0] PROGRESS:Generation -- RooMCStudy::run: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:7912,safe,safe,7912,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,1,['safe'],['safe']
Safety,"o. ; Reimplemented from RooAbsReal.; Definition at line 136 of file RooRealSumFunc.cxx. ◆ binBoundaries(). std::list< double > * RooRealSumFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Retrieve bin boundaries if this distribution is binned in obs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 142 of file RooRealSumFunc.cxx. ◆ canNodeBeCached(). CacheMode RooRealSumFunc::canNodeBeCached ; (; ); const. inlineoverridevirtual . Reimplemented from RooAbsArg.; Definition at line 58 of file RooRealSumFunc.h. ◆ checkObservables(). bool RooRealSumFunc::checkObservables ; (; const RooArgSet * ; nset); const. overridevirtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented from RooAbsArg.; Definition at line 123 of file RooRealSumFunc.cxx. ◆ Class(). static TClass * RooRealSumFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRealSumFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealSumFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file RooRealSumFunc.h. ◆ clone(). TObject * RooRealSumFunc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 33 of file RooRealSumFunc.h. ◆ coefList(). const RooArgList & RooRealSumFunc::coefList ; (; ); const. inline . Definition at line 45 of file RooRealSumFunc.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooRealSumFunc::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:64196,abort,abort,64196,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['abort'],['abort']
Safety,"o; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:3298,safe,safe,3298,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['safe'],['safe']
Safety,"oAbsPdf.; Definition at line 1746 of file RooProdPdf.cxx. ◆ initializeFromCmdArgList(). void RooProdPdf::initializeFromCmdArgList ; (; const RooArgSet & ; fullPdfSet, . const RooLinkedList & ; l . ). private . Initialize RooProdPdf configuration from given list of RooCmdArg configuration arguments and set of 'regular' p.d.f.s in product. ; Definition at line 290 of file RooProdPdf.cxx. ◆ IsA(). TClass * RooProdPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 190 of file RooProdPdf.h. ◆ isBinnedDistribution(). bool RooProdPdf::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . If all components that depend on obs are binned that so is the product. ; Reimplemented from RooAbsReal.; Definition at line 2122 of file RooProdPdf.cxx. ◆ isDirectGenSafe(). bool RooProdPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Forward determination of safety of internal generator code to component p.d.f that would generate the given observable. ; Reimplemented from RooAbsPdf.; Definition at line 1825 of file RooProdPdf.cxx. ◆ makeCondPdfRatioCorr(). std::unique_ptr< RooAbsReal > RooProdPdf::makeCondPdfRatioCorr ; (; RooAbsReal & ; term, . const RooArgSet & ; termNset, . const RooArgSet & ; termImpSet, . const char * ; normRange, . const char * ; refRange . ); const. private . For single normalization ranges. ; Definition at line 971 of file RooProdPdf.cxx. ◆ makeRGPPName(). std::string RooProdPdf::makeRGPPName ; (; const char * ; pfx, . const RooArgSet & ; term, . const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; isetRangeName . ); const. private . Make an appropriate automatic name for a RooGenProdProj object in getPartIntList() ; Definition at line 1555 of file RooProdPdf.cxx. ◆ pdfList(). const RooArgList & RooProdPdf::pdfList ; (; ); const. inline . Definition at line 67 of file RooProdPdf.h. ◆ plotSamplingHint(). std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:96699,safe,safety,96699,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['safe'],['safety']
Safety,"oAbsPdf::createNLL(), where the pdf and some configuration options are retrieved from the ModelConfig. ; The options taken from the ModelConfig are:. ConditionalObservables(); GlobalObservables(); ExternalConstraints(). Except for the options above, you can still pass all the other command arguments supported by RooAbsPdf::createNLL(). ; Definition at line 318 of file ModelConfig.h. ◆ createNLLImpl(). std::unique_ptr< RooAbsReal > RooStats::ModelConfig::createNLLImpl ; (; RooAbsData & ; data, . const RooLinkedList & ; cmdList . ); const. private . Definition at line 447 of file ModelConfig.cxx. ◆ DeclFileName(). static const char * RooStats::ModelConfig::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 368 of file ModelConfig.h. ◆ DefineSetInWS(). void RooStats::ModelConfig::DefineSetInWS ; (; const char * ; name, . const RooArgSet & ; set . ). protected . helper functions to define a set in the WS ; helper functions to avoid code duplication ; Definition at line 289 of file ModelConfig.cxx. ◆ fitTo(). template<typename... CmdArgs_t> . RooStats::ModelConfig::fitTo ; (; RooAbsData & ; data, . CmdArgs_t const &... ; cmdArgs . ). inline . Wrapper around RooAbsPdf::fitTo(), where the pdf and some configuration options are retrieved from the ModelConfig. ; See ModelConfig::createNLL() for more information. ; Definition at line 324 of file ModelConfig.h. ◆ fitToImpl(). std::unique_ptr< RooFitResult > RooStats::ModelConfig::fitToImpl ; (; RooAbsData & ; data, . const RooLinkedList & ; cmdList . ). private . Definition at line 461 of file ModelConfig.cxx. ◆ GetConditionalObservables(). const RooArgSet * RooStats::ModelConfig::GetConditionalObservables ; (; ); const. inline . get RooArgSet for conditional observables (return nullptr if not existing) ; Definition at line 289 of file ModelConfig.h. ◆ GetConstraintParameters(). const RooArgSet * RooStats::ModelConfig::GetConstraintParameters ; (; ); const. inline ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html:23453,avoid,avoid,23453,doc/master/classRooStats_1_1ModelConfig.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html,1,['avoid'],['avoid']
Safety,"oAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1; 0x2ee1ac0/V- RooRealVar::bkgfrac = 0.5; 0x4d76f30/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7444460/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x3bcf160/V- RooRealVar::sigma1 = 0.5; 0x736e030/V- RooRealVar::sig1frac = 0.8; 0x7422370/V- R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8py.html:2673,safe,safe,2673,doc/master/rf206__treevistools_8py.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html,1,['safe'],['safe']
Safety,"oAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf206_treevistoolsDefinition rf206_treevistools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7ffd18ff9e50 RooAddPdf::model = 0.582695/1 [Auto,Clean] ; 0x7ffd18ff8f60/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffd18ff65f8/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff7bd8/V- RooRealVar::a0 = 0.5; 0x7ffd18ff7fc0/V- RooRealVar::a1 = 0.2; 0x7ffd18ff8790/V- RooRealVar::bkg1frac = 0.2; 0x7ffd18ff6b28/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff83a8/V- RooRealVar::alpha = -1; 0x7ffd18ff9a68/V- RooRealVar::bkgfrac = 0.5; 0x7ffd18ff5428/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffd18ff5b48/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff8b78/V- RooRealVar::mean = 5; 0x7ffd18ff702",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8C.html:3856,safe,safe,3856,doc/master/rf206__treevistools_8C.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html,1,['safe'],['safe']
Safety,"oBBox. ◆ IsA(). TClass * TGeoHype::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoHype.h. ◆ IsCylType(). Bool_t TGeoHype::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoHype.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoHype::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoHype & TGeoHype::operator= ; (; const TGeoHype & ; ). privatedelete . ◆ RadiusHypeSq(). Double_t TGeoHype::RadiusHypeSq ; (; Double_t ; z, . Bool_t ; inner . ); const. ◆ Safety(). Double_t TGeoHype::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoHype::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToHype(). Double_t TGeoHype::SafetyToHype ; (; const Double_t * ; point, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoHype::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoHype::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetHypeDimensions(). void TGeoHype::SetHypeDimensions ; (; Double_t ; rin, . Double_t ; stin, . Double_t ; rout, . Double_t ; stout, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoHype::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoHype::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoHype::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:33437,Safe,SafetyToHype,33437,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['Safe'],['SafetyToHype']
Safety,"oBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped, depending on the value of precision:; precision < 0.: None of the PDFs are touched, bin sampling is off.; precision = 0.: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision forwarded to the integrator is 1.E-4 (the default argument of the constructor).; precision > 0.: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are fit to (see next paragraph). The same ‘'precision’` is used for all integrators. Simulating a binned fit using RooDataSet; Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to integrate over in this kind of dataset).; In this case, IntegrateBins(>0.) needs to be used, and the desired binning needs to be assigned to the observable of the dataset: RooRealVar x(""x"", ""x"", 0., 5.);; x.setBins(10);; ; // <create dataset and model>; ; model.fitTo(data, IntegrateBins(>0.));; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; See alsoRooAbsPdf::fitTo() . IntegrateBins(); NoteThis feature is currently limited to one-dimensional PDFs.; . Binned fit without RooBinSamplingPdf Binned fit with RooBinSamplingPdf . Definition at line 28 of file RooBinSamplingPdf.h. Public Member Functions;  RooBinSamplingPdf ();  ;  RooBinSamplingPdf (const char *name, const char *title, RooAbsRealLValue &observable, RooAbsPdf &inputPdf, double epsilon=1.E-4);  Construct a new RooBinSamplingPdf. ;  ;  RooBinSamplingPdf (const RooBinSamplingPdf &other, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:3775,detect,detect,3775,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['detect'],['detect']
Safety,"oBoolNode::MakeClone ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ operator=(). TGeoBoolNode & TGeoBoolNode::operator= ; (; const TGeoBoolNode & ; ). privatedelete . ◆ Paint(). void TGeoBoolNode::Paint ; (; Option_t * ; option). overridevirtual . Special schema for feeding the 3D buffers to the painter client. ; Reimplemented from TObject.; Reimplemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction.; Definition at line 295 of file TGeoBoolNode.cxx. ◆ RegisterMatrices(). void TGeoBoolNode::RegisterMatrices ; (; ). Register all matrices of the boolean node and descendents. ; Definition at line 341 of file TGeoBoolNode.cxx. ◆ ReplaceMatrix(). Bool_t TGeoBoolNode::ReplaceMatrix ; (; TGeoMatrix * ; mat, . TGeoMatrix * ; newmat . ). Replace one of the matrices. ; Does not work with TGeoIdentity. Returns true if replacement was successful. ; Definition at line 357 of file TGeoBoolNode.cxx. ◆ Safety(). virtual Double_t TGeoBoolNode::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ SavePrimitive(). void TGeoBoolNode::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction.; Definition at line 383 of file TGeoBoolNode.cxx. ◆ SetPoints() [1/2]. void TGeoBoolNode::SetPoints ; (; Double_t * ; points); const. virtual . Fill buffer with shape vertices. ; Definition at line 400 of file TGeoBoolNode.cxx. ◆ SetPoints() [2/2]. void TGeoBoolNode::SetPoints ; (; Float_t * ; points); const. virtual . Fill buffer with shape vertices. ; Definition at line 410 of file TGeoBoolNode.cxx. ◆ SetSelected(). void TGeoBoolNode::SetSelected ; (; Int_t ; sel). Set the selected branch. ; Definition at line 120 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:20160,Safe,Safety,20160,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['Safe'],['Safety']
Safety,"oChecker Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TGeoChecker Class ReferenceThe Geometry Package » Geometry painter. ; Geometry checking package. ; TGeoChecker class provides several geometry checking methods. There are two types of tests that can be performed. One is based on random sampling or ray-tracing and provides a visual check on how navigation methods work for a given geometry. The second actually checks the validity of the geometry definition in terms of overlapping/extruding objects. Both types of checks can be done for a given branch (starting with a given volume) as well as for the geometry as a whole.; TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z); This method can be called directly from the TGeoManager class and print a report on how a given point is classified by the modeller: which is the full path to the deepest node containing it, and the (under)estimation of the distance to the closest boundary (safety).; TGeoChecker::RandomPoints(Int_t npoints); Can be called from TGeoVolume class. It first draws the volume and its content with the current visualization settings. Then randomly samples points in its bounding box, plotting in the geometry display only the points classified as belonging to visible volumes.; TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz); Can be called and acts in the same way as the previous, but instead of points, rays having random isotropic directions are generated from the given point. A raytracing algorithm propagates all rays until they exit geometry, plotting all segments crossing visible nodes in the same color as these.; TGeoChecker::Test(Int_t npoints); Implementation of TGeoManager::Test(). Computes the time for the modeller to find out ""Where am I?"" for a given number of ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:1168,safe,safety,1168,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"oChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume * ; vol, . TGeoVoxelFinder * ; voxels, . Double_t * ; xyz, . Int_t ; npoints . ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. ◆ Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoChecker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TGeoChecker.h. ◆ CleanPoints(). void TGeoChecker::CleanPoints ; (; Double_t * ; points, . Int_t & ; numPoints . ); const. private . Number of points on mesh to be checked. ; Clean-up the mesh of pcon/pgon from useless points. ; Definition at line 992 of file TGeoChecker.cxx. ◆ DeclFileName(). static const char * TGeoChecker::Decl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21975,safe,safety,21975,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"oEventEntries* map.; 374 /// In the single threaded case, the two numbers are the same as the entry range corresponds; 375 /// to the number of events in an individual file (each sample is simply a single file).; 376 /// In the multithreaded case, the idea is to accumulate the higher event entry value until; 377 /// the total number of events in a given file is reached.; 378 void registerNewSample(unsigned int /*slot*/, const ROOT::RDF::RSampleInfo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_clock::now() - fLastPrintTime) < fPrintInterval) {; 409 return;; 410 }; 411 ; 412 // ***************************************************; 413 // Protected by lock from here:; 414 // ***************************************************; 415 if (!fPrintMutex.try_lock()); 416 return;; 417 std::lock_guard<std::mutex> l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:18735,safe,safe,18735,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:128939,recover,recover,128939,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['recover'],['recover']
Safety,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:127284,recover,recover,127284,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['recover'],['recover']
Safety,"oManager *manager);  Geometry painter default constructor. ;  ;  ~TVirtualGeoPainter () override;  Geometry painter default destructor. ;  ; virtual void AddSize3D (Int_t numpoints, Int_t numsegs, Int_t numpolys)=0;  ; virtual TVirtualGeoTrack * AddTrack (Int_t id, Int_t pdgcode, TObject *particle)=0;  ; virtual void AddTrackPoint (Double_t *point, Double_t *box, Bool_t reset=kFALSE)=0;  ; virtual void BombTranslation (const Double_t *tr, Double_t *bombtr)=0;  ; virtual void CheckBoundaryErrors (Int_t ntracks=1000000, Double_t radius=-1.)=0;  ; virtual void CheckBoundaryReference (Int_t icheck=-1)=0;  ; virtual void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const =0;  ; virtual void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)=0;  ; virtual void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const =0;  ; virtual void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0;  ; virtual void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0;  ; virtual Int_t CountVisibleNodes ()=0;  ; virtual void DefaultAngles ()=0;  ; virtual void DefaultColors ()=0;  ; virtual Int_t DistanceToPrimitiveVol (TGeoVolume *vol, Int_t px, Int_t py)=0;  ; virtual void DrawBatemanSol (TGeoBatemanSol *sol, Option_t *option="""")=0;  ; virtual void DrawCurrentPoint (Int_t color)=0;  ; virtual void DrawOnly (Option_t *option="""")=0;  ; virtual void DrawOverlap (void *ovlp, Option_t *option="""")=0;  ; virtual void DrawPanel ()=0;  ; virtual void DrawPath (const char *path, Option_t *option="""")=0;  ; virtual void DrawPolygon (const TGeoPolygon *poly)=0;  ; virtual void DrawShape (TGeoShape *shape, Option_t *option="""")=0;  ; virtual void DrawVolume (TGeoVolume *vol, Option_t *option="""")=0;  ; virtual void EditGeometry (Option_t *option="""")=0;  ; virtual void EstimateCameraMove (Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualGeoPainter.html:2505,safe,safety,2505,doc/master/classTVirtualGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTVirtualGeoPainter.html,1,['safe'],['safety']
Safety,"oManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:132488,safe,safety,132488,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"oNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::IsSameLocationBool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change=kFALSE)Checks if point (x,y,z) is still in the current node.Definition TGeoNavigator.cxx:2446; TGeoNavigator::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:238; TGeoNavigator::GetVirtualLevelInt_t GetVirtualLevel()Find level of virtuality of current overlapping node (number of levels up having the same tracking me...Definition TGeoNavigator.cxx:2331; TGeoNavigator::InitTrackTGeoNode * InitTrack(const Double_t *point, const Double_t *dir)Initialize current poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:224585,Safe,Safety,224585,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"oPhysicalNode * FindNodeBVH (Double_t point[3]);  Finds physical node containing the point. ;  ; TGeoPhysicalNode * FindNodeLoop (Double_t point[3]);  Finds physical node containing the point using simple algorithm (for debugging) ;  ; TGeoPhysicalNode * FindNodeOrig (Double_t point[3]);  Finds physical node containing the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoParallelWorld:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16167,Safe,SafetyBVH,16167,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyBVH']
Safety,"oShape.; Reimplemented in TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoShapeAssembly, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, TGeoVGShape, TGeoCone, TGeoConeSeg, and TGeoScaledShape. ◆ Sizeof3D(). void TGeoBBox::Sizeof3D ; (; ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ Streamer(). void TGeoBBox::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ StreamerNVirtual(). void TGeoBBox::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 99 of file TGeoBBox.h. Member Data Documentation. ◆ cases. Bool_t DO NOT USE !The overlap detection does not work for all TGeoBBox::cases. Definition at line 41 of file TGeoBBox.h. ◆ DEPRECATED. Bool_t TGeoBBox::DEPRECATED. Definition at line 41 of file TGeoBBox.h. ◆ fDX. Double_t TGeoBBox::fDX. protected . Definition at line 20 of file TGeoBBox.h. ◆ fDY. Double_t TGeoBBox::fDY. protected . Definition at line 21 of file TGeoBBox.h. ◆ fDZ. Double_t TGeoBBox::fDZ. protected . Definition at line 22 of file TGeoBBox.h. ◆ fOrigin. Double_t TGeoBBox::fOrigin[3]. protected . Definition at line 23 of file TGeoBBox.h. Libraries for TGeoBBox:. [legend]; The documentation for this class was generated from the following file:; geom/geom/inc/TGeoBBox.h. TGeoBBox. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:40065,detect,detection,40065,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['detect'],['detection']
Safety,"oShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t*) const; virtual voidSetPoints(Float_t*) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; voidTGeoShape::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHalfSpace.html:7527,Safe,SafetyPhi,7527,root/html528/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html528/TGeoHalfSpace.html,1,['Safe'],['SafetyPhi']
Safety,"oading...; Searching...; No Matches. TBuffer.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 6da0b5b613bbcfaa3a5cd4074e7b2be2448dfb31 $; 2// Author: Fons Rademakers 04/05/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TBuffer; 13\ingroup Base; 14 ; 15Buffer base class used for serializing objects.; 16*/; 17 ; 18#include ""TBuffer.h""; 19#include ""TClass.h""; 20#include ""TProcessID.h""; 21 ; 22constexpr Int_t kExtraSpace = 8; // extra space at end of buffer (used for free block count); 23constexpr Int_t kMaxBufferSize = 0x7FFFFFFE; // largest possible size.; 24 ; 25 ; 26ClassImp(TBuffer);; 27 ; 28/// Default streamer implementation used by ClassDefInline to avoid; 29/// requirement to include TBuffer.h; 30void ROOT::Internal::DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer); 31{; 32 if (R__b.IsReading()); 33 R__b.ReadClassBuffer(cl, objpointer);; 34 else; 35 R__b.WriteClassBuffer(cl, objpointer);; 36}; 37 ; 38////////////////////////////////////////////////////////////////////////////////; 39/// The user has provided memory than we don't own, thus we can not extent it; 40/// either.; 41 ; 42static char *R__NoReAllocChar(char *, size_t, size_t); 43{; 44 return nullptr;; 45}; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 49/// TBuffer::kWrite. By default the I/O buffer has a size of; 50/// TBuffer::kInitialSize (1024) bytes.; 51 ; 52TBuffer::TBuffer(EMode mode); 53{; 54 fBufSize = kInitialSize;; 55 fMode = mode;; 56 fVersion = 0;; 57 fParent = nullptr;; 58 ; 59 SetBit(kIsOwner)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:1121,avoid,avoid,1121,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety,"oat_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:10109,abort,abort,10109,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"obal histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Increment bin content by a weight w.; 1275/// Passing an out-of-range bin leads to undefined behavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:49871,avoid,avoid,49871,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:27379,safe,safe,27379,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34606,safe,safe,34606,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safe']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34394,safe,safe,34394,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safe']
Safety,"obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:2484,safe,safe,2484,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,3,['safe'],['safe']
Safety,"obj) {; 809 return subobj;; 810 }; 811 }; 812 }; 813 return nullptr;; 814}; 815 ; 816////////////////////////////////////////////////////////////////////////////////; 817/// Return pointer to object identified by namecycle.; 818///; 819/// namecycle has the format name;cycle; 820/// - name = * is illegal, cycle = * is illegal; 821/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 822///; 823/// examples:; 824/// - foo : get object named foo in memory; 825/// if object is not in memory, try with highest cycle from file; 826/// - foo;1 : get cycle 1 of foo on file; 827///; 828/// The retrieved object should in principle derive from TObject.; 829/// If not, the function TDirectory::GetObject should be called.; 830/// However, this function will still work for a non-TObject, providing that; 831/// the calling application cast the return type to the correct type (which; 832/// is the actual type of the object).; 833///; 834/// NOTE:; 835///; 836/// The method GetObject offer better protection and avoid the need; 837/// for any cast:; 838/// ~~~ {.cpp}; 839/// MyClass *obj;; 840/// directory->GetObject(""some object"",obj);; 841/// if (obj) { ... the object exist and inherits from MyClass ... }; 842/// ~~~; 843///; 844/// VERY IMPORTANT NOTE:; 845///; 846/// In case the class of this object derives from TObject but not; 847/// as a first inheritance, one must use dynamic_cast<>().; 848/// #### Example 1: Normal case:; 849/// ~~~ {.cpp}; 850/// class MyClass : public TObject, public AnotherClass; 851/// ~~~; 852/// then on return, one can do:; 853/// ~~~ {.cpp}; 854/// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; 855/// ~~~; 856/// #### Example 2: Special case:; 857/// ~~~ {.cpp}; 858/// class MyClass : public AnotherClass, public TObject; 859/// ~~~; 860/// then on return, one must do:; 861/// ~~~ {.cpp}; 862/// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 863/// ~~~; 864/// Of course, dynamic_cast<> can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:29241,avoid,avoid,29241,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:11111,timeout,timeout,11111,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMemberInspector.html:2302,avoid,avoid,2302,root/html528/TMemberInspector.html,https://root.cern,https://root.cern/root/html528/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMemberInspector.html:2302,avoid,avoid,2302,root/html530/TMemberInspector.html,https://root.cern,https://root.cern/root/html530/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemberInspector.html:2302,avoid,avoid,2302,root/html532/TMemberInspector.html,https://root.cern,https://root.cern/root/html532/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:15024,safe,safely,15024,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,6,['safe'],['safely']
Safety,"object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:10241,abort,abort,10241,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,2,['abort'],['abort']
Safety,"object. The same prior is used; for all the TEfficiency objects. Example:; If you use cuts to select electrons which can originate from two different; processes, you can determine the selection efficiency for each process. The; overall selection efficiency is then the combined efficiency. The weights to be used in the; combination should be the probability that an; electron comes from the corresponding process. VI. Further operations; VI.1 Information about the internal histograms; The methods GetPassedHistogram and GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g. the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling GetCopyPassedHisto or GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them. Example:; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directoy and write the file; //clone->SetDirectory(gDirectory);; //pFile->Wrtie();; //delete histogram object; delete clone;; clone = 0;. It is also possible to set the internal total or passed histogram by using the; methods SetPassedHistogram or; SetTotalHistogram.; In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It sometimes might be; impossible to change the histograms in a consistent way. Therefore one can force; the replacement by passing the opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEfficiency.html:17436,avoid,avoid,17436,root/html602/TEfficiency.html,https://root.cern,https://root.cern/root/html602/TEfficiency.html,2,['avoid'],['avoid']
Safety,"ocation of ROOT and non-PCH-able glibc headers.; Fix parsing of definition for forward declared enums ROOT-7419; Pass CXXFLAGS to the PCH generator, to ensure platform consistency.; Work around linker assert when building with GCC on OS X (PR #68). PyROOT. Fix lookup of templated classes in namespace with arguments that have ‘std::’ in their name ROOT-7448; Use GetTrueTypeName() instead of GetFullTypeName(), as the latter loses namespaces; Strip down number of libraries linked to libPyROOT in order to reduce to the minimum the time needed to import the ROOT module. TFormula, TF1. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range.; Added helper classes TF1NormSum, TF1Convolution.; Fix a bug in calling TF1::Update when changing the parameter values. Fix also the TF1Convolution.; Fix the caching of the parameters in TF1NormSum to avoid recomputing integrals for same parameter values.; Remove unwanted printout from Streamer method. RooFit. Fix for contour computations in RooMinimizer[ROOT-7290]. Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Tree. TTreeReaderArray now supports vector<builtin-type>. Graphics. Fix file corruption in TTeXDump::DrawPolyMarker.; Make sure the line width used to draw #sqrt is always >=1. Release 6.04/04; Build System. Fix generation of PCH with CXX flags with spaces ROOT-7478; Implemented option ‘geocad’ with CMake making use of the OpenCASCADE software package.; Fix option ‘rpath’ for CMake and ensure that works for MacOSX 10.11. Core. Fix the location of include files in ROOTINCDIR/include instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:28086,avoid,avoid,28086,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"ocation, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:1955,abort,abort,1955,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['abort'],['abort']
Safety,"ocation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9080,Abort,Abort,9080,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,2,['Abort'],['Abort']
Safety,"ocket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:12917,timeout,timeout,12917,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,3,['timeout'],['timeout']
Safety,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:47122,safe,safely,47122,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"ocumentation; TGeoPolygon(); Dummy constructor. TGeoPolygon(Int_t nvert); Default constructor. ~TGeoPolygon(); Destructor. Double_t Area() const; Computes area of the polygon in [length^2]. Bool_t Contains(Double_t* point) const; Check if a point given by X = point[0], Y = point[1] is inside the polygon. void ConvexCheck(); Check polygon convexity. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. Bool_t IsRightSided(Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoPolygon.h 27466 2009-02-17 12:53:37Z brun $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPolygon.html:8545,Safe,Safety,8545,root/html528/TGeoPolygon.html,https://root.cern,https://root.cern/root/html528/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,"ocumentation; TGeoPolygon(); Dummy constructor. TGeoPolygon(Int_t nvert); Default constructor. ~TGeoPolygon(); Destructor. Double_t Area() const; Computes area of the polygon in [length^2]. Bool_t Contains(Double_t* point) const; Check if a point given by X = point[0], Y = point[1] is inside the polygon. void ConvexCheck(); Check polygon convexity. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. Bool_t IsRightSided(Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoPolygon.h 27466 2009-02-17 12:53:37Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPolygon.html:8614,Safe,Safety,8614,root/html530/TGeoPolygon.html,https://root.cern,https://root.cern/root/html530/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,"ocumentation; TGeoPolygon(); Dummy constructor. TGeoPolygon(Int_t nvert); Default constructor. ~TGeoPolygon(); Destructor. Double_t Area() const; Computes area of the polygon in [length^2]. Bool_t Contains(Double_t* point) const; Check if a point given by X = point[0], Y = point[1] is inside the polygon. void ConvexCheck(); Check polygon convexity. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. Bool_t IsRightSided(Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoPolygon.h 27466 2009-02-17 12:53:37Z brun $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPolygon.html:8614,Safe,Safety,8614,root/html532/TGeoPolygon.html,https://root.cern,https://root.cern/root/html532/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBoolNode.html:2422,safe,safe,2422,root/html534/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html,3,['safe'],['safe']
Safety,"od, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14378,safe,safe,14378,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,1,['safe'],['safe']
Safety,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:2570,recover,recovered,2570,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,5,['recover'],['recovered']
Safety,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; ; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:2570,recover,recovered,2570,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,1,['recover'],['recovered']
Safety,"odel parameters; params = model.getParameters({x}); ; # Save snapshot of prefit parameters; initParams = params.snapshot(); ; # Do fit to data, obtain error estimates on parameters; data = model.generate({x}, 1000); model.fitTo(data, PrintLevel=-1); ; # Print LateX table of parameters of pdf; # --------------------------------------------------------------------------; ; # Print parameter list in LaTeX for (one column with names, column with; # values); params.printLatex(); ; # Print parameter list in LaTeX for (names values|names values); params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.79\pm 0.05$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8py.html:3059,safe,safe,3059,doc/master/rf407__latextables_8py.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html,1,['safe'],['safe']
Safety,"of TH1/2/3 into this RooDataHist. ; The category indexCat labels the sources in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels and the import source ; Definition at line 497 of file RooDataHist.cxx. ◆ initialize(). void RooDataHist::initialize ; (; const char * ; binningName = nullptr, . bool ; fillTree = true . ). protected . Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ; Definition at line 783 of file RooDataHist.cxx. ◆ initializeAsymErrArrays(). void RooDataHist::initializeAsymErrArrays ; (; ); const. private . Definition at line 1551 of file RooDataHist.cxx. ◆ interpolateDim(). double RooDataHist::interpolateDim ; (; int ; iDim, . double ; xval, . size_t ; centralIdx, . int ; intOrder, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). protected . Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ; Parameters. [in]iDimIndex of the histogram dimension along which to interpolate. ; [in]xvalValue of histogram variable at dimension iDim for which we want to interpolate the histogram weight. ; [in]centralIdxIndex of the bin that the point at which we interpolate the histogram weight falls into (can be obtained with RooDataHist::calcTreeIndex). ; [in]intOrderInterpolation order, i.e. how many neighbouring bins are used for the interpolation. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1638 of file RooDataHist.cxx. ◆ interpolateLinear(). void RooDataHist::interpolateLinear ; (; double * ; output, . std::span< const double > ; xVals, . bool ; correctForBinSize, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:63028,safe,safe,63028,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety,"of consecutive free segments on the file. At the same time, the first; 1482/// 4 bytes of the freed record on the file are overwritten by GAPSIZE; 1483/// where GAPSIZE = -(Number of bytes occupied by the record).; 1484 ; 1485void TFile::MakeFree(Long64_t first, Long64_t last); 1486{; 1487 TFree *f1 = (TFree*)fFree->First();; 1488 if (!f1) return;; 1489 TFree *newfree = f1->AddFree(fFree,first,last);; 1490 if(!newfree) return;; 1491 Long64_t nfirst = newfree->GetFirst();; 1492 Long64_t nlast = newfree->GetLast();; 1493 Long64_t nbytesl= nlast-nfirst+1;; 1494 if (nbytesl > 2000000000) nbytesl = 2000000000;; 1495 Int_t nbytes = -Int_t (nbytesl);; 1496 Int_t nb = sizeof(Int_t);; 1497 char * buffer = new char[nb];; 1498 char * psave = buffer;; 1499 tobuf(buffer, nbytes);; 1500 if (last == fEND-1) fEND = nfirst;; 1501 Seek(nfirst);; 1502 // We could not update the meta data for this block on the file.; 1503 // This is not fatal as this only means that we won't get it 'right'; 1504 // if we ever need to Recover the file before the block is actually; 1505 // (attempted to be reused.; 1506 // coverity[unchecked_value]; 1507 WriteBuffer(psave, nb);; 1508 if (fMustFlush) Flush();; 1509 delete [] psave;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// List the contents of a file sequentially.; 1514/// For each logical record found, it prints:; 1515///; 1516/// Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor; 1517///; 1518/// Example of output; 1519///; 1520/// 20010404/150437 At:64 N=150 TFile; 1521/// 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 1522/// 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 1523/// 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 1524/// 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 1525/// 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 1526/// 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 1527/// 20010404/150441 At:155364 N=29594 TBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:54010,Recover,Recover,54010,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Recover'],['Recover']
Safety,"of file MethodANNBase.h. Public Types; enum  EEstimator { kMSE =0; , kCE; };  ;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  MethodANNBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &theData, const TString &theOption);  standard constructor Note: Right now it is an option to choose the neuron input function, but only the input function ""sum"" leads to weight convergence – otherwise the weights go to nan and lead to an ABORT. ;  ;  MethodANNBase (Types::EMVA methodType, DataSetInfo &theData, const TString &theWeightFile);  construct the Method from the weight file ;  ; virtual ~MethodANNBase ();  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  create XML description of ANN classifier ;  ; const Ranking * CreateRanking ();  compute ranking of input variables by summing function of weights ;  ; Bool_t Debug () const;  who the hell makes such strange Debug flags that even use ""global pointers"".. ;  ; virtual void DeclareOptions ();  define the options (their key words) that can be set in the option string here the options valid for ALL MVA methods are declared. ;  ; template<typename WriteIterator > ; void GetLayerActivation (size_t layer, WriteIterator writeIterator);  ; virtual const std::vector< Float_t > & Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:1725,ABORT,ABORT,1725,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['ABORT'],['ABORT']
Safety,"of file TGeoParaboloid.h. ◆ InspectShape(). void TGeoParaboloid::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoParaboloid::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoParaboloid.h. ◆ IsCylType(). Bool_t TGeoParaboloid::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoParaboloid.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoParaboloid::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoParaboloid & TGeoParaboloid::operator= ; (; const TGeoParaboloid & ; ). privatedelete . ◆ Safety(). Double_t TGeoParaboloid::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoParaboloid::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoParaboloid::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoParaboloid::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetParaboloidDimensions(). void TGeoParaboloid::SetParaboloidDimensions ; (; Double_t ; rlo, . Double_t ; rhi, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoParaboloid::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoParaboloid::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoParaboloid::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Sizeof3D(). void TGeoPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:28592,safe,safe,28592,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety,"of file TGeoPcon.h. ◆ IsCylType(). Bool_t TGeoPcon::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoPcon.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon & ; ). protecteddelete . ◆ Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. ◆ Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_t ; ipl). inline . Definition at line 96 of file TGeoPcon.h. ◆ Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_t ; ipl). inline . Definition at line 95 of file TGeoPcon.h. ◆ Safety(). Double_t TGeoPcon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Bool_t ; in = kTRUE, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [1/2]. void TGeoPcon::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [2/2]. void TGeoPcon::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31740,safe,safe,31740,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['safe'],['safe']
Safety,"of file TGeoXtru.h. ◆ GetZ() [2/2]. Double_t TGeoXtru::GetZ ; (; Int_t ; ipl); const. ◆ InspectShape(). void TGeoXtru::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoXtru::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 121 of file TGeoXtru.h. ◆ IsPointInsidePlane(). Bool_t TGeoXtru::IsPointInsidePlane ; (; const Double_t * ; point, . Double_t * ; vert, . Double_t * ; norm . ); const. protected . ◆ MakeBuffer3D(). TBuffer3D * TGeoXtru::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoXtru & TGeoXtru::operator= ; (; const TGeoXtru & ; ). protecteddelete . ◆ Safety(). Double_t TGeoXtru::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoXtru::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToSector(). Double_t TGeoXtru::SafetyToSector ; (; const Double_t * ; point, . Int_t ; iz, . Double_t ; safmin, . Bool_t ; in . ). protected . ◆ SavePrimitive(). void TGeoXtru::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCurrentVertices(). void TGeoXtru::SetCurrentVertices ; (; Double_t ; x0, . Double_t ; y0, . Double_t ; scale . ). ◆ SetCurrentZ(). void TGeoXtru::SetCurrentZ ; (; Double_t ; z, . Int_t ; iz . ). ◆ SetDimensions(). void TGeoXtru::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetIz(). void TGeoXtru::SetIz ; (; Int_t ; iz). protected . ◆ SetPoints() [1/2]. void TGeoXtru::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoXtru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:30217,safe,safe,30217,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['safe'],['safe']
Safety,"of file TUnixSystem.cxx. ◆ UnixRecv(). int TUnixSystem::UnixRecv ; (; int ; sock, . void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Receive exactly length bytes into buffer. ; Returns number of bytes received. Returns -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4508 of file TUnixSystem.cxx. ◆ UnixResetSignal(). void TUnixSystem::UnixResetSignal ; (; ESignals ; sig). staticprotected . Restore old signal handler for specified signal. ; Definition at line 3821 of file TUnixSystem.cxx. ◆ UnixResetSignals(). void TUnixSystem::UnixResetSignals ; (; ). staticprotected . Restore old signal handlers. ; Definition at line 3836 of file TUnixSystem.cxx. ◆ UnixSelect(). int TUnixSystem::UnixSelect ; (; Int_t ; nfds, . TFdSet * ; readready, . TFdSet * ; writeready, . Long_t ; timeout . ). staticprotected . Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ; Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:74809,timeout,timeout,74809,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:66984,Recover,Recover,66984,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['Recover'],['Recover']
Safety,"of last bin (not included in last bin) . Definition at line 697 of file TH1.cxx. ◆ TH1() [4/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Float_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type float. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbins+1 . Definition at line 719 of file TH1.cxx. ◆ TH1() [5/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). override . Histogram default destructor. ; Definition at line 643 of file TH1.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TH1::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). virtual . Replace contents of this histogram by the addition of h1 and h2. ; this = c1*h1 + c2*h2 if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number indep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:73632,avoid,avoid,73632,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['avoid'],['avoid']
Safety,"of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 39166 2011-05-12 09:37:06Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSubString.html:2560,detect,detecting,2560,root/html530/TSubString.html,https://root.cern,https://root.cern/root/html530/TSubString.html,1,['detect'],['detecting']
Safety,"of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 40340 2011-07-23 16:57:07Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSubString.html:2560,detect,detecting,2560,root/html532/TSubString.html,https://root.cern,https://root.cern/root/html532/TSubString.html,1,['detect'],['detecting']
Safety,"of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferred and asynchronous.; 23.2.4.5 Deferred; Set by TThread::SetCancelDeferred() (default): When the user knows safe places in their code where a thread can be canceled without risk for the rest of the system, they can define these points by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1111699,safe,safe,1111699,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['risk', 'safe']","['risk', 'safe']"
Safety,"of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2096 of file TBufferFile.cxx. ◆ WriteFastArray() [6/15]. void TBufferFile::WriteFastArray ; (; const Long64_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n long longs into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2063 of file TBufferFile.cxx. ◆ WriteFastArray() [9/15]. void TBufferFile::WriteFastArray ; (; const UChar_t * ; c, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 517 of file TBufferFile.h. ◆ WriteFastArray() [10/15]. void TBufferFile::WriteFastArray ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:83805,abort,aborts,83805,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf206_treevistoolsDefinition rf206_treevistools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7ffd18ff9e50 RooAddPdf::model = 0.582695/1 [Auto,Clean] ; 0x7ffd18ff8f60/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffd18ff65f8/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff7bd8/V- RooRealVar::a0 = 0.5; 0x7ffd18ff7fc0/V- RooRealVar::a1 = 0.2; 0x7ffd18ff8790/V- RooRealVar::bkg1frac = 0.2; 0x7ffd18ff6b28/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff83a8/V- RooRealVar::alpha = -1; 0x7ffd18ff9a68/V- RooRealVar::bkgfrac = 0.5; 0x7ffd18ff5428/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffd18ff5b48/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff8b78/V- RooRealVar::mean = 5; 0x7ffd18ff7020/V- RooRealVar::sigma1 = 0.5; 0x7ffd18ff77f0/V- RooRealVar::sig1frac = 0.8; 0x7ffd18ff60a0/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8C.html:4023,safe,safe,4023,doc/master/rf206__treevistools_8C.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html,1,['safe'],['safe']
Safety,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRotation.html:4191,recover,recover,4191,root/html528/TRotation.html,https://root.cern,https://root.cern/root/html528/TRotation.html,4,['recover'],['recover']
Safety,"of::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. ◆ CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket * ; s, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. ◆ CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave * ; sl, . Int_t ; port . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. ◆ CreateSlave(). TSlave * TProof::CreateSlave ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . const char * ; workdir . ). protected . Create a new TSlave of type TSlave::kSlave. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 1853 of file TProof.cxx. ◆ CreateSubmaster(). TSlave * TProof::CreateSubmaster ; (; const char * ; url, . const char * ; ord, . const char * ; image, . const char * ; msd, . Int_t ; nwk = 1 . ). protected . Create a new TSlave of type TSlave::kMaster. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:79334,avoid,avoids,79334,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['avoid'],['avoids']
Safety,"ofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPacketizer.html:5711,abort,abort,5711,root/html528/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html528/TVirtualPacketizer.html,1,['abort'],['abort']
Safety,"off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:46614,safe,safe,46614,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['safe'],['safe']
Safety,"ogram in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n floats (as truncated float) into the I/O buffer. ; see comments about Float16_t encoding at TBufferFile::WriteFloat16 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2265 of file TBufferFile.cxx. ◆ WriteFastArrayString(). void TBufferFile::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2033 of file TBufferFile.cxx. ◆ WriteFloat(). void TBufferFile::WriteFloat ; (; Float_t ; f). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 349 of file TBufferFile.h. ◆ WriteFloat16(). void TBufferFile::WriteFloat16 ; (; Float_t * ; f, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write a Float16_t to the buffer. ; The following cases are supported for streaming a Float16_t type depending on the range declaration in the comment field of the data member: . Case Example . A Float16_t fNormal; . B Float16_t fTemperature; //[0,100] . C Float16_t fCharge; //[-1,1,2] . D Float16_t fVertex[3]; //[-30,30,10] . E Float16_t fChi2; //[0,0,6] . F Int_t fNsp;; Float16_t* fPointValue; //[fNsp][0,3] . In case A fNormal is converted f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:88670,abort,aborts,88670,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"oid Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:9054,avoid,avoid,9054,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['avoid'],['avoid']
Safety,"oid TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer with a milliSec timeout. ; If milliSec is 0 then the timeout will be the minimum timeout (see TSystem::ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or SetTime()) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also TurnOn(), Stop(), TurnOff(). ; Definition at line 213 of file TTimer.cxx. ◆ Stop(). virtual void TTimer::Stop ; (; ). inlinevirtual . Reimplemented in TGLRedrawTimer.; Definition at line 94 of file TTimer.h. ◆ Streamer(). void TTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSysEvtHandler. ◆ StreamerNVirtual(). void TTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TTimer.h. ◆ Timeout(). virtual void TTimer::Timeout ; (; ). inlinevirtual . Reimplemented in ROOT::RBrowserTimer, TCefTimer, TQt5Timer, TQt6Timer, TWebCanvasTimer, THttpTimer, and ROOT::RTreeDrawInvokeTimer.; Definition at line 97 of file TTimer.h. ◆ TurnOff(). void TTimer::TurnOff ; (; ). virtual . Remove timer from system timer list. ; This requires that a timer has been placed in the system timer list (using TurnOn()). If a TTimer subclass is placed on another list, override TurnOff() to remove the timer from the correct list. ; Definition at line 231 of file TTimer.cxx. ◆ TurnOn(). void TTimer::TurnOn ; (; ). virtual . Add the timer to the system timer list. ; If a TTimer subclass has to be placed on another list, override TurnOn() to add the timer to the correct list. ; Reimplemented in TSingleShotCleaner.; Definition at line 243 of file TTimer.cxx. Member Data Documentation. ◆ fAbsTime. TTime TTimer::fAbsTime. protected . Definition at line 55 of file TTimer.h. ◆ fCommand. TString TTimer::fCommand. protected . Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:25812,Timeout,Timeout,25812,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['Timeout'],['Timeout']
Safety,oid* TGeoParallelWorld::fBoundingBoxes = nullptr. protected . stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Definition at line 54 of file TGeoParallelWorld.h. ◆ fBVH. void* TGeoParallelWorld::fBVH = nullptr. protected . array of physical nodes ; Definition at line 49 of file TGeoParallelWorld.h. ◆ fGeoManager. TGeoManager* TGeoParallelWorld::fGeoManager. protected . Definition at line 41 of file TGeoParallelWorld.h. ◆ fIsClosed. Bool_t TGeoParallelWorld::fIsClosed. protected . Definition at line 44 of file TGeoParallelWorld.h. ◆ fLastState. TGeoPhysicalNode* TGeoParallelWorld::fLastState. protected . helper volume ; Definition at line 46 of file TGeoParallelWorld.h. ◆ fPaths. TObjArray* TGeoParallelWorld::fPaths. protected . Definition at line 42 of file TGeoParallelWorld.h. ◆ fPhysical. TObjArray* TGeoParallelWorld::fPhysical. protected . Last PN touched. ; Definition at line 47 of file TGeoParallelWorld.h. ◆ fSafetyCandidateStore. std::vector<unsigned int> TGeoParallelWorld::fSafetyCandidateStore {}. protected . A regular 3D cache layer for fast point-based safety lookups. ; Definition at line 52 of file TGeoParallelWorld.h. ◆ fSafetyVoxelCache. TGeoVoxelGrid<SafetyVoxelInfo>* TGeoParallelWorld::fSafetyVoxelCache. protected . Initial value:=; nullptr. BVH helper structure for safety and navigation. ; Definition at line 50 of file TGeoParallelWorld.h. ◆ fUseOverlaps. Bool_t TGeoParallelWorld::fUseOverlaps. protected . Definition at line 43 of file TGeoParallelWorld.h. ◆ fVolume. TGeoVolume* TGeoParallelWorld::fVolume. protected . Closed flag. ; Definition at line 45 of file TGeoParallelWorld.h. Libraries for TGeoParallelWorld:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoParallelWorld.h; geom/geom/src/TGeoParallelWorld.cxx. TGeoParallelWorld. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:07 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:29169,safe,safety,29169,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,3,"['Safe', 'safe']","['SafetyVoxelInfo', 'safety']"
Safety,"oid* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMonitor.html:7460,timeout,timeout,7460,root/html534/TMonitor.html,https://root.cern,https://root.cern/root/html534/TMonitor.html,2,['timeout'],['timeout']
Safety,"oid* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14533,Safe,SafetySeg,14533,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,1,['Safe'],['SafetySeg']
Safety,"oid* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:10695,Recover,Recover,10695,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['Recover'],['Recover']
Safety,"oid* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerMulti.html:5826,abort,abort,5826,root/html602/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html602/TPacketizerMulti.html,2,['abort'],['abort']
Safety,"oid*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TWebFile&operator=(const TWebFile&); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:10862,Recover,Recover,10862,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['Recover'],['Recover']
Safety,"oidRedirectOutput(Bool_t on = kTRUE); virtual Int_tTProofPlayer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:10774,abort,abort,10774,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,8,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"oidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:10073,timeout,timeout,10073,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,1,['timeout'],['timeout']
Safety,"oidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10505,timeout,timeout,10505,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,1,['timeout'],['timeout']
Safety,"oidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:10606,timeout,timeout,10606,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,1,['timeout'],['timeout']
Safety,"oidTGeoShape::NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t p); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:8125,Safe,SafetyPhi,8125,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,1,['Safe'],['SafetyPhi']
Safety,"oidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:10801,timeout,timeout,10801,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,1,['timeout'],['timeout']
Safety,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplicationServer.html:10999,abort,abort,10999,root/html528/TApplicationServer.html,https://root.cern,https://root.cern/root/html528/TApplicationServer.html,4,['abort'],['abort']
Safety,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDelete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:10908,abort,abort,10908,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,1,['abort'],['abort']
Safety,"oidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterTree&operator=(const TEventIterTree&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:4626,abort,abort,4626,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,2,['abort'],['abort']
Safety,"oidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterUnit&operator=(const TEventIterUnit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterUnit.html:4610,abort,abort,4610,root/html530/TEventIterUnit.html,https://root.cern,https://root.cern/root/html530/TEventIterUnit.html,2,['abort'],['abort']
Safety,"oiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/end of the run. . Definition at line 29 of file TClonesArray.h. Public Types; enum  EStatusBits { kBypassStreamer = (1ULL << ( 12 )); , kForgetBits = (1ULL << ( 15 )); };  Saved copies of pointers to objects. More...;  ;  Public Types inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:4166,avoid,avoid,4166,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['avoid'],['avoid']
Safety,"oid DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToParaboloid (const Double_t *point, const Double_t *dir, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetRhi () const;  ; Double_t GetRlo () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetParaboloidDimensions (Double_t rlo, Double_t rhi, Double_t dz);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:2735,Safe,Safety,2735,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"oid ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionOneDim; double Derivative (const double *x) const;  Compatibility method with multi-dimensional interface for partial derivative. ;  ; double Derivative (double x) const;  Return the derivative of the function at a point x Use the private method DoDerivative. ;  ; void FdF (const double *x, double &f, double *df) const;  Compatibility method with multi-dimensional interface for Gradient and function evaluation. ;  ; void Gradient (const double *x, double *g) const;  Compatibility method with multi-dimensional interface for Gradient. ;  ; bool HasGradient () const override;  . Private Member Functions; double DoDerivative (double x) const override;  Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:5637,avoid,avoid,5637,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['avoid'],['avoid']
Safety,"oid ProcessOptions ();  process user options reference cut value to distinguish signal-like from background-like events ;  ; Double_t TransformLikelihoodOutput (Double_t ps, Double_t pb) const;  returns transformed or non-transformed output ;  . Private Attributes; Int_t fAverageEvtPerBin;  average events per bin; used to calculate fNbins ;  ; Int_t * fAverageEvtPerBinVarB;  average events per bin; used to calculate fNbins ;  ; Int_t * fAverageEvtPerBinVarS;  average events per bin; used to calculate fNbins ;  ; TString fBorderMethodString;  the method to take care about ""border"" effects (string) ;  ; PDF * fDefaultPDFLik;  pdf that contains default definitions ;  ; Int_t fDropVariable;  for ranking test ;  ; Double_t fEpsilon;  minimum number of likelihood (to avoid zero) ;  ; std::vector< TH1 * > * fHistBgd;  background PDFs (histograms) ;  ; std::vector< TH1 * > * fHistBgd_smooth;  background PDFs (smoothed histograms) ;  ; std::vector< TH1 * > * fHistSig;  signal PDFs (histograms) ;  ; std::vector< TH1 * > * fHistSig_smooth;  signal PDFs (smoothed histograms) ;  ; TString * fInterpolateString;  which interpolation method used for reference histograms (individual for each variable) ;  ; Float_t fKDEfineFactor;  fine tuning factor for Adaptive KDE ;  ; TString fKDEiterString;  Number of iterations (string) ;  ; TString fKDEtypeString;  Kernel type to use for KDE (string) ;  ; Int_t fNsmooth;  number of smooth passes ;  ; Int_t * fNsmoothVarB;  number of smooth passes ;  ; Int_t * fNsmoothVarS;  number of smooth passes ;  ; std::vector< PDF * > * fPDFBgd;  list of PDFs (background) ;  ; std::vector< PDF * > * fPDFSig;  list of PDFs (signal) ;  ; Bool_t fTransformLikelihoodOutput;  likelihood output is sigmoid-transformed ;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:29582,avoid,avoid,29582,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['avoid'],['avoid']
Safety,"oint) const override;  Tests if point is inside the shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; void CreateThreadData (Int_t nthreads) override;  Needed just for cleanup. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute closest distance from point px,py to each corner. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to outside of this composite shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to this composite shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide all range of iaxis in range/step cells. ;  ; TGeoBoolNode * GetBoolNode () const;  ; void GetBoundingCylinder (Double_t *) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  Return number of vertices of the mesh representation. ;  ; Bool_t GetPointsOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:11883,safe,safe,11883,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"oints, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:3777,safe,safe,3777,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['safe'],['safe']
Safety,"ol is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:104542,Safe,Safety,104542,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['Safe'],['Safety']
Safety,"ol, Int_t npoints, Option_t *option);  Draw random points in the bounding box of a volume. ;  ; void RandomRays (Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays from point (startx,starty,startz) and plot intersections with surfaces for current top node. ;  ; TGeoNode * SamplePoints (Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path);  shoot npoints randomly in a box of 1E-5 around current point. ;  ; void SetNmeshPoints (Int_t npoints=1000);  Set number of points to be generated on the shape outline when checking for overlaps. ;  ; void SetSelectedNode (TGeoNode *node);  ; void ShapeDistances (TGeoShape *shape, Int_t nsamples, Option_t *option);  Test TGeoShape::DistFromInside/Outside. ;  ; void ShapeNormal (TGeoShape *shape, Int_t nsamples, Option_t *option);  Check of validity of the normal for a given shape. ;  ; void ShapeSafety (TGeoShape *shape, Int_t nsamples, Option_t *option);  Check of validity of safe distance for a given shape. ;  ; Double_t * ShootRay (Double_t *start, Double_t dirx, Double_t diry, Double_t dirz, Double_t *array, Int_t &nelem, Int_t &dim, Double_t *enpoint=nullptr) const;  Shoot one ray from start point with direction (dirx,diry,dirz). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Test (Int_t npoints, Option_t *option);  Check time of finding ""Where am I"" for n points. ;  ; void TestOverlaps (const char *path);  Geometry overlap checker based on sampling. ;  ; Bool_t TestVoxels (TGeoVolume *vol, Int_t npoints=1000000);  Returns optimal voxelization type for volume vol. ;  ; Double_t Weight (Double_t precision=0.01, Option_t *option=""v"");  Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:6075,safe,safe,6075,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safe']
Safety,"olNode.; Definition at line 118 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoUnion::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this union. ; Implements TGeoBoolNode.; Definition at line 778 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoUnion::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 128 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoUnion::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 432 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoUnion::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 440 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoUnion::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 822 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoUnion::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 846 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoUnion::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 865 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoUnion::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoUnion::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TGeoBoolNode.h. Libraries for TGeoUnion:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:18180,safe,safety,18180,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['safe'],['safety']
Safety,"olNode.cxx. ◆ DeclFileName(). static const char * TGeoIntersection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 166 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoIntersection::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1464 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoIntersection::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1472 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoIntersection::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1505 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoIntersection::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 156 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoIntersection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 166 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoIntersection::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 1230 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:17126,safe,safe,17126,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety,"ol_t TQObject::Disconnect(TQObject *sender,; 961 const char *signal,; 962 void *receiver,; 963 const char *slot); 964{; 965 Bool_t return_value = kFALSE;; 966 Bool_t next_return = kFALSE;; 967 ; 968 if (!sender->GetListOfSignals()) return kFALSE;; 969 ; 970 TString signal_name = CompressName(signal);; 971 TString slot_name = CompressName(slot);; 972 ; 973 TQConnectionList *slist = nullptr;; 974 TIter next_signal(sender->GetListOfSignals());; 975 ; 976 while ((slist = (TQConnectionList*)next_signal())) {; 977 if (!signal || signal_name.IsNull()) { // disconnect all signals; 978 next_return = slist->Disconnect(receiver,slot_name);; 979 return_value = return_value || next_return;; 980 ; 981 if (slist->IsEmpty()) {; 982 sender->GetListOfSignals()->Remove(slist);; 983 SafeDelete(slist); // delete empty list; 984 }; 985 } else if (signal && !strcmp(signal_name,slist->GetName())) {; 986 next_return = slist->Disconnect(receiver,slot_name);; 987 return_value = return_value || next_return;; 988 ; 989 if (slist->IsEmpty()) {; 990 sender->GetListOfSignals()->Remove(slist);; 991 SafeDelete(slist); // delete empty list; 992 break;; 993 }; 994 }; 995 }; 996 ; 997 if (sender->GetListOfSignals() && sender->GetListOfSignals()->IsEmpty()) {; 998 SafeDelete(sender->fListOfSignals);; 999 }; 1000 ; 1001 return return_value;; 1002}; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005/// Disconnects ""class signal"". The class is defined by class_name.; 1006/// See also Connect(class_name,signal,receiver,slot).; 1007 ; 1008Bool_t TQObject::Disconnect(const char *class_name,; 1009 const char *signal,; 1010 void *receiver,; 1011 const char *slot); 1012{; 1013 TClass *sender = TClass::GetClass(class_name);; 1014 ; 1015 // sender should be TQClass (which derives from TQObject); 1016 if (!sender || !sender->IsA()->InheritsFrom(TQObject::Class())); 1017 return kFALSE;; 1018 ; 1019 TQClass *qcl = (TQClass*)sender; // cast TClass to TQClass; 1020 return D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:32271,Safe,SafeDelete,32271,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,3,['Safe'],['SafeDelete']
Safety,"ol_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Invoke the GetAbort function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. void ResetAbort(); Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the TClass object for the interpreted class. TSelector * GetInterpretedSelector() const; { return fIntSelector; }. » Author: Rene Brun 05/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TSelectorCint.h 38871 2011-04-15 11:35:38Z pcanal $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSelectorCint.html:8852,Abort,Abort,8852,root/html530/TSelectorCint.html,https://root.cern,https://root.cern/root/html530/TSelectorCint.html,1,['Abort'],['Abort']
Safety,"ol_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Invoke the GetAbort function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. void ResetAbort(); Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the TClass object for the interpreted class. TSelector * GetInterpretedSelector() const; { return fIntSelector; }. » Author: Rene Brun 05/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TSelectorCint.h 38871 2011-04-15 11:35:38Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorCint.html:8852,Abort,Abort,8852,root/html532/TSelectorCint.html,https://root.cern,https://root.cern/root/html532/TSelectorCint.html,1,['Abort'],['Abort']
Safety,"ol_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:16726,abort,abort,16726,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['abort'],['abort']
Safety,"ol_thas_more! indicates that potentially there are more items can be found; Int_tlvl! current level of hierarchy; UInt_tmask! defines operation kind; Int_tnum_childs! number of childs; Int_tnum_fields! number of fields; TRootSnifferScanRec*parent! pointer on parent record; const char*searchpath! current path searched; TStringstarted_node! name of node stared; TRootSnifferStore*store! object to store results. Class Charts. Inheritance Chart:. TRootSnifferScanRec. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they will be replaced with '_'.; To avoid item name duplication, additional id number can be appended. void CreateNode(const char* _node_name); creates new node with specified name; if special symbols like ""[]&<>"" are used, node name; will be replaced by default name like ""extra_item_N"" and; original node name will be recorded as ""_original_name"" field; Optionally, object name can be recorded as ""_realname"" field. void CloseNode(); close started node. void SetRootClass(TClass* cl); set root class name as node kind; in addition, path to master item (streamer info) specified; Such master item required to correctly unstream data on JavaScript. Bool_t Done() const; returns true if scanning is done; Can happen when searched element is found. Bool_t IsReadyForResult() const; Checks if result will be accepted.; Used to verify if sniffer should read object from the file. Bool_t SetResult(void* obj, TClass* cl, TDataMember* member = 0, Int_t chlds = -1); set results of scanning. Int_t Depth() const; returns current depth of scanned hierarchy. Int_t ExtraFolder",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferScanRec.html:2458,avoid,avoid,2458,root/html602/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html602/TRootSnifferScanRec.html,1,['avoid'],['avoid']
Safety,"oldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitted requests, must be called from appropriate thread.Definition THttpServer.cxx:708; THttpServer::ExecuteWSBool_t ExecuteWS(std::shared_ptr< THttpCallArg > &arg, Bool_t external_thrd=kFALSE, Bool_t wait_process=kFALSE)Execute WS request.Definition THttpSer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:58971,safe,safe,58971,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,['safe'],['safe']
Safety,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30687,avoid,avoid,30687,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety,"oll) {; 3055 auto &clTemplDecl = *strigNargsToKeepPair.first;; 3056 FwdDeclFromTmplDecl(clTemplDecl , interp, fwdDecl);; 3057 initStr += ""{\"""" +; 3058 fwdDecl + ""\"", ""; 3059 + std::to_string(strigNargsToKeepPair.second); 3060 + ""},"";; 3061 }; 3062 if (!fwdDeclnArgsToSkipColl.empty()); 3063 initStr.pop_back();; 3064 initStr += ""}"";; 3065 return initStr;; 3066}; 3067 ; 3068////////////////////////////////////////////////////////////////////////////////; 3069/// Get the pointee type if possible; 3070 ; 3071clang::QualType GetPointeeTypeIfPossible(const clang::QualType &qt); 3072{; 3073 if (qt.isNull()) return qt;; 3074 clang::QualType thisQt(qt);; 3075 while (thisQt->isPointerType() ||; 3076 thisQt->isReferenceType()) {; 3077 thisQt = thisQt->getPointeeType();; 3078 }; 3079 return thisQt;; 3080 ; 3081}; 3082 ; 3083////////////////////////////////////////////////////////////////////////////////; 3084/// Extract the list of headers necessary for the Decl; 3085 ; 3086std::list<std::string> RecordDecl2Headers(const clang::CXXRecordDecl &rcd,; 3087 const cling::Interpreter &interp,; 3088 std::set<const clang::CXXRecordDecl *> &visitedDecls); 3089{; 3090 std::list<std::string> headers;; 3091 ; 3092 // We push a new transaction because we could deserialize decls here; 3093 cling::Interpreter::PushTransactionRAII RAII(&interp);; 3094 ; 3095 // Avoid infinite recursion; 3096 if (!visitedDecls.insert(rcd.getCanonicalDecl()).second); 3097 return headers;; 3098 ; 3099 // If this is a template; 3100 if (const clang::ClassTemplateSpecializationDecl *tsd = llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(&rcd)) {; 3101 ; 3102 // Loop on the template args; 3103 for (auto & tArg : tsd->getTemplateArgs().asArray()) {; 3104 if (clang::TemplateArgument::ArgKind::Type != tArg.getKind()) continue;; 3105 auto tArgQualType = GetPointeeTypeIfPossible(tArg.getAsType());; 3106 if (tArgQualType.isNull()) continue;; 3107 if (const clang::CXXRecordDecl *tArgCxxRcd = tArgQualType->getAsCXXRecor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:122555,Avoid,Avoid,122555,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"olution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ); 462 {; 463 Warning(""TF1Convolution::SetRange()"",""In FFT mode, range can not be infinite. Infinity has been replaced by range of first function plus a bufferzone to avoid spillover."");; 464 if (a ==-TMath::Infinity()) fXmin = fFunction1 -> GetXmin();; 465 if ( b== TMath::Infinity()) fXmax = fFunction1 -> GetXmax();; 466 // add a spill over of 10% in this case; 467 SetExtraRange(fgExtraRangeFraction);; 468 }; 469 fFlagGraph = false; // to indicate we need to re-do the convolution; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473/// Set the default extra range fraction used when doing a FFT convolution.; 474/// By default the value is 0.1 (10%).; 475/// The function return the previous default defined value.; 476 ; 477Double_t TF1Convolution::SetDefaultExtraRange(Double_t fraction); 478{; 479 Double_t prevValue = fgExtraRangeFraction;; 480 fgExtraRangeFraction = fraction;; 481 return prevValue;; 482}; 483 ; 484////////////////////////////////////////////////////////////////////////////////; 485/// Get the range used for the convolution.; 486 ; 487void TF1Convolution::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:17327,avoid,avoid,17327,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['avoid'],['avoid']
Safety,"om inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; create points for a composite shape. void SetPoints(Float_t* points) const; create points for a composite shape. void Sizeof3D() const; compute size of this 3D object. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:20622,Safe,Safety,20622,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['Safe'],['Safety']
Safety,"om the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111145,detect,detector,111145,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"omLumi; stringfObsName; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:8784,predict,predictions,8784,root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"omVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); Double_tSafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHype.html:9486,Safe,SafetyS,9486,root/html530/TGeoHype.html,https://root.cern,https://root.cern/root/html530/TGeoHype.html,2,['Safe'],['SafetyS']
Safety,"omVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidSetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:9507,Safe,SafetySeg,9507,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,2,['Safe'],['SafetySeg']
Safety,"omVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); voidSetCurrentZ(Double_t z, Int_t iz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:10163,Safe,SafetySeg,10163,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['Safe'],['SafetySeg']
Safety,"ombinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:15566,safe,safety,15566,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['safe'],['safety']
Safety,"ome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 79 of file TSelector.h. ◆ DeclFileName(). static const char * TSelector::Decl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15691,Abort,Abort,15691,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['Abort'],['Abort']
Safety,"omments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideCopy this to obj.Definition TFile.h:209; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::GetArchiveOffsetLong64_t GetArchiveOffset() constDefinition TFile.h:221; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:32509,timeout,timeout,32509,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"ompare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:3038,safe,safe,3038,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,['safe'],['safe']
Safety,"ompiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace=0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Mon Dec 7 13:49:51 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace__CodeRepo.html:7489,avoid,avoid,7489,root/html526/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html526/RooWorkspace__CodeRepo.html,3,"['abort', 'avoid', 'recover']","['abort', 'avoid', 'recover']"
Safety,"ompiledOK(). bool RooWorkspace::CodeRepo::compiledOK ; (; ); const. inline . Definition at line 182 of file RooWorkspace.h. ◆ DeclFileName(). static const char * RooWorkspace::CodeRepo::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 217 of file RooWorkspace.h. ◆ IsA(). TClass * RooWorkspace::CodeRepo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 217 of file RooWorkspace.h. ◆ listOfClassNames(). std::string RooWorkspace::CodeRepo::listOfClassNames ; (; ); const. Return STL string with last of class names contained in the code repository. ; Definition at line 2571 of file RooWorkspace.cxx. ◆ Streamer(). void RooWorkspace::CodeRepo::Streamer ; (; TBuffer & ; R__b). overridevirtual . Custom streamer for the workspace. ; Stream contents of workspace and code repository. When reading, read code repository first and compile missing classes before proceeding with streaming of workspace contents to avoid errors. ; Reimplemented from TObject.; Definition at line 2352 of file RooWorkspace.cxx. ◆ StreamerNVirtual(). void RooWorkspace::CodeRepo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 217 of file RooWorkspace.h. Member Data Documentation. ◆ _c2fmap. std::map<TString,ClassRelInfo> RooWorkspace::CodeRepo::_c2fmap. protected . Definition at line 212 of file RooWorkspace.h. ◆ _compiledOK. bool RooWorkspace::CodeRepo::_compiledOK. protected . Definition at line 215 of file RooWorkspace.h. ◆ _ehmap. std::map<TString,ExtraHeader> RooWorkspace::CodeRepo::_ehmap. protected . Definition at line 214 of file RooWorkspace.h. ◆ _fmap. std::map<TString,ClassFiles> RooWorkspace::CodeRepo::_fmap. protected . Definition at line 213 of file RooWorkspace.h. ◆ _wspace. RooWorkspace* RooWorkspace::CodeRepo::_wspace. protected . Definition at line 211 of file RooWorkspace.h. Libraries for RooWorkspa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html:14158,avoid,avoid,14158,doc/master/classRooWorkspace_1_1CodeRepo.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html,1,['avoid'],['avoid']
Safety,"ompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: More...;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). More...;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:7461,safe,safe,7461,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,3,['safe'],['safe']
Safety,"ompute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoHalfSpace.h 21425 2007-12-17 15:59:27Z brun $ »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHalfSpace.html:12430,Safe,Safety,12430,root/html528/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html528/TGeoHalfSpace.html,3,['Safe'],['Safety']
Safety,"omputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Computes normal vector in POINT to the composite shape. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Tests if point is inside the shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; void CreateThreadData (Int_t nthreads) override;  Needed just for cleanup. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute closest distance from point px,py to each corner. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to outside of this composite shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to this composite shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide all range of iaxis in range/step",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:11407,safe,safe,11407,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"on ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; ROOT::TSchemaRule::ReadFuncPtr_tfReadFunc!; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFunc!; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Streamer(TBuffer& ); Avoid streaming the synthetic/artificial streamer elements. ROOT::TSchemaRule::ReadFuncPtr_t GetReadFunc(); Return the read function if any. ROOT::TSchemaRule::ReadRawFuncPtr_t GetReadRawFunc(); Return the raw read function if any. TStreamerElement& operator=(const TStreamerArtificial& ). TStreamerArtificial(const TStreamerArtificial& ). TStreamerArtificial(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); TStreamerArtificial() : fReadFunc(0),fReadRawFunc(0) {}. {}. void SetReadFunc(ROOT::TSchemaRule::ReadFuncPtr_t val); { fReadFunc = val; }. void SetReadRawFunc(ROOT::TSchemaRule::ReadRawFuncPtr_t val); { fReadRawFunc = val; }. » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: e0eac11e63ad37390c9467c97c5c6849c4ab7d39 $ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerArtificial.html:11194,Avoid,Avoid,11194,root/html604/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html604/TStreamerArtificial.html,1,['Avoid'],['Avoid']
Safety,"on = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:8233,safe,safe,8233,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"on RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf502_wspacewriteDefinition rf502_wspacewrite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8C.html:4111,safe,safe,4111,doc/master/rf502__wspacewrite_8C.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html,1,['safe'],['safe']
Safety,"on RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf304_uncorrprodDefinition rf304_uncorrprod.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf304_uncorrprod.C. tutorialsroofitrf304_uncorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf304__uncorrprod_8C.html:4335,safe,safe,4335,doc/master/rf304__uncorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html,2,['safe'],['safe']
Safety,"on TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63828,abort,abort,63828,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['abort'],['abort']
Safety,"on \( x \):. \[; A x = b \\; clo \le C x \le cup \\; xlo \le x \le xup; \]. where A and C are arbitrary matrices and the rest are vectors; Not all these constraints have to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2070,risk,risks,2070,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risks']
Safety,"on at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:70981,risk,risk,70981,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['risk'],['risk']
Safety,"on at line 249 of file TGeoScaledShape.cxx. ◆ IsCylType(). Bool_t TGeoScaledShape::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoScaledShape.h. ◆ IsReflected(). Bool_t TGeoScaledShape::IsReflected ; (; ); const. overridevirtual . Check if the scale transformation is a reflection. ; Reimplemented from TGeoShape.; Definition at line 257 of file TGeoScaledShape.cxx. ◆ MakeBuffer3D(). TBuffer3D * TGeoScaledShape::MakeBuffer3D ; (; ); const. overridevirtual . Creates a TBuffer3D describing this shape. ; Coordinates are in local reference frame. ; Reimplemented from TGeoBBox.; Definition at line 266 of file TGeoScaledShape.cxx. ◆ MakeScaledShape(). TGeoShape * TGeoScaledShape::MakeScaledShape ; (; const char * ; name, . TGeoShape * ; shape, . TGeoScale * ; scale . ). static . Create a scaled shape starting from a non-scaled one. ; Definition at line 277 of file TGeoScaledShape.cxx. ◆ Safety(). Double_t TGeoScaledShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 310 of file TGeoScaledShape.cxx. ◆ Safety_v(). void TGeoScaledShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 424 of file TGeoScaledShape.cxx. ◆ SavePrimitive(). void TGeoScaledShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 322 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:31879,Safe,Safety,31879,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"on axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16367,safe,safe,16367,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,3,['safe'],['safe']
Safety,"on is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the ommited name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:83739,recover,recoverable,83739,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['recover'],['recoverable']
Safety,"on is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; virtual void SetSelection (const char *selection);  Set the selection expression. ;  ; void SlaveBegin (TTree *tree) override;  The SlaveBegin() function is called after the Begin() function. ;  ; void SlaveTerminate () override;  The SlaveTerminate() function is called after all entries or objects have been processed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  The Terminate() function is the last function to be called during a query. ;  ; Int_t Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetInputList (TList *input);  ; virtual void SetStatus (Long64_t status);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:3072,Abort,Abort,3072,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,2,['Abort'],['Abort']
Safety,"on is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Creating and Positioning Volumes; Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);; ; // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);; ; // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);; ; // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:25099,avoid,avoid,25099,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"on of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 515 of file TMonitor.cxx. ◆ GetSender(). void * TMonitor::GetSender ; (; ). inlineoverrideprivatevirtual . Reimplemented from TQObject.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19323,timeout,timeout,19323,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"on string ;  ; bool CreateTable (const TString &table);  Create the database table corresponding to this TTree. ;  ; std::vector< Int_t > * GetColumnIndice (TBranch *branch);  Return a vector of columns index corresponding to the current SQL table and the branch given as argument Returns 0 if no columns indices is found Otherwise returns a pointer to a vector to be deleted by the caller. ;  ; void Init ();  Initialization routine. ;  ; void ResetQuery ();  Reset the internal query. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:39974,detect,detection,39974,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['detect'],['detection']
Safety,"on(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10532,safe,safeties,10532,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safeties']
Safety,"on(const char* rv); static voidTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSlave.html:6553,abort,abort,6553,root/html528/TXSlave.html,https://root.cern,https://root.cern/root/html528/TXSlave.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"on. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:9413,recover,recover,9413,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"on. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:897117,safe,safe,897117,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"on. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:18131,predict,prediction,18131,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['predict'],['prediction']
Safety,"on. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 79 of file TSelector.h. ◆ DeclFileName(). static const char * TSelector::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15773,abort,abort,15773,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['abort'],['abort']
Safety,"on::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooListProxy.html:10262,safe,safeDeleteList,10262,root/html526/RooListProxy.html,https://root.cern,https://root.cern/root/html526/RooListProxy.html,2,['safe'],['safeDeleteList']
Safety,"onArguments`); 1985 ; 1986 TString replacementFormula = f->GetExpFormula();; 1987 ; 1988 // analyze expression string; 1989 // std::cout << ""formula to replace for "" << f->GetName() << "" is "" << replacementFormula <<; 1990 // std::endl;; 1991 PreProcessFormula(replacementFormula);; 1992 // we need to define different parameters if we use the unnamed default parameters ([0]); 1993 // I need to replace all the terms in the functor for backward compatibility of the case; 1994 // f1(""[0]*x"") f2(""[0]*x"") f1+f2 - it is weird but it is better to support; 1995 // std::cout << ""current number of parameter is "" << fNpar << std::endl;; 1996 int nparOffset = 0;; 1997 // if (fParams.find(""0"") != fParams.end() ) {; 1998 // do in any case if parameters are existing; 1999 std::vector<TString> newNames;; 2000 if (fNpar > 0) {; 2001 nparOffset = fNpar;; 2002 newNames.resize(f->GetNpar());; 2003 // start from higher number to avoid overlap; 2004 for (int jpar = f->GetNpar() - 1; jpar >= 0; --jpar) {; 2005 // parameters name have a ""p"" added in front; 2006 TString pj = TString(f->GetParName(jpar));; 2007 if (pj[0] == 'p' && TString(pj(1, pj.Length())).IsDigit()) {; 2008 TString oldName = TString::Format(""[%s]"", f->GetParName(jpar));; 2009 TString newName = TString::Format(""[p%d]"", nparOffset + jpar);; 2010 // std::cout << ""replace - parameter "" << f->GetParName(jpar) << "" with "" << newName <<; 2011 // std::endl;; 2012 replacementFormula.ReplaceAll(oldName, newName);; 2013 newNames[jpar] = newName;; 2014 } else; 2015 newNames[jpar] = f->GetParName(jpar);; 2016 }; 2017 // std::cout << ""after replacing params "" << replacementFormula << std::endl;; 2018 }; 2019 ExtractFunctors(replacementFormula);; 2020 // std::cout << ""after re-extracting functors "" << replacementFormula << std::endl;; 2021 ; 2022 // set parameter value from replacement formula; 2023 for (int jpar = 0; jpar < f->GetNpar(); ++jpar) {; 2024 if (nparOffset > 0) {; 2025 // parameter have an offset- so take this into account; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:75758,avoid,avoid,75758,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['avoid'],['avoid']
Safety,"on_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; void Progress (Long64_t total, Long64_t processed) override;  Progress signal. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  Progress signal. ;  ; void Progress (TProofProgressInfo *pi) override;  Progress signal. ;  ; void Progress (TSlave *, Long64_t total, Long64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; void RedirectOutput (Bool_t on=kTRUE);  Control output redirection to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:4422,abort,abort,4422,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"on_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:11125,timeout,timeout,11125,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,1,['timeout'],['timeout']
Safety,"onadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:2292,sanity check,sanity check,2292,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"ond fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3913,recover,recovery,3913,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"onditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:2411,safe,safe,2411,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,1,['safe'],['safe']
Safety,"ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:25861,detect,detect,25861,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['detect'],['detect']
Safety,"onfigure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes):",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:8431,timeout,timeout,8431,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['timeout'],['timeout']
Safety,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:3763,detect,detect,3763,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['detect'],['detect']
Safety,"ong64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:8556,avoid,avoid,8556,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,1,['avoid'],['avoid']
Safety,"onitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42474,timeout,timeout,42474,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,9,['timeout'],['timeout']
Safety,"onitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; them. Returns the number of new workers found, or <0 on errors. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:46330,timeout,timeout,46330,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,9,['timeout'],['timeout']
Safety,"onitor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19023,timeout,timeout,19023,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,2,['timeout'],['timeout']
Safety,"only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7964,avoid,avoid,7964,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['avoid'],['avoid']
Safety,"onnect a session. Use opt= ""S"" or ""s"" to; shutdown remote session.; Default is opt = """". void Close(Option_t* opt = """"); Close connection. Available options are (case insensitive); 'P' force closing of the underlying physical connection; 'S' shutdown remote session, is any; A session ID can be given using #...# signature, e.g. ""#1#"".; Default is opt = """". UnsolRespProcResult ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); We are here if an unsolicited response comes from a logical conn; The response comes in the form of an XrdClientMessage *, that must NOT be; destroyed after processing. It is destroyed by the first sender.; Remember that we are in a separate thread, since unsolicited; responses are asynchronous by nature. void PostMsg(Int_t type, const char* msg = 0); Post a message of type 'type' into the read messages queue.; If 'msg' is defined it is also added as TString.; This is used, for example, with kPROOF_FATAL to force the main thread; to mark this socket as bad, avoiding race condition when a worker; dies while in processing state. Bool_t IsServProofd(); Return kTRUE if the remote server is a 'proofd'. Int_t GetInterrupt(Bool_t& forward); Get latest interrupt level and reset it; if the interrupt has to be; propagated to lower stages forward will be kTRUE after the call. Int_t Flush(); Flush the asynchronous queue.; Typically called when a kHardInterrupt is received.; Returns number of bytes in flushed buffers. Bool_t Create(Bool_t attach = kFALSE); This method sends a request for creation of (or attachment to) a remote; server application. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); Send a raw buffer of specified length.; Use opt = kDontBlock to ask xproofd to push the message into the proofsrv.; (by default is appended to a queue waiting for a request from proofsrv).; Returns the number of bytes sent or -1 in case of error. Bool_t Ping(const char* ord = 0); Ping functionality: contact the serve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:15569,avoid,avoiding,15569,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['avoid'],['avoiding']
Safety,"onnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:20068,timeout,timeout,20068,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,1,['timeout'],['timeout']
Safety,"onnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:19986,timeout,timeout,19986,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,1,['timeout'],['timeout']
Safety,"ons steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Training Model Summary; custom objects for loading model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/13 [=>............................] - ETA: 10s - loss: 0.9275 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 4/13 [========>.....................] - ETA: 0s - loss: 2.4547 - accuracy: 0.4675 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 7/13 [===============>..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:16897,predict,predict,16897,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predict']
Safety,"ons; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus() & 8) != 0) {; 644 iparNewMin = i;; 645 }; 646 if (ret); 647 fResult->SetMinosError(index, elow, eup);; 648 ok |= ret;; 649 }; 650 ; 651 iparMax = iparNewMin;; 652 iter++; // to avoid infinite looping; 653 }; 654 while( iparNewMin > 0 && iter < 10);; 655 if (!ok) {; 656 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minos error calculation failed for all the selected parameters"");; 657 }; 658 ; 659 // update obj function in case it was an external one; 660 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 661 fResult->fObjFunc = fObjFunction;; 662 ; 663 // re-give a minimizer instance in case it has been changed; 664 // but maintain previous valid status. Do not set result to false if minos failed; 665 ok &= fResult->Update(fMinimizer, fConfig, fResult->IsValid());; 666 ; 667 return ok;; 668}; 669 ; 670 ; 671 ; 672// traits for distinguishing fit methods functions from generic objective functions; 673template<class Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:25121,avoid,avoid,25121,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"onsider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:. The part of a MANY node B extruding its container A will never be “seen” during navigation, as if B was in fact the result of the intersection of A and B.; If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.; If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.; The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - might be in some cases a better way out.; 18.4.2.7 Replicating Volumes; What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:949650,detect,detector,949650,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,"onst &mode);  ; std::ostream & operator<< (std::ostream &os, const RooPrintable &rp);  ; RooCmdArg Optimize (Int_t flag=2);  ; RooCmdArg OutputFile (const char *fileName);  ; RooCmdArg OutputStream (std::ostream &os);  ; RooCmdArg OwnLinked ();  ; RooCmdArg Parallelize (int nWorkers);  ; RooCmdArg Parameters (const RooArgSet &params);  ; RooCmdArg Precision (double prec);  ; RooCmdArg PrefitDataFraction (double data_ratio=0.0);  ; RooCmdArg Prefix (bool flag);  ; RooCmdArg PrintEvalErrors (Int_t numErrors);  ; RooCmdArg PrintLevel (Int_t code);  ; RooCmdArg Project (const RooArgSet &projSet);  ; template<class... Args_t> ; RooCmdArg ProjectedObservables (Args_t &&... argsOrArgSet);  ; RooCmdArg ProjectionRange (const char *rangeName);  ; RooCmdArg ProjWData (const RooAbsData &projData, bool binData=false);  ; RooCmdArg ProjWData (const RooArgSet &projSet, const RooAbsData &projData, bool binData=false);  ; RooCmdArg ProtoData (const RooDataSet &protoData, bool randomizeOrder=false, bool resample=false);  ; RooCmdArg Range (const char *rangeName, bool adjustNorm=true);  ; RooCmdArg Range (double lo, double hi, bool adjustNorm=true);  ; RooCmdArg RecoverFromUndefinedRegions (double strength);  When parameters are chosen such that a PDF is undefined, try to indicate to the minimiser how to leave this region. ;  ; RooCmdArg RecycleConflictNodes (bool flag=true);  ; RooCmdArg RefreshNorm ();  ; RooCmdArg Rename (const char *suffix);  ; RooCmdArg RenameAllNodes (const char *suffix);  ; RooCmdArg RenameAllVariables (const char *suffix);  ; RooCmdArg RenameAllVariablesExcept (const char *suffix, const char *exceptionList);  ; RooCmdArg RenameConflictNodes (const char *suffix, bool renameOrigNodes=false);  ; RooCmdArg RenameVariable (const char *inputName, const char *outputName);  ; RooCmdArg Rescale (double factor);  ; RooCmdArg Restrict (const char *catName, const char *stateNameList);  ; RooConstVar & RooConst (double val);  ; RooCmdArg Save (bool flag=true);  ; RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit.html:16259,Recover,RecoverFromUndefinedRegions,16259,doc/master/namespaceRooFit.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety,"onst Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoTube::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTube::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTube::Capacitystatic Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::CapacityDouble_t Capacity() const override; TGeoTube::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTube::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::Sizeof3Dvoid Sizeof3D() const override; TGeoTube::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTube::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTube::TGeoTubeTGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::HasRminBool_t HasRmin() constDefinition TGeoTube.h:75; TGeoTube::GetAxisNameconst char * GetAxisName(Int_t iaxis) const override; TGeoTube::GetRmaxvirtual Double_t GetRmax() constDefinition TGeoTube.h:73; TGeoTube::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoTube::~TGeoTube~TGeoTube() override; TGeoTube::SafetySstatic Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz=0); TGeoTube::TGeoTubeTGeoTube(); TGeoTube::TGeoTubeTGeoTube(const TGeoTube &)=delete; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; bool; double; int; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14. geomgeomincTGeoTube.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:28007,Safe,SafetySstatic,28007,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,['Safe'],"['SafetyS', 'SafetySstatic']"
Safety,"onst Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToHype(). Int_t TGeoHype::DistToHype ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; s, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoHype::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoHype::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoHype::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoHype::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoHype::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 67 of file TGeoHype.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoHype::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoHype::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoHype::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoHype::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoHype.h. ◆ GetStIn(). Double_t TGeoHype::GetStIn ; (; ); const. inline . Definition at line 72 of file TGeoHype.h. ◆ GetStOut(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:31129,avoid,avoid,31129,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['avoid'],['avoid']
Safety,"onst RooAbsAnaConvPdf &other, const char *name=nullptr);  ;  ~RooAbsAnaConvPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by given code, which is returned by getAnalyticalIntegralWN() ;  ; virtual bool changeModel (const RooResolutionModel &newModel);  Change the current resolution model to newModel. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:5414,unsafe,unsafe,5414,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['unsafe'],['unsafe']
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:64354,sanity check,sanity check,64354,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,124,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:67432,sanity check,sanity check,67432,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,4,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:68641,sanity check,sanity check,68641,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:61112,sanity check,sanity check,61112,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,14,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:73661,sanity check,sanity check,73661,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:68657,sanity check,sanity check,68657,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,6,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Create a scaled shape starting from a non-scaled one. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoScaledShape.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScaledShape.html:13407,Safe,Safety,13407,root/html528/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"onst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Create a scaled shape starting from a non-scaled one. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoScaledShape.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoScaledShape.html:13595,Safe,Safety,13595,root/html530/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"onst TSemaphore& s); TSemaphore(const TSemaphore& s). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance Chart:. TObject. ←; TSemaphore. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSemaphore.html:6148,timeout,timeout,6148,root/html604/TSemaphore.html,https://root.cern,https://root.cern/root/html604/TSemaphore.html,1,['timeout'],['timeout']
Safety,"onst TSemaphore& s); TSemaphore(const TSemaphore& s). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance Chart:. TObject. ←; TSemaphore. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSemaphore.html:6148,timeout,timeout,6148,root/html602/TSemaphore.html,https://root.cern,https://root.cern/root/html602/TSemaphore.html,1,['timeout'],['timeout']
Safety,"onst char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROOT ./configure detected build features. ;  ; TString fConfigOptions;  ROOT ./configure set build options. ;  ; TString fCutClassName;  Name of default CutG class in graphics editor. ;  ; TSeqCollection * fDataSets;  List of data sets (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:34670,detect,detected,34670,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['detect'],['detected']
Safety,"onst char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoMoreParallel(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:23291,timeout,timeout,23291,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['timeout'],['timeout']
Safety,"onst char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp | kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoMoreParallel(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:23164,timeout,timeout,23164,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['timeout'],['timeout']
Safety,"onst char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8487,Safe,SafetyPhi,8487,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['Safe'],['SafetyPhi']
Safety,"onst char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:8340,safe,safe,8340,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,1,['safe'],['safe']
Safety,"onst char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:14245,safe,safe,14245,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,3,['safe'],['safe']
Safety,"onst char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:8062,safe,safe,8062,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['safe'],['safe']
Safety,"onst override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t Daxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Double_t DDaxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Double_t DDDaxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Double_t GetDphi () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetR () const;  ; Double_t GetRmax () const;  ; Double_t GetR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:1568,safe,safe,1568,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"onst. inline . Definition at line 213 of file TGeoTube.h. ◆ GetNmeshVertices(). Int_t TGeoCtub::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoCtub::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetZcoord(). Double_t TGeoCtub::GetZcoord ; (; Double_t ; xc, . Double_t ; yc, . Double_t ; zc . ); const. ◆ InspectShape(). void TGeoCtub::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoCtub::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 226 of file TGeoTube.h. ◆ Safety(). Double_t TGeoCtub::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoCtub::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoCtub::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCtubDimensions(). void TGeoCtub::SetCtubDimensions ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2, . Double_t ; lx, . Double_t ; ly, . Double_t ; lz, . Double_t ; tx, . Double_t ; ty, . Double_t ; tz . ). ◆ SetDimensions(). void TGeoCtub::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoCtub::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoCtub::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Streamer(). void TGeoCtub::Streamer ; (; TBuffer & ; R__b). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:33721,safe,safe,33721,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety,"onst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooListProxy.html:10521,safe,safeDeleteList,10521,root/html532/RooListProxy.html,https://root.cern,https://root.cern/root/html532/RooListProxy.html,1,['safe'],['safeDeleteList']
Safety,"onst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooListProxy.html:10459,safe,safeDeleteList,10459,root/html530/RooListProxy.html,https://root.cern,https://root.cern/root/html530/RooListProxy.html,1,['safe'],['safeDeleteList']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:21111,Safe,Safety,21111,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBox.html:22865,Safe,Safety,22865,root/html604/TGeoBBox.html,https://root.cern,https://root.cern/root/html604/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:22865,Safe,Safety,22865,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:17067,safe,safe,17067,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd1.html:18821,safe,safe,18821,root/html604/TGeoTrd1.html,https://root.cern,https://root.cern/root/html604/TGeoTrd1.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1.html:18821,safe,safe,18821,root/html602/TGeoTrd1.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst;  ; virtual ULongptr_t GetMethod () const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObjectAnyPointer.html:3209,detect,detected,3209,doc/master/classTStreamerObjectAnyPointer.html,https://root.cern,https://root.cern/doc/master/classTStreamerObjectAnyPointer.html,2,['detect'],['detected']
Safety,"onst;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:10992,safe,safely,10992,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,5,['safe'],['safely']
Safety,"onstDefinition MethodDL.h:278; TMVA::MethodDL::ParseBatchLayoutvoid ParseBatchLayout()Parse the input layout.Definition MethodDL.cxx:482; TMVA::MethodDL::ParseBatchNormLayervoid ParseBatchNormLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate reshape layer.Definition MethodDL.cxx:890; TMVA::MethodDL::ReadWeightsFromStreamvoid ReadWeightsFromStream(std::istream &)Definition MethodDL.cxx:2330; TMVA::MethodDL::ReadWeightsFromXMLvoid ReadWeightsFromXML(void *wghtnode)Definition MethodDL.cxx:2112; TMVA::MethodDL::fNumValidationStringTString fNumValidationStringThe string defining the number (or percentage) of training data used for validation.Definition MethodDL.h:199; TMVA::MethodDL::KeyValueVector_tstd::vector< std::map< TString, TString > > KeyValueVector_tDefinition MethodDL.h:93; TMVA::MethodDL::fOutputFunctionDNN::EOutputFunction fOutputFunctionThe output function for making the predictions.Definition MethodDL.h:189; TMVA::MethodDL::fWeightInitializationDNN::EInitialization fWeightInitializationThe initialization method.Definition MethodDL.h:188; TMVA::MethodDL::GetBatchDepthsize_t GetBatchDepth() constDefinition MethodDL.h:262; TMVA::MethodDL::ERecurrentLayerTypeERecurrentLayerTypeDefinition MethodDL.h:153; TMVA::MethodDL::kLayerLSTM@ kLayerLSTMDefinition MethodDL.h:153; TMVA::MethodDL::kLayerGRU@ kLayerGRUDefinition MethodDL.h:153; TMVA::MethodDL::kLayerRNN@ kLayerRNNDefinition MethodDL.h:153; TMVA::MethodDL::ParseRecurrentLayervoid ParseRecurrentLayer(ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate rnn layer.Definition MethodDL.cxx:931; TMVA::MethodDL::fTrainingSettingsstd::vector< TTrainingSettings > fTrainingSettingsThe vector defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:107948,predict,predictions,107948,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['predictions']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerRemote.html:11175,abort,abort,11175,root/html604/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html604/TProofPlayerRemote.html,1,['abort'],['abort']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:11270,abort,abort,11270,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,1,['abort'],['abort']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:11045,timeout,timeout,11045,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,1,['timeout'],['timeout']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11455,timeout,timeout,11455,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,1,['timeout'],['timeout']
Safety,"ontaining the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoParallelWorld:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AccelerationMode. enum class TGeoParallelWorld::AccelerationMode. strong . EnumeratorkVoxelFinder ; kBVH . Definition at line 28 of file TGeoParallelWorld.h. Constructor & Destructor Documentation. ◆ TGeoParallelWorld() [1/3]. TGeoParallelWorld::TGeoParallelWor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16431,safe,safety,16431,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,2,"['Safe', 'safe']","['SafetyOrig', 'safety']"
Safety,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8C.html:4120,safe,safe,4120,doc/master/rf602__chi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html,2,['safe'],['safe']
Safety,"ooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:15202,safe,safely,15202,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['safe'],['safely']
Safety,"ooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:10654,safe,safely,10654,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,49,['safe'],['safely']
Safety,"ooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by given code, which is returned by getAnalyticalIntegralWN() ;  ; virtual bool changeModel (const RooResolutionModel &newModel);  Change the current resolution model to newModel. ;  ; virtual RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:5595,unsafe,unsafe,5595,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,4,['unsafe'],['unsafe']
Safety,"ooFit::Detail::CompileContext & ctx) const override;; 268 ; 269private:; 270 ; 271 std::unique_ptr<RooDataSet> generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,; 272 double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false,; 273 bool extended=false) const ;; 274 ; 275 // Implementation version; 276 virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, bool showConstants=false,; 277 const char *label= """", double xmin=0.65,; 278 double xmax= 0.99,double ymax=0.95, const RooCmdArg* formatCmd=nullptr) ;; 279 ; 280 void logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const;; 281 bool traceEvalPdf(double value) const;; 282 ; 283 /// Setter for the _normSet member, which should never be set directly.; 284 inline void setActiveNormSet(RooArgSet const* normSet) const {; 285 _normSet = normSet;; 286 // Also store the unique ID of the _normSet. This makes it possible to; 287 // detect if the pointer was invalidated.; 288 _normSetId = RooFit::getUniqueId(normSet);; 289 }; 290 ; 291protected:; 292 ; 293 virtual std::unique_ptr<RooAbsReal> createNLLImpl(RooAbsData& data, const RooLinkedList& cmdList);; 294 virtual std::unique_ptr<RooFitResult> fitToImpl(RooAbsData& data, const RooLinkedList& cmdList);; 295 ; 296 /// Checks if `normSet` is the currently active normalization set of this; 297 /// PDF, meaning is exactly the same object as the one the `_normSet` member; 298 /// points to (or both are `nullptr`).; 299 inline bool isActiveNormSet(RooArgSet const* normSet) const {; 300 return RooFit::getUniqueId(normSet).value() == _normSetId;; 301 }; 302 ; 303 double normalizeWithNaNPacking(double rawVal, double normVal) const;; 304 ; 305 RooPlot *plotOn(RooPlot *frame, PlotOpt o) const override;; 306 ; 307 friend class RooMCStudy ;; 308 ; 309 Int_t* randomizeProtoOrder(Int_t nProto,Int_t nGen,bool resample=false) const ;; 310 ; 311 // This also forces the definition of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:14187,detect,detect,14187,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['detect'],['detect']
Safety,"ooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4860,recover,recovery,4860,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"ooVectorDataStore & ; vstore). overrideprotectedvirtual . Overload RooAbsReal::attachToTree to also attach branches for errors and/or asymmetric errors attribute StoreError and/or StoreAsymError are set. ; Reimplemented from RooAbsReal.; Definition at line 1069 of file RooRealVar.cxx. ◆ chopAt(). double RooRealVar::chopAt ; (; double ; what, . Int_t ; where . ); const. protected . Utility to calculate number of decimals to show based on magnitude of error. ; Definition at line 1055 of file RooRealVar.cxx. ◆ Class(). static TClass * RooRealVar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRealVar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealVar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 173 of file RooRealVar.h. ◆ cleanup(). void RooRealVar::cleanup ; (; ). static . Explicitly deletes the shared properties list on exit to avoid problems with the initialization order. ; Meant to be only used internally in RooFit by RooSentinel. ; Definition at line 75 of file RooRealVar.cxx. ◆ clone(). TObject * RooRealVar::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 48 of file RooRealVar.h. ◆ copyCache(). void RooRealVar::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Reimplemented from RooAbsRealLValue.; Definition at line 1193 of file RooRealVar.cxx. ◆ copyCacheFast(). void RooRealVar::copyCacheFast ; (; const RooRealVar & ; other, . bool ; setValDirty = true . ). inline . Definition at line 131 of file RooRealVar.h. ◆ DeclFileName(). static const char * RooRealVar::DeclFileName ; (; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:76499,avoid,avoid,76499,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['avoid'],['avoid']
Safety,"oof::EQueryMode mode); voidSetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:15934,abort,abort,15934,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['abort'],['abort']
Safety,"oof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:21378,timeout,timeout,21378,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['timeout'],['timeout']
Safety,"oof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t nodes, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:21233,timeout,timeout,21233,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['timeout'],['timeout']
Safety,"oof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:19268,timeout,timeout,19268,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['timeout'],['timeout']
Safety,"ool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategoryLValue.h>. Inheritance diagram for RooAbsCategoryLValue:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsCategoryLValue() [1/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; ). inline . Definition at line 29 of file RooAbsCategoryLValue.h. ◆ RooAbsCategoryLValue() [2/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const char * ; name, . const char * ; title . ). Constructor. ; Definition at line 44 of file RooAbsCategoryLValue.cxx. ◆ RooAbsCategoryLValue() [3/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const RooAbsCategoryLValue & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 56 of file RooAbsCategoryLValue.cxx. Member Function Documentation. ◆ Class(). static TClass * RooAbsCategoryLValue::Class ; (; ). static .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:46562,Avoid,Avoids,46562,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['Avoid'],['Avoids']
Safety,"ool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCategory.h>. Inheritance diagram for RooCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ RangeMap_t. using RooCategory::RangeMap_t = std::map<std::string, std::vector<value_type> >. private . Definition at line 128 of file RooCategory.h. Constructor & Destructor Documentation. ◆ RooCategory() [1/4]. RooCategory::RooCategory ; (; ). Definition at line 104 of file RooCategory.cxx. ◆ RooCategory() [2/4]. RooCategory::RooCategory ; (; const char * ; name, . const char * ; title . ). Constructor. Types must be defined using defineType() before variable can be used. ; Definition at line 113 of file RooCategory.cxx. ◆ RooCategory() [3/4]. RooCategory::RooCategory ; (; const char * ; name, . const char * ; title, . const std::map< std::string, int > & ; allowedStates . ). Create a new catego",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:52102,Avoid,Avoids,52102,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['Avoid'],['Avoids']
Safety,"ool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStringVar.h>. Inheritance diagram for RooStringVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooStringVar() [1/3]. RooStringVar::RooStringVar ; (; ). inline . Definition at line 26 of file RooStringVar.h. ◆ RooStringVar() [2/3]. RooStringVar::RooStringVar ; (; const char * ; name, . const char * ; title, . const char * ; value, . Int_t ; size = 1024 . ). Constructor with initial value. The size argument is ignored. ; Definition at line 36 of file RooStringVar.cxx. ◆ RooStringVar() [3/3]. RooStringVar::RooStringVar ; (; const RooStringVar & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 48 of file RooStringVar.cxx. Member Function Documentation. ◆ attachToTree(). void RooStringVar::attachToTree ; (; TTree & ; t, . Int_t ; bufSize = 32000 .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:37846,Avoid,Avoids,37846,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,1,['Avoid'],['Avoids']
Safety,"ool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSuperCategory.h>. Inheritance diagram for RooSuperCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSuperCategory() [1/3]. RooSuperCategory::RooSuperCategory ; (; ). default . ◆ RooSuperCategory() [2/3]. RooSuperCategory::RooSuperCategory ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; inputCategories . ). Construct a super category from other categories. ; Parameters. [in]nameName of this object ; [in]titleTitle (for e.g. printing) ; [in]inputCategoriesRooArgSet with category objects. These all need to derive from RooAbsCategoryLValue, i.e. one needs to be able to assign to them. . Definition at line 55 of file RooSuperCategory.cxx. ◆ RooSuperCategory() [3/3]. RooSuperCategory::RooSuperCategory ; (; const RooSuperCategory & ; other, . const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:48188,Avoid,Avoids,48188,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['Avoid'],['Avoids']
Safety,"oolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoIntersection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 166 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoIntersection::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 1230 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoIntersection::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 1238 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoIntersection::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1641 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoIntersection::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1665 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoIntersection::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1684 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoIntersection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoIntersection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 166 of file TGeoBoolNode.h. Libraries for TGeoIntersection:. [legend]; The documentation for this class was generated from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:18470,safe,safety,18470,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safety']
Safety,"ool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:3362,safe,safe,3362,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['safe'],['safe']
Safety,"ool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParaboloid.html:8725,safe,safe,8725,root/html602/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html,2,['safe'],['safe']
Safety,"ool_t IsStepEntering () const;  ; Bool_t IsStepExiting () const;  ; void LocalToMaster (const Double_t *local, Double_t *master) const;  ; void LocalToMasterBomb (const Double_t *local, Double_t *master) const;  ; void LocalToMasterVect (const Double_t *local, Double_t *master) const;  ; void MasterToLocal (const Double_t *master, Double_t *local) const;  ; void MasterToLocalBomb (const Double_t *master, Double_t *local) const;  ; void MasterToLocalVect (const Double_t *master, Double_t *local) const;  ; void MasterToTop (const Double_t *master, Double_t *top) const;  Convert coordinates from master volume frame to top. ;  ; void PopDummy (Int_t ipop=9999);  ; Bool_t PopPath ();  ; Bool_t PopPath (Int_t index);  ; Bool_t PopPoint ();  ; Bool_t PopPoint (Int_t index);  ; Int_t PushPath (Int_t startlevel=0);  ; Int_t PushPoint (Int_t startlevel=0);  ; void ResetAll ();  Reset the navigator. ;  ; void ResetState ();  Reset current state flags. ;  ; Double_t Safety (Bool_t inside=kFALSE);  Compute safe distance from the current point. ;  ; TGeoNode * SearchNode (Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr);  Returns the deepest node containing fPoint, which must be set a priori. ;  ; void SetCheckingOverlaps (Bool_t flag=kTRUE);  ; void SetCldirChecked (Double_t *dir);  ; void SetCurrentDirection (const Double_t *dir);  ; void SetCurrentDirection (Double_t nx, Double_t ny, Double_t nz);  ; void SetCurrentPoint (const Double_t *point);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastSafetyForPoint (Double_t safe, const Double_t *point);  ; void SetLastSafetyForPoint (Double_t safe, Double_t x, Double_t y, Double_t z);  ; void SetOutside (Bool_t flag=kTRUE);  ; void SetStartSafe (Bool_t flag=kTRUE);  ; void SetStep (Double_t step);  ; TGeoNode * Step (Bool_t is_geom=kTRUE, Bool_t cross=kTRUE);  Make a rectiliniar step of length fStep from current point (fPoint) on current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:8098,Safe,Safety,8098,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"oord from vy; and the errors from vectors vex and vey.; The number of points in the graph is the minimum of number of points; in vx and vy. TGraphErrors(const TGraphErrors& gr); TGraphErrors copy constructor. TGraphErrors& operator=(const TGraphErrors& gr); TGraphErrors assignment operator. TGraphErrors(const TH1* h); TGraphErrors constructor importing its parameters from the TH1 object passed as argument. TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); GraphErrors constructor reading input from filename; filename is assumed to contain at least 3 columns of numbers; convention for format (default=""%lg %lg %lg %lg); format = ""%lg %lg"" read only 2 first columns into X,Y; format = ""%lg %lg %lg"" read only 3 first columns into X,Y and EY; format = ""%lg %lg %lg %lg"" read only 4 first columns into X,Y,EX,EY.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphErrors.html:16768,avoid,avoid,16768,root/html532/TGraphErrors.html,https://root.cern,https://root.cern/root/html532/TGraphErrors.html,1,['avoid'],['avoid']
Safety,"oostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVector();; 583 } else {; 584 // TODO - should attempt to Throw with msg about; 585 // boostToCM computed for two 4-vectors with combined t=0; 586 return BetaVector(vecSum/eSum);; 587 }; 588 // TODO - should attempt to Throw with msg about; 589 // boostToCM computed for two 4-vectors with combined e=0; 590 }; 591 return BetaVector (vecSum * (-1./eSum));; 592 }; 593 ; 594 //beta and gamma; 595 ; 596 /**; 597 Return beta scalar value; 598 */; 599 Scalar Beta() const {; 600 if ( E() == 0 ) {; 601 if ( P2() == 0); 602 // to avoid Nan; 603 return 0;; 604 else {; 605 GenVector::Throw (""LorentzVector::Beta() - beta computed for LorentzVector with t = 0. Return an Infinite result"");; 606 return 1./E();; 607 }; 608 }; 609 if ( M2() <= 0 ) {; 610 GenVector::Throw (""LorentzVector::Beta() - beta computed for non-timelike LorentzVector . Result is physically meaningless"" );; 611 }; 612 return P() / E();; 613 }; 614 /**; 615 Return Gamma scalar value; 616 */; 617 Scalar Gamma() const {; 618 const Scalar v2 = P2();; 619 const Scalar t2 = E() * E();; 620 if (E() == 0) {; 621 if ( P2() == 0) {; 622 return 1;; 623 } else {; 624 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for LorentzVector with t = 0. Return a zero result"");; 625 ; 626 }; 627 }; 628 if ( t2 < v2 ) {; 629 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for a spacelike LorentzVector. Imaginary result"");; 630 return 0;; 631 }; 632 else if ( t2 == v2 ) {; 633 GenVector::Throw (""LorentzVector::Gamma() - gamm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:19232,avoid,avoid,19232,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['avoid'],['avoid']
Safety,"opPoint() [2/2]. Bool_t TGeoNavigator::PopPoint ; (; Int_t ; index). inline . Definition at line 272 of file TGeoNavigator.h. ◆ PushPath(). Int_t TGeoNavigator::PushPath ; (; Int_t ; startlevel = 0). inline . Definition at line 246 of file TGeoNavigator.h. ◆ PushPoint(). Int_t TGeoNavigator::PushPoint ; (; Int_t ; startlevel = 0). inline . Definition at line 263 of file TGeoNavigator.h. ◆ ResetAll(). void TGeoNavigator::ResetAll ; (; ). Reset the navigator. ; Definition at line 2708 of file TGeoNavigator.cxx. ◆ ResetState(). void TGeoNavigator::ResetState ; (; ). Reset current state flags. ; Definition at line 1643 of file TGeoNavigator.cxx. ◆ Safety(). Double_t TGeoNavigator::Safety ; (; Bool_t ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 1689 of file TGeoNavigator.cxx. ◆ SafetyOverlaps(). void TGeoNavigator::SafetyOverlaps ; (; ). protected . Compute safe distance from the current point within an overlapping node. ; Definition at line 1846 of file TGeoNavigator.cxx. ◆ SearchNode(). TGeoNode * TGeoNavigator::SearchNode ; (; Bool_t ; downwards = kFALSE, . const TGeoNode * ; skipnode = nullptr . ). Returns the deepest node containing fPoint, which must be set a priori. ; Check if parallel world navigation is enabled ; Definition at line 1924 of file TGeoNavigator.cxx. ◆ SetCheckingOverlaps(). void TGeoNavigator::SetCheckingOverlaps ; (; Bool_t ; flag = kTRUE). inline . Definition at line 147 of file TGeoNavigator.h. ◆ SetCldirChecked(). void TGeoNavigator::SetCldirChecked ; (; Double_t * ; dir). inline . Definition at line 193 of file TGeoNavigator.h. ◆ SetCurrentDirection() [1/2]. void TGeoNavigator::SetCurrentDirection ; (; const Double_t * ; dir). inline . Definition at line 185 of file TGeoNavigator.h. ◆ SetCurrentDirection() [2/2]. void TGeoNavigator::SetCurrentDirection ; (; Double_t ; nx, . Double_t ; ny, . Double_t ; nz . ). inline . Definition at line 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:41624,safe,safe,41624,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"opagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoManager::FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix); 2767{; 2768 return G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:98304,safe,safety,98304,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:9948,safe,safety,9948,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,3,['safe'],['safety']
Safety,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void Check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoChecker.html:10406,safe,safety,10406,root/html534/TGeoChecker.html,https://root.cern,https://root.cern/root/html534/TGeoChecker.html,1,['safe'],['safety']
Safety,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:31155,recover,recover,31155,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,6,"['Recover', 'recover']","['Recover', 'recover', 'recovered']"
Safety,"open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const TClass * ; cl). protected . Search in database tables for specified class an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85709,recover,recovered,85709,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXML objects When saving, all this elements are linked to root xml node At the end StreamerInfo structures are added After x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67760,recover,recovered,67760,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented from TTree.; Definition at line 91 of file TChain.h. ◆ FindBranch(). TBranch * TChain::FindBranch ; (; const char * ; name). overridevirtual . See TTree::GetReadEntry(). ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 83",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:70875,recover,recoverable,70875,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['recover'],['recoverable']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented from TTree.; Definition at line 91 of file TChain.h. ◆ FindBranch(). TBranch * TChain::FindBranch ; (; const char * ; name). overridevirtual . See TTree::GetReadEntry(). ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 85",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:71284,recover,recoverable,71284,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['recover'],['recoverable']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNtuple, TNtupleD, and TTreeSQL.; Definition at line 4603 of file TTree.cxx. ◆ FindBranch(). TBranch * TTree::FindBranch ; (; const char * ; branchname). virtual . Return the branch that correspond to the path 'branchname', which can includ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:140277,recover,recoverable,140277,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['recover'],['recoverable']
Safety,"operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:8802,Safe,SafetySeg,8802,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,2,['Safe'],['SafetySeg']
Safety,"operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:6468,abort,abort,6468,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,2,['abort'],['abort']
Safety,"operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPSocket.html:6173,timeout,timeout,6173,root/html530/TPSocket.html,https://root.cern,https://root.cern/root/html530/TPSocket.html,5,['timeout'],['timeout']
Safety,"operties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:4029,safe,safety,4029,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['safe'],['safety']
Safety,"operty() [2/2]. Double_t TGeoMaterial::GetConstProperty ; (; Int_t ; i, . Bool_t * ; error = nullptr . ); const. Definition at line 405 of file TGeoMaterial.cxx. ◆ GetConstPropertyRef() [1/2]. const char * TGeoMaterial::GetConstPropertyRef ; (; const char * ; property); const. Definition at line 384 of file TGeoMaterial.cxx. ◆ GetConstPropertyRef() [2/2]. const char * TGeoMaterial::GetConstPropertyRef ; (; Int_t ; i); const. inline . Definition at line 90 of file TGeoMaterial.h. ◆ GetDefaultColor(). Int_t TGeoMaterial::GetDefaultColor ; (; ); const. virtual . Get some default color related to this material. ; Definition at line 614 of file TGeoMaterial.cxx. ◆ GetDensity(). virtual Double_t TGeoMaterial::GetDensity ; (; ); const. inlinevirtual . Definition at line 102 of file TGeoMaterial.h. ◆ GetElement() [1/2]. TGeoElement * TGeoMaterial::GetElement ; (; ); const. Get a pointer to the element this material is made of. ; This second call is to avoid warnings to not call a virtual method from the constructor ; Definition at line 625 of file TGeoMaterial.cxx. ◆ GetElement() [2/2]. TGeoElement * TGeoMaterial::GetElement ; (; Int_t ; i); const. virtual . Get a pointer to the element this material is made of. ; Reimplemented in TGeoMixture.; Definition at line 636 of file TGeoMaterial.cxx. ◆ GetElementProp(). void TGeoMaterial::GetElementProp ; (; Double_t & ; a, . Double_t & ; z, . Double_t & ; w, . Int_t ; i = 0 . ). virtual . Single interface to get element properties. ; Reimplemented in TGeoMixture.; Definition at line 647 of file TGeoMaterial.cxx. ◆ GetFWExtension(). TGeoExtension * TGeoMaterial::GetFWExtension ; (; ); const. inline . Definition at line 119 of file TGeoMaterial.h. ◆ GetIndex(). Int_t TGeoMaterial::GetIndex ; (; ). Retrieve material index in the list of materials. ; Definition at line 657 of file TGeoMaterial.cxx. ◆ GetIntLen(). virtual Double_t TGeoMaterial::GetIntLen ; (; ); const. inlinevirtual . Definition at line 110 of file TGeoMaterial.h. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMaterial.html:27301,avoid,avoid,27301,doc/master/classTGeoMaterial.html,https://root.cern,https://root.cern/doc/master/classTGeoMaterial.html,1,['avoid'],['avoid']
Safety,"option given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupPySelf(). PyObject* CallSelf(const char* method, PyObject* pyobject = 0); Forward <method> to python. TPySelector(TTree* = 0, PyObject* self = 0); Construct a TSelector derived with <self> as the underlying, which is; generally 0 to start out with in the current PROOF framework. ~TPySelector(); Destructor. Only deref if still holding on to Py_None (circular otherwise). Int_t Version() const; Return version number of this selector. First forward; if not overridden, then; yield an obvious ""undefined"" number,. Int_t GetEntry(Long64_t entry, Int_t getall = 0); Boilerplate get entry; same as for generated code; not forwarded. void Init(TTree* tree); Initialize with the current tree to be used; not forwarded (may be called; multiple times, and is called from Begin() and SlaveBegin() ). Bool_t Notify(); Forward call to derived Notify() if available. void Begin(TTree* tree = 0); First function called, and used to setup the python self; forward call. void SlaveBegin(TTree* tree); First function called on worker node, needs to make sure python self is setup,; then store the tree to be used, initialize client, and forward call. Bool_t Process(Long64_t entry); Actual processing; call is forwarded to python self. void SlaveTerminate(); End of client; call is forwarded to python self. void Terminate(); End of job; call is forwarded to python self. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); If no 'why' given, read from python error. » Last changed: Mon Jul 4 15:36:39 2011 » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPySelector.html:9661,Abort,Abort,9661,root/html530/TPySelector.html,https://root.cern,https://root.cern/root/html530/TPySelector.html,1,['Abort'],['Abort']
Safety,"options ""FB"" and ""BB"" suppress the ""Front Box"" and ""Back Box"" around the plot.; {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; }; TF3A 3-Dim function with parameters.Definition TF3.h:28. Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated functions of an histogram h without calling TH1::Fit simply doing: h->GetListOfFunctions()->Add(f1);; or h->GetListOfFunctions()->Add(f1,someoption);; To retrieve a function by name from this list, do: TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; or TF1 *f1 = h->GetFunction(name);; Associated functions are automatically painted when an histogram is drawn. To avoid the painting of the associated functions the option HIST should be added to the list of the options used to paint the histogram. Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D graphics library. The plotting options start with GL keyword. In addition, in order to inform canvases that OpenGL should be used to render 3D representations, the following option should be set: gStyle->SetCanvasPreferGL(true);; General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. Option Description . ""GLLEGO"" Draw a lego plot. It works also for TH2Poly. . ""GLLEGO2"" Bins with color levels. . ""GLLEGO3"" Cylindrical bars. . Lego painter in cartesian supports logarithmic scales for X, Y, Z. In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. Option Description . ""GLSURF"" Draw a surface. . ""GLSURF1"" Surface with color levels . ""GLSURF2"" The same as ""GLSURF1"" but without p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:123187,avoid,avoid,123187,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avoid'],['avoid']
Safety,"or ""silence"" option in configuration option string ; Definition at line 691 of file Tools.cxx. ◆ CheckForVerboseOption(). Bool_t TMVA::Tools::CheckForVerboseOption ; (; const TString & ; cs); const. check if verbosity ""V"" set in option ; Definition at line 708 of file Tools.cxx. ◆ CheckSplines(). Bool_t TMVA::Tools::CheckSplines ; (; const TH1 * ; theHist, . const TSpline * ; theSpline . ). check quality of splining by comparing splines and histograms in each bin ; Definition at line 479 of file Tools.cxx. ◆ Color(). const TString & TMVA::Tools::Color ; (; const TString & ; c). human readable color strings ; Definition at line 828 of file Tools.cxx. ◆ ComputeStat(). void TMVA::Tools::ComputeStat ; (; const std::vector< TMVA::Event * > & ; events, . std::vector< Float_t > * ; valVec, . Double_t & ; meanS, . Double_t & ; meanB, . Double_t & ; rmsS, . Double_t & ; rmsB, . Double_t & ; xmin, . Double_t & ; xmax, . Int_t ; signalClass, . Bool_t ; norm = kFALSE . ). sanity check ; Definition at line 202 of file Tools.cxx. ◆ ComputeVariance(). Double_t TMVA::Tools::ComputeVariance ; (; Double_t ; sumx2, . Double_t ; sumx, . Int_t ; nx . ). inline . compute variance from given sums ; Definition at line 358 of file Tools.h. ◆ ContainsRegularExpression(). Bool_t TMVA::Tools::ContainsRegularExpression ; (; const TString & ; s). check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ; Definition at line 784 of file Tools.cxx. ◆ DestroyInstance(). void TMVA::Tools::DestroyInstance ; (; ). static . Definition at line 82 of file Tools.cxx. ◆ FormattedOutput() [1/3]. void TMVA::Tools::FormattedOutput ; (; const std::vector< Double_t > & ; values, . const std::vector< TString > & ; V, . const TString ; titleVars, . const TString ; titleValues, . MsgLogger & ; logger, . TString ; format = ""%+1.3f"" . ). formatted output of simple table ; Definition at line 887 of file Tools.cxx. ◆ FormattedOutput() [2/3]. void TMVA::Tools::FormattedOutput ; (; const TMatr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:13516,sanity check,sanity check,13516,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['sanity check'],['sanity check']
Safety,"or class code unload/reload and schema evolution. ; Definition at line 2209 of file TBranchElement.cxx. ◆ IsA(). TClass * TBranchElement::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBranch.; Definition at line 255 of file TBranchElement.h. ◆ IsBranchFolder(). bool TBranchElement::IsBranchFolder ; (; ); const. inline . Definition at line 211 of file TBranchElement.h. ◆ IsFolder(). bool TBranchElement::IsFolder ; (; ); const. overridevirtual . Return true if more than one leaf, false otherwise. ; Reimplemented from TBranch.; Definition at line 3758 of file TBranchElement.cxx. ◆ IsMissingCollection(). bool TBranchElement::IsMissingCollection ; (; ); const. protected . Detect a collection written using a zero pointer in old versions of root. ; In versions of ROOT older than 4.00/03, if a collection (TClonesArray or STL container) was split but the pointer to the collection was zeroed out, nothing was saved. Hence there is no easy way to detect the case. In newer versions, a zero is written so that a 'missing' collection appears to be an empty collection. ; Definition at line 3776 of file TBranchElement.cxx. ◆ IsObjectOwner(). virtual bool TBranchElement::IsObjectOwner ; (; ); const. inlinevirtual . Definition at line 213 of file TBranchElement.h. ◆ Notify(). bool TBranchElement::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 214 of file TBranchElement.h. ◆ operator=(). TBra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:59362,detect,detect,59362,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['detect'],['detect']
Safety,"or cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside); compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.; Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside); returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a different array. Dividing shapes; Shapes can generally be divided along a given axis. Supported axis are X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes should not be performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide(). The algorithm for dividing a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:5893,Safe,Safety,5893,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['Safety']
Safety,"or each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 194}; 195 ; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; 199/// arrays of type float.; 200///; 201/// \param[in] name name of histogram (avoid blanks); 202/// \param[in] title histogram title.; 203/// If title is of the form `stringt;stringx;stringy;stringz`; 204/// the histogram title is set to `stringt`,; 205/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 206/// \param[in] nbinsx number of bins; 207/// \param[in] xbins array of low-edges for each bin.; 208/// This is an array of type float and size nbinsx+1; 209/// \param[in] nbinsy number of bins; 210/// \param[in] ybins array of low-edges for each bin.; 211/// This is an array of type float and size nbinsy+1; 212 ; 213TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 214 ,Int_t nbinsy,const Float_t *ybins); 215 :TH1(name,title,nbinsx,xbins); 216{; 217 fDimension = 2;; 218 fScalefactor = 1;; 219 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 220 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 221 if (ybins) fYaxis.Set(nbinsy,ybins);; 222 else fYaxis.Set(nbinsy,0,1);; 223 fNcells = fNcells*(n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:9058,avoid,avoid,9058,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"or from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDCacheFile.h>. Inheritance diagram for TDCacheFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EOnErrorAction. enum TDCacheFile::EOnErrorAction. Note: This must be kept in sync with values #defined in dcap.h. . EnumeratorkOnErrorRetry ; kOnErrorFail ; kOnErrorDefault . Definition at line 61 of file TDCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:41760,Timeout,Timeout,41760,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['Timeout'],['Timeout']
Safety,"or from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDavixFile.h>. Inheritance diagram for TDavixFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDavixFile(). TDavixFile::TDavixFile ; (; const char * ; url, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Open",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:40874,Timeout,Timeout,40874,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['Timeout'],['Timeout']
Safety,"or from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TNetXNGFile.h>. Inheritance diagram for TNetXNGFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetXNGFile() [1/4]. TNetXNGFile::TNetXNGFile ; (; ). Definition at line 123 of file TNetXNGFile.cxx. ◆ TNetXNGFile() [2/4]. TNetXNGFile::TNetXNGFile ; (; const char * ; url, . const char * ; lurl, . Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:40679,Timeout,Timeout,40679,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['Timeout'],['Timeout']
Safety,"or indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false otherwise.; 1241bool CheckReshuffling(TTree &mainTree, TTree &friendTree); 1242{; 1243 const auto isMainReshuffled = mainTree.TestBit(TTree::kEntriesReshuffled);; 1244 const auto isFriendReshuffled = friendTree.TestBit(TTree::kEntriesReshuffled);; 1245 const auto friendHasValidIndex = [&] {; 1246 auto idx = friendTree.GetTreeIndex();; 1247 return idx ? idx->IsValidFor(&mainTree) : false;; 1248 }();; 1249 ; 1250 if ((isMainReshuffled || isFriendReshuffled) && !friendHasValidIndex) {; 1251 const auto reshuffledTreeName = isMainReshuffled ? mainTree.GetName() : friendTree.GetName();; 1252 const auto msg =; 1253 ""Tree '%s' has the kEntriesReshuffled bit set and cannot have friends nor can be added as a friend unless the ""; 1254 ""main tree has a TTreeIndex on the friend tree '%s'. You can also unset the bit manually if you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:44741,risk,risk,44741,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['risk'],['risk']
Safety,"or memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:18126,avoid,avoid,18126,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,1,['avoid'],['avoid']
Safety,"or memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:18127,avoid,avoid,18127,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,1,['avoid'],['avoid']
Safety,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:3335,avoid,avoided,3335,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,4,['avoid'],['avoided']
Safety,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:3335,avoid,avoided,3335,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,2,['avoid'],['avoided']
Safety,"or of the variability of the size of entries. ;  ; Int_t * fNbins;  ![fDimension] Number of bins per dimension ;  ; Int_t fNfill;  ! Total number of histogram fills ;  ; bool fObjEval;  True if fVar1 returns an object (or pointer to). ;  ; Long64_t fOldEstimate;  Value of Tree fEstimate when selector is called. ;  ; TH1 * fOldHistogram;  ! Pointer to previously used histogram ;  ; TTreeFormula * fSelect;  Pointer to selection formula. ;  ; Long64_t fSelectedRows;  Number of selected entries. ;  ; bool fSelectMultiple;  True if selection has a variable index. ;  ; TTree * fTree;  Pointer to current Tree. ;  ; TObject * fTreeElist;  Pointer to Tree Event list. ;  ; TEntryListArray * fTreeElistArray;  ! Pointer to Tree Event list array ;  ; Double_t ** fVal;  ![fSelectedRows][fDimension] Local buffer for the variables ;  ; Int_t fValSize;  ; TTreeFormula ** fVar;  ![fDimension] Array of pointers to variables formula ;  ; bool * fVarMultiple;  ![fDimension] True if fVar[i] has a variable index ;  ; Double_t * fVmax;  ![fDimension] Maxima of varexp columns ;  ; Double_t * fVmin;  ![fDimension] Minima of varexp columns ;  ; Double_t * fW;  ![fSelectedRows]Local buffer for weights ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Private Member Functions;  REvePointSelector (const REvePointSelector &)=delete;  ; REvePointSelector & operator= (const REvePointSelector &)=delete;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html:16451,Abort,Abort,16451,doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,1,['Abort'],['Abort']
Safety,"or of the variability of the size of entries. ;  ; Int_t * fNbins;  ![fDimension] Number of bins per dimension ;  ; Int_t fNfill;  ! Total number of histogram fills ;  ; bool fObjEval;  True if fVar1 returns an object (or pointer to). ;  ; Long64_t fOldEstimate;  Value of Tree fEstimate when selector is called. ;  ; TH1 * fOldHistogram;  ! Pointer to previously used histogram ;  ; TTreeFormula * fSelect;  Pointer to selection formula. ;  ; Long64_t fSelectedRows;  Number of selected entries. ;  ; bool fSelectMultiple;  True if selection has a variable index. ;  ; TTree * fTree;  Pointer to current Tree. ;  ; TObject * fTreeElist;  Pointer to Tree Event list. ;  ; TEntryListArray * fTreeElistArray;  ! Pointer to Tree Event list array ;  ; Double_t ** fVal;  ![fSelectedRows][fDimension] Local buffer for the variables ;  ; Int_t fValSize;  ; TTreeFormula ** fVar;  ![fDimension] Array of pointers to variables formula ;  ; bool * fVarMultiple;  ![fDimension] True if fVar[i] has a variable index ;  ; Double_t * fVmax;  ![fDimension] Maxima of varexp columns ;  ; Double_t * fVmin;  ![fDimension] Minima of varexp columns ;  ; Double_t * fW;  ![fSelectedRows]Local buffer for weights ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Private Member Functions;  REveSelectorToEventList (const REveSelectorToEventList &)=delete;  ; REveSelectorToEventList & operator= (const REveSelectorToEventList &)=delete;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html:15681,Abort,Abort,15681,doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,1,['Abort'],['Abort']
Safety,"or of the variability of the size of entries. ;  ; Int_t * fNbins;  ![fDimension] Number of bins per dimension ;  ; Int_t fNfill;  ! Total number of histogram fills ;  ; bool fObjEval;  True if fVar1 returns an object (or pointer to). ;  ; Long64_t fOldEstimate;  Value of Tree fEstimate when selector is called. ;  ; TH1 * fOldHistogram;  ! Pointer to previously used histogram ;  ; TTreeFormula * fSelect;  Pointer to selection formula. ;  ; Long64_t fSelectedRows;  Number of selected entries. ;  ; bool fSelectMultiple;  True if selection has a variable index. ;  ; TTree * fTree;  Pointer to current Tree. ;  ; TObject * fTreeElist;  Pointer to Tree Event list. ;  ; TEntryListArray * fTreeElistArray;  ! Pointer to Tree Event list array ;  ; Double_t ** fVal;  ![fSelectedRows][fDimension] Local buffer for the variables ;  ; Int_t fValSize;  ; TTreeFormula ** fVar;  ![fDimension] Array of pointers to variables formula ;  ; bool * fVarMultiple;  ![fDimension] True if fVar[i] has a variable index ;  ; Double_t * fVmax;  ![fDimension] Maxima of varexp columns ;  ; Double_t * fVmin;  ![fDimension] Minima of varexp columns ;  ; Double_t * fW;  ![fSelectedRows]Local buffer for weights ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Private Member Functions;  TEvePointSelector (const TEvePointSelector &)=delete;  ; TEvePointSelector & operator= (const TEvePointSelector &)=delete;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEvePointSelector.html:16449,Abort,Abort,16449,doc/master/classTEvePointSelector.html,https://root.cern,https://root.cern/doc/master/classTEvePointSelector.html,1,['Abort'],['Abort']
Safety,"or of the variability of the size of entries. ;  ; Int_t * fNbins;  ![fDimension] Number of bins per dimension ;  ; Int_t fNfill;  ! Total number of histogram fills ;  ; bool fObjEval;  True if fVar1 returns an object (or pointer to). ;  ; Long64_t fOldEstimate;  Value of Tree fEstimate when selector is called. ;  ; TH1 * fOldHistogram;  ! Pointer to previously used histogram ;  ; TTreeFormula * fSelect;  Pointer to selection formula. ;  ; Long64_t fSelectedRows;  Number of selected entries. ;  ; bool fSelectMultiple;  True if selection has a variable index. ;  ; TTree * fTree;  Pointer to current Tree. ;  ; TObject * fTreeElist;  Pointer to Tree Event list. ;  ; TEntryListArray * fTreeElistArray;  ! Pointer to Tree Event list array ;  ; Double_t ** fVal;  ![fSelectedRows][fDimension] Local buffer for the variables ;  ; Int_t fValSize;  ; TTreeFormula ** fVar;  ![fDimension] Array of pointers to variables formula ;  ; bool * fVarMultiple;  ![fDimension] True if fVar[i] has a variable index ;  ; Double_t * fVmax;  ![fDimension] Maxima of varexp columns ;  ; Double_t * fVmin;  ![fDimension] Minima of varexp columns ;  ; Double_t * fW;  ![fSelectedRows]Local buffer for weights ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Private Member Functions;  TEveSelectorToEventList (const TEveSelectorToEventList &)=delete;  ; TEveSelectorToEventList & operator= (const TEveSelectorToEventList &)=delete;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelectorToEventList.html:15601,Abort,Abort,15601,doc/master/classTEveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classTEveSelectorToEventList.html,1,['Abort'],['Abort']
Safety,"or of the variability of the size of entries. ;  ; Int_t * fNbins;  ![fDimension] Number of bins per dimension ;  ; Int_t fNfill;  ! Total number of histogram fills ;  ; bool fObjEval;  True if fVar1 returns an object (or pointer to). ;  ; Long64_t fOldEstimate;  Value of Tree fEstimate when selector is called. ;  ; TH1 * fOldHistogram;  ! Pointer to previously used histogram ;  ; TTreeFormula * fSelect;  Pointer to selection formula. ;  ; Long64_t fSelectedRows;  Number of selected entries. ;  ; bool fSelectMultiple;  True if selection has a variable index. ;  ; TTree * fTree;  Pointer to current Tree. ;  ; TObject * fTreeElist;  Pointer to Tree Event list. ;  ; TEntryListArray * fTreeElistArray;  ! Pointer to Tree Event list array ;  ; Double_t ** fVal;  ![fSelectedRows][fDimension] Local buffer for the variables ;  ; Int_t fValSize;  ; TTreeFormula ** fVar;  ![fDimension] Array of pointers to variables formula ;  ; bool * fVarMultiple;  ![fDimension] True if fVar[i] has a variable index ;  ; Double_t * fVmax;  ![fDimension] Maxima of varexp columns ;  ; Double_t * fVmin;  ![fDimension] Minima of varexp columns ;  ; Double_t * fW;  ![fSelectedRows]Local buffer for weights ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . Private Member Functions;  TSelectorDraw (const TSelectorDraw &);  ; TSelectorDraw & operator= (const TSelectorDraw &);  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:15595,Abort,Abort,15595,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['Abort'],['Abort']
Safety,"or only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TSlave ();  Default constructor used by derived classes. ;  ; virtual void FlushSocket ();  ; void Init (TSocket *s, Int_t stype);  Init a PROOF slave object using the connection opened via s. ;  ; virtual void Interrupt (Int_t type);  Send interrupt OOB byte to master or slave servers. ;  ; virtual Int_t Ping ();  Ping the remote master or slave servers. ;  ; virtual TObjString * SendCoordinator (Int_t kind, const char *msg=0, Int_t int2=0);  Send message to intermediate coordinator. ;  ; virtual Int_t SendGroupPriority (const char *, Int_t);  ; virtual void SetAlias (const char *alias);  Set an alias for this session. ;  ; void SetSocket (TSocket *s);  ; virtual void SetStatus (Int_t st);  ; virtual void StopProcess (Bool_t abort, Int_t timeout);  Sent stop/abort request to PROOF server. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString fArchComp;  ; Long64_t fBytesRead;  ; Float_t fCpuTime;  ; TString fGroup;  ; TString fImage;  ; TFileHandler * fInput;  ; TString fMsd;  ; TString fName;  ; TString fOrdinal;  ; Int_t fParallel;  ; Int_t fPerfIdx;  ; Int_t fPort;  ; TProof * fProof;  ; TString fProofWorkDir;  ; Int_t fProtocol;  ; Float_t fRealTime;  ; TString fROOTVers;  ; TString fSessionTag;  ; ESlaveType fSlaveType;  ; TSocket * fSocket;  ; Int_t fStatus;  ; TString fUser;  ; TString fWorkDir;  . Private Member Functions;  TSlave (const char *host, const char *ord, Int_t perf, const char *image, TProof *proof, Int_t stype, const char *workdir, const char *msd, Int_t=1);  Create a PROOF s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:12101,abort,abort,12101,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"or the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:9932,timeout,timeout,9932,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,6,['timeout'],['timeout']
Safety,"or the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13/** \class TGeoVolume; 14\ingroup Shapes_classes; 15 ; 16TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes; 17 ; 18 Volumes are the basic objects used in building the geometrical hierarchy.; 19They represent unpositioned objects but store all information about the; 20placement of the other volumes they may contain. Therefore a volume can; 21be replicated several times in the geometry. In order to create a volume, one; 22has to put together a shape and a medium which are already defined. Volumes; 23have to be named by users at creation time. Every different name may represent a; 24an unique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:1574,avoid,avoid,1574,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['avoid'],['avoid']
Safety,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:2570,avoid,avoid,2570,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
